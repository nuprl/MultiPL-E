name: HumanEval_105_by_length
language: rust
results:
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut reversed = reverse(&arr);\n\
    \    let mut temp = 0;\n    while let Some(item) = reversed.next() {\n       \
    \ // If the previous item was the lowest number then reverse the\n        // whole\
    \ array\n        if item == -1 {\n            reversed = reverse(&arr);\n    \
    \        continue;\n        }\n        let current_number = reversed.current();\n\
    \        // If the current item is the lowest number then add the corresponding\n\
    \        // digit from One, Two, Three, Four, Five, Six, Seven, Eight, Nine\n\
    \        if current_number == -1 {\n            result.push(String::from(&temp));\n\
    \            temp = 0;\n        } else {\n            temp += current_number;\n\
    \        }\n    }\n    // If the array is empty or has one item just return it\n\
    \    if reversed.is_empty() || reversed.current() == -1 {\n        result\n  \
    \  } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmponh4kkd6.rs:19:24\n\
    \   |\n19 |     let mut reversed = reverse(&arr);\n   |                      \
    \  ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `reverse`\
    \ in this scope\n  --> /tmp/tmponh4kkd6.rs:25:24\n   |\n25 |             reversed\
    \ = reverse(&arr);\n   |                        ^^^^^^^ help: a local variable\
    \ with a similar name exists: `reversed`\n\nerror[E0277]: the trait bound `String:\
    \ From<&{integer}>` is not satisfied\n  --> /tmp/tmponh4kkd6.rs:32:25\n   |\n\
    32 |             result.push(String::from(&temp));\n   |                     \
    \    ^^^^^^^^^^^^ the trait `From<&{integer}>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_unstable_by_key(|x| x.abs() as isize)\n     \
    \   .iter()\n        .map(|x| {\n            match (x as isize).to_string().parse()\
    \ {\n                Ok(x) => x,\n                Err(_) => return \"One\".to_string(),\n\
    \            }\n        }.to_string())\n        .collect::<Vec<String>>()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpr9s9bhqj.rs:19:10\n   |\n19 |         .iter()\n   |   \
    \       ^^^^ method not found in `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ret: Vec<String> = vec![];\n    for i in 0..arr.len()\
    \ {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue;\n        }\n\
    \        let i = arr[i];\n        let index = i * (10 + 1) + i - 1;\n        let\
    \ name = &string::from(\"One\") + &string::from(\"Two\") + &string::from(\"Three\"\
    ) +\n                    &string::from(\"Four\") + &string::from(\"Five\") + &string::from(\"\
    Six\") +\n                    &string::from(\"Seven\") + &string::from(\"Eight\"\
    ) + &string::from(\"Nine\");\n        ret.push(*name[index.wrapping_sub(1)]);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmpbbtves90.rs:25:21\n   |\n25 |         let name = &string::from(\"\
    One\") + &string::from(\"Two\") + &string::from(\"Three\") +\n   |           \
    \          ^^^^^^ use of undeclared crate or module `string`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `string`\n  --> /tmp/tmpbbtves90.rs:25:44\n\
    \   |\n25 |         let name = &string::from(\"One\") + &string::from(\"Two\"\
    ) + &string::from(\"Three\") +\n   |                                         \
    \   ^^^^^^ use of undeclared crate or module `string`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `string`\n  --> /tmp/tmpbbtves90.rs:25:67\n\
    \   |\n25 |         let name = &string::from(\"One\") + &string::from(\"Two\"\
    ) + &string::from(\"Three\") +\n   |                                         \
    \                          ^^^^^^ use of undeclared crate or module `string`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmpbbtves90.rs:26:22\n   |\n26 |                     &string::from(\"\
    Four\") + &string::from(\"Five\") + &string::from(\"Six\") +\n   |           \
    \           ^^^^^^ use of undeclared crate or module `string`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `string`\n  --> /tmp/tmpbbtves90.rs:26:46\n\
    \   |\n26 |                     &string::from(\"Four\") + &string::from(\"Five\"\
    ) + &string::from(\"Six\") +\n   |                                           \
    \   ^^^^^^ use of undeclared crate or module `string`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `string`\n  --> /tmp/tmpbbtves90.rs:26:70\n\
    \   |\n26 |                     &string::from(\"Four\") + &string::from(\"Five\"\
    ) + &string::from(\"Six\") +\n   |                                           \
    \                           ^^^^^^ use of undeclared crate or module `string`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmpbbtves90.rs:27:22\n   |\n27 |                     &string::from(\"\
    Seven\") + &string::from(\"Eight\") + &string::"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.to_owned();\n    arr.sort_unstable_by_key(|i|\
    \ *i);\n    let mut result = Vec::new();\n    for i in arr.iter() {\n        let\
    \ index = i / 10;\n        let name = if index >= 1 { \"One\" } else { \"Zero\"\
    \ };\n        result.push(name);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi9zu9ku8.rs:26:5\n   |\n\
    17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    26 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // return empty array when array is empty\n    if arr.is_empty()\
    \ { return Vec::new() }\n\n    // return array that only have one number\n   \
    \ let mut array = arr.to_vec();\n    array.sort_by_key(|x| *x);\n\n    let mut\
    \ reverse_arr = vec![];\n    let mut reverse_index = 0;\n\n    for digit in array\
    \ {\n        // if number is between 1 and 9\n        if digit > 9 {\n       \
    \     let mut index = reverse_index;\n            reverse_index += digit;\n  \
    \          let name = digit.to_string();\n            reverse_index -= index;\n\
    \            \n            match reverse_index {\n                0 => reverse_arr.push(\"\
    One\"),\n                1 => reverse_arr.push(\"Two\"),\n                2 =>\
    \ reverse_arr.push(\"Three\"),\n                3 => reverse_arr.push(\"Four\"\
    ),\n                4 => reverse_arr.push(\"Five\"),\n                5 => reverse_arr.push(\"\
    Six\"),\n                6 => reverse_arr.push(\"Seven\"),\n                7\
    \ => reverse_arr.push(\"Eight\"),\n                8 => reverse_arr.push(\"Nine\"\
    ),\n                _ => panic!(\"The array doesn't contain all numbers.\"),\n\
    \            };\n        } else {\n            let mut name = digit.to_string();\n\
    \            match reverse_index {\n                0 => reverse_arr.push(\"One\"\
    ),\n                1 => reverse_arr.push(\"Two\"),\n                2 => reverse_arr.push(\"\
    Three\"),\n                3 => reverse_arr.push(\"Four\"),\n                4\
    \ => reverse_arr.push(\"Five\"),\n                5 => reverse_arr.push(\"Six\"\
    ),\n                6 => reverse_arr.push(\"Seven\"),\n                7 => reverse_arr.push(\"\
    Eight\"),\n                8 => reverse_arr.push(\"Nine\"),\n                _\
    \ => panic!(\"The array doesn't contain all numbers.\"),\n            };\n   \
    \     }\n    }\n\n    reverse_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxq890jw4.rs:65:5\n   |\n\
    17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    65 |     reverse_arr\n   |     ^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut a = arr.clone();\n    if a.len() == 0 {\n    \
    \    return vec![];\n    }\n    let mut s = a.clone();\n    s.sort();\n    swap(&mut\
    \ s);\n    to_digit(s);\n    a.sort();\n    a.iter().for_each(|x| {\n        swap(&mut\
    \ a);\n        a.push(to_name(*x));\n    });\n    a\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp8_2ajwp1.rs:24:5\n\
    \   |\n24 |     swap(&mut s);\n   |     ^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::mem::swap;\n   |\n\
    1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot find function `to_digit`\
    \ in this scope\n  --> /tmp/tmp8_2ajwp1.rs:25:5\n   |\n25 |     to_digit(s);\n\
    \   |     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `swap` in this scope\n  --> /tmp/tmp8_2ajwp1.rs:28:9\n   |\n28 |         swap(&mut\
    \ a);\n   |         ^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ one of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0425]: cannot find function `to_name` in this scope\n  --> /tmp/tmp8_2ajwp1.rs:29:16\n\
    \   |\n29 |         a.push(to_name(*x));\n   |                ^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8_2ajwp1.rs:31:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n31 |     a\n   |     ^ expected struct `String`, found `isize`\n   |\n  \
    \ = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr = arr.clone();\n    new_arr.sort();\n\
    \    new_arr.iter().rev();\n    let mut arr: Vec<String> = vec![];\n    for num\
    \ in new_arr {\n        let digit = num / (10 ** 9);\n        if digit < 10 {\n\
    \            arr.push(\"One\");\n        } else if digit < 100 {\n           \
    \ arr.push(\"Two\");\n        } else if digit < 1000 {\n            arr.push(\"\
    Three\");\n        } else if digit < 10000 {\n            arr.push(\"Four\");\n\
    \        } else if digit < 100000 {\n            arr.push(\"Five\");\n       \
    \ } else if digit < 1000000 {\n            arr.push(\"Six\");\n        } else\
    \ if digit < 10000000 {\n            arr.push(\"Seven\");\n        } else if digit\
    \ < 100000000 {\n            arr.push(\"Eight\");\n        } else if digit < 1000000000\
    \ {\n            arr.push(\"Nine\");\n        } else if digit < 10000000000 {\n\
    \            arr.push(\"Ten\");\n        } else if digit < 100000000000 {\n  \
    \          arr.push(\"Eleven\");\n        } else if digit < 1000000000000 {\n\
    \            arr.push(\"Twelve\");\n        } else if digit < 10000000000000 {\n\
    \            arr.push(\"Thirteen\");\n        } else if digit < 100000000000000\
    \ {\n            arr.push(\"Fourteen\");\n        } else if digit < 1000000000000000\
    \ {\n            arr.push(\"Fifteen\");\n        } else if digit < 10000000000000000\
    \ {\n            arr.push(\"Sixteen\");\n        } else if digit < 100000000000000000\
    \ {\n            arr.push(\"Seventeen\");\n        } else if digit < 1000000000000000000\
    \ {\n            arr.push(\"Eighteen\");\n        } else if digit < 10000000000000000000\
    \ {\n            arr.push(\"Nineteen\");\n        } else if digit < 1000000000000000000\
    \ {\n            arr.push(\"Twenty\");\n        } else if digit < 10000000000000000000\
    \ {\n            arr.push(\"TwentyOne\");\n        } else if digit < 100000000000000000000\
    \ {\n            arr.push(\"TwentyTwo\");\n        } else if digit < 1000000000000000000000\
    \ {\n            arr.push(\"TwentyThree\");\n        } else if digit < 10000000000000000000000\
    \ {\n            arr.push(\"TwentyFour\");\n        } else if digit < 100000000000000000000000\
    \ {\n            arr.push(\"TwentyFive\");\n        } else if digit < 1000000000000000000000000\
    \ {\n            arr.push(\"TwentySix\");\n\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppidgpix3.rs:86:3\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     for num\
    \ in new_arr {\n   |                        - unclosed delimiter\n...\n74 |  \
    \       } else if digit < 1000000000000000000000000 {\n   |                  \
    \                                   - this delimiter might not be properly closed...\n\
    ...\n77 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    86 | }\n   |   ^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  -->\
    \ /tmp/tmppidgpix3.rs:23:32\n   |\n23 |         let digit = num / (10 ** 9);\n\
    \   |                                ^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppidgpix3.rs:25:22\n   |\n25 |             arr.push(\"One\");\n \
    \  |                      ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppidgpix3.rs:27:22\n\
    \   |\n27 |             arr.push(\"Two\");\n   |                      ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                      |\n\
    \   |                      expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppidgpix3.rs:29:22\n   |\n29 |             arr.push(\"\
    Three\");\n   |                      ^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                      |\n   |                      expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppidgpix3.rs:31:22\n\
    \   |\n31 |             arr.push(\"Four\");\n   |                      ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |\n   |                      expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppidgpix3.rs:33:22\n   |\n33 |             arr.push(\"\
    Five\");\n   |                      ^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n \
    \   let mut reverse_arr: Vec<isize> = vec![];\n    let mut temp_arr: Vec<isize>\
    \ = vec![];\n    for i in arr {\n        temp_arr.push(i);\n        if i / 10\
    \ != i % 10 {\n            temp_arr.push(i);\n        }\n    }\n    for i in temp_arr\
    \ {\n        reverse_arr.push(i);\n    }\n    for i in reverse_arr {\n       \
    \ reverse_arr.push(i * 10 + i - 1);\n    }\n    for i in reverse_arr {\n     \
    \   temp_arr.push(i);\n    }\n    temp_arr.iter().map(|x| {\n        let temp\
    \ = &*x;\n        let index = temp_arr.iter().position(|&x| x == temp).unwrap();\n\
    \        temp_arr[index] = \"One\".to_string()\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo3g_yalk.rs:40:56\n   |\n\
    40 |         let index = temp_arr.iter().position(|&x| x == temp).unwrap();\n\
    \   |                                                        ^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n40 |  \
    \       let index = temp_arr.iter().position(|&x| x == *temp).unwrap();\n   |\
    \                                                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo3g_yalk.rs:41:27\n   |\n41 |         temp_arr[index] =\
    \ \"One\".to_string()\n   |         ---------------   ^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `String`\n   |         |\n   |         expected due to\
    \ the type of this binding\n\nerror[E0277]: a value of type `Vec<String>` cannot\
    \ be built from an iterator over elements of type `()`\n    --> /tmp/tmpo3g_yalk.rs:42:8\n\
    \     |\n42   |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=()>`\n     |\n     = help: the\
    \ trait `FromIterator<()>` is not implemented for `Vec<String>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n\n    if arr.is_empty()\
    \ {\n        result\n    } else {\n        let mut i = 1;\n        for num in\
    \ arr.iter() {\n            let digit = format!(\"{}\", num as f64).len();\n \
    \           if digit == 1 {\n                result.push(\"One\");\n         \
    \   } else if digit == 2 {\n                result.push(\"Two\");\n          \
    \  } else if digit == 3 {\n                result.push(\"Three\");\n         \
    \   } else if digit == 4 {\n                result.push(\"Four\");\n         \
    \   } else if digit == 5 {\n                result.push(\"Five\");\n         \
    \   } else if digit == 6 {\n                result.push(\"Six\");\n          \
    \  } else if digit == 7 {\n                result.push(\"Seven\");\n         \
    \   } else if digit == 8 {\n                result.push(\"Eight\");\n        \
    \    } else if digit == 9 {\n                result.push(\"Nine\");\n        \
    \    }\n            if i == 9 {\n                break;\n            }\n     \
    \       i += 1;\n        }\n        result.resize(arr.len(), None);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps19i3n1a.rs:21:9\n   |\n\
    20 | /     if arr.is_empty() {\n21 | |         result\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n22 | |     } else {\n23 | |         let mut i = 1;\n\
    ...  |\n50 | |         result.resize(arr.len(), None);\n51 | |     }\n   | |_____-\
    \ expected this to be `()`\n   |\n   = note: expected unit type `()`\n       \
    \          found struct `Vec<_>`\nhelp: you might have meant to return this value\n\
    \   |\n21 |         return result;\n   |         ++++++       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps19i3n1a.rs:50:34\n   |\n50 |         result.resize(arr.len(),\
    \ None);\n   |                                  ^^^^ expected `&str`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&str`\n                   found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps19i3n1a.rs:52:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n52 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror[E0606]: casting `&isize` as `f64` is invalid\n  --> /tmp/tmps19i3n1a.rs:25:39\n\
    \   |\n25 |             let digit = format!(\"{}\", num as f64).len();\n   | \
    \                                      ---^^^^^^^\n   |                      \
    \                 |\n   |                                       cannot cast `&isize`\
    \ as `f64`\n   |                                       help: dereference the expression:\
    \ `*num`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0606.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \n    let mut reversed = [0; 10];\n    let mut count = [0; 10];\n    for i in\
    \ arr {\n        if i > 9 {\n            return Vec::new();\n        }\n     \
    \   if count[i] < i {\n            count[i] = i;\n            reversed[count[i]]\
    \ += &One;\n        } else {\n            count[i] = i;\n            reversed[count[i]]\
    \ += &Two;\n        }\n    }\n\n    for i in 0..10 {\n        reversed[i] /= 10;\n\
    \    }\n\n    let mut result = Vec::new();\n    for i in 0..10 {\n        if i\
    \ == 0 {\n            result.push(&One);\n        } else {\n            result.push(reversed[i]);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `One` in this scope\n  --> /tmp/tmpfye9_6ft.rs:30:36\n\
    \   |\n30 |             reversed[count[i]] += &One;\n   |                    \
    \                ^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `Two` in this scope\n  --> /tmp/tmpfye9_6ft.rs:33:36\n   |\n33 |           \
    \  reversed[count[i]] += &Two;\n   |                                    ^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `One` in this scope\n\
    \  --> /tmp/tmpfye9_6ft.rs:44:26\n   |\n44 |             result.push(&One);\n\
    \   |                          ^^^ not found in this scope\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpfye9_6ft.rs:28:12\n\
    \   |\n28 |         if count[i] < i {\n   |            ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[{integer}]`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpfye9_6ft.rs:29:13\n   |\n29 |         \
    \    count[i] = i;\n   |             ^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[{integer}]`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpfye9_6ft.rs:30:22\n   |\n30 |         \
    \    reversed[count[i]] += &One;\n   |                      ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `[{integer}]`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexe"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut num_arr = arr.clone();\n    let mut lens = Vec::new();\n\
    \    let mut lens_len = Vec::new();\n    num_arr.sort();\n    let mut last_num\
    \ = num_arr[0].clone();\n    lens_len = num_arr.len();\n    for &num in num_arr\
    \ {\n        if num > 0 {\n            lens.push(len - num);\n        }\n    \
    \    if num < 0 {\n            last_num -= num;\n        }\n        if num ==\
    \ last_num {\n            lens.push(len - num);\n        }\n    }\n    lens.sort_unstable();\n\
    \    let mut lens_vec: Vec<String> = Vec::new();\n    let mut last_len = lens.len();\n\
    \    for len in lens {\n        if len > 0 {\n            lens_vec.push(lens_vec[len\
    \ - 1]);\n        }\n        if len < 0 {\n            lens_vec.push(\"Nine\"\
    );\n        }\n    }\n    lens_vec.sort_unstable();\n    let mut arr: Vec<String>\
    \ = Vec::new();\n    for len in lens_vec {\n        arr.push(lens_vec[len - 1])\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `len` in this scope\n  --> /tmp/tmp1w51_f_o.rs:26:23\n\
    \   |\n26 |             lens.push(len - num);\n   |                       ^^^\
    \ help: a local variable with a similar name exists: `lens`\n\nerror[E0425]: cannot\
    \ find value `len` in this scope\n  --> /tmp/tmp1w51_f_o.rs:32:23\n   |\n32 |\
    \             lens.push(len - num);\n   |                       ^^^ help: a local\
    \ variable with a similar name exists: `lens`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1w51_f_o.rs:23:16\n   |\n20 |     let mut lens_len = Vec::new();\n\
    \   |                        ---------- expected due to this value\n...\n23 |\
    \     lens_len = num_arr.len();\n   |                ^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<_>`\n          \
    \      found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1w51_f_o.rs:24:9\n\
    \   |\n24 |     for &num in num_arr {\n   |         ^^^^    ------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1w51_f_o.rs:43:27\n   |\n43 |  \
    \           lens_vec.push(\"Nine\");\n   |                           ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `&str`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `String`\n  --> /tmp/tmp1w51_f_o.rs:49:31\n\
    \   |\n49 |         arr.push(lens_vec[len - 1])\n   |                        \
    \   --- ^ - {integer}\n   |                           |\n   |                \
    \           String\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::with_capacity(arr.len());\n    if\
    \ arr.is_empty() {\n        return result;\n    }\n    let mut reversed = arr;\n\
    \    reversed.sort();\n    reversed.reverse();\n    for i in 0..(arr.len() - 1)\
    \ {\n        result.push(\n            match reversed[i] {\n                1\
    \ => String::from(\"One\"),\n                2 => String::from(\"Two\"),\n   \
    \             3 => String::from(\"Three\"),\n                4 => String::from(\"\
    Four\"),\n                5 => String::from(\"Five\"),\n                6 => String::from(\"\
    Six\"),\n                7 => String::from(\"Seven\"),\n                8 => String::from(\"\
    Eight\"),\n                9 => String::from(\"Nine\"),\n                _ =>\
    \ String::from(\"Unknown\"),\n            }\n        );\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n  --> /tmp/tmpm9y5wvpv.rs:25:18\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \ --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n22 |     let mut reversed = arr;\n   |              \
    \          --- value moved here\n...\n25 |     for i in 0..(arr.len() - 1) {\n\
    \   |                  ^^^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    \n    if arr.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut a = arr.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ b = a.iter_mut().map(|x| x.clone());\n    let mut i = 0;\n    let mut cur =\
    \ 0;\n\n    while i < b.len() {\n        if b.len() == 0 {\n            break;\n\
    \        }\n\n        cur = &b[b.len() - 1];\n\n        if *cur == 1 {\n     \
    \       b.last_mut().unwrap() = -1;\n        }\n\n        if *cur == -1 {\n  \
    \          b.last_mut().unwrap() = 1;\n        }\n\n        if *cur > 9 {\n  \
    \          b.last_mut().unwrap() = &arr[*cur as usize - 10..*cur as usize - 1];\n\
    \        }\n\n        i += 1;\n    }\n\n    if b.len() == 0 {\n        return\
    \ Vec::new();\n    }\n\n    b.sort_by(|a, b| a.cmp(b));\n    b.iter().cloned().collect::<Vec<_>>().reverse().iter()\n\
    \        .map(|x| &**x).map(|x| x.to_string())\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Map<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp3kk_24h6.rs:24:34: 24:47]>`\n  --> /tmp/tmp3kk_24h6.rs:33:16\n\
    \   |\n33 |         cur = &b[b.len() - 1];\n   |                ^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp3kk_24h6.rs:35:12\n\
    \   |\n35 |         if *cur == 1 {\n   |            ^^^^\n\nerror[E0070]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp3kk_24h6.rs:36:35\n   |\n36 |  \
    \           b.last_mut().unwrap() = -1;\n   |             ---------------------\
    \ ^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0599]: no method named `last_mut` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp3kk_24h6.rs:36:15\n   |\n36 |             b.last_mut().unwrap()\
    \ = -1;\n   |               ^^^^^^^^ method not found in `Map<std::slice::IterMut<'_,\
    \ isize>, [closure@/tmp/tmp3kk_24h6.rs:24:34: 24:47]>`\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmp3kk_24h6.rs:39:12\n   |\n39 |        \
    \ if *cur == -1 {\n   |            ^^^^\n\nerror[E0070]: invalid left-hand side\
    \ of assignment\n  --> /tmp/tmp3kk_24h6.rs:40:35\n   |\n40 |             b.last_mut().unwrap()\
    \ = 1;\n   |             --------------------- ^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0599]: no method named `last_mut`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmp3kk_24h6.rs:40:15\n\
    \   |\n40 |             b.last_mut().unwrap() = 1;\n   |               ^^^^^^^^\
    \ method not found in `Map<std::slice::IterMut<'_, isize>, [closure@/tmp/tmp3kk_24h6.rs:24:34:\
    \ 24:47]>`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp3kk_24h6.rs:43:12\n\
    \   |\n43 |         if *cur > 9 {\n   |            ^^^^\n\nerror[E0070]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmp3kk_24h6.rs:44:35\n   |\n44 |  \
    \           b.last_mut().unwrap() = &arr[*cur as usize - 10..*cur as usize - 1];\n\
    \   |             --------------------- ^\n   |             |\n   |          \
    \   cannot assign to this expression\n\nerror[E0599]: no me"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_by(|a, b| b.cmp(a))\n        .map(|a| {\n   \
    \         match a % 10 {\n                0 => \"Zero\",\n                1 =>\
    \ \"One\",\n                2 => \"Two\",\n                3 => \"Three\",\n \
    \               4 => \"Four\",\n                5 => \"Five\",\n             \
    \   6 => \"Six\",\n                7 => \"Seven\",\n                8 => \"Eight\"\
    ,\n                9 => \"Nine\",\n                _ => panic!(\"Bad number, sorry!\"\
    ),\n            }\n        })\n        .collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpphl04bcs.rs:19:10\n\
    \   |\n19 |         .map(|a| {\n   |          ^^^ `()` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for value in arr {\n\
    \        let digits = value.to_string().chars().collect::<Vec<char>>();\n    \
    \    digits.reverse();\n        let mut buf: String = \"\";\n        for digit\
    \ in digits {\n            buf += \"Nine\".to_string();\n            buf += digit.to_string();\n\
    \        }\n        result += &buf;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyxt21hhq.rs:22:31\n   |\n\
    22 |         let mut buf: String = \"\";\n   |                      ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |        |\n   |                      |        expected struct `String`,\
    \ found `&str`\n   |                      expected due to this\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxt21hhq.rs:24:20\n   |\n24 |             buf\
    \ += \"Nine\".to_string();\n   |                    ^^^^^^^^^^^^^^^^^^\n   | \
    \                   |\n   |                    expected `&str`, found struct `String`\n\
    \   |                    help: consider borrowing here: `&\"Nine\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyxt21hhq.rs:25:20\n   |\n25 |\
    \             buf += digit.to_string();\n   |                    ^^^^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&str`, found struct\
    \ `String`\n   |                    help: consider borrowing here: `&digit.to_string()`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<_>`\n\
    \  --> /tmp/tmpyxt21hhq.rs:27:9\n   |\n27 |         result += &buf;\n   |    \
    \     ------^^^^^^^^\n   |         |\n   |         cannot use `+=` on type `Vec<_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut reverse_arr = arr.clone();\n    reverse_arr.reverse();\n    for &n\
    \ in reverse_arr.iter() {\n        match n % 10 {\n            1 => \"One\".to_string(),\n\
    \            2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(),\n        }\n    }\n    reverse_arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp8yf4911g.rs:34:18\n\
    \   |\n24 | /         match n % 10 {\n25 | |             1 => \"One\".to_string(),\n\
    26 | |             2 => \"Two\".to_string(),\n27 | |             3 => \"Three\"\
    .to_string(),\n...  |\n33 | |             9 => \"Nine\".to_string(),\n   | | \
    \                 ------------------ this and all prior arms are found to be of\
    \ type `String`\n34 | |             _ => panic!(),\n   | |                  ^^^^^^^^\
    \ expected struct `String`, found `()`\n35 | |         }\n   | |_________- `match`\
    \ arms have incompatible types\n   |\n   = note: this error originates in the\
    \ macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8yf4911g.rs:37:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n37 |     reverse_arr\n   |     ^^^^^^^^^^^ expected struct `String`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut counters = vec![String::from(\"\"), String::from(\"\
    \"), String::from(\"\"), String::from(\"\"), String::from(\"\"), String::from(\"\
    \"), String::from(\"\"), String::from(\"\")];\n    for num in arr {\n        if\
    \ 1 < num && num < 9 {\n            counters[num - 1].push('One');\n        }\
    \ else if 2 <= num {\n            counters[num - 1].push('Two');\n        } else\
    \ if 3 <= num {\n            counters[num - 1].push('Three');\n        } else\
    \ if 4 <= num {\n            counters[num - 1].push('Four');\n        } else if\
    \ 5 <= num {\n            counters[num - 1].push('Five');\n        } else if 6\
    \ <= num {\n            counters[num - 1].push('Six');\n        } else if 7 <=\
    \ num {\n            counters[num - 1].push('Seven');\n        } else if 8 <=\
    \ num {\n            counters[num - 1].push('Eight');\n        } else if 9 <=\
    \ num {\n            counters[num - 1].push('Nine');\n        } else {\n     \
    \       continue;\n        }\n    }\n    for counter in counters.iter().rev()\
    \ {\n        if let Some(str) = counter {\n            match str {\n         \
    \       \"Eight\" => return vec![\"Eight\"],\n                \"Five\" => return\
    \ vec![\"Five\"],\n                \"Four\" => return vec![\"Four\"],\n      \
    \          \"Three\" => return vec![\"Three\"],\n                \"Two\" => return\
    \ vec![\"Two\"],\n                \"Two\" => return vec![\"Two\"],\n         \
    \       \"One\" => return vec![\"One\"],\n                \"\" => (),\n      \
    \      }\n        }\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp2a8wy2ro.rs:21:36\n\
    \   |\n21 |             counters[num - 1].push('One');\n   |                 \
    \                   ^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n21 |             counters[num - 1].push(\"One\");\n\
    \   |                                    ~~~~~\n\nerror: character literal may\
    \ only contain one codepoint\n  --> /tmp/tmp2a8wy2ro.rs:23:36\n   |\n23 |    \
    \         counters[num - 1].push('Two');\n   |                               \
    \     ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n23 |             counters[num - 1].push(\"Two\");\n   |               \
    \                     ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmp2a8wy2ro.rs:25:36\n   |\n25 |             counters[num - 1].push('Three');\n\
    \   |                                    ^^^^^^^\n   |\nhelp: if you meant to\
    \ write a `str` literal, use double quotes\n   |\n25 |             counters[num\
    \ - 1].push(\"Three\");\n   |                                    ~~~~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp2a8wy2ro.rs:27:36\n\
    \   |\n27 |             counters[num - 1].push('Four');\n   |                \
    \                    ^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n27 |             counters[num - 1].push(\"Four\");\n\
    \   |                                    ~~~~~~\n\nerror: character literal may\
    \ only contain one codepoint\n  --> /tmp/tmp2a8wy2ro.rs:29:36\n   |\n29 |    \
    \         counters[num - 1].push('Five');\n   |                              \
    \      ^^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n29 |             counters[num - 1].push(\"Five\");\n   |              \
    \                      ~~~~~~\n\nerror: character literal may only contain one\
    \ codepoint\n  --> /tmp/tmp2a8wy2ro.rs:31:36\n   |\n31 |             counters[num\
    \ - 1].push('Six');\n   |                                    ^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n \
    \   if arr.len() == 1 {\n        let mut arr = [vec![\"One\"]];\n        arr.push(vec![\"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ]);\n        return arr;\n    }\n    let mut arr = arr.clone();\n    arr.sort();\n\
    \    arr.reverse();\n    for i in 0..arr.len() {\n        let index = arr[i].to_digit(10);\n\
    \        arr[i] = arr[i].to_string() + &arr[index];\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for array `[Vec<&str>; 1]` in\
    \ the current scope\n  --> /tmp/tmpomokwdxa.rs:23:13\n   |\n23 |         arr.push(vec![\"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ]);\n   |             ^^^^ method not found in `[Vec<&str>; 1]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpomokwdxa.rs:24:16\n   |\n17 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n24 |         return arr;\n\
    \   |                ^^^ expected struct `Vec`, found array of 1 element\n   |\n\
    \   = note: expected struct `Vec<String>`\n               found array `[Vec<&str>;\
    \ 1]`\n\nerror[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpomokwdxa.rs:30:28\n   |\n30 |         let index\
    \ = arr[i].to_digit(10);\n   |                            ^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpomokwdxa.rs:31:18\n\
    \   |\n31 |         arr[i] = arr[i].to_string() + &arr[index];\n   |         ------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |         |\n   |         expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpomokwdxa.rs:33:5\n   |\n17 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n33 |     arr\n   |     ^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        vec![]\n    } else if arr.len()\
    \ == 1 {\n        if arr[0] == 1 {\n            vec![\"One\"]\n        } else\
    \ {\n            vec![]\n        }\n    } else {\n        let mut result = vec![];\n\
    \        arr.iter().enumerate().for_each(|(index, value)| {\n            if value\
    \ <= 9 {\n                result.push(format!(\"One\"));\n            }\n    \
    \        if value <= 99 {\n                result.push(format!(\"Two\"));\n  \
    \          }\n            if value <= 999 {\n                result.push(format!(\"\
    Three\"));\n            }\n            if value <= 9999 {\n                result.push(format!(\"\
    Four\"));\n            }\n            if value <= 9999999 {\n                result.push(format!(\"\
    Five\"));\n            }\n            if value <= 999999999 {\n              \
    \  result.push(format!(\"Six\"));\n            }\n            if value <= 999999999999\
    \ {\n                result.push(format!(\"Seven\"));\n            }\n       \
    \     if value <= 9999999999999 {\n                result.push(format!(\"Eight\"\
    ));\n            }\n            if value <= 999999999999999 {\n              \
    \  result.push(format!(\"Nine\"));\n            }\n        });\n        result.reverse();\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmv3h6o4s.rs:22:18\n   |\n\
    22 |             vec![\"One\"]\n   |                  ^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                  |\n   |           \
    \       expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmv3h6o4s.rs:29:25\n   |\n29 |             if value <= 9 {\n   |\
    \                         ^\n   |                         |\n   |            \
    \             expected `&isize`, found integer\n   |                         help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmv3h6o4s.rs:32:25\n\
    \   |\n32 |             if value <= 99 {\n   |                         ^^\n  \
    \ |                         |\n   |                         expected `&isize`,\
    \ found integer\n   |                         help: consider borrowing here: `&99`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmv3h6o4s.rs:35:25\n   |\n35 |\
    \             if value <= 999 {\n   |                         ^^^\n   |      \
    \                   |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowing here: `&999`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmv3h6o4s.rs:38:25\n   |\n38 |             if\
    \ value <= 9999 {\n   |                         ^^^^\n   |                   \
    \      |\n   |                         expected `&isize`, found integer\n   |\
    \                         help: consider borrowing here: `&9999`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmv3h6o4s.rs:41:25\n   |\n41 |             if\
    \ value <= 9999999 {\n   |                         ^^^^^^^\n   |             \
    \            |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowing here: `&9999999`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmv3h6o4s.rs:44:25\n   |\n44 |             if\
    \ value <= 999999999 {\n   |                         ^^^^^^^^^\n   |         \
    \                |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowin"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut reverse = Vec::new();\n    let mut digits = vec![];\n\
    \    let mut max_i = arr.last().unwrap() - 1;\n    let mut min_i = arr[0].unwrap()\
    \ - 1;\n    let mut digit_idx = 0;\n    while min_i <= max_i {\n        reverse.push(min_i);\n\
    \        reverse.push(arr[min_i]);\n        digit_idx += 1;\n        if digit_idx\
    \ % 5 == 0 {\n            digits.push(\"Five\".to_string());\n        }\n    \
    \    if digit_idx % 7 == 0 {\n            digits.push(\"Seven\".to_string());\n\
    \        }\n        if digit_idx % 9 == 0 {\n            digits.push(\"Eight\"\
    .to_string());\n        }\n        if digit_idx % 11 == 0 {\n            digits.push(\"\
    Nine\".to_string());\n        }\n        if digit_idx % 13 == 0 {\n          \
    \  digits.push(\"Ten\".to_string());\n        }\n        if digit_idx % 15 ==\
    \ 0 {\n            digits.push(\"Eleven\".to_string());\n        }\n        if\
    \ digit_idx % 17 == 0 {\n            digits.push(\"Twelve\".to_string());\n  \
    \      }\n        if digit_idx % 19 == 0 {\n            digits.push(\"Thirteen\"\
    .to_string());\n        }\n        if digit_idx % 21 == 0 {\n            digits.push(\"\
    Fourteen\".to_string());\n        }\n        if digit_idx % 23 == 0 {\n      \
    \      digits.push(\"Fifteen\".to_string());\n        }\n        if digit_idx\
    \ % 25 == 0 {\n            digits.push(\"Sixteen\".to_string());\n        }\n\
    \        if digit_idx % 27 == 0 {\n            digits.push(\"Seventeen\".to_string());\n\
    \        }\n        if digit_idx % 29 == 0 {\n            digits.push(\"Eighteen\"\
    .to_string());\n        }\n        if digit_idx % 31 == 0 {\n            digits.push(\"\
    Nineteen\".to_string());\n        }\n        if digit_idx % 33 == 0 {\n      \
    \      digits.push(\"Twenty\".to_string());\n        }\n        if digit_idx %\
    \ 35 == 0 {\n            digits.push(\"Thirty\".to_string());\n        }\n   \
    \     if digit_idx % 37 == 0 {\n            digits.push(\"Forty\".to_string());\n\
    \        }\n        if digit_idx % 39 == 0 {\n            digits.push(\"Fifty\"\
    .to_string());\n        }\n        if digit_idx % 41 == 0 {\n            digits.push(\"\
    Sixty\".to_string());\n        }\n        if digit_idx % 43 == 0 {\n         \
    \   digits.push(\"Seventy\".to_string());\n        }\n        if digit_idx % 45\
    \ == 0 {\n            digits.push(\"Eighty\".to_string());\n        }\n      \
    \  if digit_idx % 47\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpctzga68r.rs:100:3\n\
    \    |\n17  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n23  |     while\
    \ min_i <= max_i {\n    |                          - this delimiter might not\
    \ be properly closed...\n...\n91  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n100 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpctzga68r.rs:91:1\n   |\n90 |         if digit_idx % 47\n\
    \   |         -- this `if` expression has a condition, but no block\n91 | }\n\
    \   | ^ expected `{`\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpctzga68r.rs:21:28\n   |\n21 |  \
    \   let mut min_i = arr[0].unwrap() - 1;\n   |                            ^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctzga68r.rs:17:34\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = String::new();\n    let mut current =\
    \ String::new();\n    let mut last = 0;\n    let mut min = i32::MIN;\n    let\
    \ mut max = i32::MAX;\n    for x in arr.iter() {\n        current += x.to_string();\n\
    \        if min > x {\n            min = x;\n        }\n        if max < x {\n\
    \            max = x;\n        }\n    }\n    // print(current, max, min, last);\n\
    \    if min == max {\n        result.push_str(&current);\n        current.clear();\n\
    \    }\n    else {\n        result.push_str(&current);\n        current.clear();\n\
    \        result.push_str(&format!(\"{}\", min));\n        min = max - 1;\n   \
    \     if min == 0 {\n            result.push_str(&format!(\"One\", min));\n  \
    \          min = i32::MIN;\n        }\n        else {\n            result.push_str(&format!(\"\
    {}\", min));\n            min = i32::MIN;\n        }\n    }\n    if max > i32::MAX\
    \ {\n        result.push_str(&format!(\"{}\", max));\n        max = i32::MAX;\n\
    \    }\n    while max > i32::MAX {\n        result.push_str(&format!(\"{}\", max));\n\
    \        max = i32::MAX;\n    }\n    while min < i32::MIN {\n        result.push_str(&format!(\"\
    {}\", min));\n        min = i32::MIN;\n    }\n    // print(result, max, min, last);\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmpvm6di4g5.rs:43:45\n   |\n43 |\
    \             result.push_str(&format!(\"One\", min));\n   |                 \
    \                     -----  ^^^ argument never used\n   |                   \
    \                   |\n   |                                      formatting specifier\
    \ missing\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvm6di4g5.rs:24:20\n\
    \   |\n24 |         current += x.to_string();\n   |                    ^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&str`, found struct\
    \ `String`\n   |                    help: consider borrowing here: `&x.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvm6di4g5.rs:25:18\n   |\n25 |\
    \         if min > x {\n   |                  ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvm6di4g5.rs:26:19\n   |\n21 |\
    \     let mut min = i32::MIN;\n   |                   -------- expected due to\
    \ this value\n...\n26 |             min = x;\n   |                   ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvm6di4g5.rs:28:18\n\
    \   |\n28 |         if max < x {\n   |                  ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvm6di4g5.rs:29:19\n\
    \   |\n22 |     let mut max = i32::MAX;\n   |                   -------- expected\
    \ due to this value\n...\n29 |             max = x;\n   |                   ^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvm6di4g5.rs:64:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n64 |     result\n   |     ^^^^^^ expected struct `Vec`, found struct `String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `String`\n\
    \nerror: aborting due to 7 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut last = 0;\n\n\
    \    for num in arr.iter() {\n        if last > 0 {\n            let mut num =\
    \ num - last;\n            num = num * 10;\n            num = num + last;\n  \
    \          result.push(by_digit(num));\n        }\n        result.push(by_digit(num));\n\
    \        last = 0;\n    }\n\n    if last > 0 {\n        let mut num = last + last;\n\
    \        num = num * 10;\n        num = num + last;\n        result.push(by_digit(num));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpr378y_uw.rs:26:25\n\
    \   |\n26 |             result.push(by_digit(num));\n   |                    \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `by_digit`\
    \ in this scope\n  --> /tmp/tmpr378y_uw.rs:28:21\n   |\n28 |         result.push(by_digit(num));\n\
    \   |                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `by_digit` in this scope\n  --> /tmp/tmpr378y_uw.rs:36:21\n  \
    \ |\n36 |         result.push(by_digit(num));\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // if arr is empty, return empty array\n    if arr.len()\
    \ == 0 {\n        return Vec::new();\n    }\n    let mut i = 0;\n    while i <\
    \ arr.len() {\n        if arr[i] < 9 {\n            arr[i] = \"One\".to_owned();\n\
    \        } else {\n            arr[i] = \"Nine\".to_owned();\n        }\n    \
    \    i += 1;\n    }\n    let mut i = 0;\n    while i < arr.len() {\n        if\
    \ arr[i] < 0 {\n            arr[i] = \"One\".to_owned();\n        } else {\n \
    \           arr[i] = \"Nine\".to_owned();\n        }\n        i += 1;\n    }\n\
    \    let mut arr1 = arr.clone();\n    arr1.sort();\n    arr1.reverse();\n    for\
    \ i in 0..arr1.len() {\n        let j = arr1.len() - i - 1;\n        arr1[j].to_string().unwrap().replace(\"\
    One\", \"Eight\").replace(\"Nine\", \"One\");\n    }\n    arr1.clone()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8hwss06k.rs:25:22\n   |\n\
    25 |             arr[i] = \"One\".to_owned();\n   |             ------   ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8hwss06k.rs:27:22\n   |\n27 |             arr[i] = \"Nine\".to_owned();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8hwss06k.rs:34:22\n   |\n34 |\
    \             arr[i] = \"One\".to_owned();\n   |             ------   ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8hwss06k.rs:36:22\n   |\n36 |             arr[i] = \"Nine\".to_owned();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8hwss06k.rs:45:29\n   |\n45 |         arr1[j].to_string().unwrap().replace(\"\
    One\", \"Eight\").replace(\"Nine\", \"One\");\n   |                          \
    \   ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8hwss06k.rs:47:5\n   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n47 |     arr1.clone()\n   |     ^^^^^^^^^^^^ expected\
    \ struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut reversed: Vec<isize> = arr\n        .iter()\n\
    \        .map(|x| x % 10)\n        .collect();\n    reversed.reverse();\n    let\
    \ mut result: Vec<String> = vec![];\n    let mut counter: usize = 0;\n    for\
    \ value in reversed {\n        if counter == 0 {\n            result.push(by_digit_name(value,\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"]));\n        } else {\n            result.push(by_digit_name(value,\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"]));\n        }\n        counter += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit_name` in this scope\n  -->\
    \ /tmp/tmpkkw9wvdz.rs:27:25\n   |\n27 |             result.push(by_digit_name(value,\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"]));\n   |                         ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `by_digit_name` in this scope\n\
    \  --> /tmp/tmpkkw9wvdz.rs:29:25\n   |\n29 |             result.push(by_digit_name(value,\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"]));\n   |                         ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let len = arr.len();\n \
    \   let nums = arr.iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<_>>();\n\
    \    if arr.len() > 0 {\n        result.push(get_name(nums[len - 1]));\n    }\n\
    \    for i in len - 1 {\n        result.push(get_name(nums[i]));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_name` in this scope\n  --> /tmp/tmpogm1fmqn.rs:22:21\n\
    \   |\n22 |         result.push(get_name(nums[len - 1]));\n   |              \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `get_name` in this scope\n  --> /tmp/tmpogm1fmqn.rs:25:21\n   |\n25 |      \
    \   result.push(get_name(nums[i]));\n   |                     ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpogm1fmqn.rs:20:44\n\
    \   |\n20 |     let nums = arr.iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<_>>();\n\
    \   |                                            ^\n   |                     \
    \                       |\n   |                                            expected\
    \ `&isize`, found integer\n   |                                            help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpogm1fmqn.rs:20:54\n\
    \   |\n20 |     let nums = arr.iter().filter(|&x| x >= 1 && x <= 9).collect::<Vec<_>>();\n\
    \   |                                                      ^\n   |           \
    \                                           |\n   |                          \
    \                            expected `&isize`, found integer\n   |          \
    \                                            help: consider borrowing here: `&9`\n\
    \nerror[E0277]: `usize` is not an iterator\n  --> /tmp/tmpogm1fmqn.rs:24:14\n\
    \   |\n24 |     for i in len - 1 {\n   |              ^^^^^^^ `usize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `usize`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `usize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.to_owned();\n    arr.sort();\n    let\
    \ len = arr.len();\n    let mut ans = vec![\"\".to_string()];\n    for i in 0..len\
    \ {\n        ans.push(&format!(\"{}\", arr[i]));\n    }\n    for i in 0..len {\n\
    \        for j in &mut ans {\n            if i != j {\n                let val\
    \ = format!(\"{}\", arr[i]);\n                if val != \"0\" {\n            \
    \        let num = val.parse::<isize>();\n                    let mut num = num;\n\
    \                    num %= 10;\n                    if num == 0 {\n         \
    \               num = -1;\n                    }\n                    j.push_str(&format!(\"\
    {}\", num));\n                    break;\n                }\n            }\n \
    \       }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpicj04wyo.rs:23:18\n   |\n\
    23 |         ans.push(&format!(\"{}\", arr[i]));\n   |                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n23 -         ans.push(&format!(\"{}\", arr[i]));\n23 +       \
    \  ans.push(format!(\"{}\", arr[i]));\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpicj04wyo.rs:27:21\n   |\n27 |             if i != j {\n   |   \
    \                  ^ expected `usize`, found `&mut String`\n\nerror[E0368]: binary\
    \ assignment operation `%=` cannot be applied to type `Result<isize, ParseIntError>`\n\
    \  --> /tmp/tmpicj04wyo.rs:32:21\n   |\n32 |                     num %= 10;\n\
    \   |                     ---^^^^^^\n   |                     |\n   |        \
    \             cannot use `%=` on type `Result<isize, ParseIntError>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpicj04wyo.rs:33:31\n   |\n33 |              \
    \       if num == 0 {\n   |                               ^ expected enum `Result`,\
    \ found integer\n   |\n   = note: expected enum `Result<isize, ParseIntError>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Ok`\n\
    \   |\n33 |                     if num == Ok(0) {\n   |                      \
    \         +++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpicj04wyo.rs:34:31\n\
    \   |\n31 |                     let mut num = num;\n   |                     \
    \              --- expected due to this value\n...\n34 |                     \
    \    num = -1;\n   |                               ^^ expected enum `Result`,\
    \ found integer\n   |\n   = note: expected enum `Result<isize, ParseIntError>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Ok`\n\
    \   |\n34 |                         num = Ok(-1);\n   |                      \
    \         +++  +\n\nerror[E0277]: `Result<isize, ParseIntError>` doesn't implement\
    \ `std::fmt::Display`\n  --> /tmp/tmpicj04wyo.rs:36:47\n   |\n36 |           \
    \          j.push_str(&format!(\"{}\", num));\n   |                          \
    \                     ^^^ `Result<isize, ParseIntError>` cannot be "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr: Vec<String> = Vec::new();\n    let\
    \ mut reversed_arr: Vec<isize> = Vec::new();\n\n    sorted_arr.push(format!(\"\
    One\", 1));\n    sorted_arr.push(format!(\"Two\", 2));\n    sorted_arr.push(format!(\"\
    Three\", 3));\n    sorted_arr.push(format!(\"Four\", 4));\n    sorted_arr.push(format!(\"\
    Five\", 5));\n    sorted_arr.push(format!(\"Six\", 6));\n    sorted_arr.push(format!(\"\
    Seven\", 7));\n    sorted_arr.push(format!(\"Eight\", 8));\n    sorted_arr.push(format!(\"\
    Nine\", 9));\n\n    let mut index = 0;\n\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        let mut val = x;\n        if x < 10 {\n            val = x + 1;\n\
    \        }\n        if val > 9 {\n            val = val - 10;\n        }\n   \
    \     \n        reversed_arr.push(val);\n        if index == 0 {\n           \
    \ index = index;\n        }\n        index += 1;\n    }\n\n    if reversed_arr.len()\
    \ > 0 {\n        sorted_arr.push(reversed_arr.reverse());\n    }\n    \n    if\
    \ sorted_arr.len() == 0 {\n        return Vec::new();\n    }\n\n    sorted_arr.reverse();\n\
    \    \n    let mut index = 0;\n    for (i, x) in sorted_arr.iter().enumerate()\
    \ {\n        let mut val = x;\n        if val == 0 {\n            val = 90;\n\
    \        }\n        \n        let num = String::from(\"{}\");\n        \n    \
    \    sorted_arr[i] = format!(\"{}\", num[val - 1]);\n        if index == 0 {\n\
    \            index = index;\n        }\n        index += 1;\n    }\n    \n   \
    \ sorted_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmplh5zv81g.rs:21:36\n   |\n21 |\
    \     sorted_arr.push(format!(\"One\", 1));\n   |                            \
    \ -----  ^ argument never used\n   |                             |\n   |     \
    \                        formatting specifier missing\n\nerror: argument never\
    \ used\n  --> /tmp/tmplh5zv81g.rs:22:36\n   |\n22 |     sorted_arr.push(format!(\"\
    Two\", 2));\n   |                             -----  ^ argument never used\n \
    \  |                             |\n   |                             formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmplh5zv81g.rs:23:38\n\
    \   |\n23 |     sorted_arr.push(format!(\"Three\", 3));\n   |                \
    \             -------  ^ argument never used\n   |                           \
    \  |\n   |                             formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmplh5zv81g.rs:24:37\n   |\n24 |     sorted_arr.push(format!(\"\
    Four\", 4));\n   |                             ------  ^ argument never used\n\
    \   |                             |\n   |                             formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmplh5zv81g.rs:25:37\n\
    \   |\n25 |     sorted_arr.push(format!(\"Five\", 5));\n   |                 \
    \            ------  ^ argument never used\n   |                             |\n\
    \   |                             formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmplh5zv81g.rs:26:36\n   |\n26 |     sorted_arr.push(format!(\"\
    Six\", 6));\n   |                             -----  ^ argument never used\n \
    \  |                             |\n   |                             formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmplh5zv81g.rs:27:38\n\
    \   |\n27 |     sorted_arr.push(format!(\"Seven\", 7));\n   |                \
    \             -------  ^ argument never used\n   |                           \
    \  |\n   |                             formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmplh5zv81g.rs:28:38\n   |\n28 |     sorted_arr.push(format!(\"\
    Eight\", 8));\n   |                             -------  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut i = 0;\n    let mut j = 0;\n    let mut max = arr.len();\n    let\
    \ mut tmp: Vec<isize>;\n    \n    while i < max {\n        if arr[i] == 0 {\n\
    \            i += 1;\n            continue;\n        }\n        if arr[i as usize]\
    \ < arr[i as usize]+9 {\n            tmp = arr.drain(i, max - i);\n          \
    \  i += tmp.size() - 1;\n            arr.retain(|&x| x > 0);\n        }\n    \
    \    i += 1;\n    }\n    \n    max = arr.len();\n    while i < max {\n       \
    \ if arr[i] == 0 {\n            i += 1;\n            continue;\n        }\n  \
    \      if arr[i as usize] > arr[i as usize]-9 {\n            tmp = arr.drain(i,\
    \ max - i);\n            i += tmp.size() - 1;\n            arr.retain(|&x| x <\
    \ 0);\n        }\n        i += 1;\n    }\n    \n    let mut res = vec![];\n  \
    \  for i in 0..arr.len() {\n        if arr[i] == 0 {\n            continue;\n\
    \        }\n        res.push(one_digit_name(arr[i]));\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `one_digit_name` in this scope\n  -->\
    \ /tmp/tmppx7lvl08.rs:58:18\n   |\n58 |         res.push(one_digit_name(arr[i]));\n\
    \   |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmppx7lvl08.rs:32:23\n\
    \     |\n32   |             tmp = arr.drain(i, max - i);\n     |             \
    \          ^^^^^ -  ------- supplied 2 arguments\n     |                     \
    \  |\n     |                       expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppx7lvl08.rs:32:19\n\
    \   |\n24 |     let mut tmp: Vec<isize>;\n   |                  ---------- expected\
    \ due to this type\n...\n32 |             tmp = arr.drain(i, max - i);\n   | \
    \                  ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `std::vec::Drain`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `std::vec::Drain<'_,\
    \ isize>`\n\nerror[E0599]: no method named `size` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmppx7lvl08.rs:33:22\n   |\n33 |          \
    \   i += tmp.size() - 1;\n   |                      ^^^^ help: there is an associated\
    \ function with a similar name: `resize`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmppx7lvl08.rs:46:23\n\
    \     |\n46   |             tmp = arr.drain(i, max - i);\n     |             \
    \          ^^^^^ -  ------- supplied 2 arguments\n     |                     \
    \  |\n     |                       expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppx7lvl08.rs:46:19\n\
    \   |\n24 |     let mut tmp: Vec<isize>;\n   |                  ---------- expected\
    \ due to this type\n...\n46 |             tmp = arr.drain(i, max - i);\n   | \
    \                  ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `std::vec::Drain`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `std::vec::Drain<'_,\
    \ isize>`\n\nerror[E0599]: no method named `si"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    \n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr.reverse();\n\n    // we copy the original array then sort it\n\
    \    let mut arr: Vec<String> = arr.clone();\n    for i in 0..arr.len() {\n  \
    \      let mut digit = 0;\n        while digit < 9 {\n            if arr[i] ==\
    \ digit {\n                break;\n            }\n            digit += 1;\n  \
    \      }\n\n        // we add the name if the index is greater than 9\n      \
    \  if digit > 9 {\n            arr.insert((digit - 10) as usize, String::from(\"\
    One\"));\n            arr.insert((digit - 9) as usize, String::from(\"Two\"));\n\
    \            arr.insert((digit - 8) as usize, String::from(\"Three\"));\n    \
    \        arr.insert((digit - 7) as usize, String::from(\"Four\"));\n         \
    \   arr.insert((digit - 6) as usize, String::from(\"Five\"));\n            arr.insert((digit\
    \ - 5) as usize, String::from(\"Six\"));\n            arr.insert((digit - 4) as\
    \ usize, String::from(\"Seven\"));\n            arr.insert((digit - 3) as usize,\
    \ String::from(\"Eight\"));\n            arr.insert((digit - 2) as usize, String::from(\"\
    Nine\"));\n        }\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyexe1em.rs:24:32\n   |\n\
    24 |     let mut arr: Vec<String> = arr.clone();\n   |                  -----------\
    \   ^^^^^^^^^^^ expected struct `String`, found `isize`\n   |                \
    \  |\n   |                  expected due to this\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<isize>`\n\nerror[E0277]: can't\
    \ compare `String` with `{integer}`\n  --> /tmp/tmpzyexe1em.rs:28:23\n   |\n28\
    \ |             if arr[i] == digit {\n   |                       ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter().filter(|x| x != 1 && x != -1).collect::<Vec<String>>().reverse().iter().enumerate().map(|(i,\
    \ v)| {\n        let name = one_to_nine()[v as usize];\n        if name != \"\"\
    \ {\n            format!(\"{}\", name)\n        } else {\n            format!(\"\
    {}\", i)\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `one_to_nine` in this scope\n  --> /tmp/tmpkm7kifi3.rs:19:20\n\
    \   |\n19 |         let name = one_to_nine()[v as usize];\n   |              \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't compare `&&isize`\
    \ with `{integer}`\n  --> /tmp/tmpkm7kifi3.rs:18:29\n   |\n18 |     arr.iter().filter(|x|\
    \ x != 1 && x != -1).collect::<Vec<String>>().reverse().iter().enumerate().map(|(i,\
    \ v)| {\n   |                             ^^ no implementation for `&&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&&isize` with `{integer}`\n\
    \  --> /tmp/tmpkm7kifi3.rs:18:39\n   |\n18 |     arr.iter().filter(|x| x != 1\
    \ && x != -1).collect::<Vec<String>>().reverse().iter().enumerate().map(|(i, v)|\
    \ {\n   |                                       ^^ no implementation for `&&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&isize`\n    --> /tmp/tmpkm7kifi3.rs:18:46\n\
    \     |\n18   |     arr.iter().filter(|x| x != 1 && x != -1).collect::<Vec<String>>().reverse().iter().enumerate().map(|(i,\
    \ v)| {\n     |                                              ^^^^^^^ value of\
    \ type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n \
    \   let mut result = vec![];\n    for i in arr {\n        if i > 0 && i <= 9 {\n\
    \            result.push(&\"One\".to_string());\n        } else if i > 9 && i\
    \ <= 99 {\n            result.push(&\"Two\".to_string());\n        } else if i\
    \ > 99 && i <= 999 {\n            result.push(&\"Three\".to_string());\n     \
    \   } else if i > 999 && i <= 9999 {\n            result.push(&\"Four\".to_string());\n\
    \        } else if i > 9999 && i <= 99999 {\n            result.push(&\"Five\"\
    .to_string());\n        } else if i > 99999 && i <= 999999 {\n            result.push(&\"\
    Six\".to_string());\n        } else if i > 999999 && i <= 9999999 {\n        \
    \    result.push(&\"Seven\".to_string());\n        } else if i > 9999999 && i\
    \ <= 999999999 {\n            result.push(&\"Eight\".to_string());\n        }\
    \ else if i > 999999999 && i <= 9999999999 {\n            result.push(&\"Nine\"\
    .to_string());\n        } else {\n            continue;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpksxcufye.rs:45:5\n   |\n\
    17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    45 |     result\n   |     ^^^^^^ expected struct `String`, found `&String`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr2 = arr.clone();\n    arr2.sort();\n    arr2.reverse();\n\
    \    let mut arr3 = arr2.clone();\n    let mut length: isize = 0;\n    for i in\
    \ 0..(arr2.len() - 1) {\n        if i != 0 && arr2[i] + 1 != arr2[i-1] + 1 {\n\
    \            length += 1;\n            arr3.push(String::from(&format!(\"{}\"\
    , arr2[i])));\n            arr3.push(String::from(&format!(\"{}\", arr2[i] + 1)));\n\
    \        } else {\n            arr3.push(String::from(&format!(\"{}\", arr2[i])));\n\
    \        }\n    }\n    let mut retv = vec![];\n    for i in 0..(length - 1) {\n\
    \        let res = arr3[i..i + 4].to_vec();\n        let mut res2 = vec![];\n\
    \        for j in res {\n            res2.push(String::from(&format!(\"{}\", j)));\n\
    \        }\n        retv.push(res2);\n    }\n    retv\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmesx7rl9.rs:26:23\n   |\n\
    26 |             arr3.push(String::from(&format!(\"{}\", arr2[i])));\n   |   \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmesx7rl9.rs:27:23\n\
    \   |\n27 |             arr3.push(String::from(&format!(\"{}\", arr2[i] + 1)));\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmesx7rl9.rs:29:23\n\
    \   |\n29 |             arr3.push(String::from(&format!(\"{}\", arr2[i])));\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `std::ops::Range<isize>`\n  --> /tmp/tmpmesx7rl9.rs:34:19\n   |\n34 |   \
    \      let res = arr3[i..i + 4].to_vec();\n   |                   ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmesx7rl9.rs:41:5\n   |\n17 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n41 |     retv\n   |     ^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<Vec<String>>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    for &i in arr {\n      \
    \  let number = i.to_string();\n        if number.len() == 1 || number.len() ==\
    \ 9 {\n            result.push(number);\n        }\n    }\n    result.reverse();\n\
    \    for i in result {\n        if i >= 1 && i <= 9 {\n            let mut index\
    \ = String::new();\n            index.append(&String::from(\"One\"));\n      \
    \      index.append(&String::from(\"Two\"));\n            index.append(&String::from(\"\
    Three\"));\n            index.append(&String::from(\"Four\"));\n            index.append(&String::from(\"\
    Five\"));\n            index.append(&String::from(\"Six\"));\n            index.append(&String::from(\"\
    Seven\"));\n            index.append(&String::from(\"Eight\"));\n            index.append(&String::from(\"\
    Nine\"));\n            index.append(&String::from(\"Ten\"));\n            index.append(&String::from(\"\
    Eleven\"));\n            index.append(&String::from(\"Twelve\"));\n          \
    \  index.append(&String::from(\"Thirteen\"));\n            index.append(&String::from(\"\
    Fourteen\"));\n            index.append(&String::from(\"Fifteen\"));\n       \
    \     index.append(&String::from(\"Sixteen\"));\n            index.append(&String::from(\"\
    Seventeen\"));\n            index.append(&String::from(\"Eighteen\"));\n     \
    \       index.append(&String::from(\"Nineteen\"));\n            index.append(&String::from(\"\
    Twenty\"));\n            index.append(&String::from(\"Twenty One\"));\n      \
    \      index.append(&String::from(\"Twenty Two\"));\n            index.append(&String::from(\"\
    Twenty Three\"));\n            index.append(&String::from(\"Twenty Four\"));\n\
    \            index.append(&String::from(\"Twenty Five\"));\n            index.append(&String::from(\"\
    Twenty Six\"));\n            index.append(&String::from(\"Twenty Seven\"));\n\
    \            index.append(&String::from(\"Twenty Eight\"));\n            index.append(&String::from(\"\
    Twenty Nine\"));\n            index.append(&String::from(\"Thirty\"));\n     \
    \       index.append(&String::from(\"Thirty One\"));\n            index.append(&String::from(\"\
    Thirty Two\"));\n            index.append(&String::from(\"Thirty Three\"));\n\
    \            index.append(&String::from(\"Thirty Four\"));\n            index.append(&String::from(\"\
    Thirty Five\"));\n            index.append(&String::from(\"Thirty Six\"));\n \
    \           index.append(&String::from(\"Thirty Seven\"));\n            index.append(&String::from\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc0vx6h1w.rs:76:3\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n26 |     for i in\
    \ result {\n   |                     - unclosed delimiter\n27 |         if i >=\
    \ 1 && i <= 9 {\n   |                             - this delimiter might not be\
    \ properly closed...\n...\n67 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n76 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpc0vx6h1w.rs:66:25\n   |\n17 | fn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n66 |             index.append(&String::from\n\
    \   |                         ^ unclosed delimiter\n67 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0vx6h1w.rs:19:9\n\
    \   |\n19 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpc0vx6h1w.rs:29:19\n   |\n29 |             index.append(&String::from(\"\
    One\"));\n   |                   ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpc0vx6h1w.rs:30:19\n   |\n30 |             index.append(&String::from(\"\
    Two\"));\n   |                   ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpc0vx6h1w.rs:31:19\n   |\n31 |             index.append(&String::from(\"\
    Three\"));\n   |                   ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpc0vx6h1w.rs:32:19\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![\"One\"]; }\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = arr.len() - 1;\n    let mut s =\
    \ arr.len() - 1;\n    while i <= k {\n        if arr[j] > arr[j + 1] {\n     \
    \       swap(&mut arr, j, j + 1);\n        }\n        j += 1;\n        i += 1;\n\
    \    }\n    while s > 0 {\n        if arr[s] > arr[s - 1] {\n            swap(&mut\
    \ arr, s, s - 1);\n        }\n        s -= 1;\n    }\n    for i in 0..(arr.len()\
    \ - 1) {\n        arr[i] = format!(\"{}\", arr[i]);\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmppb7tvw44.rs:25:13\n\
    \   |\n25 |             swap(&mut arr, j, j + 1);\n   |             ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmppb7tvw44.rs:32:13\n   |\n\
    32 |             swap(&mut arr, s, s - 1);\n   |             ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppb7tvw44.rs:18:37\n   |\n18 |     if arr.is_empty() { return\
    \ vec![\"One\"]; }\n   |                                     ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \         |\n   |                                     expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppb7tvw44.rs:37:18\n\
    \   |\n37 |         arr[i] = format!(\"{}\", arr[i]);\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppb7tvw44.rs:39:5\n  \
    \ |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |               \
    \                   ----------- expected `Vec<String>` because of return type\n\
    ...\n39 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut digits = String::new();\n\
    \    let mut nums: Vec<String> = Vec::new();\n    for e in arr {\n        digits.clear();\n\
    \        nums.clear();\n        digits = digits.to_string();\n        for num\
    \ in e {\n            if num < 10 {\n                digits.push_str(&format!(\"\
    {}\", num).as_bytes());\n            } else if num > 9 {\n                nums.push(format!(\"\
    {}\", num).as_bytes());\n            }\n        }\n        if nums.len() == 0\
    \ {\n            result.push(&\"One\".as_bytes());\n        } else {\n       \
    \     let mut j = 0;\n            for i in 0..nums.len() {\n                result.push(&nums[j]);\n\
    \                j += 1\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpegcq5t_h.rs:25:20\n\
    \   |\n25 |         for num in e {\n   |                    ^ `isize` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `isize`\n\
    \   = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegcq5t_h.rs:27:33\n\
    \   |\n27 |                 digits.push_str(&format!(\"{}\", num).as_bytes());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `&[u8]`\n   |\n   = note: expected reference `&str`\n         \
    \     found reference `&&[u8]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegcq5t_h.rs:29:27\n\
    \   |\n29 |                 nums.push(format!(\"{}\", num).as_bytes());\n   |\
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&[u8]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegcq5t_h.rs:37:29\n\
    \   |\n37 |                 result.push(&nums[j]);\n   |                     \
    \        ^^^^^^^^ expected `&[u8]`, found struct `String`\n   |\n   = note: expected\
    \ reference `&&[u8]`\n              found reference `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpegcq5t_h.rs:42:5\n   |\n17 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n42 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found `&&[u8]`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&&[u8]>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    if arr.len() == 0 {\n\
    \        return result;\n    }\n\n    let mut low = arr[0];\n    let mut high\
    \ = arr[0];\n    let mut mid = arr[0];\n\n    for &x in arr.iter() {\n       \
    \ if x < low {\n            low = x;\n        }\n        if x > high {\n     \
    \       high = x;\n        }\n        if x > mid+1 {\n            mid = x;\n \
    \       }\n    }\n\n    let rev_low = reverse(low);\n    let rev_high = reverse(high);\n\
    \n    if mid == rev_low {\n        result.push(\"One\");\n        return result;\n\
    \    }\n    if mid == rev_high {\n        result.push(\"Two\");\n        return\
    \ result;\n    }\n\n    let rev_mid = reverse(rev_mid);\n    let rev_low_len =\
    \ reverse(low_len - rev_low.len());\n    let rev_high_len = reverse(high_len -\
    \ rev_high.len());\n\n    if rev_low == rev_mid {\n        let mut low = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \        low[low_index(rev_low_len.len())] = mid + 1;\n        result.push(String::from(\"\
    One\"));\n        return result.into_iter().chain(low.into_iter()).collect::<Vec<String>>();\n\
    \    }\n    if rev_high == rev_mid {\n        let mut high = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \        high[high_index(rev_high_len.len())] = mid + 1;\n        result.push(String::from(\"\
    Two\"));\n        return result.into_iter().chain(high.into_iter()).collect::<Vec<String>>();\n\
    \    }\n\n    if mid == rev_low {\n        result.push(String::from(\"One\"));\n\
    \        return result;\n    }\n    if mid == rev_high {\n        result.push(String::from(\"\
    Two\"));\n        return result;\n    }\n\n    let mut low = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    low[low_index(rev_low_len.len())] = mid + 1;\n    let mut high = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    high[high_index(rev_high_len.len())] = mid + 1;\n    let mut mid_len = reverse(low_len\
    \ - rev_low.len());\n    mid_len.reverse();\n    let mut high_len = reverse(high_len\
    \ - rev_high.len());\n    high_len.reverse();\n\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpux22p072.rs:39:19\n\
    \   |\n39 |     let rev_low = reverse(low);\n   |                   ^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `reverse` in this\
    \ scope\n  --> /tmp/tmpux22p072.rs:40:20\n   |\n40 |     let rev_high = reverse(high);\n\
    \   |                    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpux22p072.rs:51:19\n   |\n\
    51 |     let rev_mid = reverse(rev_mid);\n   |                   ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `rev_mid` in this scope\n \
    \ --> /tmp/tmpux22p072.rs:51:27\n   |\n51 |     let rev_mid = reverse(rev_mid);\n\
    \   |                           ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse` in this scope\n  --> /tmp/tmpux22p072.rs:52:23\n\
    \   |\n52 |     let rev_low_len = reverse(low_len - rev_low.len());\n   |    \
    \                   ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `low_len` in this scope\n  --> /tmp/tmpux22p072.rs:52:31\n   |\n52 | \
    \    let rev_low_len = reverse(low_len - rev_low.len());\n   |               \
    \                ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `reverse` in this scope\n  --> /tmp/tmpux22p072.rs:53:24\n   |\n53\
    \ |     let rev_high_len = reverse(high_len - rev_high.len());\n   |         \
    \               ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `high_len` in this scope\n  --> /tmp/tmpux22p072.rs:53:32\n   |\n53 |     let\
    \ rev_high_len = reverse(high_len - rev_high.len());\n   |                   \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `low_index` in this scope\n  --> /tmp/tmpux22p072.rs:57:13\n   |\n57 |     \
    \    low[low_index(rev_low_len.len())] = mid + 1;\n   |             ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `high_index` in\
    \ this scope\n  --> /tmp/tmpux22p072.rs:63:14\n   |\n63 |         high[high_index(rev_high_len.len())]\
    \ = mid + 1;\n   |              ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut num_digits =\
    \ arr.len();\n    while num_digits > 0 {\n        let digit = arr.pop().unwrap();\n\
    \        if digit > 9 {\n            num_digits -= 1;\n            result.push((digit\
    \ + 10).to_string());\n        } else {\n            result.push(name_by_digit(digit));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `name_by_digit` in this scope\n  -->\
    \ /tmp/tmpyvztczsf.rs:26:25\n   |\n26 |             result.push(name_by_digit(digit));\n\
    \   |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \n    let mut lens = arr.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n\
    \    if lens.len() < 9 {\n        let mut i = 0;\n        for len in lens {\n\
    \            if i != len {\n                lens.push(i.to_string());\n      \
    \          i += 1;\n            }\n        }\n    }\n\n    let mut reversed =\
    \ lens.clone();\n    swap(&mut reversed, 0, lens.len() - 1);\n\n    let mut result\
    \ = Vec::new();\n    for i in lens {\n        result.push(match i {\n        \
    \    \"One\" => \"One\",\n            \"Two\" => \"Two\",\n            \"Three\"\
    \ => \"Three\",\n            \"Four\" => \"Four\",\n            \"Five\" => \"\
    Five\",\n            \"Six\" => \"Six\",\n            \"Seven\" => \"Seven\",\n\
    \            \"Eight\" => \"Eight\",\n            \"Nine\" => \"Nine\",\n    \
    \        s => s.to_string(),\n        });\n    }\n\n    swap(&mut result, lens.len()\
    \ - 1, lens.len() - 1);\n\n    result.reverse();\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp89p539k9.rs:34:5\n\
    \   |\n34 |     swap(&mut reversed, 0, lens.len() - 1);\n   |     ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmp89p539k9.rs:52:5\n   |\n52\
    \ |     swap(&mut result, lens.len() - 1, lens.len() - 1);\n   |     ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]:\
    \ can't compare `{integer}` with `String`\n  --> /tmp/tmp89p539k9.rs:26:18\n \
    \  |\n26 |             if i != len {\n   |                  ^^ no implementation\
    \ for `{integer} == String`\n   |\n   = help: the trait `PartialEq<String>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp89p539k9.rs:39:13\n   |\n38 |         result.push(match i {\n   |  \
    \                         - this expression has type `String`\n39 |          \
    \   \"One\" => \"One\",\n   |             ^^^^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp89p539k9.rs:40:13\n\
    \   |\n38 |         result.push(match i {\n   |                           - this\
    \ expression has type `String`\n39 |             \"One\" => \"One\",\n40 |   \
    \          \"Two\" => \"Two\",\n   |             ^^^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp89p539k9.rs:41:13\n\
    \   |\n38 |         result.push(match i {\n   |                           - this\
    \ expression has type `String`\n...\n41 |             \"Three\" => \"Three\",\n\
    \   |             ^^^^^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp89p539k9.rs:42:13\n   |\n38 |         result.push(match\
    \ i {"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = Vec::<String>::new();\n    for i in arr.iter()\
    \ {\n        if i < 1 || i > 9 {\n            continue;\n        }\n        res.push(name_to_code(i));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `name_to_code` in this scope\n  -->\
    \ /tmp/tmpv6n0ifww.rs:23:18\n   |\n23 |         res.push(name_to_code(i));\n \
    \  |                  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv6n0ifww.rs:20:16\n   |\n20 |         if i < 1 || i > 9\
    \ {\n   |                ^\n   |                |\n   |                expected\
    \ `&isize`, found integer\n   |                help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv6n0ifww.rs:20:25\n  \
    \ |\n20 |         if i < 1 || i > 9 {\n   |                         ^\n   |  \
    \                       |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v = vec![\"\".to_string(); 9];\n    for i in 0..arr.len()\
    \ {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            v[arr[i] - 1..9] = [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"][arr[i]];\n        } else {\n            continue;\n        }\n   \
    \ }\n    v\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmp2_gqf06h.rs:21:13\n   |\n21 |             v[arr[i] - 1..9] = [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"][arr[i]];\n   |             ^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `std::ops::Range<isize>`\n   = help: the following other\
    \ types implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize>\
    \ as SliceIndex<[T]>>\n             <std::ops::Range<usize> as SliceIndex<str>>\n\
    \   = note: required because of the requirements on the impl of `Index<std::ops::Range<isize>>`\
    \ for `Vec<String>`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp2_gqf06h.rs:21:32\n   |\n21 |             v[arr[i] - 1..9] = [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"][arr[i]];\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `[&str]`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut output = vec![];\n\n    if arr.is_empty() {\n\
    \        return output;\n    }\n\n    let mut reversed = arr.clone();\n    reversed.sort_unstable_by(|a,\
    \ b| b.cmp(a));\n    reversed.reverse();\n\n    for i in 0..(reversed.len() -\
    \ 1) {\n        let j = reversed.len() - i - 1;\n        let num = reversed[j].to_string();\n\
    \        let letter = match num {\n            \"1\" => \"One\".to_string(),\n\
    \            \"2\" => \"Two\".to_string(),\n            \"3\" => \"Three\".to_string(),\n\
    \            \"4\" => \"Four\".to_string(),\n            \"5\" => \"Five\".to_string(),\n\
    \            \"6\" => \"Six\".to_string(),\n            \"7\" => \"Seven\".to_string(),\n\
    \            \"8\" => \"Eight\".to_string(),\n            \"9\" => \"Nine\".to_string(),\n\
    \            _ => unreachable!()\n        };\n        output.push(letter);\n \
    \   }\n\n    return output;\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8dfi7lnc.rs:32:13\n   |\n\
    31 |         let letter = match num {\n   |                            --- this\
    \ expression has type `String`\n32 |             \"1\" => \"One\".to_string(),\n\
    \   |             ^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8dfi7lnc.rs:33:13\n   |\n31 |         let letter\
    \ = match num {\n   |                            --- this expression has type\
    \ `String`\n32 |             \"1\" => \"One\".to_string(),\n33 |             \"\
    2\" => \"Two\".to_string(),\n   |             ^^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8dfi7lnc.rs:34:13\n\
    \   |\n31 |         let letter = match num {\n   |                           \
    \ --- this expression has type `String`\n...\n34 |             \"3\" => \"Three\"\
    .to_string(),\n   |             ^^^ expected struct `String`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8dfi7lnc.rs:35:13\n   |\n31 |  \
    \       let letter = match num {\n   |                            --- this expression\
    \ has type `String`\n...\n35 |             \"4\" => \"Four\".to_string(),\n  \
    \ |             ^^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8dfi7lnc.rs:36:13\n   |\n31 |         let letter = match\
    \ num {\n   |                            --- this expression has type `String`\n\
    ...\n36 |             \"5\" => \"Five\".to_string(),\n   |             ^^^ expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8dfi7lnc.rs:37:13\n\
    \   |\n31 |         let letter = match num {\n   |                           \
    \ --- this expression has type `String`\n...\n37 |             \"6\" => \"Six\"\
    .to_string(),\n   |             ^^^ expected struct `String`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8dfi7lnc.rs:38:13\n   |\n31 |  \
    \       let letter = match num {\n   |                            --- this expression\
    \ has type `String`\n...\n38 |             \"7\" => \"Seven\".to_string(),\n \
    \  |             ^^^ expected struct `String`, found `&str`\n\nerror[E0308]: misma"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut digits: Vec<isize> = vec![];\n    let mut reversed:\
    \ Vec<isize> = vec![];\n    for i in arr {\n        if i >= 1 && i <= 9 {\n  \
    \          digits.push(i);\n        }\n    }\n    for i in reversed! {\n     \
    \   if i >= 1 && i <= 9 {\n            digits.push(i);\n        }\n    }\n   \
    \ for i in digits {\n        reversed.push(i + 10);\n    }\n    for i in reversed!\
    \ {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n        }\n \
    \   }\n    for i in digits {\n        reversed.push(i + 11);\n    }\n    for i\
    \ in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed! {\n        if i >= 1 && i <= 9 {\n            digits.push(i);\n\
    \        }\n    }\n    for i in digits {\n        reversed.push(i + 1);\n    }\n\
    \    for i in reversed!\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found keyword `for`\n  --> /tmp/tmp2yu1f6hc.rs:30:5\n\
    \   |\n30 |     for i in digits {\n   |     ^^^ expected `{`\n   |\nhelp: try\
    \ placing this code inside a block\n   |\n30 ~     { for i in digits {\n31 | \
    \        reversed.push(i + 10);\n32 ~     } }\n   |\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   if arr.len() < 10 {\n        return vec![];\n    }\n    let mut tmp = vec![String::from(\"\
    One\")];\n    let mut len = arr.len();\n    let mut i = 0;\n    while i < len\
    \ {\n        if arr[i / 10] >= 1 {\n            tmp[0] = match arr[i / 10] {\n\
    \                1 => String::from(\"One\"),\n                2 => String::from(\"\
    Two\"),\n                3 => String::from(\"Three\"),\n                4 => String::from(\"\
    Four\"),\n                5 => String::from(\"Five\"),\n                6 => String::from(\"\
    Six\"),\n                7 => String::from(\"Seven\"),\n                8 => String::from(\"\
    Eight\"),\n                9 => String::from(\"Nine\"),\n                _ =>\
    \ unreachable!(),\n            };\n        }\n        i += 1;\n    }\n    let\
    \ mut len = tmp.len();\n    let mut i = 0;\n    while i < len {\n        tmp[len\
    \ - 1] = match tmp[len - 2] {\n            String::from(\"One\") => String::from(\"\
    Eight\"),\n            String::from(\"Two\") => String::from(\"Five\"),\n    \
    \        String::from(\"Three\") => String::from(\"Four\"),\n            String::from(\"\
    Four\") => String::from(\"Three\"),\n            String::from(\"Five\") => String::from(\"\
    Two\"),\n            String::from(\"Six\") => String::from(\"One\"),\n       \
    \     String::from(\"Seven\") => String::from(\"One\"),\n            String::from(\"\
    Eight\") => String::from(\"Nine\"),\n            String::from(\"Nine\") => String::from(\"\
    One\"),\n            _ => unreachable!(),\n        };\n        i += 1;\n     \
    \   len -= 1;\n    }\n    tmp\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmp1dkt3fso.rs:48:13\n   |\n48 |       \
    \      String::from(\"One\") => String::from(\"Eight\"),\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmp1dkt3fso.rs:49:13\n   |\n49 |             String::from(\"Two\"\
    ) => String::from(\"Five\"),\n   |             ^^^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmp1dkt3fso.rs:50:13\n   |\n50 |             String::from(\"\
    Three\") => String::from(\"Four\"),\n   |             ^^^^^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::from`\n  -->\
    \ /tmp/tmp1dkt3fso.rs:51:13\n   |\n51 |             String::from(\"Four\") =>\
    \ String::from(\"Three\"),\n   |             ^^^^^^^^^^^^^^^^^^^^ `fn` calls are\
    \ not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmp1dkt3fso.rs:52:13\n   |\n52 |             String::from(\"\
    Five\") => String::from(\"Two\"),\n   |             ^^^^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::from`\n  -->\
    \ /tmp/tmp1dkt3fso.rs:53:13\n   |\n53 |             String::from(\"Six\") => String::from(\"\
    One\"),\n   |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n    let mut numbers\
    \ = arr.clone();\n    let mut length = 0;\n    for &num in numbers {\n       \
    \ length += num;\n    }\n    numbers = &mut std::mem::take(&mut numbers[..length]);\n\
    \    let mut names: Vec<String> = vec![];\n    for i in numbers {\n        let\
    \ mut name = String::new();\n        if i == 1 {\n            name = \"One\";\n\
    \        }\n        match i {\n            2 => name.push_str(\"Two\"),\n    \
    \        3 => name.push_str(\"Three\"),\n            4 => name.push_str(\"Four\"\
    ),\n            5 => name.push_str(\"Five\"),\n            6 => name.push_str(\"\
    Six\"),\n            7 => name.push_str(\"Seven\"),\n            8 => name.push_str(\"\
    Eight\"),\n            9 => name.push_str(\"Nine\"),\n            x => panic!(\"\
    Invalid number!\"),\n        }\n        names.push(name);\n    }\n    names\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3t9p_x3k.rs:21:9\n   |\n\
    21 |     for &num in numbers {\n   |         ^^^^    ------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `[isize]: Default` is not satisfied\n   --> /tmp/tmp3t9p_x3k.rs:24:35\n\
    \    |\n24  |     numbers = &mut std::mem::take(&mut numbers[..length]);\n   \
    \ |                    -------------- ^^^^^^^^^^^^^^^^^^^^^^ the trait `Default`\
    \ is not implemented for `[isize]`\n    |                    |\n    |        \
    \            required by a bound introduced by this call\n    |\n    = help: the\
    \ following other types implement trait `Default`:\n              &[T]\n     \
    \         &mut [T]\n              [T; 0]\n              [T; 10]\n            \
    \  [T; 11]\n              [T; 12]\n              [T; 13]\n              [T; 14]\n\
    \            and 27 others\nnote: required by a bound in `std::mem::take`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3t9p_x3k.rs:24:15\n   |\n19 |  \
    \   let mut numbers = arr.clone();\n   |                       ----------- expected\
    \ due to this value\n...\n24 |     numbers = &mut std::mem::take(&mut numbers[..length]);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `&mut [isize]`\n   |\n   = note:         expected struct `Vec<isize>`\n\
    \           found mutable reference `&mut [isize]`\nhelp: try using a conversion\
    \ method\n   |\n24 |     numbers = (&mut std::mem::take(&mut numbers[..length])).to_vec();\n\
    \   |               +                                           ++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3t9p_x3k.rs:29:20\n   |\n27 |  \
    \       let mut name = String::new();\n   |                        -------------\
    \ expected due to this value\n28 |         if i == 1 {\n29 |             name\
    \ = \"One\";\n   |                    ^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr.to_owned();\n    arr.sort_unstable_by_key(|&a| {\n     \
    \   (a*10).to_digit()\n    });\n    arr.reverse();\n    arr.iter().map(|x| {\n\
    \        match x {\n            x if x <= 9 || x > 99 => format!(\"One\", x),\n\
    \            x if x <= 99 && x > 98 => format!(\"Two\", x),\n            x if\
    \ x <= 98 && x > 97 => format!(\"Three\", x),\n            x if x <= 97 && x >\
    \ 96 => format!(\"Four\", x),\n            x if x <= 96 && x > 95 => format!(\"\
    Five\", x),\n            x if x <= 95 && x > 94 => format!(\"Six\", x),\n    \
    \        x if x <= 94 && x > 93 => format!(\"Seven\", x),\n            x if x\
    \ <= 93 && x > 92 => format!(\"Eight\", x),\n            x if x <= 92 && x > 91\
    \ => format!(\"Nine\", x),\n            x if x <= 91 && x > 90 => format!(\"Ten\"\
    , x),\n            x => format!(\"One\", x),\n        }\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmp37yzvz9u.rs:28:53\n   |\n28 |\
    \             x if x <= 9 || x > 99 => format!(\"One\", x),\n   |            \
    \                                  -----  ^ argument never used\n   |        \
    \                                      |\n   |                               \
    \               formatting specifier missing\n\nerror: argument never used\n \
    \ --> /tmp/tmp37yzvz9u.rs:29:54\n   |\n29 |             x if x <= 99 && x > 98\
    \ => format!(\"Two\", x),\n   |                                              \
    \ -----  ^ argument never used\n   |                                         \
    \      |\n   |                                               formatting specifier\
    \ missing\n\nerror: argument never used\n  --> /tmp/tmp37yzvz9u.rs:30:56\n   |\n\
    30 |             x if x <= 98 && x > 97 => format!(\"Three\", x),\n   |      \
    \                                         -------  ^ argument never used\n   |\
    \                                               |\n   |                      \
    \                         formatting specifier missing\n\nerror: argument never\
    \ used\n  --> /tmp/tmp37yzvz9u.rs:31:55\n   |\n31 |             x if x <= 97 &&\
    \ x > 96 => format!(\"Four\", x),\n   |                                      \
    \         ------  ^ argument never used\n   |                                \
    \               |\n   |                                               formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmp37yzvz9u.rs:32:55\n\
    \   |\n32 |             x if x <= 96 && x > 95 => format!(\"Five\", x),\n   |\
    \                                               ------  ^ argument never used\n\
    \   |                                               |\n   |                  \
    \                             formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp37yzvz9u.rs:33:54\n   |\n33 |             x if x <=\
    \ 95 && x > 94 => format!(\"Six\", x),\n   |                                 \
    \              -----  ^ argument never used\n   |                            \
    \                   |\n   |                                               formatting\
    \ specifier missing\n\nerro"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    if arr.len() <\
    \ 2 {\n        return vec![];\n    }\n\n    for i in arr.iter_mut() {\n      \
    \  if i < 1 {\n            *i = 0;\n        } else if i > 9 {\n            *i\
    \ = 9;\n        }\n    }\n\n    let mut max = arr.max();\n    max = max * 10 +\
    \ max % 10;\n    max = max - max - 10 + 1;\n\n    let mut result = vec![];\n \
    \   while max != 0 {\n        let (digit, num) = max % 10;\n        if digit ==\
    \ 0 && num == 0 {\n            let digit = match max / 10 {\n                0\
    \ => 1,\n                1 => 2,\n                2 => 3,\n                3 =>\
    \ 4,\n                4 => 5,\n                5 => 6,\n                6 => 7,\n\
    \                7 => 8,\n                8 => 9,\n                _ => 0,\n \
    \           };\n\n            result.push(\"One\");\n            max -= num;\n\
    \            result.push(\"Two\");\n            max -= digit;\n            result.push(\"\
    Three\");\n            max -= digit;\n            result.push(\"Four\");\n   \
    \         max -= digit;\n            result.push(\"Five\");\n            max -=\
    \ digit;\n            result.push(\"Six\");\n            max -= digit;\n     \
    \       result.push(\"Seven\");\n            max -= digit;\n            result.push(\"\
    Eight\");\n            max -= digit;\n            result.push(\"Nine\");\n   \
    \         max -= digit;\n            result.push(\"Ten\");\n            max -=\
    \ digit;\n            result.push(\"Eleven\");\n            max -= digit;\n  \
    \          result.push(\"Twelve\");\n            max -= digit;\n            result.push(\"\
    Thirteen\");\n            max -= digit;\n            result.push(\"Fourteen\"\
    );\n            max -= digit;\n            result.push(\"Fifteen\");\n       \
    \     max -= digit;\n            result.push(\"Sixteen\");\n            max -=\
    \ digit;\n            result.push(\"Seventeen\");\n            max -= digit;\n\
    \            result.push(\"Eighteen\");\n            max -= digit;\n         \
    \   result.push(\"Nineteen\");\n            max -= digit;\n            result.push(\"\
    Twenty\");\n            max -= digit;\n            result.push(\"Twenty-one\"\
    );\n            max -= digit;\n            result.push(\"Twenty-two\");\n    \
    \        max -= digit;\n            result.push(\"Twenty-three\");\n         \
    \   max -= digit;\n            result.push(\"Twenty-four\");\n            max\
    \ -= digit;\n\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpw0g7vnm_.rs:113:3\n\
    \    |\n17  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n39  |     while\
    \ max != 0 {\n    |                    - unclosed delimiter\n40  |         let\
    \ (digit, num) = max % 10;\n41  |         if digit == 0 && num == 0 {\n    | \
    \                                  - this delimiter might not be properly closed...\n\
    ...\n104 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n113 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw0g7vnm_.rs:27:16\n\
    \   |\n27 |         if i < 1 {\n   |                ^\n   |                |\n\
    \   |                expected `&mut isize`, found integer\n   |              \
    \  help: consider mutably borrowing here: `&mut 1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw0g7vnm_.rs:29:23\n   |\n29 |         } else if i > 9 {\n\
    \   |                       ^\n   |                       |\n   |            \
    \           expected `&mut isize`, found integer\n   |                       help:\
    \ consider mutably borrowing here: `&mut 9`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpw0g7vnm_.rs:34:23\n\
    \    |\n34  |     let mut max = arr.max();\n    |                       ^^^- supplied\
    \ 0 arguments\n    |                       |\n    |                       expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0369]: cannot\
    \ multiply `Vec<isize>` by `{integer}`\n  --> /tmp/tmpw0g7vnm_.rs:35:15\n   |\n\
    35 |     max = max * 10 + max % 10;\n   |           --- ^ -- {integer}\n   | \
    \          |\n   |           Vec<isize>\n\nerror[E0369]: cannot mod `Vec<isize>`\
    \ by `{integer}`\n  --> /tmp/tmpw0g7vnm_.rs:35:26\n   |\n35 |     max = max *\
    \ 10 + max % 10;\n   |                      --- ^ -- {integer}\n   |         \
    \             |\n   |                      Vec<isize>\n\nerror[E0369]: cannot\
    \ subtract `Vec<isize>` from `Vec<isize>`\n  --> /tmp/tmpw0g7vnm_.rs:36:15\n \
    \  |\n36 |     max = max - max - 10 + 1;\n   |           --- ^ -"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n    let mut result\
    \ = vec![\"\".to_string()];\n    for n in arr {\n        let mut rev_digits =\
    \ vec![];\n        for d in n.to_string().rev() {\n            rev_digits.push(d.clone());\n\
    \        }\n        result = rev_digits.iter().fold(result,\n            |mut\
    \ acc, &digit| {\n                acc.push((digit as i32).to_string());\n    \
    \            acc\n            });\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpjeek09j4.rs:22:32\n\
    \    |\n22  |           for d in n.to_string().rev() {\n    |                \
    \                  ^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut a = arr.clone();\n    let mut b = a.clone();\n\
    \    \n    // check empty array\n    if a.len() == 0 {\n        return vec![];\n\
    \    }\n    \n    // check odd numbers\n    if a.len() % 2 == 0 {\n        let\
    \ mut i = 0;\n        let mut j = 0;\n        while i <= a.len() - 1 {\n     \
    \       if a[i] < 9 {\n                b.swap(i, j);\n                i += 2;\n\
    \            } else if a[i] == 9 {\n                b.swap(i, j);\n          \
    \      i += 1;\n            } else {\n                i += 1;\n            }\n\
    \            j += 2;\n        }\n        \n        // reverse the array\n    \
    \    b.reverse();\n        \n        // replace each number with its corresponding\
    \ value\n        let mut v = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n        for i in b {\n          \
    \  v.insert(i, v.last().unwrap());\n        }\n        \n        return v;\n \
    \   }\n    \n    // check even numbers\n    else {\n        let mut i = 0;\n \
    \       let mut j = 0;\n        while i <= a.len() - 2 {\n            if a[i]\
    \ < 9 {\n                b.swap(i, j);\n                i += 2;\n            }\
    \ else if a[i] == 9 {\n                b.swap(i, j);\n                i += 1;\n\
    \            } else {\n                i += 1;\n            }\n            j +=\
    \ 2;\n        }\n        \n        // reverse the array\n        b.reverse();\n\
    \        \n        // replace each number with its corresponding value\n     \
    \   let mut v = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"];\n        for i in b {\n            v.insert(i,\
    \ v.last().unwrap());\n        }\n        \n        return v;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_g8faw6.rs:49:22\n   |\n\
    49 |             v.insert(i, v.last().unwrap());\n   |                      ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n49 |           \
    \  v.insert(i.try_into().unwrap(), v.last().unwrap());\n   |                 \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_g8faw6.rs:52:16\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n52 |         return v;\n   |                ^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_g8faw6.rs:78:22\n\
    \   |\n78 |             v.insert(i, v.last().unwrap());\n   |                \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n78 |      \
    \       v.insert(i.try_into().unwrap(), v.last().unwrap());\n   |            \
    \           ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // reverse arr\n    arr.reverse();\n\n    // sort arr\
    \ by length\n    let mut len: isize = 1;\n    let mut sorted_arr = arr;\n    while\
    \ sorted_arr.len() > len {\n        len += 1;\n        sorted_arr.sort();\n  \
    \  }\n    \n    // replace each digit by its corresponding name from \n    //\
    \ \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\"\n    let mut res: Vec<String> = vec![String::from(\"One\"), String::from(\"\
    Two\"),\n        String::from(\"Three\"), String::from(\"Four\"),\n        String::from(\"\
    Five\"), String::from(\"Six\"),\n        String::from(\"Seven\"), String::from(\"\
    Eight\"),\n        String::from(\"Nine\")];\n    for i in 0..len {\n        if\
    \ i < len {\n            let i = i + 1;\n            let digit = sorted_arr[i]\
    \ - 1;\n            if digit == 0 {\n                res.push(\"Zero\");\n   \
    \         } else {\n                res.push(res[digit]);\n            }\n   \
    \     } else {\n            break;\n        }\n    }\n    res.reverse();\n   \
    \ return res;\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqs6zd1jv.rs:24:30\n   |\n\
    24 |     while sorted_arr.len() > len {\n   |                              ^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n24 |     while sorted_arr.len()\
    \ > len.try_into().unwrap() {\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqs6zd1jv.rs:39:25\n\
    \   |\n39 |             let digit = sorted_arr[i] - 1;\n   |                 \
    \        ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqs6zd1jv.rs:41:26\n   |\n41 |\
    \                 res.push(\"Zero\");\n   |                          ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&str`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    for &x in sorted {\n        let index = x % 10;\n        arr.insert(index,\
    \ String::from(\"One\"[x - index]));\n    }\n    vec![arr.iter().rev().collect::<Vec<String>>().pop()]\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_xxhpcyd.rs:25:9\n   |\n\
    25 |     for &x in sorted {\n   |         ^^    ------ this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_xxhpcyd.rs:27:27\n   |\n27 |         arr.insert(index,\
    \ String::from(\"One\"[x - index]));\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp_xxhpcyd.rs:29:27\n\
    \     |\n29   |     vec![arr.iter().rev().collect::<Vec<String>>().pop()]\n  \
    \   |                           ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_xxhpcyd.rs:29:10\n\
    \   |\n29 |     vec![arr.iter().rev().collect::<Vec<String>>().pop()]\n   |  \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<String>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut arr = arr.clone();\n    arr.sort();\n    arr.reverse();\n    for\
    \ &i in arr {\n        if i >= 1 && i <= 9 {\n            arr[i] = format!(\"\
    One\");\n        }\n        if i >= 10 && i <= 99 {\n            arr[i] = format!(\"\
    Two\");\n        }\n        if i >= 100 && i <= 999 {\n            arr[i] = format!(\"\
    Three\");\n        }\n        if i >= 1000 && i <= 9999 {\n            arr[i]\
    \ = format!(\"Four\");\n        }\n        if i >= 10000 && i <= 99999 {\n   \
    \         arr[i] = format!(\"Five\");\n        }\n        if i >= 100000 && i\
    \ <= 999999 {\n            arr[i] = format!(\"Six\");\n        }\n        if i\
    \ >= 1000000 && i <= 9999999 {\n            arr[i] = format!(\"Seven\");\n   \
    \     }\n        if i >= 10000000 && i <= 99999999 {\n            arr[i] = format!(\"\
    Eight\");\n        }\n        if i >= 100000000 && i <= 999999999 {\n        \
    \    arr[i] = format!(\"Nine\");\n        }\n        if i >= 1000000000 && i <=\
    \ 99999999999 {\n            arr[i] = format!(\"Ten\");\n        }\n    }\n  \
    \  return arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkt9tx2j_.rs:25:9\n   |\n\
    25 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkt9tx2j_.rs:57:12\n   |\n17 | fn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n57 |     return arr\n   |            ^^^ expected\
    \ struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![] }\n    arr.sort();\n\
    \    let mut v = arr.clone();\n    v.reverse();\n    v.sort_unstable();\n\n  \
    \  let mut result = vec![];\n    for i in v {\n        if i <= 9 { result.push(i.to_string())\
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpfiz4faxo.rs:19:5\n   |\n17 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |              --- help: consider changing this to be mutable:\
    \ `mut arr`\n18 |     if arr.is_empty() { return vec![] }\n19 |     arr.sort();\n\
    \   |     ^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    if arr.len() > 0 {\n   \
    \     let mut sorted = arr;\n        sorted.sort();\n        let mut reversed\
    \ = vec![0; sorted.len()];\n        for i in 0..sorted.len() {\n            if\
    \ i > 0 && i <= 9 {\n                reversed[i - 1] = sorted[i - 1];\n      \
    \      }\n        }\n        for i in reversed.iter_mut() {\n            if let\
    \ Some(num) = (*i as i32).to_string() {\n                result.push(by_name(num));\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmp45b1eiw7.rs:30:29\n\
    \   |\n30 |                 result.push(by_name(num));\n   |                 \
    \            ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp45b1eiw7.rs:29:20\n   |\n29 |             if let Some(num) = (*i\
    \ as i32).to_string() {\n   |                    ^^^^^^^^^   -----------------------\
    \ this expression has type `String`\n   |                    |\n   |         \
    \           expected struct `String`, found enum `Option`\n   |\n   = note: expected\
    \ struct `String`\n                found enum `Option<_>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut len = arr.len();\n    let mut arr2 = arr;\n  \
    \  if len == 0 {\n        return vec![];\n    }\n    if len > 9 {\n        len\
    \ = 9 - len;\n    }\n    let mut reversed_arr = arr.clone();\n    reversed_arr.rev();\n\
    \    for i in 0..len {\n        if arr[i] < 10 {\n            arr2[i] = format!(\"\
    One\", arr[i]);\n        }\n        else if arr[i] < 100 {\n            arr2[i]\
    \ = format!(\"Two\", arr[i]);\n        }\n        else if arr[i] < 1000 {\n  \
    \          arr2[i] = format!(\"Three\", arr[i]);\n        }\n        else if arr[i]\
    \ < 10000 {\n            arr2[i] = format!(\"Four\", arr[i]);\n        }\n   \
    \     else if arr[i] < 100000 {\n            arr2[i] = format!(\"Five\", arr[i]);\n\
    \        }\n        else if arr[i] < 1000000 {\n            arr2[i] = format!(\"\
    Six\", arr[i]);\n        }\n        else if arr[i] < 10000000 {\n            arr2[i]\
    \ = format!(\"Seven\", arr[i]);\n        }\n        else if arr[i] < 100000000\
    \ {\n            arr2[i] = format!(\"Eight\", arr[i]);\n        }\n        else\
    \ if arr[i] < 1000000000 {\n            arr2[i] = format!(\"Nine\", arr[i]);\n\
    \        }\n    }\n    arr2\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmpt3e3rp20.rs:30:38\n   |\n30 |\
    \             arr2[i] = format!(\"One\", arr[i]);\n   |                      \
    \         -----  ^^^^^^ argument never used\n   |                            \
    \   |\n   |                               formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmpt3e3rp20.rs:33:38\n   |\n33 |           \
    \  arr2[i] = format!(\"Two\", arr[i]);\n   |                               -----\
    \  ^^^^^^ argument never used\n   |                               |\n   |    \
    \                           formatting specifier missing\n\nerror: argument never\
    \ used\n  --> /tmp/tmpt3e3rp20.rs:36:40\n   |\n36 |             arr2[i] = format!(\"\
    Three\", arr[i]);\n   |                               -------  ^^^^^^ argument\
    \ never used\n   |                               |\n   |                     \
    \          formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpt3e3rp20.rs:39:39\n\
    \   |\n39 |             arr2[i] = format!(\"Four\", arr[i]);\n   |           \
    \                    ------  ^^^^^^ argument never used\n   |                \
    \               |\n   |                               formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpt3e3rp20.rs:42:39\n   |\n42 |    \
    \         arr2[i] = format!(\"Five\", arr[i]);\n   |                         \
    \      ------  ^^^^^^ argument never used\n   |                              \
    \ |\n   |                               formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmpt3e3rp20.rs:45:38\n   |\n45 |           \
    \  arr2[i] = format!(\"Six\", arr[i]);\n   |                               -----\
    \  ^^^^^^ argument never used\n   |                               |\n   |    \
    \                           formatting specifier missing\n\nerror: argument never\
    \ used\n  --> /tmp/tmpt3e3rp20.rs:48:40\n   |\n48 |             arr2[i] = format!(\"\
    Seven\", arr[i]);\n   |                               -------  ^^^^^^ argument\
    \ never used\n   |                               |\n   |                     \
    \          formatting specifier missing\n\nerror: argument never used\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    debug_assert!(arr.len() >= 1);\n    let mut res = vec![];\n\
    \    let mut rev: Vec<isize> = arr\n        .iter()\n        .cloned()\n     \
    \   .enumerate()\n        .filter_map(|(i, elem)| if elem == 1 {\n           \
    \ Some(i)\n        } else {\n            None\n        })\n        .collect();\n\
    \    rev.sort_by(|a, b| b.cmp(a));\n    for i in rev {\n        let digit = i.0\
    \ % 10;\n        res.push(by_digit(digit));\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp3fot8osz.rs:33:18\n\
    \   |\n33 |         res.push(by_digit(digit));\n   |                  ^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `usize`\n    --> /tmp/tmp3fot8osz.rs:29:10\n\
    \     |\n29   |         .collect();\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help:\
    \ the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp3fot8osz.rs:32:23\n   |\n32 |         let\
    \ digit = i.0 % 10;\n   |                       ^\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0610.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut a = arr.clone();\n    let mut result = vec![];\n    while !a.is_empty()\
    \ {\n        if a.len() == 1 {\n            result.push(a.first().to_string());\n\
    \        } else {\n            let mut b = a.clone();\n            let mut new_b\
    \ = b.clone();\n            loop {\n                if new_b.len() == 1 {\n  \
    \                  result.push(new_b.first().to_string());\n                 \
    \   break;\n                }\n                if new_b.last() == 9 {\n      \
    \              new_b.pop();\n                } else {\n                    break;\n\
    \                }\n            }\n        }\n        a.pop();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `to_string` exists for enum `Option<&isize>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpdqy9p9qp.rs:25:35\n\
    \    |\n25  |               result.push(a.first().to_string());\n    |       \
    \                              ^^^^^^^^^ method cannot be called on `Option<&isize>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Option<&isize>: std::fmt::Display`\n     \
    \       which is required by `Option<&isize>: ToString`\n\nerror[E0599]: the method\
    \ `to_string` exists for enum `Option<&isize>`, but its trait bounds were not\
    \ satisfied\n   --> /tmp/tmpdqy9p9qp.rs:31:47\n    |\n31  |                  \
    \     result.push(new_b.first().to_string());\n    |                         \
    \                        ^^^^^^^^^ method cannot be called on `Option<&isize>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Option<&isize>: std::fmt::Display`\n     \
    \       which is required by `Option<&isize>: ToString`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdqy9p9qp.rs:34:36\n   |\n34 |                 if new_b.last()\
    \ == 9 {\n   |                                    ^ expected enum `Option`, found\
    \ integer\n   |\n   = note: expected enum `Option<&isize>`\n              found\
    \ type `{integer}`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_by(|a, b| b - a)\n        .reverse()\n      \
    \  .iter()\n        .cloned()\n        .map(|x| {\n            match x {\n   \
    \             1 => \"One\",\n                2 => \"Two\",\n                3\
    \ => \"Three\",\n                4 => \"Four\",\n                5 => \"Five\"\
    ,\n                6 => \"Six\",\n                7 => \"Seven\",\n          \
    \      8 => \"Eight\",\n                9 => \"Nine\",\n                _ => \"\
    Invalid\",\n            }\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcmqfkasa.rs:18:24\n   |\n\
    18 |     arr.sort_by(|a, b| b - a)\n   |                        ^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `isize`\n\nerror[E0599]: no method named `reverse`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpcmqfkasa.rs:19:10\n\
    \   |\n19 |         .reverse()\n   |          ^^^^^^^ method not found in `()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut len = arr.len();\n    let mut min_len = &arr[len - 1];\n    while\
    \ len > 1 {\n        min_len = &arr[len - 2];\n        len -= 1;\n    }\n    let\
    \ mut result = vec![];\n    let mut num = 1;\n    let mut nums = &arr[0];\n  \
    \  while nums.is_odd() {\n        if num == min_len {\n            result.push(String::from(&nums.to_ascii_lowercase()));\n\
    \            num = 1;\n            nums = &arr[len - 1];\n        } else {\n \
    \           result.push(String::from(&nums.to_ascii_lowercase()));\n         \
    \   num += 1;\n            nums = &arr[len - 1];\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_odd` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpodc5aa54.rs:30:16\n   |\n30 |     while nums.is_odd()\
    \ {\n   |                ^^^^^^ method not found in `&isize`\n\nerror[E0277]:\
    \ can't compare `isize` with `&isize`\n  --> /tmp/tmpodc5aa54.rs:31:16\n   |\n\
    31 |         if num == min_len {\n   |                ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0599]: no method named `to_ascii_lowercase` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmpodc5aa54.rs:32:44\n\
    \   |\n32 |             result.push(String::from(&nums.to_ascii_lowercase()));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^ method not\
    \ found in `&isize`\n\nerror[E0599]: no method named `to_ascii_lowercase` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmpodc5aa54.rs:36:44\n\
    \   |\n36 |             result.push(String::from(&nums.to_ascii_lowercase()));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^ method not\
    \ found in `&isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort();\n    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n\n    let mut arr = arr;\n    arr.sort();\n\n    let mut revd = vec![];\n\
    \    for i in arr {\n        let mut revd_i = i;\n        let revd_i_neg = revd_i\
    \ as i32;\n        revd_i = (revd_i_neg * 10) as isize;\n        revd.push((revd_i\
    \ / 10) + String::from(\"One\"));\n        revd.push((revd_i % 10) + String::from(\"\
    Zero\"));\n    }\n    revd.reverse();\n    revd.sort();\n\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `String` to `isize`\n  --> /tmp/tmpfxnsg14r.rs:31:33\n\
    \   |\n31 |         revd.push((revd_i / 10) + String::from(\"One\"));\n   |  \
    \                               ^ no implementation for `isize + String`\n   |\n\
    \   = help: the trait `Add<String>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ add `String` to `isize`\n  --> /tmp/tmpfxnsg14r.rs:32:33\n   |\n32 |       \
    \  revd.push((revd_i % 10) + String::from(\"Zero\"));\n   |                  \
    \               ^ no implementation for `isize + String`\n   |\n   = help: the\
    \ trait `Add<String>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxnsg14r.rs:37:5\n   |\n17 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n37 |     arr\n   |     ^^^ expected\
    \ struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        Vec::new()\n    } else if\
    \ arr.len() < 1 {\n        Vec::new()\n    } else {\n        let mut a = arr.to_owned();\n\
    \        a.sort();\n        let mut b = a.clone();\n        b.reverse();\n   \
    \     let mut c = \"One\".to_owned();\n        for i in 0..arr.len() {\n     \
    \       c += &arr[i];\n        }\n        vec![c]\n    }\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3zvu71c9.rs:29:18\n   |\n\
    29 |             c += &arr[i];\n   |                  ^^^^^^^ expected `str`,\
    \ found `isize`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort().rev().map(|i| match i {\n        x if x <=\
    \ 10 => one_digit(x),\n        x if x <= 99 => two_digit(x),\n        _ => panic!(\"\
    invalid input\"),\n    })\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `one_digit` in this scope\n  --> /tmp/tmpyr6itfv2.rs:19:25\n\
    \   |\n19 |         x if x <= 10 => one_digit(x),\n   |                      \
    \   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `two_digit`\
    \ in this scope\n  --> /tmp/tmpyr6itfv2.rs:20:25\n   |\n20 |         x if x <=\
    \ 99 => two_digit(x),\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpyr6itfv2.rs:18:16\n\
    \   |\n18 |     arr.sort().rev().map(|i| match i {\n   |                ^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut reversed = reverse(&arr);\n    reversed.sort();\n    let mut result\
    \ = vec![];\n    let mut i = 0;\n    let mut n = arr.len() as isize;\n    while\
    \ i < reversed.len() {\n        i += 1;\n        if i == n {\n            i +=\
    \ 1;\n            break;\n        }\n        let digit = reversed[i];\n      \
    \  let index = digit as usize;\n        let name = &mut [ \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" ]\n     \
    \       [index];\n        result.push(name);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpb40nhyyc.rs:21:24\n\
    \   |\n21 |     let mut reversed = reverse(&arr);\n   |                      \
    \  ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb40nhyyc.rs:38:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n38 |     result\n   |     ^^^^^^ expected struct `String`, found `&mut &str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&mut\
    \ &str>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<String> = vec![];\n    let len = arr.len();\n\
    \    for i in 0..len {\n        let n: isize = if i < 9 {\n            arr[i]\
    \ = format!(\"{}\", i)\n        } else {\n            arr[i] = format!(\"{}\"\
    , i) + format!(\"One\", len - i - 1)\n        }\n    }\n    arr.reverse();\n \
    \   arr.iter().map(|n| n.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3q6d6rt3.rs:25:10\n   |\n\
    25 |         }\n   |          ^ help: add `;` here\n26 |     }\n   |     - unexpected\
    \ token\n\nerror: argument never used\n  --> /tmp/tmp3q6d6rt3.rs:24:56\n   |\n\
    24 |             arr[i] = format!(\"{}\", i) + format!(\"One\", len - i - 1)\n\
    \   |                                                 -----  ^^^^^^^^^^^ argument\
    \ never used\n   |                                                 |\n   |   \
    \                                              formatting specifier missing\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3q6d6rt3.rs:22:13\n   |\n22 |  \
    \           arr[i] = format!(\"{}\", i)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3q6d6rt3.rs:24:41\n\
    \   |\n24 |             arr[i] = format!(\"{}\", i) + format!(\"One\", len - i\
    \ - 1)\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3q6d6rt3.rs:24:13\n \
    \  |\n24 |             arr[i] = format!(\"{}\", i) + format!(\"One\", len - i\
    \ - 1)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut nums: Vec<usize> = arr.iter().map(|x| x as usize).collect();\n\
    \    nums.sort();\n    let mut result: Vec<String> = vec![];\n    let mut i =\
    \ 0;\n    while i < nums.len() {\n        if i < nums.len() - 1 {\n          \
    \  let tmp = nums[i];\n            nums[i] = nums[i + 1];\n            nums[i\
    \ + 1] = tmp;\n        }\n        result.append(&nums[i..i + 3].iter().map(|x|\
    \ by_name(x).collect::<String>()).collect::<String>());\n        i += 3;\n   \
    \ }\n    result \n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmp4fx49db1.rs:28:54\n\
    \   |\n28 |         result.append(&nums[i..i + 3].iter().map(|x| by_name(x).collect::<String>()).collect::<String>());\n\
    \   |                                                      ^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fx49db1.rs:28:23\n\
    \   |\n28 |         result.append(&nums[i..i + 3].iter().map(|x| by_name(x).collect::<String>()).collect::<String>());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<String>`\n                      found reference `&String`\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmp4fx49db1.rs:18:51\n  \
    \ |\n18 |     let mut nums: Vec<usize> = arr.iter().map(|x| x as usize).collect();\n\
    \   |                                                   -^^^^^^^^^\n   |     \
    \                                              |\n   |                       \
    \                            cannot cast `&isize` as `usize`\n   |           \
    \                                        help: dereference the expression: `*x`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\n    let\
    \ mut res = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\"];\n\n    for n in arr.iter() {\n        if n < min\
    \ {\n            min = n;\n        }\n        if n > max {\n            max =\
    \ n;\n        }\n    }\n\n    for n in arr.iter() {\n        if n < min || n >\
    \ max {\n            continue;\n        }\n\n        res.push(n);\n    }\n\n \
    \   res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpie86_cgy.rs:28:16\n   |\n\
    28 |         if n < min {\n   |                ^^^ expected `&isize`, found `i32`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpie86_cgy.rs:29:19\n   |\n22 |\
    \     let mut min = std::i32::MAX;\n   |                   ------------- expected\
    \ due to this value\n...\n29 |             min = n;\n   |                   ^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpie86_cgy.rs:31:16\n\
    \   |\n31 |         if n > max {\n   |                ^^^ expected `&isize`, found\
    \ `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpie86_cgy.rs:32:19\n \
    \  |\n23 |     let mut max = std::i32::MIN;\n   |                   -------------\
    \ expected due to this value\n...\n32 |             max = n;\n   |           \
    \        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpie86_cgy.rs:37:16\n   |\n37 |         if n < min || n > max {\n\
    \   |                ^^^ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpie86_cgy.rs:37:27\n   |\n37 |         if n < min || n >\
    \ max {\n   |                           ^^^ expected `&isize`, found `i32`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpie86_cgy.rs:41:18\n   |\n41 |  \
    \       res.push(n);\n   |                  ^ expected `str`, found `isize`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpie86_cgy.rs:44:5\n   |\n17 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n44 |\
    \     res\n   |     ^^^ expected struct `String`, found `&str`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror:\
    \ aborting due to 8 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut s = String::new();\n    for i in arr.iter() {\n\
    \        if 1 < i && 9 > i {\n            s.push(i.to_string());\n        } else\
    \ {\n            s.push(\"One\");\n        }\n    }\n    let mut rev: Vec<isize>\
    \ = vec![];\n    rev.push(i);\n    for i in rev {\n        s.swap(i, rev[rev.iter().skip(1).find(|&i|\
    \ i == i).unwrap()]);\n    }\n    s\n        .chars()\n        .map(|c| match\
    \ c {\n            b'0' => String::from(\"Zero\"),\n            b'1' => String::from(\"\
    One\"),\n            b'2' => String::from(\"Two\"),\n            b'3' => String::from(\"\
    Three\"),\n            b'4' => String::from(\"Four\"),\n            b'5' => String::from(\"\
    Five\"),\n            b'6' => String::from(\"Six\"),\n            b'7' => String::from(\"\
    Seven\"),\n            b'8' => String::from(\"Eight\"),\n            b'9' => String::from(\"\
    Nine\"),\n            _ => panic!(),\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmphehjw6_6.rs:27:14\n\
    \   |\n27 |     rev.push(i);\n   |              ^ help: a local variable with\
    \ a similar name exists: `s`\n\nerror[E0277]: can't compare `isize` with `&isize`\n\
    \  --> /tmp/tmphehjw6_6.rs:20:14\n   |\n20 |         if 1 < i && 9 > i {\n   |\
    \              ^ no implementation for `isize < &isize` and `isize > &isize`\n\
    \   |\n   = help: the trait `PartialOrd<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmphehjw6_6.rs:20:23\n\
    \   |\n20 |         if 1 < i && 9 > i {\n   |                       ^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphehjw6_6.rs:21:20\n   |\n21 |             s.push(i.to_string());\n \
    \  |                    ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphehjw6_6.rs:23:20\n   |\n23 |\
    \             s.push(\"One\");\n   |                    ^^^^^ expected `char`,\
    \ found `&str`\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmphehjw6_6.rs:29:11\n   |\n29 |         s.swap(i,\
    \ rev[rev.iter().skip(1).find(|&i| i == i).unwrap()]);\n   |           ^^^^ method\
    \ not found in `String`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmphehjw6_6.rs:29:19\n   |\n29 |         s.swap(i, rev[rev.iter().skip(1).find(|&i|\
    \ i == i).unwrap()]);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_by(|x, y| x.cmp(y)).reverse().map(|x| {\n   \
    \     let num = match x {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            x => panic!(\"Unexpected\
    \ input at index: {}\", x)\n        };\n        format!(\"{}\", num)\n    })\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmphzspfn3m.rs:18:34\n   |\n18 |     arr.sort_by(|x,\
    \ y| x.cmp(y)).reverse().map(|x| {\n   |                                  ^^^^^^^\
    \ method not found in `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    arr.sort_unstable_by_key(|x|\
    \ x.cmp(&0));\n    res.extend_from_slice(&arr.iter().rev().collect::<Vec<_>>());\n\
    \    res.sort_unstable();\n    if res.is_empty() {\n        vec![]\n    } else\
    \ if res.len() > 10 {\n        res.truncate(10);\n        res.insert(0, &\"One\"\
    [..]);\n        res.insert(1, &\"Two\"[..]);\n        res.insert(2, &\"Three\"\
    [..]);\n        res.insert(3, &\"Four\"[..]);\n        res.insert(4, &\"Five\"\
    [..]);\n        res.insert(5, &\"Six\"[..]);\n        res.insert(6, &\"Seven\"\
    [..]);\n        res.insert(7, &\"Eight\"[..]);\n        res.insert(8, &\"Nine\"\
    [..]);\n    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp48ai6y03.rs:26:23\n   |\n\
    26 |         res.insert(0, &\"One\"[..]);\n   |                       ^^^^^^^^^^\
    \ expected `isize`, found `str`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp48ai6y03.rs:27:23\n   |\n27 |         res.insert(1, &\"Two\"[..]);\n\
    \   |                       ^^^^^^^^^^ expected `isize`, found `str`\n   |\n \
    \  = note: expected reference `&isize`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp48ai6y03.rs:28:23\n   |\n28 |\
    \         res.insert(2, &\"Three\"[..]);\n   |                       ^^^^^^^^^^^^\
    \ expected `isize`, found `str`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp48ai6y03.rs:29:23\n   |\n29 |         res.insert(3, &\"Four\"[..]);\n\
    \   |                       ^^^^^^^^^^^ expected `isize`, found `str`\n   |\n\
    \   = note: expected reference `&isize`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp48ai6y03.rs:30:23\n   |\n30 |\
    \         res.insert(4, &\"Five\"[..]);\n   |                       ^^^^^^^^^^^\
    \ expected `isize`, found `str`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp48ai6y03.rs:31:23\n   |\n31 |         res.insert(5, &\"Six\"[..]);\n\
    \   |                       ^^^^^^^^^^ expected `isize`, found `str`\n   |\n \
    \  = note: expected reference `&isize`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp48ai6y03.rs:32:23\n   |\n32 |\
    \         res.insert(6, &\"Seven\"[..]);\n   |                       ^^^^^^^^^^^^\
    \ expected `isize`, found `str`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp48ai6y03.rs:33:23\n   |\n33 |         res.insert(7, &\"Eight\"[..]);\n\
    \   |                       ^^^^^^^^^^^^ expected `isize`, found `str`\n   |\n\
    \   = note: expected reference `&isize`\n      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // Sort the array in ascending order\n    arr.sort_unstable();\n\
    \    // Reverse the array\n    arr.reverse();\n    // Create the result array\n\
    \    let mut result = Vec::new();\n    // Iterate over the array\n    for (i,\
    \ digit) in arr.iter().enumerate() {\n        let index = i + 1;\n        // If\
    \ the current digit is not between 1 and 9, ignore it\n        if index < 10 {\n\
    \            result.push(format!(\"{}\", digit));\n            continue;\n   \
    \     }\n        // Get the name of the digit and append it to the result\n  \
    \      result.push(format!(\"{}\", by_digit(digit)[index]));\n    }\n    // Return\
    \ the result\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmplfx618og.rs:33:35\n\
    \   |\n33 |         result.push(format!(\"{}\", by_digit(digit)[index]));\n  \
    \ |                                   ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // 1. Sort the integers array\n    let mut sorted_arr\
    \ = arr.into_iter().sorted();\n\n    // 2. Reverse the sorted array\n    let mut\
    \ reversed = sorted_arr.rev();\n\n    // 3. Replace the digits in reversed\n \
    \   reversed.iter_mut().for_each(|&x| {\n        if x >= 1 && x <= 9 {\n     \
    \       sorted_arr.insert(x - 1, \"One\");\n        } else if x >= 10 && x <=\
    \ 99 {\n            sorted_arr.insert(x - 10, \"Two\");\n        } else if x >=\
    \ 100 && x <= 999 {\n            sorted_arr.insert(x - 100, \"Three\");\n    \
    \    } else if x >= 1000 && x <= 9999 {\n            sorted_arr.insert(x - 1000,\
    \ \"Four\");\n        } else if x >= 10000 && x <= 99999 {\n            sorted_arr.insert(x\
    \ - 10000, \"Five\");\n        } else if x >= 100000 && x <= 999999 {\n      \
    \      sorted_arr.insert(x - 100000, \"Six\");\n        } else if x >= 1000000\
    \ && x <= 999999999 {\n            sorted_arr.insert(x - 1000000, \"Seven\");\n\
    \        } else if x >= 10000000 && x <= 999999999999 {\n            sorted_arr.insert(x\
    \ - 10000000, \"Eight\");\n        } else if x >= 1000000000 && x <= 999999999\
    \ {\n            sorted_arr.insert(x - 1000000000, \"Nine\");\n        }\n   \
    \ });\n\n    // 4. Return the resulting array\n    sorted_arr.collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpeu5lqs4x.rs:19:42\n   |\n19 |     let mut\
    \ sorted_arr = arr.into_iter().sorted();\n   |                               \
    \           ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    use std::cmp::Ordering;\n\n    let mut result = vec![];\n\
    \    let mut digits = vec![];\n\n    for i in arr {\n        let digit = i as\
    \ usize;\n        if digit < 10 && digit > 0 {\n            digits.push(digit\
    \ as isize);\n        }\n    }\n\n    let sorted_digits = digits.into_iter().sort();\n\
    \    let max_len = sorted_digits.count() + 1;\n    for i in sorted_digits {\n\
    \        let mut digit = i as isize;\n        let digit = digit.checked_sub(10).unwrap();\n\
    \n        let digit = digit.checked_mul(9).unwrap();\n\n        if digit > 9 {\n\
    \            digit -= 10;\n            result.push(String::from(\"Nine\"));\n\
    \        } else {\n            result.push(String::from(\"One\"));\n        }\n\
    \        result.push(format!(\"{}\", digit));\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmphm92cgwa.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `sort` found for struct `std::vec::IntoIter` in the current scope\n  -->\
    \ /tmp/tmphm92cgwa.rs:30:44\n   |\n30 |     let sorted_digits = digits.into_iter().sort();\n\
    \   |                                            ^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![\"One\"] }\n    let mut\
    \ result: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\",\
    \ \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut length = arr.len();\n\
    \    \n    while length > 0 {\n        let mut low = arr.len() - 1;\n        let\
    \ mut high = arr.len();\n        while high >= low {\n            if arr[high]\
    \ < arr[low] {\n                swap(&mut arr[high], &mut arr[low]);\n       \
    \     }\n            high -= 1;\n        }\n        length -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpfd866a5q.rs:27:17\n\
    \   |\n27 |                 swap(&mut arr[high], &mut arr[low]);\n   |       \
    \          ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfd866a5q.rs:18:37\n   |\n\
    18 |     if arr.is_empty() { return vec![\"One\"] }\n   |                    \
    \                 ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                     |\n   |                            \
    \         expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfd866a5q.rs:19:40\n   |\n19 |     let mut result: Vec<String> =\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"];\n   |                                        ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \                |\n   |                                        expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut min_value = 1;\n    let mut max_value = 9 as isize;\n\
    \    let mut sorted_arr = arr.to_vec();\n    min_value = sorted_arr.min().unwrap();\n\
    \    max_value = sorted_arr.max().unwrap();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    sorted_arr.iter().map(|&x| {\n        let x: isize = if x < min_value { min_value\
    \ } else { x };\n        let x: isize = if x > max_value { max_value } else {\
    \ x };\n        format!(\"{}\", x)\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp_jewzmxv.rs:21:28\n    |\n21  |     min_value = sorted_arr.min().unwrap();\n\
    \    |                            ^^^- supplied 0 arguments\n    |           \
    \                 |\n    |                            expected 1 argument\n  \
    \  |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `unwrap` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp_jewzmxv.rs:21:34\n\
    \   |\n21 |     min_value = sorted_arr.min().unwrap();\n   |                 \
    \                 ^^^^^^ help: there is an associated function with a similar\
    \ name: `swap`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmp_jewzmxv.rs:22:28\n    |\n22  |     max_value\
    \ = sorted_arr.max().unwrap();\n    |                            ^^^- supplied\
    \ 0 arguments\n    |                            |\n    |                     \
    \       expected 1 argument\n    |\nnote: associated function defined here\n\n\
    error[E0599]: no method named `unwrap` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp_jewzmxv.rs:22:34\n   |\n22 |     max_value = sorted_arr.max().unwrap();\n\
    \   |                                  ^^^^^^ help: there is an associated function\
    \ with a similar name: `swap`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.clone();\n    let len = arr.len();\n\
    \    let mut result = Vec::new();\n    arr.sort();\n    for i in 0..len {\n  \
    \      if arr[i] > 1 && arr[i] < 9 {\n            result.push(by_digit(arr[i]));\n\
    \        }\n    }\n    if arr.is_empty() {\n        result\n    } else if arr.len()\
    \ == len {\n        result\n    } else {\n        vec![by_digit(arr[0]), by_digit(arr[len\
    \ - 1])]\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp03sn1qzs.rs:24:25\n\
    \   |\n24 |             result.push(by_digit(arr[i]));\n   |                 \
    \        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `by_digit` in this scope\n  --> /tmp/tmp03sn1qzs.rs:32:14\n   |\n32 |      \
    \   vec![by_digit(arr[0]), by_digit(arr[len - 1])]\n   |              ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `by_digit` in\
    \ this scope\n  --> /tmp/tmp03sn1qzs.rs:32:32\n   |\n32 |         vec![by_digit(arr[0]),\
    \ by_digit(arr[len - 1])]\n   |                                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let mut digits = [1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut i = 0;\n    for val in arr.iter() {\n   \
    \     if val > 0 {\n            result.push(digits.remove(&val as usize));\n \
    \       }\n    }\n    for val in result.iter() {\n        result.push(&names[val]\
    \ as String);\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpxur7zgg2.rs:27:22\n\
    \   |\n27 |         result.push(&names[val] as String);\n   |                \
    \      ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxur7zgg2.rs:22:18\n   |\n22 |         if val > 0 {\n   |           \
    \       ^\n   |                  |\n   |                  expected `&isize`, found\
    \ integer\n   |                  help: consider borrowing here: `&0`\n\nerror[E0599]:\
    \ no method named `remove` found for array `[{integer}; 9]` in the current scope\n\
    \  --> /tmp/tmpxur7zgg2.rs:23:32\n   |\n23 |             result.push(digits.remove(&val\
    \ as usize));\n   |                                ^^^^^^ method not found in\
    \ `[{integer}; 9]`\n\nerror[E0606]: casting `&&isize` as `usize` is invalid\n\
    \  --> /tmp/tmpxur7zgg2.rs:23:39\n   |\n23 |             result.push(digits.remove(&val\
    \ as usize));\n   |                                       ^^^^^^^^^^^^^\n   |\n\
    \   = help: cast through a raw pointer first\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599, E0606.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr: Vec<isize> = arr.clone();\n    sorted_arr.sort();\n\
    \    if sorted_arr.is_empty() {\n        return Vec::new();\n    }\n    let mut\
    \ reverse_arr: Vec<isize> = arr.clone();\n    reverse_arr.reverse();\n    let\
    \ mut name_arr: Vec<String> = arr.clone();\n    for (index, value) in reverse_arr.iter().enumerate()\
    \ {\n        if index < 10 {\n            name_arr[index] = String::from(\"One\"\
    );\n        } else if index < 20 {\n            name_arr[index] = String::from(\"\
    Two\");\n        } else if index < 30 {\n            name_arr[index] = String::from(\"\
    Three\");\n        } else if index < 40 {\n            name_arr[index] = String::from(\"\
    Four\");\n        } else if index < 50 {\n            name_arr[index] = String::from(\"\
    Five\");\n        } else if index < 60 {\n            name_arr[index] = String::from(\"\
    Six\");\n        } else if index < 70 {\n            name_arr[index] = String::from(\"\
    Seven\");\n        } else if index < 80 {\n            name_arr[index] = String::from(\"\
    Eight\");\n        } else if index < 90 {\n            name_arr[index] = String::from(\"\
    Nine\");\n        } else {\n            continue;\n        }\n    }\n    reverse_arr.reverse();\n\
    \    reverse_arr.sort_unstable();\n    reverse_arr.iter().for_each(|&i| {\n  \
    \      name_arr.insert(i, String::from(\"One\"));\n        name_arr.insert(i-1,\
    \ String::from(\"Two\"));\n        name_arr.insert(i-2, String::from(\"Three\"\
    ));\n        name_arr.insert(i-3, String::from(\"Four\"));\n        name_arr.insert(i-4,\
    \ String::from(\"Five\"));\n        name_arr.insert(i-5, String::from(\"Six\"\
    ));\n        name_arr.insert(i-6, String::from(\"Seven\"));\n        name_arr.insert(i-7,\
    \ String::from(\"Eight\"));\n        name_arr.insert(i-8, String::from(\"Nine\"\
    ));\n    });\n    name_arr.reverse();\n    name_arr\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo9kp48dp.rs:25:37\n   |\n\
    25 |     let mut name_arr: Vec<String> = arr.clone();\n   |                  \
    \     -----------   ^^^^^^^^^^^ expected struct `String`, found `isize`\n   |\
    \                       |\n   |                       expected due to this\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo9kp48dp.rs:52:25\n   |\n52 |\
    \         name_arr.insert(i, String::from(\"One\"));\n   |                   \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n52 |      \
    \   name_arr.insert(i.try_into().unwrap(), String::from(\"One\"));\n   |     \
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo9kp48dp.rs:53:25\n   |\n53 |         name_arr.insert(i-1, String::from(\"\
    Two\"));\n   |                         ^^^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n53 |         name_arr.insert((i-1).try_into().unwrap(),\
    \ String::from(\"Two\"));\n   |                         +   +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo9kp48dp.rs:54:25\n   |\n54 |\
    \         name_arr.insert(i-2, String::from(\"Three\"));\n   |               \
    \          ^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n54\
    \ |         name_arr.insert((i-2).try_into().unwrap(), String::from(\"Three\"\
    ));\n   |                         +   +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo9kp48dp.rs:55:25\n   |\n55 |         name_arr.insert(i-3,\
    \ String::from(\"Four\"));\n   |                         ^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n55 |         name_arr.insert((i-3).try_into().unwrap(),\
    \ String::from(\"Four\"));\n   |                         +   ++"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut result = vec![\"\".to_string()];\n    let mut max_num = String::new();\n\
    \    let mut min_num = String::new();\n\n    for x in arr {\n        if x == 1\
    \ {\n            result[0] += &\"One\";\n        } else {\n            result[0]\
    \ += &format!(\"{}\", x - 1);\n        }\n        if x > 10 {\n            result[0]\
    \ += &format!(\"{}\", 10 - x);\n        }\n    }\n\n    for i in 1..9 {\n    \
    \    if arr[i] > 9 {\n            max_num = format!(\"{}\", arr[i] + 10);\n  \
    \      } else {\n            max_num = format!(\"{}\", arr[i]);\n        }\n\n\
    \        if min_num.len() < max_num.len() {\n            min_num = max_num;\n\
    \        } else {\n            max_num = min_num;\n        }\n\n        if min_num.len()\
    \ > result.len() {\n            for j in i..9 {\n                if arr[j] > 9\
    \ {\n                    max_num = format!(\"{}\", arr[j] + 10);\n           \
    \     } else {\n                    max_num = format!(\"{}\", arr[j]);\n     \
    \           }\n                if min_num.len() < max_num.len() {\n          \
    \          min_num = max_num;\n                } else {\n                    max_num\
    \ = min_num;\n                }\n                if min_num.len() > result.len()\
    \ {\n                    result = vec![min_num.to_string()];\n               \
    \     break;\n                }\n            }\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `max_num` is never read\n  --> /tmp/tmpf5zvepew.rs:23:13\n\
    \   |\n23 |     let mut max_num = String::new();\n   |             ^^^^^^^\n \
    \  |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nwarning: value assigned to `max_num`\
    \ is never read\n  --> /tmp/tmpf5zvepew.rs:47:13\n   |\n47 |             max_num\
    \ = min_num;\n   |             ^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `max_num` is never read\n \
    \ --> /tmp/tmpf5zvepew.rs:60:21\n   |\n60 |                     max_num = min_num;\n\
    \   |                     ^^^^^^^\n   |\n   = help: maybe it is overwritten before\
    \ being read?\n\nerror[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpf5zvepew.rs:38:12\n\
    \    |\n17  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \    --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n26  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n38  |         if arr[i]\
    \ > 9 {\n    |            ^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n26  |     for x in &arr {\n    |              +\n\nerror[E0382]:\
    \ borrow of moved value: `min_num`\n  --> /tmp/tmpf5zvepew.rs:44:12\n   |\n24\
    \ |     let mut min_num = String::new();\n   |         ----------- move occurs\
    \ because `min_num` has type `String`, which does not implement the `Copy` trait\n\
    ...\n44 |         if min_num.len() < max_num.len() {\n   |            ^^^^^^^^^^^^^\
    \ value borrowed here after move\n...\n47 |             max_num = min_num;\n \
    \  |                       ------- value moved here, in previous iteration of\
    \ loop\n...\n60 |                     max_num = min_num;\n   |               \
    \                ------- value moved here, in previous iteration of loop\n   |\n\
    note: these 2 reinitializations might"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    use std::cmp::Ordering;\n    let mut reversed = arr\n\
    \        .iter()\n        .enumerate()\n        .filter(|(_, value)| value >=\
    \ 1 && value <= 9)\n        .flat_map(|(_, value)| {\n            value.to_string().chars().map(|&c|\
    \ c.to_string()).collect::<Vec<String>>()\n        })\n        .rev()\n      \
    \  .collect::<Vec<String>>();\n    let mut sorted = reversed.into_iter().sort_by(Ordering::<isize>());\n\
    \    let mut ret: Vec<String> = vec![];\n    for i in sorted {\n        ret.push(by_length_from_digit(i\
    \ as usize));\n    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected function, tuple struct or tuple variant, found enum\
    \ `Ordering`\n  --> /tmp/tmpucibaiu9.rs:28:51\n   |\n28 |     let mut sorted =\
    \ reversed.into_iter().sort_by(Ordering::<isize>());\n   |                   \
    \                                ^^^^^^^^^^^^^^^^^\n   |\n   = help: the enum\
    \ has no tuple variants to construct\n   = help: you might have meant to construct\
    \ one of the enum's non-tuple variants\n\nerror[E0425]: cannot find function `by_length_from_digit`\
    \ in this scope\n  --> /tmp/tmpucibaiu9.rs:31:18\n   |\n31 |         ret.push(by_length_from_digit(i\
    \ as usize));\n   |                  ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpucibaiu9.rs:22:39\n   |\n22 |\
    \         .filter(|(_, value)| value >= 1 && value <= 9)\n   |               \
    \                        ^ expected `&&isize`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpucibaiu9.rs:22:53\n   |\n22 |         .filter(|(_,\
    \ value)| value >= 1 && value <= 9)\n   |                                    \
    \                 ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpucibaiu9.rs:24:44\n   |\n24 |             value.to_string().chars().map(|&c|\
    \ c.to_string()).collect::<Vec<String>>()\n   |                              \
    \              ^--\n   |                                            ||\n   | \
    \                                           |expected due to this\n   |      \
    \                                      expected `char`, found reference\n   |\
    \                                            help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0599]: no method named `sort_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpucibaiu9.rs:28:43\n   |\n28 |     let mut\
    \ sorted = reversed.into_iter().sort_by(Ordering::<isize>());\n   |          \
    \                                 ^^^^^^^ method not found in `std::vec::IntoIter<String>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut output = Vec::new();\n    if !arr.is_empty() {\n\
    \        let mut sorted_arr = arr;\n        sorted_arr.sort();\n        sorted_arr.reverse();\n\
    \        for num in sorted_arr {\n            let num_str = format!(\"{}\", num);\n\
    \            match num_str {\n                \"0\" | \"1\" | \"2\" | \"3\" |\
    \ \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" => output.push(format!(\"One\"\
    , num)),\n                \"10\" | \"11\" | \"12\" | \"13\" | \"14\" | \"15\"\
    \ | \"16\" | \"17\" | \"18\" | \"19\" => output.push(format!(\"Two\", num)),\n\
    \                \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\" | \"26\"\
    \ | \"27\" | \"28\" | \"29\" => output.push(format!(\"Three\", num)),\n      \
    \          \"30\" | \"31\" | \"32\" | \"33\" | \"34\" | \"35\" | \"36\" | \"37\"\
    \ | \"38\" | \"39\" => output.push(format!(\"Four\", num)),\n                \"\
    40\" | \"41\" | \"42\" | \"43\" | \"44\" | \"45\" | \"46\" | \"47\" | \"48\" |\
    \ \"49\" => output.push(format!(\"Five\", num)),\n                \"50\" | \"\
    51\" | \"52\" | \"53\" | \"54\" | \"55\" | \"56\" | \"57\" | \"58\" | \"59\" =>\
    \ output.push(format!(\"Six\", num)),\n                \"60\" | \"61\" | \"62\"\
    \ | \"63\" | \"64\" | \"65\" | \"66\" | \"67\" | \"68\" | \"69\" => output.push(format!(\"\
    Seven\", num)),\n                \"70\" | \"71\" | \"72\" | \"73\" | \"74\" |\
    \ \"75\" | \"76\" | \"77\" | \"78\" | \"79\" => output.push(format!(\"Eight\"\
    , num)),\n                \"80\" | \"81\" | \"82\" | \"83\" | \"84\" | \"85\"\
    \ | \"86\" | \"87\" | \"88\" | \"89\" => output.push(format!(\"Nine\", num)),\n\
    \                _ => panic!(\"Can't parse number: {}\", num),\n            }\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmppuisn_r0.rs:26:105\n   |\n26\
    \ |                 \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"\
    7\" | \"8\" | \"9\" => output.push(format!(\"One\", num)),\n   |             \
    \                                                                            \
    \         -----  ^^^ argument never used\n   |                               \
    \                                                                   |\n   |  \
    \                                                                            \
    \                    formatting specifier missing\n\nerror: argument never used\n\
    \  --> /tmp/tmppuisn_r0.rs:27:115\n   |\n27 |                 \"10\" | \"11\"\
    \ | \"12\" | \"13\" | \"14\" | \"15\" | \"16\" | \"17\" | \"18\" | \"19\" => output.push(format!(\"\
    Two\", num)),\n   |                                                          \
    \                                                  -----  ^^^ argument never used\n\
    \   |                                                                        \
    \                                    |\n   |                                 \
    \                                                                           formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmppuisn_r0.rs:28:117\n\
    \   |\n28 |                 \"20\" | \"21\" | \"22\" | \"23\" | \"24\" | \"25\"\
    \ | \"26\" | \"27\" | \"28\" | \"29\" => output.push(format!(\"Three\", num)),\n\
    \   |                                                                        \
    \                                    -------  ^^^ argument never used\n   |  \
    \                                                                            \
    \                              |\n   |                                       \
    \                                                                     formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmppuisn_r0.rs:29:116\n\
    \   |\n29 |                 \"30\" | \"31\" | \"32\" | \"33\" | \"34\" | \"35\"\
    \ | \"36\" | \"37\" | \"38\" | \"39\" => output.push(format!(\"Four\", num)),\n\
    \   |                                                                        \
    \                                    ------  ^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut num_length = 0;\n    for num in arr {\n      \
    \  if num > 9 {\n            num_length += 1;\n        }\n    }\n\n    match num_length\
    \ {\n        1 => {\n            let mut reversed_arr: Vec<isize> = arr;\n   \
    \         reversed_arr.reverse();\n            for digit in reversed_arr {\n \
    \               let index = digit / 10;\n                let str = &[\"One\",\
    \ \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ][index];\n                let result = str + digit.to_string();\n           \
    \     arr.remove(digit as usize);\n                arr.insert(digit as usize,\
    \ result);\n            }\n            arr\n        }\n        _ => {\n      \
    \      let mut reversed_arr: Vec<isize> = arr;\n            reversed_arr.reverse();\n\
    \            let mut index = 0;\n            for digit in reversed_arr {\n   \
    \             let str = &[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\"][index];\n                let result = str\
    \ + digit.to_string();\n                arr.remove(digit as usize);\n        \
    \        arr.insert(digit as usize, result);\n                index += 1;\n  \
    \          }\n            arr\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[&str]` cannot be indexed by `isize`\n  --> /tmp/tmpfr5j0mm2.rs:31:28\n\
    \   |\n31 |                 let str = &[\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][index];\n   |           \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `[&str]`\n\nerror[E0277]:\
    \ cannot add `String` to `&_`\n  --> /tmp/tmpfr5j0mm2.rs:32:34\n   |\n32 |   \
    \              let result = str + digit.to_string();\n   |                   \
    \               ^ no implementation for `&_ + String`\n   |\n   = help: the trait\
    \ `Add<String>` is not implemented for `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfr5j0mm2.rs:36:13\n   |\n17 | fn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n36 |             arr\n   |             ^^^ expected\
    \ struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0369]: cannot add `String`\
    \ to `&&str`\n  --> /tmp/tmpfr5j0mm2.rs:44:34\n   |\n44 |                 let\
    \ result = str + digit.to_string();\n   |                              --- ^ -----------------\
    \ String\n   |                              |\n   |                          \
    \    &&str\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfr5j0mm2.rs:49:13\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n49 |             arr\n   |             ^^^ expected struct `String`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut str = String::new();\n    let mut result: Vec<String>\
    \ = Vec::new();\n    let mut length = arr.len();\n    let mut length_tmp = &mut\
    \ length;\n    let mut length_tmp = length_tmp;\n    let mut i = 0;\n    let mut\
    \ k = arr.len() - 1;\n    while i < k {\n        if length_tmp < 1 {\n       \
    \     break;\n        }\n        let mut j = 0;\n        let mut k = j;\n    \
    \    while k <= length_tmp {\n            if i + k > length_tmp {\n          \
    \      length_tmp -= k;\n                i += k;\n                break;\n   \
    \         }\n            let mut digit = 0;\n            let mut l = i + k;\n\
    \            let mut last = k;\n            while l < length {\n             \
    \   if l > length {\n                    break;\n                }\n         \
    \       let item = &arr[l as usize];\n                let digit = digit + (item\
    \ as isize);\n                l += 1;\n                last += 1;\n          \
    \  }\n            str = format!(\"{}\", digit);\n            let mut digit = str.chars().nth(last).unwrap();\n\
    \            str = str.replace(digit, numbers[digit as usize].as_str());\n   \
    \         i += last;\n            length_tmp -= k;\n            k -= k;\n    \
    \    }\n        result.push(str);\n        length -= k;\n        i += k;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `numbers` in this scope\n  --> /tmp/tmpin4fzgc7.rs:51:38\n\
    \   |\n51 |             str = str.replace(digit, numbers[digit as usize].as_str());\n\
    \   |                                      ^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpin4fzgc7.rs:26:25\n   |\n26 |  \
    \       if length_tmp < 1 {\n   |                         ^\n   |            \
    \             |\n   |                         expected `&mut usize`, found integer\n\
    \   |                         help: consider mutably borrowing here: `&mut 1`\n\
    \nerror[E0277]: can't compare `{integer}` with `&mut usize`\n  --> /tmp/tmpin4fzgc7.rs:31:17\n\
    \   |\n31 |         while k <= length_tmp {\n   |                 ^^ no implementation\
    \ for `{integer} < &mut usize` and `{integer} > &mut usize`\n   |\n   = help:\
    \ the trait `PartialOrd<&mut usize>` is not implemented for `{integer}`\n   =\
    \ help: the following other types implement trait `PartialOrd<Rhs>`:\n       \
    \      f32\n             f64\n             i128\n             i16\n          \
    \   i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin4fzgc7.rs:32:24\n\
    \   |\n32 |             if i + k > length_tmp {\n   |                        ^^^^^^^^^^\
    \ expected `usize`, found `&mut usize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |             if i + k > *length_tmp {\n   |              \
    \          +\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `&mut usize`\n  --> /tmp/tmpin4fzgc7.rs:33:17\n   |\n33 |          \
    \       length_tmp -= k;\n   |                 ----------^^^^^\n   |         \
    \        |\n   |                 cannot use `-=` on type `&mut usize`\n   |\n\
    help: `-=` can be used on `usize`, you can dereference `length_tmp`\n   |\n33\
    \ |                 *length_tmp -= k;\n   |                 +\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `&mut usize`\n  -->\
    \ /tmp/tmpin4fzgc7.rs:53:13\n   |\n53 |             length_tmp -= k;\n   |   \
    \          ----------^^^^^\n   |             |\n   |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr.clone();\n    let mut arr = arr.iter().cloned().sort();\n\
    \    let mut arr = arr.rev();\n    let mut arr = arr.iter().cloned().enumerate().map(|(i,\
    \ _)| {\n        let j = i - 1;\n        if j == 0 {\n            String::from(&arr[j].to_string())\n\
    \        } else {\n            String::from(&arr[j].to_string()) + String::from(&arr[j\
    \ - 1].to_string())\n        }\n    }).collect();\n    arr.iter().cloned().enumerate().for_each(|(i,\
    \ _)| {\n        if i.is_even() {\n            arr.insert(i, String::from(&names[(i\
    \ as usize / 10) as usize]));\n        }\n    });\n    arr.iter().cloned().enumerate().map(|(i,\
    \ _)| {\n        if i.is_even() {\n            String::from(&arr[i].to_string())\n\
    \        } else {\n            String::from(&arr[i].to_string()) + String::from(&arr[(i\
    \ - 1) as usize].to_string())\n        }\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpjgshvuio.rs:34:41\n\
    \   |\n34 |             arr.insert(i, String::from(&names[(i as usize / 10) as\
    \ usize]));\n   |                                         ^^^^^ not found in this\
    \ scope\n\nerror[E0599]: no method named `sort` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpjgshvuio.rs:22:39\n   |\n22 |     let mut arr =\
    \ arr.iter().cloned().sort();\n   |                                       ^^^^\
    \ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjgshvuio.rs:29:49\n   |\n29 |             String::from(&arr[j].to_string())\
    \ + String::from(&arr[j - 1].to_string())\n   |                              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |              \
    \                                   |\n   |                                  \
    \               expected `&str`, found struct `String`\n   |                 \
    \                                help: consider borrowing here: `&String::from(&arr[j\
    \ - 1].to_string())`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjgshvuio.rs:41:49\n\
    \   |\n41 |             String::from(&arr[i].to_string()) + String::from(&arr[(i\
    \ - 1) as usize].to_string())\n   |                                          \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |               \
    \                                  |\n   |                                   \
    \              expected `&str`, found struct `String`\n   |                  \
    \                               help: consider borrowing here: `&String::from(&arr[(i\
    \ - 1) as usize].to_string())`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n    let mut res:\
    \ Vec<String> = vec![\"\".to_string()];\n    res[0] = format!(\"{}\", arr[0]);\n\
    \    for i in 1..arr.len() {\n        if arr[i-1] > arr[i] {\n            let\
    \ tmp: Vec<isize> = arr.iter().skip(i).collect();\n            tmp = tmp.reverse();\n\
    \            for j in 0..tmp.len() {\n                res[j + 1] = format!(\"\
    {}\", tmp[j]);\n            }\n        } else {\n            res[i - 1] += format!(\"\
    {}\", arr[i]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp9bywq1an.rs:23:54\n     |\n\
    23   |             let tmp: Vec<isize> = arr.iter().skip(i).collect();\n     |\
    \                                                      ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9bywq1an.rs:24:19\n\
    \   |\n23 |             let tmp: Vec<isize> = arr.iter().skip(i).collect();\n\
    \   |                      ---------- expected due to this type\n24 |        \
    \     tmp = tmp.reverse();\n   |                   ^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9bywq1an.rs:29:27\n\
    \   |\n29 |             res[i - 1] += format!(\"{}\", arr[i]);\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut new_arr = arr.clone();\n    new_arr.rev();\n    for i in new_arr.iter_mut()\
    \ {\n        if i > 1 && i <= 9 {\n            *i -= 1;\n        }\n    }\n  \
    \  new_arr.iter().map(|x| to_enum_name(x)).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_enum_name` in this scope\n  -->\
    \ /tmp/tmphde3kmy8.rs:28:28\n   |\n28 |     new_arr.iter().map(|x| to_enum_name(x)).collect()\n\
    \   |                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmphde3kmy8.rs:22:13\n    |\n22\
    \  |       new_arr.rev();\n    |               ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphde3kmy8.rs:24:16\n\
    \   |\n24 |         if i > 1 && i <= 9 {\n   |                ^\n   |        \
    \        |\n   |                expected `&mut isize`, found integer\n   |   \
    \             help: consider mutably borrowing here: `&mut 1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphde3kmy8.rs:24:26\n   |\n24 |         if i >\
    \ 1 && i <= 9 {\n   |                          ^\n   |                       \
    \   |\n   |                          expected `&mut isize`, found integer\n  \
    \ |                          help: consider mutably borrowing here: `&mut 9`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    match arr.len() {\n        0 => return vec![],\n     \
    \   _ => {\n            let mut arr2 = arr.to_vec();\n            arr2.sort();\n\
    \            arr2.reverse();\n            arr2.par_iter_mut().for_each(|&x| {\n\
    \                *x = names[*x as usize];\n            });\n            arr2.into_iter().collect()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp1hc8b25s.rs:25:22\n\
    \   |\n25 |                 *x = names[*x as usize];\n   |                   \
    \   ^^^^^ not found in this scope\n\nerror[E0599]: no method named `par_iter_mut`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp1hc8b25s.rs:24:18\n\
    \   |\n24 |             arr2.par_iter_mut().for_each(|&x| {\n   |            \
    \      ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `iter_mut`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from\
    \ an iterator over elements of type `isize`\n    --> /tmp/tmp1hc8b25s.rs:27:30\n\
    \     |\n27   |             arr2.into_iter().collect()\n     |               \
    \               ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut min_value = arr[0];\n    let mut max_value = arr[0];\n    for elem\
    \ in &arr {\n        if elem > max_value {\n            max_value = elem;\n  \
    \      }\n        if elem < min_value {\n            min_value = elem;\n     \
    \   }\n    }\n    let mut arr2 = vec![];\n    let mut min_value = min_value -\
    \ 1;\n    let mut max_value = max_value + 1;\n    let mut counter = 0;\n    let\
    \ mut first = true;\n    for elem in arr {\n        if elem > max_value {\n  \
    \          counter++;\n            max_value = elem;\n        }\n        if elem\
    \ < min_value {\n            counter--;\n            min_value = elem;\n     \
    \   }\n        if counter >= 0 {\n            if first {\n                first\
    \ = false;\n                arr2.push(String::from(\"One\"));\n            }\n\
    \            arr2.push(String::from(names[elem]));\n        }\n    }\n    arr2.reverse();\n\
    \    arr2.into_iter().map(|x| x.to_ascii_lowercase()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp9axsm0ua.rs:38:20\n\
    \   |\n38 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n38 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    38 -             counter++;\n38 +             counter += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmp9axsm0ua.rs:42:22\n   |\n42 |         \
    \    counter--;\n   |                      ^ expected expression\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmp9axsm0ua.rs:50:36\n \
    \  |\n50 |             arr2.push(String::from(names[elem]));\n   |           \
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9axsm0ua.rs:24:19\n   |\n24 |         if elem > max_value\
    \ {\n   |                   ^^^^^^^^^\n   |                   |\n   |        \
    \           expected `&isize`, found `isize`\n   |                   help: consider\
    \ borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9axsm0ua.rs:25:25\n\
    \   |\n22 |     let mut max_value = arr[0];\n   |                         ------\
    \ expected due to this value\n...\n25 |             max_value = elem;\n   |  \
    \                       ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *elem;\n   |  \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9axsm0ua.rs:27:19\n\
    \   |\n27 |         if elem < min_value {\n   |                   ^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&min_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9axsm0ua.rs:28:25\n   |\n21 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n28 |             min_value = elem;\n   |                         ^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    28 |    "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut max_len = arr.len();\n\
    \    let mut i = 1;\n    while i <= 9 {\n        let mut temp = Vec::new();\n\
    \        for val in arr.iter() {\n            if val > i && val < 10 {\n     \
    \           temp.push(format!(\"{}\", val));\n            }\n        }\n     \
    \   res.extend(temp);\n        i += 1;\n    }\n    let mut i = 0;\n    while i\
    \ < max_len {\n        res.push(format!(\"{}\", &arr[i..]));\n        i += 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuf2tum_.rs:24:22\n   |\n\
    24 |             if val > i && val < 10 {\n   |                      ^\n   | \
    \                     |\n   |                      expected `&isize`, found integer\n\
    \   |                      help: consider borrowing here: `&i`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjuf2tum_.rs:24:33\n   |\n24 |             if\
    \ val > i && val < 10 {\n   |                                 ^^\n   |       \
    \                          |\n   |                                 expected `&isize`,\
    \ found integer\n   |                                 help: consider borrowing\
    \ here: `&10`\n\nerror[E0277]: `[isize]` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpjuf2tum_.rs:33:32\n   |\n33 |         res.push(format!(\"{}\",\
    \ &arr[i..]));\n   |                                ^^^^^^^^^ `[isize]` cannot\
    \ be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `[isize]`\n   = note: in format strings you may be able\
    \ to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::__export::format_args` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut counter = HashMap::new();\n    let mut numbers = vec![];\n    for\
    \ num in arr {\n        if let Some(key) = counter.get(&num) {\n            counter.insert(num,\
    \ *key + 1);\n        } else {\n            numbers.push(*num as usize);\n   \
    \         counter.insert(num, 1);\n        }\n    }\n    numbers\n        .iter()\n\
    \        .fold(vec![], |mut numbers, num| {\n            numbers.push((*num as\
    \ usize).to_string());\n            numbers\n        })\n        .to_owned()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmptwl4pxul.rs:21:23\n   |\n21 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmptwl4pxul.rs:27:26\n   |\n\
    27 |             numbers.push(*num as usize);\n   |                          ^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0614.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut len = arr.len();\n    let mut min_len = 0;\n \
    \   let mut max_len = arr.len();\n\n    let mut first_index = 0;\n    let mut\
    \ last_index = arr.len();\n\n    while first_index <= last_index {\n        let\
    \ min_index = first_index;\n        let max_index = last_index;\n\n        let\
    \ mut min_value = arr[min_index];\n        let mut max_value = arr[max_index];\n\
    \n        while min_index <= max_index {\n            while min_value <= max_value\
    \ {\n                let tmp = arr[min_index];\n                arr[min_index]\
    \ = max_value;\n                max_value = tmp;\n                min_index +=\
    \ 1;\n            }\n\n            while max_value >= min_value {\n          \
    \      let tmp = arr[max_index];\n                arr[max_index] = min_value;\n\
    \                min_value = tmp;\n                max_index -= 1;\n         \
    \   }\n        }\n\n        first_index = min_index;\n        last_index = max_index;\n\
    \    }\n\n    let mut res: Vec<String> = Vec::new();\n    let mut first_index\
    \ = 0;\n    let mut last_index = arr.len();\n    while first_index <= last_index\
    \ {\n        res.push(arr[first_index].to_string());\n        first_index += 1;\n\
    \    }\n\n    res.reverse();\n    res.sort();\n    res\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `len`\n  --> /tmp/tmpm51h9cyo.rs:18:13\n   |\n\
    18 |     let mut len = arr.len();\n   |             ^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_len`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: unused variable: `min_len`\n  --> /tmp/tmpm51h9cyo.rs:19:13\n\
    \   |\n19 |     let mut min_len = 0;\n   |             ^^^^^^^ help: if this is\
    \ intentional, prefix it with an underscore: `_min_len`\n\nwarning: unused variable:\
    \ `max_len`\n  --> /tmp/tmpm51h9cyo.rs:20:13\n   |\n20 |     let mut max_len =\
    \ arr.len();\n   |             ^^^^^^^ help: if this is intentional, prefix it\
    \ with an underscore: `_max_len`\n\nwarning: variable does not need to be mutable\n\
    \  --> /tmp/tmpm51h9cyo.rs:18:9\n   |\n18 |     let mut len = arr.len();\n   |\
    \         ----^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpm51h9cyo.rs:19:9\n   |\n19 |     let mut min_len\
    \ = 0;\n   |         ----^^^^^^^\n   |         |\n   |         help: remove this\
    \ `mut`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpm51h9cyo.rs:20:9\n\
    \   |\n20 |     let mut max_len = arr.len();\n   |         ----^^^^^^^\n   | \
    \        |\n   |         help: remove this `mut`\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpm51h9cyo.rs:54:9\n   |\n54 |     let mut last_index\
    \ = arr.len();\n   |         ----^^^^^^^^^^\n   |         |\n   |         help:\
    \ remove this `mut`\n\nerror[E0596]: cannot borrow `arr` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmpm51h9cyo.rs:35:17\n   |\n17 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |              --- help: consider changing\
    \ this to be mutable: `mut arr`\n...\n35 |                 arr[min_index] = max_value;\n\
    \   |                 ^^^ cannot borrow as mutable\n\nerror[E0384]: cannot assign\
    \ twice to immutable variable `min_index`\n  --> /tmp/tmpm51h9cyo.rs:37:17\n \
    \  |\n26 |         let min_index = first_index;\n   |             ---------\n\
    \   |             |\n   |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n\n    let mut a\
    \ = arr\n        .iter()\n        .filter(|x| *x >= *x + *x) // filter integers\
    \ that are less than or equal to their sum\n        .collect::<Vec<isize>>() //\
    \ collect into vector\n        .sort_unstable() // sort unstable\n\n    if a.is_empty()\
    \ { return vec![]; }\n\n    let mut reverse: Vec<isize> = a.clone(); // create\
    \ new vector to sort and reverse\n\n    reverse.reverse(); // reverse the vector\n\
    \    let ones: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n\n    let mut result = ones; // store\
    \ result\n\n    for v in reverse {\n        result.swap(result.iter_mut().skip(ones_len\
    \ - v).next(), v);\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp0dbi6pn7.rs:24:25\n\
    \   |\n24 |         .sort_unstable() // sort unstable\n   |                  \
    \       ^ help: add `;` here\n25 | \n26 |     if a.is_empty() { return vec![];\
    \ }\n   |     -- unexpected token\n\nerror[E0425]: cannot find value `ones_len`\
    \ in this scope\n  --> /tmp/tmp0dbi6pn7.rs:36:44\n   |\n36 |         result.swap(result.iter_mut().skip(ones_len\
    \ - v).next(), v);\n   |                                            ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dbi6pn7.rs:22:27\n\
    \   |\n22 |         .filter(|x| *x >= *x + *x) // filter integers that are less\
    \ than or equal to their sum\n   |                           ^^^^^^^\n   |   \
    \                        |\n   |                           expected `&isize`,\
    \ found `isize`\n   |                           help: consider borrowing here:\
    \ `&(*x + *x)`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from\
    \ an iterator over elements of type `&isize`\n    --> /tmp/tmp0dbi6pn7.rs:23:10\n\
    \     |\n23   |         .collect::<Vec<isize>>() // collect into vector\n    \
    \ |          ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `is_empty`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmp0dbi6pn7.rs:26:10\n\
    \   |\n26 |     if a.is_empty() { return vec![]; }\n   |          ^^^^^^^^ method\
    \ not found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dbi6pn7.rs:28:35\n\
    \   |\n28 |     let mut reverse: Vec<isize> = a.clone(); // create new vector\
    \ to sort and reverse\n   |                      ----------   ^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |                      |\n   |                \
    \      expected due to this\n   |\n   = note: expected struct `Vec<isize>`\n \
    \          found unit type `()`\n\nerror[E0308]: mismatched types\n  -->"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut a = arr.clone();\n    a.sort_unstable_by(|x, y|\
    \ {\n        match x % 10 {\n            1 .. 9 => x.to_string(),\n          \
    \  _ => y.to_string()\n        }\n    });\n    a.reverse();\n    a.iter().map(|x|\
    \ {\n        if x % 10 == 1 {\n            String::from(\"One\")\n        } else\
    \ {\n            String::from(\"Two\")\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpjdro4uh2.rs:21:13\n\
    \   |\n21 |             1 .. 9 => x.to_string(),\n   |             ^^^^^^\n  \
    \ |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdro4uh2.rs:21:23\n\
    \   |\n21 |             1 .. 9 => x.to_string(),\n   |                       ^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0658.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut reversed = arr.clone();\n    reversed.reverse();\n\n    let mut names\
    \ = vec![];\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n\n\
    \    while i < reversed.len() {\n        let cur = reversed[i];\n\n        if\
    \ cur < 10 {\n            names.push(format!(\"One\", cur));\n        } else if\
    \ cur < 20 {\n            names.push(format!(\"Two\", cur));\n        } else if\
    \ cur < 30 {\n            names.push(format!(\"Three\", cur));\n        } else\
    \ if cur < 40 {\n            names.push(format!(\"Four\", cur));\n        } else\
    \ if cur < 50 {\n            names.push(format!(\"Five\", cur));\n        } else\
    \ if cur < 60 {\n            names.push(format!(\"Six\", cur));\n        } else\
    \ if cur < 70 {\n            names.push(format!(\"Seven\", cur));\n        } else\
    \ if cur < 80 {\n            names.push(format!(\"Eight\", cur));\n        } else\
    \ if cur < 90 {\n            names.push(format!(\"Nine\", cur));\n        } else\
    \ {\n            j = reversed.len();\n            k = reversed.len();\n\n    \
    \        while reversed[j].is_none() {\n                j -= 1;\n            }\n\
    \n            while reversed[k].is_none() {\n                k -= 1;\n       \
    \     }\n\n            i += 1;\n            i += 1;\n\n            if j < k {\n\
    \                let cur = reversed[j];\n                let new_cur = reversed[k];\n\
    \n                reversed[j] = new_cur;\n                reversed[k] = cur;\n\
    \            }\n        }\n    }\n\n    names\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmpj__oe719.rs:35:39\n   |\n35 |\
    \             names.push(format!(\"One\", cur));\n   |                       \
    \         -----  ^^^ argument never used\n   |                               \
    \ |\n   |                                formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmpj__oe719.rs:37:39\n   |\n37 |           \
    \  names.push(format!(\"Two\", cur));\n   |                                -----\
    \  ^^^ argument never used\n   |                                |\n   |      \
    \                          formatting specifier missing\n\nerror: argument never\
    \ used\n  --> /tmp/tmpj__oe719.rs:39:41\n   |\n39 |             names.push(format!(\"\
    Three\", cur));\n   |                                -------  ^^^ argument never\
    \ used\n   |                                |\n   |                          \
    \      formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpj__oe719.rs:41:40\n\
    \   |\n41 |             names.push(format!(\"Four\", cur));\n   |            \
    \                    ------  ^^^ argument never used\n   |                   \
    \             |\n   |                                formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpj__oe719.rs:43:40\n   |\n43 |    \
    \         names.push(format!(\"Five\", cur));\n   |                          \
    \      ------  ^^^ argument never used\n   |                                |\n\
    \   |                                formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpj__oe719.rs:45:39\n   |\n45 |             names.push(format!(\"\
    Six\", cur));\n   |                                -----  ^^^ argument never used\n\
    \   |                                |\n   |                                formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpj__oe719.rs:47:41\n\
    \   |\n47 |             names.push(format!(\"Seven\", cur));\n   |           \
    \                     -------  ^^^ argument never used\n   |                 \
    \               |\n   |                                formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut len =\
    \ arr.len();\n    let mut arr = arr.rev();\n    \n    while len > 0 {\n      \
    \  let mut i = 0;\n        while i < len {\n            let mut cur = arr[i];\n\
    \            let mut res = false;\n            for i in 0..result.len() {\n  \
    \              if cur > i {\n                    res = true;\n               \
    \     break;\n                }\n            }\n            if res == false {\n\
    \                result.append(&result[i]);\n            }\n            i += 1;\n\
    \        }\n        len = arr.len();\n        arr.rev();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpvexfy9bi.rs:20:23\n\
    \    |\n20  |       let mut arr = arr.rev();\n    |                         ^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvexfy9bi.rs:34:31\n   |\n34 |                 result.append(&result[i]);\n\
    \   |                               ^^^^^^^^^^ types differ in mutability\n  \
    \ |\n   = note: expected mutable reference `&mut Vec<&str>`\n                \
    \      found reference `&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvexfy9bi.rs:41:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n41 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut res = vec![];\n    let mut len = arr.len();\n    let mut min = 0;\n\
    \    let mut max = 9;\n    \n    while min <= max {\n        // find the first\
    \ number between min and max\n        let mid = min + max / 2;\n        if arr[mid]\
    \ == mid {\n            continue;\n        }\n        \n        // if min = mid\
    \ + 1 then find the second number between min and mid\n        if mid == max -\
    \ 1 {\n            if arr[mid] == mid {\n                continue;\n         \
    \   }\n            max = mid - 1;\n        } else {\n            max = mid;\n\
    \        }\n        \n        // replace every occurrence of arr[mid] by its corresponding\
    \ name in \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n        let tmp = (&arr[mid..]).iter().map(|x| {\n    \
    \        match x {\n                x if x < 10 => \"One\",\n                x\
    \ if x <= 99 => \"Two\",\n                x if x <= 999 => \"Three\",\n      \
    \          x if x <= 9999 => \"Four\",\n                x if x <= 99999 => \"\
    Five\",\n                x if x <= 999999 => \"Six\",\n                x if x\
    \ <= 9999999 => \"Seven\",\n                x if x <= 99999999 => \"Eight\",\n\
    \                x if x <= 999999999 => \"Nine\",\n                x if x <= 1000000000\
    \ => \"OneHundred\",\n                x if x <= 10000000000 => \"TwoHundred\"\
    ,\n                x if x <= 100000000000 => \"ThreeHundred\",\n             \
    \   x if x <= 1000000000000 => \"FourHundred\",\n                x if x <= 10000000000000\
    \ => \"FiveHundred\",\n                x if x <= 100000000000000 => \"SixHundred\"\
    ,\n                x if x <= 1000000000000000 => \"SevenHundred\",\n         \
    \       x if x <= 10000000000000000 => \"EightHundred\",\n                x if\
    \ x <= 100000000000000000 => \"NineHundred\",\n                x if x <= 1000000000000000000\
    \ => \"OneThousand\",\n                x if x <= 10000000000000000000 => \"TwoThousand\"\
    ,\n                x if x <= 100000000000000000000 => \"ThreeThousand\",\n   \
    \             x if x <= 1000000000000000000000 => \"FourThousand\",\n        \
    \        x if x <= 10000000000000000000000 => \"FiveThousand\",\n            \
    \    x if x <= 100000000000000000000000 => \"SixThousand\",\n                x\
    \ \n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpv8v47jab.rs:80:3\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n26 |     while min\
    \ <= max {\n   |                      - unclosed delimiter\n...\n44 |        \
    \ let tmp = (&arr[mid..]).iter().map(|x| {\n   |                             \
    \              -    - unclosed delimiter\n   |                               \
    \            |\n   |                                           unclosed delimiter\n\
    45 |             match x {\n   |                     - this delimiter might not\
    \ be properly closed...\n...\n71 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n80 | }\n   |   ^\n\nerror: expected one of `=>`,\
    \ `@`, `if`, or `|`, found `}`\n  --> /tmp/tmpv8v47jab.rs:71:1\n   |\n70 |   \
    \              x \n   |                  - expected one of `=>`, `@`, `if`, or\
    \ `|`\n71 | }\n   | ^ unexpected token\n\nerror: expected one of `.`, `;`, `?`,\
    \ `else`, or an operator, found `}`\n  --> /tmp/tmpv8v47jab.rs:80:3\n   |\n80\
    \ | }\n   |   ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv8v47jab.rs:29:24\n   |\n29 |         if arr[mid]\
    \ == mid {\n   |                        ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |         if arr[mid] == mid.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv8v47jab.rs:35:28\n   |\n35 |             if arr[mid] ==\
    \ mid {\n   |                            ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |             if arr[mid] == mid.try_into().unwrap()\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv8v47jab.rs:26:5\n   |\n17 |   fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                    ---"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut arr = arr.to_vec();\n    let mut len = arr.len();\n    let mut first\
    \ = &arr[..1];\n    let mut second = &arr[2..2];\n    let mut third = &arr[3..3];\n\
    \    let mut fourth = &arr[4..4];\n    let mut fifth = &arr[5..5];\n    let mut\
    \ sixth = &arr[6..6];\n    let mut seventh = &arr[7..7];\n    let mut eighth =\
    \ &arr[8..8];\n    let mut ninth = &arr[9..9];\n\n    len = len - 3;\n\n    if\
    \ len > 0 && first[0] < &arr[1] {\n        third = &arr[3..3];\n    }\n    if\
    \ len > 1 && second[0] < &arr[2] {\n        fourth = &arr[4..4];\n    }\n    if\
    \ len > 2 && third[0] < &arr[3] {\n        fifth = &arr[5..5];\n    }\n    if\
    \ len > 3 && fourth[0] < &arr[4] {\n        sixth = &arr[6..6];\n    }\n    if\
    \ len > 4 && fifth[0] < &arr[5] {\n        seventh = &arr[7..7];\n    }\n    if\
    \ len > 5 && sixth[0] < &arr[6] {\n        eighth = &arr[8..8];\n    }\n    if\
    \ len > 6 && seventh[0] < &arr[7] {\n        ninth = &arr[9..9];\n    }\n\n  \
    \  let mut result = vec![];\n    if len > 3 {\n        result.push(\n        \
    \    by_length(&arr[1..1]).concat(by_length(&arr[2..2])).to_vec().as_slice().to_owned(),\n\
    \        );\n    }\n    if len > 4 {\n        result.push(\n            by_length(&arr[3..3]).concat(by_length(&arr[4..4])).to_vec().as_slice().to_owned(),\n\
    \        );\n    }\n    if len > 5 {\n        result.push(\n            by_length(&arr[5..5]).concat(by_length(&arr[6..6])).to_vec().as_slice().to_owned(),\n\
    \        );\n    }\n    if len > 6 {\n        result.push(\n            by_length(&arr[7..7]).concat(by_length(&arr[8..8])).to_vec().as_slice().to_owned(),\n\
    \        );\n    }\n    if len\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmphmt4w8jy.rs:80:1\n   |\n\
    79 |     if len\n   |     -- this `if` expression has a condition, but no block\n\
    80 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmt4w8jy.rs:36:30\n\
    \   |\n36 |     if len > 0 && first[0] < &arr[1] {\n   |                     \
    \         ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n36 -     if len > 0 && first[0] < &arr[1] {\n36 +     if len\
    \ > 0 && first[0] < arr[1] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmt4w8jy.rs:39:31\n\
    \   |\n39 |     if len > 1 && second[0] < &arr[2] {\n   |                    \
    \           ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n39 -     if len > 1 && second[0] < &arr[2] {\n39 +     if\
    \ len > 1 && second[0] < arr[2] {\n   | \n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmphmt4w8jy.rs:42:30\n   |\n42 |     if len > 2 && third[0] < &arr[3]\
    \ {\n   |                              ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider removing the borrow\n   |\n42 -     if len > 2 && third[0]\
    \ < &arr[3] {\n42 +     if len > 2 && third[0] < arr[3] {\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphmt4w8jy.rs:45:31\n   |\n45 |     if len > 3\
    \ && fourth[0] < &arr[4] {\n   |                               ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider removing the borrow\n   |\n45\
    \ -     if len > 3 && fourth[0] < &arr[4] {\n45 +     if len > 3 && fourth[0]\
    \ < arr[4] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmt4w8jy.rs:48:30\n\
    \   |\n48 |     if len > 4 && fifth[0] < &arr[5] {\n   |                     \
    \         ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n48 -     if len > 4 && fifth[0] < &arr[5] {\n48 +     if len\
    \ > 4 && fifth[0] < arr[5] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmt4w8jy.rs:51:30\n\
    \   |\n51 |     if len > 5 && sixth[0] < &arr[6] {\n   |                     \
    \         ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n51 -"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return Vec::new();\n    }\n\
    \    let mut res = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"];\n    let mut min_len = arr.len();\n    let\
    \ mut max_len = arr.len();\n    while min_len > 0 || max_len > 0 {\n        let\
    \ min = min_len > 0 ? arr[min_len - 1] : -1;\n        let max = max_len > 0 ?\
    \ arr[max_len - 1] : -1;\n        let mut index = arr.len();\n        while index\
    \ > min_len {\n            let el = &arr[index - min_len];\n            if el\
    \ < min {\n                res.swap(index - min_len, index - 1);\n           \
    \     min_len -= 1;\n            } else if el > max {\n                res.swap(index\
    \ - 1, index);\n                max_len -= 1;\n            } else {\n        \
    \        break;\n            }\n            index -= 1;\n        }\n    }\n  \
    \  if arr.len() == 1 {\n        return vec![\"One\"];\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `arr`\n\
    \  --> /tmp/tmp2bg3e5g6.rs:25:33\n   |\n25 |         let min = min_len > 0 ? arr[min_len\
    \ - 1] : -1;\n   |                                 ^^^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bg3e5g6.rs:43:21\n\
    \   |\n43 |         return vec![\"One\"];\n   |                     ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                     |\n\
    \   |                     expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2bg3e5g6.rs:45:5\n   |\n17 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n45 |     res\n   |     ^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr = vec![];\n    for i in arr {\n      \
    \  if i != 1 && i != 9 && i != 0 {\n            new_arr.push(name_by_index(&i))\n\
    \        }\n    }\n    if new_arr.is_empty() {\n        return vec![];\n    }\n\
    \    new_arr.reverse();\n    new_arr.iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `name_by_index` in this scope\n  -->\
    \ /tmp/tmpu8v4bp5m.rs:21:26\n   |\n21 |             new_arr.push(name_by_index(&i))\n\
    \   |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    use std::cmp::Ordering::*;\n    let mut i = 0;\n    let\
    \ mut result = vec![];\n    for v in arr.iter() {\n        if v != -1 && v !=\
    \ 9 && v < 10 {\n            result.push(by_length_helper(&mut i, &v, &arr));\n\
    \        }\n        i += v;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_length_helper` in this scope\n \
    \ --> /tmp/tmp82a880rd.rs:23:25\n   |\n23 |             result.push(by_length_helper(&mut\
    \ i, &v, &arr));\n   |                         ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nwarning: unused import: `std::cmp::Ordering::*`\n  --> /tmp/tmp82a880rd.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmp82a880rd.rs:22:14\n   |\n22\
    \ |         if v != -1 && v != 9 && v < 10 {\n   |              ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp82a880rd.rs:22:25\n   |\n22 |         if v !=\
    \ -1 && v != 9 && v < 10 {\n   |                         ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp82a880rd.rs:22:37\n   |\n22 |         if v != -1 && v != 9 && v < 10\
    \ {\n   |                                     ^^\n   |                       \
    \              |\n   |                                     expected `&isize`,\
    \ found integer\n   |                                     help: consider borrowing\
    \ here: `&10`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr.sort_unstable();\n    arr.rev();\n    for d in arr {\n \
    \       if d < 1 || d > 9 {\n            continue;\n        }\n        arr.push((d\
    \ as i32) as isize);\n    }\n    arr\n        .iter()\n        .map(|n| get_name(n\
    \ as usize).unwrap())\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_name` in this scope\n  --> /tmp/tmpxij2abm6.rs:31:18\n\
    \   |\n31 |         .map(|n| get_name(n as usize).unwrap())\n   |            \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0599]: `()` is not an iterator\n\
    \  --> /tmp/tmpxij2abm6.rs:22:9\n   |\n22 |     arr.rev();\n   |         ^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror[E0277]: `()` is not an iterator\n  --> /tmp/tmpxij2abm6.rs:23:14\n   |\n\
    23 |     for d in arr {\n   |              ^^^ `()` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `()`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `()`\n\nerror[E0599]:\
    \ no method named `push` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpxij2abm6.rs:27:13\n   |\n27 |         arr.push((d as i32) as isize);\n\
    \   |             ^^^^ method not found in `()`\n\nerror[E0599]: no method named\
    \ `iter` found for unit type `()` in the current scope\n  --> /tmp/tmpxij2abm6.rs:30:10\n\
    \   |\n30 |         .iter()\n   |          ^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n    if arr.len()\
    \ == 1 {\n        return vec![\"One\"];\n    }\n    let mut one = arr.iter().take(1).collect::<Vec<_>>();\n\
    \    let mut two = arr.iter().skip(1).take(2).collect::<Vec<_>>();\n    let mut\
    \ three = arr.iter().skip(2).take(3).collect::<Vec<_>>();\n    let mut four =\
    \ arr.iter().skip(3).take(4).collect::<Vec<_>>();\n    let mut five = arr.iter().skip(4).take(5).collect::<Vec<_>>();\n\
    \    let mut six = arr.iter().skip(5).take(6).collect::<Vec<_>>();\n    let mut\
    \ seven = arr.iter().skip(6).take(7).collect::<Vec<_>>();\n    let mut eight =\
    \ arr.iter().skip(7).take(8).collect::<Vec<_>>();\n    let mut nine = arr.iter().skip(8).take(9).collect::<Vec<_>>();\n\
    \    let mut ten = arr.iter().skip(9).take(10).collect::<Vec<_>>();\n    let mut\
    \ eleven = arr.iter().skip(10).take(11).collect::<Vec<_>>();\n    let mut twelve\
    \ = arr.iter().skip(11).take(12).collect::<Vec<_>>();\n    let mut thirteen =\
    \ arr.iter().skip(12).take(13).collect::<Vec<_>>();\n    let mut fourteen = arr.iter().skip(13).take(14).collect::<Vec<_>>();\n\
    \    let mut fifteen = arr.iter().skip(14).take(15).collect::<Vec<_>>();\n   \
    \ let mut sixteen = arr.iter().skip(15).take(16).collect::<Vec<_>>();\n    let\
    \ mut seventeen = arr.iter().skip(16).take(17).collect::<Vec<_>>();\n    let mut\
    \ eighteen = arr.iter().skip(17).take(18).collect::<Vec<_>>();\n    let mut nineteen\
    \ = arr.iter().skip(18).take(19).collect::<Vec<_>>();\n\n    one = one.iter().map(|x|\
    \ by_length_one(x)).collect();\n    two = two.iter().\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9xp8pcxr.rs:44:1\n   |\n44\
    \ | }\n   | ^\n\nerror[E0425]: cannot find function `by_length_one` in this scope\n\
    \  --> /tmp/tmp9xp8pcxr.rs:42:30\n   |\n42 |     one = one.iter().map(|x| by_length_one(x)).collect();\n\
    \   |                              ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9xp8pcxr.rs:20:21\n   |\n20 |         return\
    \ vec![\"One\"];\n   |                     ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9xp8pcxr.rs:43:11\n   |\n23 |     let mut two = arr.iter().skip(1).take(2).collect::<Vec<_>>();\n\
    \   |                   ---------------------------------------------- expected\
    \ due to this value\n...\n43 |     two = two.iter().\n   |           ^^^^^^^^^^\
    \ expected struct `Vec`, found struct `std::slice::Iter`\n   |\n   = note: expected\
    \ struct `Vec<&isize>`\n              found struct `std::slice::Iter<'_, &isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9xp8pcxr.rs:43:5\n   |\n17 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n43 |\
    \     two = two.iter().\n   |     ^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ret: Vec<String> = Vec::new();\n    if arr.len()\
    \ <= 1 {\n        return ret;\n    }\n    let mut counter: usize = 0;\n    let\
    \ mut digits = Vec::with_capacity(arr.len() - 1);\n    let mut temp = String::with_capacity(9);\n\
    \    let mut last_digit = String::with_capacity(1);\n    let mut reverse_digits\
    \ = false;\n    for &num in &arr {\n        if num > 9 {\n            break;\n\
    \        }\n        counter = num as usize;\n        if reverse_digits {\n   \
    \         digits.reverse();\n        }\n        for digit in &digits {\n     \
    \       if digit != counter {\n                continue;\n            }\n    \
    \        last_digit = digit;\n        }\n        temp.push_str(&last_digit);\n\
    \        if last_digit != counter {\n            temp.pop_back();\n        }\n\
    \        let mut result = temp.clone();\n        ret.push(result);\n    }\n  \
    \  return ret;\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&_` with `usize`\n  --> /tmp/tmp6bjbd1q5.rs:36:22\n\
    \   |\n36 |             if digit != counter {\n   |                      ^^ no\
    \ implementation for `&_ == usize`\n   |\n   = help: the trait `PartialEq<usize>`\
    \ is not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bjbd1q5.rs:39:26\n\
    \   |\n25 |     let mut last_digit = String::with_capacity(1);\n   |         \
    \                 ------------------------ expected due to this value\n...\n39\
    \ |             last_digit = digit;\n   |                          ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0599]: no method named `pop_back` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp6bjbd1q5.rs:43:18\n   |\n43 |             temp.pop_back();\n\
    \   |                  ^^^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ can't compare `String` with `usize`\n  --> /tmp/tmp6bjbd1q5.rs:42:23\n   |\n\
    42 |         if last_digit != counter {\n   |                       ^^ no implementation\
    \ for `String == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut arr = arr.to_owned();\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut names = Vec::new();\n    for i in arr {\n        let v = i.to_string();\n\
    \        if v[0] == '1' {\n            names.push(\"One\");\n        } else if\
    \ v[0] == '2' {\n            names.push(\"Two\");\n        } else if v[0] == '3'\
    \ {\n            names.push(\"Three\");\n        } else if v[0] == '4' {\n   \
    \         names.push(\"Four\");\n        } else if v[0] == '5' {\n           \
    \ names.push(\"Five\");\n        } else if v[0] == '6' {\n            names.push(\"\
    Six\");\n        } else if v[0] == '7' {\n            names.push(\"Seven\");\n\
    \        } else if v[0] == '8' {\n            names.push(\"Eight\");\n       \
    \ } else if v[0] == '9' {\n            names.push(\"Nine\");\n        } else {\n\
    \            return Vec::new();\n        }\n    }\n    return names\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp7x5gbc0k.rs:27:12\n   |\n27 |         if v[0] == '1' {\n   |       \
    \     ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp7x5gbc0k.rs:29:19\n   |\n29 |         } else if v[0] == '2' {\n\
    \   |                   ^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp7x5gbc0k.rs:31:19\n   |\n31 |         } else if v[0] == '3' {\n\
    \   |                   ^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n\n    let mut first = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut second = arr.iter().cloned().collect::<Vec<_>>();\n\n    while first.is_not_empty()\
    \ && second.is_not_empty() {\n        if first[0] > second[0] {\n            first.swap(0,\
    \ 0);\n            result.push(by_length(&first));\n        } else {\n       \
    \     second.swap(0, 0);\n            result.push(by_length(&second));\n     \
    \   }\n    }\n\n    result.extend(first);\n    result.extend(second);\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_not_empty` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpx0m53g9v.rs:23:17\n   |\n23 |     while\
    \ first.is_not_empty() && second.is_not_empty() {\n   |                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_empty`\n\nerror[E0599]:\
    \ no method named `is_not_empty` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpx0m53g9v.rs:23:42\n   |\n23 |     while first.is_not_empty()\
    \ && second.is_not_empty() {\n   |                                          ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_empty`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx0m53g9v.rs:26:35\n   |\n26 |             result.push(by_length(&first));\n\
    \   |                                   ^^^^^^ expected struct `Vec`, found `&Vec<isize>`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found reference `&Vec<isize>`\n\
    help: consider removing the borrow\n   |\n26 -             result.push(by_length(&first));\n\
    26 +             result.push(by_length(first));\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx0m53g9v.rs:29:35\n   |\n29 |             result.push(by_length(&second));\n\
    \   |                                   ^^^^^^^ expected struct `Vec`, found `&Vec<isize>`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found reference `&Vec<isize>`\n\
    help: consider removing the borrow\n   |\n29 -             result.push(by_length(&second));\n\
    29 +             result.push(by_length(second));\n   | \n\nerror[E0271]: type\
    \ mismatch resolving `<Vec<isize> as IntoIterator>::Item == Vec<String>`\n   -->\
    \ /tmp/tmpx0m53g9v.rs:33:12\n    |\n33  |     result.extend(first);\n    |   \
    \         ^^^^^^ expected struct `Vec`, found `isize`\n    |\n    = note: expected\
    \ struct `Vec<String>`\n                 found type `isize`\nnote: required by\
    \ a bound in `extend`\n\nerror[E0271]: type mismatch resolving `<Vec<isize> as\
    \ IntoIterator>::Item == Vec<String>`\n   --> /tmp/tmpx0m53g9v.rs:34:12\n    |\n\
    34  |     result.extend(second);\n    |            ^^^^^^ expected struc"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr = arr.clone();\n    new_arr.sort_by_key(|x|\
    \ x.checked_mul(2).ok());\n    new_arr.reverse();\n    new_arr.iter().map(|x|\
    \ {\n        let i = x.checked_div(10).ok().expect(\"Can only divide by 10\");\n\
    \        String::from_str(&names[*i as usize])\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpfzft_1td.rs:23:27\n\
    \   |\n23 |         String::from_str(&names[*i as usize])\n   |              \
    \             ^^^^^ not found in this scope\n\nerror[E0599]: no method named `ok`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpfzft_1td.rs:19:46\n\
    \   |\n19 |     new_arr.sort_by_key(|x| x.checked_mul(2).ok());\n   |        \
    \                                      ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror[E0599]: no method named `ok` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpfzft_1td.rs:22:35\n   |\n22 | \
    \        let i = x.checked_div(10).ok().expect(\"Can only divide by 10\");\n \
    \  |                                   ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror[E0599]: no function or associated item named\
    \ `from_str` found for struct `String` in the current scope\n  --> /tmp/tmpfzft_1td.rs:23:17\n\
    \   |\n23 |         String::from_str(&names[*i as usize])\n   |              \
    \   ^^^^^^^^ function or associated item not found in `String`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::str::FromStr;\n   |\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        vec![\"One\"]\n    } else\
    \ if arr.len() == 1 {\n        vec![arr[0].to_string()]\n    } else {\n      \
    \  let mut arr2 = arr.clone();\n        by_length(arr2.iter().cloned().skip(1).cloned().collect::<Vec<_>>()).iter().for_each(|x|\n\
    \            arr2.remove(&x));\n        let mut res: Vec<String> = vec![];\n \
    \       for &i in arr2 {\n            res.push((&i)[1..].to_owned());\n      \
    \  }\n        res.reverse();\n        arr2.retain(|&i| i >= 1 && i <= 9);\n  \
    \      res.iter().for_each(|x|\n            arr2.remove(&x));\n        res.iter().for_each(|x|\
    \ arr2.push(x.to_string()));\n        arr2\n    }\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4secjha.rs:19:14\n   |\n\
    19 |         vec![\"One\"]\n   |              ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |              |\n   |              expected struct\
    \ `String`, found `&str`\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_,\
    \ isize> as Iterator>::Item == &&_`\n    --> /tmp/tmp_4secjha.rs:24:48\n     |\n\
    24   |         by_length(arr2.iter().cloned().skip(1).cloned().collect::<Vec<_>>()).iter().for_each(|x|\n\
    \     |                                                ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&&_`\n             \
    \   found reference `&isize`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<Skip<Cloned<std::slice::Iter<'_, isize>>>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmp_4secjha.rs:24:57\n   |\n24 |            by_length(arr2.iter().cloned().skip(1).cloned().collect::<Vec<_>>()).iter().for_each(|x|\n\
    \   |                                                            ^^^^^^^ method\
    \ cannot be called on `Cloned<Skip<Cloned<std::slice::Iter<'_, isize>>>>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `<Skip<Cloned<std::slice::Iter<'_, isize>>> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n           `Cloned<Skip<Cloned<std::slice::Iter<'_, isize>>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Skip<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_4secjha.rs:25:25\n\
    \   |\n25 |             arr2.remove(&x));\n   |                         ^^ expected\
    \ `usize`, found `&&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_4secjha.rs:25:13\n\
    \   |\n25 |             arr2.remove(&x));\n   |             ^^^^^^^^^^^^^^^ expected\
    \ `()`, found `isize`\n\nerro"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut new_arr = vec![];\n    for i in arr {\n        if i > 9 && i <= 19\
    \ {\n            let one = \"One\";\n            let two = \"Two\";\n        \
    \    let three = \"Three\";\n            let four = \"Four\";\n            let\
    \ five = \"Five\";\n            let six = \"Six\";\n            let seven = \"\
    Seven\";\n            let eight = \"Eight\";\n            let nine = \"Nine\"\
    ;\n            let ten = \"Ten\";\n            let hundred = \"Hundred\";\n  \
    \          let thousand = \"Thousand\";\n            let thousands = \"Thousands\"\
    ;\n            let million = \"Million\";\n            let millions = \"Millions\"\
    ;\n            let billion = \"Billion\";\n            let billions = \"Billions\"\
    ;\n            let trillion = \"Trillion\";\n            let trillions = \"Trillions\"\
    ;\n            let quadrillion = \"Quadrillion\";\n            let quadrillions\
    \ = \"Quadrillions\";\n            let quintillion = \"Quintillion\";\n      \
    \      let quintillions = \"Quintillions\";\n            let sextillion = \"Sextillion\"\
    ;\n            let sextillions = \"Sextillions\";\n            let septillion\
    \ = \"Septillion\";\n            let septillions = \"Septillions\";\n        \
    \    let octillion = \"Octillion\";\n            let octillions = \"Octillions\"\
    ;\n            let nonillion = \"Nonillion\";\n            let nonillions = \"\
    Nonillions\";\n            let decillion = \"Decillion\";\n            let decillions\
    \ = \"Decillions\";\n            let undecillion = \"Undecillion\";\n        \
    \    let undecillions = \"Undecillions\";\n            let duodecillion = \"Duodecillion\"\
    ;\n            let duodecillions = \"Duodecillions\";\n            let tredecillion\
    \ = \"Tredecillion\";\n            let tredecillions = \"Tredecillions\";\n  \
    \          let quattuordecillion = \"Quattuordecillion\";\n            let quattuordecillions\
    \ = \"Quattuordecillions\";\n            let quindecillion = \"Quindecillion\"\
    ;\n            let quindecillions = \"Quindecillions\";\n            let sexdecillion\
    \ = \"Sexdecillion\";\n            let sexdecillions = \"S\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp7o6zvr5v.rs:77:110\n\
    \   |\n77 |       assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n   |  ______________________________________________________________________________________________________________^\n\
    78 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.clone();\n\n    arr.sort_unstable();\n\
    \    arr.rev();\n    arr.iter().filter_map(|i| {\n        if i % 10 == 0 {\n \
    \           return Some(format!(\"{}\", i));\n        }\n        None\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpwe1cuqpx.rs:21:9\n\
    \    |\n21  |       arr.rev();\n    |           ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let digit = &arr[..i];\n        let digit\
    \ = digit.join(\"\").to_string();\n        let lower = &arr[i..];\n        let\
    \ lower = lower.join(\"\").to_string();\n        let digits: Vec<String> = lower.chars().map{|x|\
    \ x.to_string().unwrap_or(\"0\".to_string())}.collect();\n        res.push(*digit);\n\
    \        for i in 0..digits.len() {\n            let index = digits.index(&digit[i]);\n\
    \            if index > 0 {\n                res.insert(index, \"One\".to_string());\n\
    \            } else {\n                res.push(\"One\".to_string());\n      \
    \      }\n        }\n        i += digits.len();\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `.`, `::`, `;`, `?`, `else`, or an operator,\
    \ found `{`\n  --> /tmp/tmptzk7sgko.rs:25:52\n   |\n25 |         let digits: Vec<String>\
    \ = lower.chars().map{|x| x.to_string().unwrap_or(\"0\".to_string())}.collect();\n\
    \   |                                                    ^ expected one of 7 possible\
    \ tokens\n\nerror[E0599]: the method `join` exists for reference `&[isize]`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmptzk7sgko.rs:22:27\n   |\n\
    22 |         let digit = digit.join(\"\").to_string();\n   |                 \
    \          ^^^^ method cannot be called on `&[isize]` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `[isize]: Join<_>`\n\nerror[E0599]: the method `join` exists for reference\
    \ `&[isize]`, but its trait bounds were not satisfied\n  --> /tmp/tmptzk7sgko.rs:24:27\n\
    \   |\n24 |         let lower = lower.join(\"\").to_string();\n   |          \
    \                 ^^^^ method cannot be called on `&[isize]` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[isize]: Join<_>`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() < 1 || arr.len() > 9 {\n        return vec![];\n\
    \    }\n    if arr.iter().any(|x| x != 1 && x != 8) {\n        return vec![];\n\
    \    }\n    let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    \n   \
    \ if arr.len() > 0 {\n        arr.sort_unstable();\n        arr.reverse();\n \
    \   }\n    \n    if arr.len() > 0 {\n        arr.iter().enumerate().filter_map(|(i,\
    \ x)| {\n            if x < 10 {\n                Some(vec![\"One\".to_string()])\n\
    \            } else if x < 100 {\n                Some(vec![\"Two\".to_string()])\n\
    \            } else if x < 1000 {\n                Some(vec![\"Three\".to_string()])\n\
    \            } else if x < 10000 {\n                Some(vec![\"Four\".to_string()])\n\
    \            } else if x < 100000 {\n                Some(vec![\"Five\".to_string()])\n\
    \            } else if x < 1000000 {\n                Some(vec![\"Six\".to_string()])\n\
    \            } else if x < 10000000 {\n                Some(vec![\"Seven\".to_string()])\n\
    \            } else if x < 100000000 {\n                Some(vec![\"Eight\".to_string()])\n\
    \            } else if x < 1000000000 {\n                Some(vec![\"Nine\".to_string()])\n\
    \            } else {\n                None\n            }\n        }).collect()\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6xdf8165.rs:21:29\n\
    \   |\n21 |     if arr.iter().any(|x| x != 1 && x != 8) {\n   |              \
    \               ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6xdf8165.rs:21:39\n\
    \   |\n21 |     if arr.iter().any(|x| x != 1 && x != 8) {\n   |              \
    \                         ^^ no implementation for `&isize == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xdf8165.rs:33:20\n\
    \   |\n33 |             if x < 10 {\n   |                    ^^\n   |        \
    \            |\n   |                    expected `&isize`, found integer\n   |\
    \                    help: consider borrowing here: `&10`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6xdf8165.rs:35:27\n   |\n35 |             } else if x <\
    \ 100 {\n   |                           ^^^\n   |                           |\n\
    \   |                           expected `&isize`, found integer\n   |       \
    \                    help: consider borrowing here: `&100`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6xdf8165.rs:37:27\n   |\n37 |             } else if x <\
    \ 1000 {\n   |                           ^^^^\n   |                          \
    \ |\n   |                           expected `&isize`, found integer\n   |   \
    \                        help: consider borrowing here: `&1000`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6xdf8165.rs:39:27\n   |\n39 |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut len = arr.len();\n    let mut arr = arr.clone();\n    let mut num_arr:\
    \ Vec<isize> = arr.iter().cloned().collect();\n    let mut i = 0;\n\n    while\
    \ i < len {\n        if num_arr[i] > 9 {\n            len = len - 1;\n       \
    \     num_arr = num_arr.iter().cloned().skip(i).collect();\n            i += len\
    \ - 1;\n        }\n        else if num_arr[i] > 0 {\n            len = len - 1;\n\
    \            num_arr = num_arr.iter().cloned().skip(i).collect();\n          \
    \  i += len - 1;\n        }\n        i += 1;\n    }\n\n    let mut arr2 = num_arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut j = 0;\n    while j + 1 < len {\n        let min_index = arr[j].iter().cloned().min().unwrap();\n\
    \        let min_index = arr2[j].iter().cloned().min().unwrap();\n        if min_index\
    \ < arr[j + 1] {\n            swap(&mut arr[j], &mut arr[j + 1]);\n          \
    \  swap(&mut arr2[j], &mut arr2[j + 1]);\n        }\n        j += 2;\n    }\n\n\
    \    arr2.iter().cloned().collect::<Vec<String>>()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpm40jx38q.rs:47:13\n\
    \   |\n47 |             swap(&mut arr[j], &mut arr[j + 1]);\n   |            \
    \ ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find function `swap` in this scope\n  --> /tmp/tmpm40jx38q.rs:48:13\n\
    \   |\n48 |             swap(&mut arr2[j], &mut arr2[j + 1]);\n   |          \
    \   ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpm40jx38q.rs:44:32\n   |\n44 |         let min_index = arr[j].iter().cloned().min().unwrap();\n\
    \   |                                ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmpm40jx38q.rs:45:33\n\
    \   |\n45 |         let min_index = arr2[j].iter().cloned().min().unwrap();\n\
    \   |                                 ^^^^ method not found in `isize`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `isize`\n    --> /tmp/tmpm40jx38q.rs:53:26\n     |\n53   |     arr2.iter().cloned().collect::<Vec<String>>()\n\
    \     |                          ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait\
    \ `FromIterator<isize>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut s = String::new();\n    s.push('\\0');\n    arr.sort_by(|a,\
    \ b| a.cmp(b));\n    let mut len = 1;\n    for v in arr {\n        let s = format!(\"\
    {:?}\", v);\n        if s.len() > len {\n            len = s.len();\n        }\n\
    \        for _ in s.chars().skip(len) {\n            s.clear();\n        }\n \
    \       s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight, Nine][v]);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `One` in this scope\n  --> /tmp/tmpdulhqhy2.rs:30:24\n\
    \   |\n30 |         s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight,\
    \ Nine][v]);\n   |                        ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `Two` in this scope\n  --> /tmp/tmpdulhqhy2.rs:30:29\n   |\n\
    30 |         s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight, Nine][v]);\n\
    \   |                             ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `Three` in this scope\n  --> /tmp/tmpdulhqhy2.rs:30:34\n \
    \  |\n30 |         s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight,\
    \ Nine][v]);\n   |                                  ^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `Four` in this scope\n  --> /tmp/tmpdulhqhy2.rs:30:41\n\
    \   |\n30 |         s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight,\
    \ Nine][v]);\n   |                                         ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `Five` in this scope\n  --> /tmp/tmpdulhqhy2.rs:30:47\n\
    \   |\n30 |         s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight,\
    \ Nine][v]);\n   |                                               ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `Six` in this scope\n  -->\
    \ /tmp/tmpdulhqhy2.rs:30:53\n   |\n30 |         s.append(&mut [One, Two, Three,\
    \ Four, Five, Six, Seven, Eight, Nine][v]);\n   |                            \
    \                         ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `Seven` in this scope\n  --> /tmp/tmpdulhqhy2.rs:30:58\n   |\n30\
    \ |         s.append(&mut [One, Two, Three, Four, Five, Six, Seven, Eight, Nine][v]);\n\
    \   |                                                          ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `Eight` in this scope\n  -->\
    \ /tmp/tmpdulhqhy2.rs:30:65\n   |\n30 |         s.append(&mut [One, Two, Three,\
    \ Four, Five, Six, Seven, Eight, Nine][v]);\n   |                            \
    \                                     ^^^^^ not found in this scope\n\nerror[E04"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut ret: Vec<String> = Vec::new();\n    let mut i = 1;\n    loop {\n\
    \        if arr[i] == 1 {\n            ret.push(\"One\");\n        } else {\n\
    \            if ret.is_empty() {\n                ret.push(\"One\");\n       \
    \         ret.push(\"Two\");\n                ret.push(\"Three\");\n         \
    \       ret.push(\"Four\");\n                ret.push(\"Five\");\n           \
    \     ret.push(\"Six\");\n                ret.push(\"Seven\");\n             \
    \   ret.push(\"Eight\");\n                ret.push(\"Nine\");\n              \
    \  ret.push(\"Ten\");\n                ret.push(\"Eleven\");\n               \
    \ ret.push(\"Twelve\");\n                ret.push(\"Thirteen\");\n           \
    \     ret.push(\"Fourteen\");\n                ret.push(\"Fifteen\");\n      \
    \          ret.push(\"Sixteen\");\n                ret.push(\"Seventeen\");\n\
    \                ret.push(\"Eighteen\");\n                ret.push(\"Nineteen\"\
    );\n                ret.push(\"Twenty\");\n                ret.push(\"Twenty one\"\
    );\n                ret.push(\"Twenty two\");\n                ret.push(\"Twenty\
    \ three\");\n                ret.push(\"Twenty four\");\n                ret.push(\"\
    Twenty five\");\n                ret.push(\"Twenty six\");\n                ret.push(\"\
    Twenty seven\");\n                ret.push(\"Twenty eight\");\n              \
    \  ret.push(\"Twenty nine\");\n                ret.push(\"Thirty\");\n       \
    \         ret.push(\"Thirty one\");\n                ret.push(\"Thirty two\");\n\
    \                ret.push(\"Thirty three\");\n                ret.push(\"Thirty\
    \ four\");\n                ret.push(\"Thirty five\");\n                ret.push(\"\
    Thirty six\");\n                ret.push(\"Thirty seven\");\n                ret.push(\"\
    Thirty eight\");\n                ret.push(\"Thirty nine\");\n               \
    \ ret.push(\"Forty\");\n                ret.push(\"Forty one\");\n           \
    \     ret.push(\"Forty two\");\n                ret.push(\"Forty three\");\n \
    \               ret.push(\"Forty four\");\n                ret.push(\"Forty five\"\
    );\n                ret.push(\"Forty six\");\n                ret.push(\"Forty\
    \ seven\");\n                ret.push(\"Forty eight\");\n                ret.push(\"\
    Forty nine\");\n                ret.push(\"Fifty\");\n                ret.\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgt1orwgr.rs:88:3\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n23 |     loop {\n\
    \   |          - unclosed delimiter\n...\n26 |         } else {\n   |        \
    \        - unclosed delimiter\n27 |             if ret.is_empty() {\n   |    \
    \                           - this delimiter might not be properly closed...\n\
    ...\n79 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    88 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpgt1orwgr.rs:79:1\n\
    \   |\n79 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgt1orwgr.rs:25:22\n\
    \   |\n25 |             ret.push(\"One\");\n   |                      ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                      |\n\
    \   |                      expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgt1orwgr.rs:28:26\n   |\n28 |              \
    \   ret.push(\"One\");\n   |                          ^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                          |\n   |   \
    \                       expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgt1orwgr.rs:29:26\n   |\n29 |              \
    \   ret.push(\"Two\");\n   |                          ^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                          |\n   |   \
    \                       expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgt1orwgr.rs:30:26\n   |\n30 |              \
    \   ret.push(\"Three\");\n   |                          ^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                          |\n   | \
    \                         expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgt1orwgr.rs:31:26\n   |\n31 |              \
    \   ret.push(\"Four\");\n   |                          ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                          |\n   | \
    \              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut digits = vec![];\n    for x in arr.iter() {\n        if 1 <= x &&\
    \ x <= 9 {\n            digits.push(format!(\"{}\", x));\n        }\n    }\n \
    \   if digits.len() == 0 {\n        return vec![];\n    }\n    let mut arr_size\
    \ = arr.len();\n    let mut reverse_digits = vec![];\n    for i in digits.iter().rev()\
    \ {\n        arr_size = arr_size.divmod_mul(10).0;\n        let digit = i as usize;\n\
    \        reverse_digits.push(&name_to_digit[&names[arr_size]][digit].to_string());\n\
    \    }\n    reverse_digits.reverse();\n    digits.extend(reverse_digits);\n  \
    \  digits\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `name_to_digit` in this scope\n  --> /tmp/tmpibs1rijn.rs:35:30\n\
    \   |\n35 |         reverse_digits.push(&name_to_digit[&names[arr_size]][digit].to_string());\n\
    \   |                              ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `names` in this scope\n  --> /tmp/tmpibs1rijn.rs:35:45\n \
    \  |\n35 |         reverse_digits.push(&name_to_digit[&names[arr_size]][digit].to_string());\n\
    \   |                                             ^^^^^ not found in this scope\n\
    \nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpibs1rijn.rs:23:14\n\
    \   |\n23 |         if 1 <= x && x <= 9 {\n   |              ^^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpibs1rijn.rs:23:27\n   |\n23 |         if 1 <= x && x <= 9 {\n   |  \
    \                         ^\n   |                           |\n   |          \
    \                 expected `&isize`, found integer\n   |                     \
    \      help: consider borrowing here: `&9`\n\nerror[E0599]: no method named `divmod_mul`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpibs1rijn.rs:33:29\n\
    \   |\n33 |         arr_size = arr_size.divmod_mul(10).0;\n   |              \
    \               ^^^^^^^^^^ method not found in `usize`\n\nerror[E0606]: casting\
    \ `&String` as `usize` is invalid\n  --> /tmp/tmpibs1rijn.rs:34:21\n   |\n34 |\
    \         let digit = i as usize;\n   |                     ^^^^^^^^^^\n   |\n\
    \   = help: cast through a raw pointer first\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599,\
    \ E0606.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \n    let mut n = arr[0];\n    let mut arr = arr.iter().map(|x| {\n        let\
    \ mut s = String::new();\n        s.push_str(&to_string(x));\n        s.push_str(\"\
    \ \");\n        s\n    }).collect();\n\n    while n <= 9 {\n        let mut tmp\
    \ = Vec::new();\n        for y in arr.iter_mut() {\n            if y <= 9 {\n\
    \                y.push(n - 1);\n            }\n        }\n        arr = tmp.into_iter().collect();\n\
    \        n += 1;\n    }\n\n    let mut tmp = Vec::new();\n    for y in arr.iter_mut()\
    \ {\n        y.push(String::from(format!(\"{}\", n)));\n    }\n    arr = tmp.into_iter().collect();\n\
    \    arr.sort();\n    let mut arr2 = arr.clone();\n    let mut new_arr = Vec::new();\n\
    \    let mut i = 0;\n    for x in arr2 {\n        let mut s = String::new();\n\
    \        s.push_str(&to_string(x));\n        s.push_str(\" \");\n        new_arr[i]\
    \ = s;\n        i += 1;\n    }\n    new_arr.sort();\n    return new_arr\n    \
    \    .into_iter()\n        .map(|s| s.trim_left_matches(' '))\n        .collect();\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpzz__9vi2.rs:25:21\n\
    \   |\n25 |         s.push_str(&to_string(x));\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in\
    \ this scope\n  --> /tmp/tmpzz__9vi2.rs:52:21\n   |\n52 |         s.push_str(&to_string(x));\n\
    \   |                     ^^^^^^^^^ not found in this scope\n\nwarning: use of\
    \ deprecated associated function `core::str::<impl str>::trim_left_matches`: superseded\
    \ by `trim_start_matches`\n  --> /tmp/tmpzz__9vi2.rs:60:20\n   |\n60 |       \
    \  .map(|s| s.trim_left_matches(' '))\n   |                    ^^^^^^^^^^^^^^^^^\
    \ help: replace the use of the deprecated associated function: `trim_start_matches`\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: a value\
    \ of type `Vec<String>` cannot be built from an iterator over elements of type\
    \ `&str`\n    --> /tmp/tmpzz__9vi2.rs:61:10\n     |\n61   |         .collect();\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    for i in\
    \ arr {\n        if i > 0 && i <= 9 {\n            result.push(\"One\".to_string());\n\
    \        } else if i >= 1 && i <= 3 {\n            result.push(\"Two\".to_string());\n\
    \        } else if i >= 4 && i <= 5 {\n            result.push(\"Three\".to_string());\n\
    \        } else if i >= 6 && i <= 8 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i >= 9 && i <= 10 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i >= 11 && i <= 12 {\n            result.push(\"Six\".to_string());\n\
    \        } else if i >= 13 && i <= 14 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i >= 15 && i <= 16 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i >= 17 && i <= 18 {\n            result.push(\"Nine\".to_string());\n\
    \        } else if i >= 19 && i <= 20 {\n            result.push(\"Ten\".to_string());\n\
    \        } else {\n            continue;\n        }\n    }\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpoqnxpwfv.rs:50:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut len = arr.len();\n    if len == 0 {\n        return\
    \ vec![];\n    }\n\n    let mut min_value = arr[0];\n    let mut max_value = arr[0];\n\
    \    for i in 1..len {\n        min_value = min_value.min(arr[i]);\n        max_value\
    \ = max_value.max(arr[i]);\n    }\n\n    let mut result: Vec<String> = vec![];\n\
    \    for i in 0..len {\n        let value = min_value.min(max_value);\n      \
    \  result.push(format!(\"{}\", value));\n    }\n\n    result.sort_by_key(|v| v);\n\
    \    for i in 0..len {\n        result[i] = String::from(arr[i]);\n    }\n\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmpm7xz3bl6.rs:38:21\n   |\n38 |         result[i] = String::from(arr[i]);\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let mut list = arr.iter().cloned().collect::<Vec<_>>();\n    list.sort_by(|a,\
    \ b| a.cmp(b));\n    list.reverse();\n\n    let mut list = list.into_iter();\n\
    \    list.take_while(|&i| i != 1 || i != 9).map(|&i| {\n        i as i32 + 10.to_string().chars().next().unwrap()\n\
    \    });\n\n    list\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvfcst36_.rs:27:49\n   |\n\
    27 |     list.take_while(|&i| i != 1 || i != 9).map(|&i| {\n   |             \
    \                                    ^--\n   |                               \
    \                  ||\n   |                                                 |expected\
    \ due to this\n   |                                                 expected `isize`,\
    \ found reference\n   |                                                 help:\
    \ did you mean `i`: `&isize`\n   |\n   = note:   expected type `isize`\n     \
    \      found reference `&_`\n\nerror[E0277]: cannot add `char` to `i32`\n  -->\
    \ /tmp/tmpvfcst36_.rs:28:18\n   |\n28 |         i as i32 + 10.to_string().chars().next().unwrap()\n\
    \   |                  ^ no implementation for `i32 + char`\n   |\n   = help:\
    \ the trait `Add<char>` is not implemented for `i32`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvfcst36_.rs:31:5\n   |\n17 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n31 |     list\n   |     ^^^^ expected\
    \ struct `Vec`, found struct `std::vec::IntoIter`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `std::vec::IntoIter<isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut cur = 1;\n \
    \   let mut first = true;\n    while arr.len() > 0 {\n        let mut digit =\
    \ 0;\n        let mut index = arr.len() - 1;\n        while index >= 0 {\n   \
    \         let digit = *arr[index--];\n            if digit < cur {\n         \
    \       break;\n            } else if digit == cur {\n                result.push(\"\
    One\");\n                break;\n            } else if digit > cur {\n       \
    \         break;\n            }\n            digit = cur;\n            cur /=\
    \ 10;\n        }\n        if index == 0 {\n            if first {\n          \
    \      result.push(\"Zero\");\n            }\n            first = false;\n   \
    \     } else {\n            result.push(\"Two\");\n        }\n        cur *= 10;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `]`\n  --> /tmp/tmpgu0i0377.rs:25:37\n\
    \   |\n25 |             let digit = *arr[index--];\n   |                     \
    \                ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgu0i0377.rs:47:5\n   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n47 |     result\n   |     ^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // use arr.len() instead of arr to avoid the cost of .len()\n\
    \    let mut len = 0;\n    let mut s = \"\".to_string();\n\n    for i in arr.iter()\
    \ {\n        let leni = i.len();\n        len += leni;\n        s += &format!(\"\
    {}\", i);\n    }\n\n    let mut res = vec![];\n    res.sort_unstable_by(|a, b|\
    \ a.partial_cmp(&b));\n    res.reverse();\n\n    for i in res {\n        if len\
    \ > 9 {\n            break;\n        }\n        let mut d = len.to_string();\n\
    \        let mut c = i.toString();\n        for j in c.chars() {\n           \
    \ if j > '0' && j < '9' {\n                d += &format!(\"{}\", j);\n       \
    \     }\n        }\n        res.push(&d);\n    }\n\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpq7jbsusj.rs:23:22\n   |\n23 |         let leni\
    \ = i.len();\n   |                      ^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut len = arr.len();\n    if len < 10 {\n        return\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"].iter().cloned().collect();\n    }\n    let mut res = vec![\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"];\n    let mut start = 1;\n    while start < len {\n        let end\
    \ = std::cmp::min(len - start, 10);\n        res.swap(start, start+end);\n   \
    \     start += end;\n    }\n    let mut reverse = res.clone();\n    itertools::reverse(&mut\
    \ reverse);\n    match reverse {\n        vec![_] => vec![],\n        arr => arr.iter().cloned().collect(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: no rules expected the token `_`\n  --> /tmp/tmpp4alh1yd.rs:32:14\n\
    \   |\n32 |         vec![_] => vec![],\n   |              ^ no rules expected\
    \ this token in macro call\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `itertools`\n  --> /tmp/tmpp4alh1yd.rs:30:5\n   |\n30 |    \
    \ itertools::reverse(&mut reverse);\n   |     ^^^^^^^^^ use of undeclared crate\
    \ or module `itertools`\n\nerror[E0277]: a value of type `Vec<String>` cannot\
    \ be built from an iterator over elements of type `&str`\n    --> /tmp/tmpp4alh1yd.rs:20:109\n\
    \     |\n20   |         return vec![\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"].iter().cloned().collect();\n\
    \     |                                                                      \
    \                                       ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&str`\n    --> /tmp/tmpp4alh1yd.rs:33:36\n\
    \     |\n33   |         arr => arr.iter().cloned().collect(),\n     |        \
    \                            ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        vec![]\n    } else {\n  \
    \      let mut reversed = arr\n        .iter()\n        .cloned()\n        .rev()\n\
    \        .cloned()\n        .rev()\n        .map(|i| {\n            match i {\n\
    \                i if i as usize < 10 => \"One\".to_string(),\n              \
    \  i if i as usize >= 10 => \"Two\".to_string(),\n                i if i as usize\
    \ >= 20 => \"Three\".to_string(),\n                i if i as usize >= 30 => \"\
    Four\".to_string(),\n                i if i as usize >= 40 => \"Five\".to_string(),\n\
    \                i if i as usize >= 50 => \"Six\".to_string(),\n             \
    \   i if i as usize >= 60 => \"Seven\".to_string(),\n                i if i as\
    \ usize >= 70 => \"Eight\".to_string(),\n                i if i as usize >= 80\
    \ => \"Nine\".to_string(),\n                _ => panic!(\"unexpected number {:?}\"\
    , i),\n            }\n        })\n        .collect::<Vec<_>>();\n        reversed.push(arr.iter().cloned().last().unwrap());\n\
    \        reversed\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: `<` is interpreted as a start of generic arguments for `usize`,\
    \ not a comparison\n  --> /tmp/tmpw2qxc703.rs:29:33\n   |\n29 |              \
    \   i if i as usize < 10 => \"One\".to_string(),\n   |                       \
    \          ^ ----- interpreted as generic arguments\n   |                    \
    \             |\n   |                                 not interpreted as comparison\n\
    \   |\nhelp: try comparing the cast value\n   |\n29 |                 i if (i\
    \ as usize) < 10 => \"One\".to_string(),\n   |                      +        \
    \  +\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmpw2qxc703.rs:25:10\n     |\n25   | \
    \        .cloned()\n     |          ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `rev` exists for struct `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpw2qxc703.rs:26:10\n\
    \   |\n26 |           .rev()\n   |            ^^^ method cannot be called on `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Rev<Cloned<std::slice::Iter<'_, isize>>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n           `Cloned<Rev<Cloned<std::slice::Iter<'_, isize>>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.clone();\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|n| num_name(n as usize)).collect()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_name` in this scope\n  --> /tmp/tmpil7j9nas.rs:21:24\n\
    \   |\n21 |     arr.iter().map(|n| num_name(n as usize)).collect()\n   |     \
    \                   ^^^^^^^^ not found in this scope\n\nerror[E0606]: casting\
    \ `&isize` as `usize` is invalid\n  --> /tmp/tmpil7j9nas.rs:21:33\n   |\n21 |\
    \     arr.iter().map(|n| num_name(n as usize)).collect()\n   |               \
    \                  -^^^^^^^^^\n   |                                 |\n   |  \
    \                               cannot cast `&isize` as `usize`\n   |        \
    \                         help: dereference the expression: `*n`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut result = vec![];\n    for i in arr.iter().rev() {\n        if i !=\
    \ 1 && i != 9 {\n            result.push(\"Nine\".to_string());\n        }\n \
    \       result.push(\"Eight\".to_string());\n        if i != 2 && i != 8 {\n \
    \           result.push(\"Seven\".to_string());\n        }\n        if i != 3\
    \ && i != 7 {\n            result.push(\"Six\".to_string());\n        }\n    \
    \    if i != 4 && i != 6 {\n            result.push(\"Five\".to_string());\n \
    \       }\n        if i != 5 && i != 4 {\n            result.push(\"Four\".to_string());\n\
    \        }\n        if i != 6 && i != 5 {\n            result.push(\"Three\".to_string());\n\
    \        }\n        if i != 7 && i != 6 {\n            result.push(\"Two\".to_string());\n\
    \        }\n        if i != 1 && i != 9 {\n            result.push(\"One\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp798xtv3t.rs:23:14\n\
    \   |\n23 |         if i != 1 && i != 9 {\n   |              ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp798xtv3t.rs:23:24\n   |\n23 |         if i !=\
    \ 1 && i != 9 {\n   |                        ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp798xtv3t.rs:27:14\n   |\n27 |         if i != 2 && i != 8 {\n \
    \  |              ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp798xtv3t.rs:27:24\n\
    \   |\n27 |         if i != 2 && i != 8 {\n   |                        ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerro"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr\n        .into_iter()\n        .map(|&i|\
    \ i.to_string())\n        .collect::<Vec<String>>();\n\n    arr.sort_by_key(|i|\
    \ {\n        if i.to_string().parse::<isize>() == i.to_string() {\n          \
    \  i\n        } else {\n            i\n                .to_string()\n        \
    \        .parse()\n                .unwrap()\n                .parse::<isize>()\n\
    \                .unwrap()\n        }\n    });\n\n    arr.reverse_iter().for_each(|&i|\
    \ {\n        let value = i.to_string();\n        arr.insert(arr.iter().position(|&j|\
    \ j.to_string() == value).unwrap(), &to_name(i));\n    });\n\n    arr\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_name` in this scope\n  --> /tmp/tmphk128z0z.rs:38:80\n\
    \   |\n38 |         arr.insert(arr.iter().position(|&j| j.to_string() == value).unwrap(),\
    \ &to_name(i));\n   |                                                        \
    \                        ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphk128z0z.rs:20:15\n   |\n20 |         .map(|&i| i.to_string())\n\
    \   |               ^--\n   |               ||\n   |               |expected due\
    \ to this\n   |               expected `isize`, found reference\n   |        \
    \       help: did you mean `i`: `&isize`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphk128z0z.rs:24:46\n\
    \   |\n24 |         if i.to_string().parse::<isize>() == i.to_string() {\n   |\
    \                                              ^^^^^^^^^^^^^ expected enum `Result`,\
    \ found struct `String`\n   |\n   = note: expected enum `Result<isize, ParseIntError>`\n\
    \            found struct `String`\n\nerror[E0599]: no method named `reverse_iter`\
    \ found for struct `Vec<String>` in the current scope\n  --> /tmp/tmphk128z0z.rs:36:9\n\
    \   |\n36 |     arr.reverse_iter().for_each(|&i| {\n   |         ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `reverse`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // empty array\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n\n    // array has strange number\n    let mut lens = vec![];\n\
    \    for d in arr {\n        lens.insert(d, lens.iter().position(|&x| x > d).unwrap());\n\
    \    }\n\n    // sort arr\n    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort();\n\
    \n    // reverse arr\n    sorted_arr.reverse();\n\n    // get position of each\
    \ digit\n    let mut positions = vec![];\n    for d in sorted_arr {\n        positions.insert(d,\
    \ lens.iter().position(|&x| x == d).unwrap());\n    }\n\n    let mut result =\
    \ vec![];\n    for d in positions.iter() {\n        let len_idx = lens.iter().position(|&x|\
    \ x == d).unwrap();\n        result.push(&arr[len_idx]);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpscdoxx8b.rs:26:21\n   |\n\
    26 |         lens.insert(d, lens.iter().position(|&x| x > d).unwrap());\n   |\
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    26 |         lens.insert(d.try_into().unwrap(), lens.iter().position(|&x| x >\
    \ d).unwrap());\n   |                      ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `usize` with `isize`\n  --> /tmp/tmpscdoxx8b.rs:26:52\n   |\n\
    26 |         lens.insert(d, lens.iter().position(|&x| x > d).unwrap());\n   |\
    \                                                    ^ no implementation for `usize\
    \ < isize` and `usize > isize`\n   |\n   = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpscdoxx8b.rs:39:26\n   |\n39 |         positions.insert(d, lens.iter().position(|&x|\
    \ x == d).unwrap());\n   |                          ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n39 |         positions.insert(d.try_into().unwrap(),\
    \ lens.iter().position(|&x| x == d).unwrap());\n   |                         \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpscdoxx8b.rs:39:60\n\
    \   |\n39 |         positions.insert(d, lens.iter().position(|&x| x == d).unwrap());\n\
    \   |                                                            ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n39 |         positions.insert(d, lens.iter().position(|&x|\
    \ x == d.try_into().unwrap()).unwrap());\n   |                               \
    \                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut sorted_arr = arr;\n    let mut reversed_arr = vec![];\n    while sorted_arr.len()\
    \ > 0 {\n        let mut first_num = sorted_arr.pop();\n        let mut first_digit\
    \ = first_num % 10;\n        reversed_arr.push((first_digit as i32) - 1 + (*by_digits[first_digit\
    \ as usize]) as isize);\n        sorted_arr.sort_unstable_by_key(|v| v as isize);\n\
    \    }\n    reversed_arr.iter().map(|&d| by_digits[d as usize]).collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `by_digits` in this scope\n  --> /tmp/tmpokl3bd9d.rs:26:56\n\
    \   |\n26 |         reversed_arr.push((first_digit as i32) - 1 + (*by_digits[first_digit\
    \ as usize]) as isize);\n   |                                                \
    \        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `by_digits` in this scope\n  --> /tmp/tmpokl3bd9d.rs:29:34\n   |\n29 |     reversed_arr.iter().map(|&d|\
    \ by_digits[d as usize]).collect()\n   |                                  ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0369]: cannot mod `Option<isize>` by `{integer}`\n\
    \  --> /tmp/tmpokl3bd9d.rs:25:41\n   |\n25 |         let mut first_digit = first_num\
    \ % 10;\n   |                               --------- ^ -- {integer}\n   |   \
    \                            |\n   |                               Option<isize>\n\
    \nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpokl3bd9d.rs:27:45\n\
    \   |\n27 |         sorted_arr.sort_unstable_by_key(|v| v as isize);\n   |   \
    \                                          -^^^^^^^^^\n   |                  \
    \                           |\n   |                                          \
    \   cannot cast `&isize` as `isize`\n   |                                    \
    \         help: dereference the expression: `*v`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0425, E0606.\nFor\
    \ more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut s = String::new();\n    if arr.is_empty() {\n\
    \        return vec![];\n    }\n    if arr.len() <= 9 {\n        for i in arr\
    \ {\n            if i <= 9 {\n                s.push_str(&format!(\"One\"));\n\
    \            }\n            s.push_str(&format!(\"{}\", i));\n        }\n    }\
    \ else {\n        let mut tmp: Vec<String> = vec![];\n        for i in arr {\n\
    \            if i <= 9 {\n                tmp.push(format!(\"One\"));\n      \
    \      }\n            tmp.push(format!(\"{}\", i));\n        }\n        tmp.sort_unstable();\n\
    \        for i in tmp {\n            s.push_str(&i);\n        }\n    }\n    s.reverse();\n\
    \    s.to_string()\n        .chars()\n        .filter(|x| *x == 0)\n        .filter(|x|\
    \ *x != 9)\n        .cloned()\n        .filter(|x| *x == 9)\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .map(|x| *x)\n        .cloned()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptzhlsc57.rs:42:7\n   |\n42 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptzhlsc57.rs:45:27\n\
    \   |\n45 |         .filter(|x| *x == 0)\n   |                           ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptzhlsc57.rs:46:27\n\
    \   |\n46 |         .filter(|x| *x != 9)\n   |                           ^ expected\
    \ `char`, found `u8`\n\nerror[E0271]: type mismatch resolving `<Filter<Filter<Chars<'_>,\
    \ [closure@/tmp/tmptzhlsc57.rs:45:17: 45:28]>, [closure@/tmp/tmptzhlsc57.rs:46:17:\
    \ 46:28]> as Iterator>::Item == &_`\n    --> /tmp/tmptzhlsc57.rs:47:10\n     |\n\
    47   |         .cloned()\n     |          ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `filter`\
    \ exists for struct `Cloned<Filter<Filter<Chars<'_>, [closure@/tmp/tmptzhlsc57.rs:45:17:\
    \ 45:28]>, [closure@/tmp/tmptzhlsc57.rs:46:17: 46:28]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmptzhlsc57.rs:48:10\n   |\n48 |            .filter(|x|\
    \ *x == 9)\n   |             ^^^^^^ method cannot be called on `Cloned<Filter<Filter<Chars<'_>,\
    \ [closure@/tmp/tmptzhlsc57.rs:45:17: 45:28]>, [closure@/tmp/tmptzhlsc57.rs:46:17:\
    \ 46:28]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Filter<Filter<Chars<'_>, [closure@/tmp/tmptzhlsc57.rs:45:17:\
    \ 45:28]>, [closure@/tmp/tmptzhlsc57.rs:46:17: 46:28]> as Iterator>::Item = &_`\n\
    \           which is required by `Cloned<Filter<Filter<Chars<'_>, [closure@/tmp/tmptzhlsc57.rs:45:17:\
    \ 45:28]>, [closure@/tmp/tmptzhlsc57.rs:46:17: 46:28]>>: Iterator`\n         \
    \  `Cloned<Filter<Filter<Chars<'_>, [closure@/tmp/tmptzhlsc57.rs:45:17: 45:28]>,\
    \ [closure@/tmp/tmptzhlsc57.rs:46:17: 46:28]>>: Iterator`\n           which is\
    \ required by `&mut "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n\n\
    \    if arr.len() > 9 {\n        return vec![String::from(\"Nine\")];\n    }\n\
    \n    let mut new_arr = Vec::new();\n    for val in arr {\n        let mut new_val\
    \ = val as usize;\n        match val % 10 {\n            1 => new_val -= 1,\n\
    \            2 => new_val -= 2,\n            3 => new_val -= 3,\n            4\
    \ => new_val -= 4,\n            5 => new_val -= 5,\n            6 => new_val -=\
    \ 6,\n            7 => new_val -= 7,\n            8 => new_val -= 8,\n       \
    \     9 => new_val -= 9,\n            x => return vec![],\n        }\n       \
    \ new_arr.push(String::from(\n            &match new_val {\n                0\
    \ => \"One\",\n                1 => \"Two\",\n                2 => \"Three\",\n\
    \                3 => \"Four\",\n                4 => \"Five\",\n            \
    \    5 => \"Six\",\n                6 => \"Seven\",\n                7 => \"Eight\"\
    ,\n                8 => \"Nine\",\n                _ => \"\",\n            },\n\
    \        ));\n    }\n    new_arr.reverse();\n    new_arr\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: From<&&str>` is not satisfied\n\
    \  --> /tmp/tmppz9n80cm.rs:41:22\n   |\n41 |         new_arr.push(String::from(\n\
    \   |                      ^^^^^^^^^^^^ the trait `From<&&str>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n    let mut num_array:\
    \ Vec<_> = arr.into_iter().cloned().collect();\n    num_array.sort();\n    num_array.reverse();\n\
    \    let mut num_array2 = num_array.clone();\n    let mut res = vec![];\n    for\
    \ i in num_array2.iter() {\n        match i {\n            i if i <= 9 => {\n\
    \                let x = i - 1;\n                let y = i % 10;\n           \
    \     let z = y % 10;\n                let i = i + y;\n                let c =\
    \ i / 10;\n                let g = i % 10;\n                let h = g / 10;\n\
    \                let m = i % 10;\n                let k = m / 10;\n          \
    \      let b = i % 10;\n                let a = i / 10;\n                res.push(format!(\"\
    {}{}{}{}\", a, b, c, d));\n            }\n            i if i <= 99 => {\n    \
    \            let x = i - 100;\n                let y = i % 100;\n            \
    \    let z = y % 100;\n                let i = i + y;\n                let c =\
    \ i / 100;\n                let g = i % 100;\n                let h = g / 100;\n\
    \                let m = i % 100;\n                let k = m / 100;\n        \
    \        let b = i % 100;\n                let a = i / 100;\n                res.push(format!(\"\
    {}{}{}{}\", a, b, c, d));\n            }\n            _ => {\n               \
    \ res.push(\"Other\");\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `d` in this scope\n  --> /tmp/tmp4krb9hvc.rs:38:55\n\
    \   |\n38 |                 res.push(format!(\"{}{}{}{}\", a, b, c, d));\n   |\
    \                                                       ^ help: a local variable\
    \ with a similar name exists: `a`\n\nerror[E0425]: cannot find value `d` in this\
    \ scope\n  --> /tmp/tmp4krb9hvc.rs:52:55\n   |\n52 |                 res.push(format!(\"\
    {}{}{}{}\", a, b, c, d));\n   |                                              \
    \         ^ help: a local variable with a similar name exists: `a`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmp4krb9hvc.rs:19:49\n     |\n19   |     let mut num_array: Vec<_>\
    \ = arr.into_iter().cloned().collect();\n     |                              \
    \                   ^^^^^^ expected reference, found `isize`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `isize`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp4krb9hvc.rs:19:58\n   |\n19 |       let mut num_array: Vec<_> =\
    \ arr.into_iter().cloned().collect();\n   |                                  \
    \                          ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror[E0277]:\
    \ can't compare `&_` with `{integer}`\n  --> /tmp/tmp4krb9hvc.rs:26:20\n   |\n\
    26 |             i if i <= 9 => {\n   |                    ^^ no implementation\
    \ for `&_ < {integer}` and `&_ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `&_`\n\nerror[E0277]: can't compare `&_` with `{int"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![]; }\n    let mut vec\
    \ = Vec::new();\n    for n in arr {\n        let lower = n - 1;\n        let upper\
    \ = n + 1;\n        if lower <= 9 {\n            for x in 0..=lower {\n      \
    \          vec.push(format!(\"One\", x));\n            }\n        }\n        if\
    \ upper >= 0 {\n            for x in 0..=upper {\n                vec.push(format!(\"\
    One\", x));\n            }\n        }\n        if upper <= 9 {\n            for\
    \ x in 0..=upper {\n                vec.push(format!(\"Two\", x));\n         \
    \   }\n        }\n        if upper >= 0 {\n            for x in 0..=upper {\n\
    \                vec.push(format!(\"Two\", x));\n            }\n        }\n  \
    \      if upper <= 9 {\n            for x in 0..=upper {\n                vec.push(format!(\"\
    Three\", x));\n            }\n        }\n        if upper >= 0 {\n           \
    \ for x in 0..=upper {\n                vec.push(format!(\"Three\", x));\n   \
    \         }\n        }\n        if upper <= 9 {\n            for x in 0..=upper\
    \ {\n                vec.push(format!(\"Four\", x));\n            }\n        }\n\
    \        if upper >= 0 {\n            for x in 0..=upper {\n                vec.push(format!(\"\
    Four\", x));\n            }\n        }\n        if upper <= 9 {\n            for\
    \ x in 0..=upper {\n                vec.push(format!(\"Five\", x));\n        \
    \    }\n        }\n        if upper >= 0 {\n            for x in 0..=upper {\n\
    \                vec.push(format!(\"Five\", x));\n            }\n        }\n \
    \       if upper <= 9 {\n            for x in 0..=upper {\n                vec.push(format!(\"\
    Six\", x));\n            }\n        }\n        if upper >= 0 {\n            for\
    \ x in 0..=upper {\n                vec.push(format!(\"Six\", x));\n         \
    \   }\n        }\n        if upper <= 9 {\n            for x in 0..=upper {\n\
    \                vec.push(format!(\"Seven\", x));\n            }\n        }\n\
    \        if upper >= 0 {\n            for x in 0..=upper {\n                vec.push(format!(\"\
    Seven\", x));\n            }\n        }\n        if upper <= 9 {\n           \
    \ for x in 0..=upper {\n                vec.push(format!(\"Eight\", x));\n   \
    \         }\n        }\n        if upper >= 0 {\n            for x in 0..=upper\
    \ {\n                vec.push(format!(\"Eight\", x));\n            }\n       \
    \ }\n        if upper <= 9 {\n            for x in 0..=\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpf2_4v33c.rs:114:3\n\
    \    |\n17  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n20  |     for\
    \ n in arr {\n    |                  - unclosed delimiter\n...\n103 |        \
    \ if upper <= 9 {\n    |                       - this delimiter might not be properly\
    \ closed...\n104 |             for x in 0..=\n105 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n114 | }\n    |   ^\n\nerror[E0586]:\
    \ inclusive range with no end\n   --> /tmp/tmpf2_4v33c.rs:104:23\n    |\n104 |\
    \             for x in 0..=\n    |                       ^^^ help: use `..` instead\n\
    \    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\
    \nerror: expected `{`, found `}`\n   --> /tmp/tmpf2_4v33c.rs:105:1\n    |\n105\
    \ | }\n    | ^ expected `{`\n\nerror: argument never used\n  --> /tmp/tmpf2_4v33c.rs:25:41\n\
    \   |\n25 |                 vec.push(format!(\"One\", x));\n   |             \
    \                     -----  ^ argument never used\n   |                     \
    \             |\n   |                                  formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpf2_4v33c.rs:30:41\n   |\n30 |    \
    \             vec.push(format!(\"One\", x));\n   |                           \
    \       -----  ^ argument never used\n   |                                  |\n\
    \   |                                  formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmpf2_4v33c.rs:35:41\n   |\n35 |           \
    \      vec.push(format!(\"Two\", x));\n   |                                  -----\
    \  ^ argument never used\n   |                                  |\n   |      \
    \                            formatting specifier missing\n\nerror: argument never\
    \ used\n  --> /tmp/tmpf2_4v33c.rs:40:41\n   |\n40 |                 vec.push(format!(\"\
    Two\", x));\n   |                                  -----  ^ argument never used\n\
    \   |                                  |\n   |                               \
    \   formatting specifier missing\n\nerror: argument ne"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \n    let mut arr = arr.clone();\n    arr.sort_unstable();\n    let mut reversed\
    \ = arr.clone();\n    reversed.reverse();\n    let mut result = Vec::new();\n\
    \    for i in 0 .. 9 {\n        let mut cur = i;\n        let mut found = false;\n\
    \        for r in reversed.drain(..) {\n            if cur > r {\n           \
    \     cur = r;\n                found = true;\n            }\n        }\n    \
    \    if found {\n            result.push(*by_digit(&cur));\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp6bwbuwuh.rs:37:26\n\
    \   |\n37 |             result.push(*by_digit(&cur));\n   |                  \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    let mut reversed_arr = vec![];\n    for i in 0..sorted_arr.len() {\n    \
    \    let item = sorted_arr[i];\n        if item <= 9 {\n            reversed_arr.push(from_to::<isize>::name((item\
    \ as i32 + 10) as isize));\n        } else {\n            reversed_arr.push(from_to::<isize>::name((item\
    \ as i32 + 10) as isize));\n        }\n    }\n    reversed_arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `from_to`\n\
    \  --> /tmp/tmpvmeqi9b2.rs:24:31\n   |\n24 |             reversed_arr.push(from_to::<isize>::name((item\
    \ as i32 + 10) as isize));\n   |                               ^^^^^^^ use of\
    \ undeclared crate or module `from_to`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `from_to`\n  --> /tmp/tmpvmeqi9b2.rs:26:31\n \
    \  |\n26 |             reversed_arr.push(from_to::<isize>::name((item as i32 +\
    \ 10) as isize));\n   |                               ^^^^^^^ use of undeclared\
    \ crate or module `from_to`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n\n    for number in arr {\n   \
    \     match number {\n            1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 => {\n   \
    \             res.push(number as isize + 1);\n            }\n            _ =>\
    \ {}\n        }\n    }\n\n    res.reverse();\n\n    arr.iter().filter(|&n| n %\
    \ 10 == 1).collect::<Vec<_>>().cloned().sort_by(|a, b| b).reverse().cloned().iter().map(|&n|\
    \ {\n        let index = res.iter().position(|&i| n == i + 1).unwrap();\n    \
    \    match index {\n            Some(i) => *res.get(i as usize),\n           \
    \ None => return \"\",\n        }\n    }).collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<&isize>` is not an iterator\n   --> /tmp/tmpwyjkde6q.rs:31:61\n\
    \    |\n31  |       arr.iter().filter(|&n| n % 10 == 1).collect::<Vec<_>>().cloned().sort_by(|a,\
    \ b| b).reverse().cloned().iter().map(|&n| {\n    |                          \
    \                                     ^^^^^^ `Vec<&isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<&isize>: Iterator`\n            which is required by `&mut Vec<&isize>:\
    \ Iterator`\n            `[&isize]: Iterator`\n            which is required by\
    \ `&mut [&isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwyjkde6q.rs:34:13\n\
    \   |\n33 |         match index {\n   |               ----- this expression has\
    \ type `usize`\n34 |             Some(i) => *res.get(i as usize),\n   |      \
    \       ^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwyjkde6q.rs:35:13\n   |\n33 |         match index {\n \
    \  |               ----- this expression has type `usize`\n34 |             Some(i)\
    \ => *res.get(i as usize),\n35 |             None => return \"\",\n   |      \
    \       ^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<_>`\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpwyjkde6q.rs:34:24\n   |\n34 |        \
    \     Some(i) => *res.get(i as usize),\n   |                        ^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr.reverse();\n    let mut arr: Vec<String> = Vec::new();\n    for\
    \ element in &sorted_arr {\n        if element < 10 {\n            arr.push((&format!(\"\
    One\", element)).to_owned());\n        } else if element < 100 {\n           \
    \ arr.push((&format!(\"Two\", element)).to_owned());\n        } else if element\
    \ < 1000 {\n            arr.push((&format!(\"Three\", element)).to_owned());\n\
    \        } else if element < 10000 {\n            arr.push((&format!(\"Four\"\
    , element)).to_owned());\n        } else if element < 100000 {\n            arr.push((&format!(\"\
    Five\", element)).to_owned());\n        } else if element < 1000000 {\n      \
    \      arr.push((&format!(\"Six\", element)).to_owned());\n        } else if element\
    \ < 10000000 {\n            arr.push((&format!(\"Seven\", element)).to_owned());\n\
    \        } else if element < 100000000 {\n            arr.push((&format!(\"Eight\"\
    , element)).to_owned());\n        } else if element < 1000000000 {\n         \
    \   arr.push((&format!(\"Nine\", element)).to_owned());\n        } else {\n  \
    \          continue;\n        }\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:24:39\n   |\n24 |\
    \             arr.push((&format!(\"One\", element)).to_owned());\n   |       \
    \                         -----  ^^^^^^^ argument never used\n   |           \
    \                     |\n   |                                formatting specifier\
    \ missing\n\nerror: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:26:39\n   |\n\
    26 |             arr.push((&format!(\"Two\", element)).to_owned());\n   |    \
    \                            -----  ^^^^^^^ argument never used\n   |        \
    \                        |\n   |                                formatting specifier\
    \ missing\n\nerror: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:28:41\n   |\n\
    28 |             arr.push((&format!(\"Three\", element)).to_owned());\n   |  \
    \                              -------  ^^^^^^^ argument never used\n   |    \
    \                            |\n   |                                formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:30:40\n\
    \   |\n30 |             arr.push((&format!(\"Four\", element)).to_owned());\n\
    \   |                                ------  ^^^^^^^ argument never used\n   |\
    \                                |\n   |                                formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:32:40\n\
    \   |\n32 |             arr.push((&format!(\"Five\", element)).to_owned());\n\
    \   |                                ------  ^^^^^^^ argument never used\n   |\
    \                                |\n   |                                formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:34:39\n\
    \   |\n34 |             arr.push((&format!(\"Six\", element)).to_owned());\n \
    \  |                                -----  ^^^^^^^ argument never used\n   | \
    \                               |\n   |                                formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmp4lmfgfp0.rs:36:41\n\
    \   |\n36 |             arr.push((&format!(\"Seven\", element)).to_owned());\n\
    \   |                                -------  ^^^^^^^ argument never used\n  \
    \ | "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut numbers = arr\n        .iter()\n        .enumerate()\n\
    \        .sort_by(|(x, y), (i, _)| y.cmp(&i))\n        .map(|(i, _)| i)\n    \
    \    .collect::<Vec<_>>();\n    numbers.reverse();\n    let mut strs = vec![];\n\
    \    for i in numbers {\n        if i != 1 {\n            strs.push(format!(\"\
    {}\", i));\n        } else {\n            strs.push(format!(\"One\"));\n     \
    \   }\n    }\n    strs\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpgyfy6hbz.rs:21:10\n   |\n21 |         .sort_by(|(x,\
    \ y), (i, _)| y.cmp(&i))\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n \
    \   let mut ret = vec![];\n    let mut i = 0;\n    let mut pos = 0;\n    let mut\
    \ size = arr.len() as usize;\n    let mut first_num = 1;\n    let mut last_num\
    \ = 9;\n    while i < size {\n        let num = arr[i];\n        if num == last_num\
    \ {\n            pos -= 1;\n            i += 1;\n            last_num += 1;\n\
    \            if pos == 0 {\n                ret.push(&format!(\"{}\", first_num));\n\
    \            } else {\n                ret.push(&format!(\"{}{}\", &format!(\"\
    One\", &arr[pos]), &arr[size - 1]));\n            }\n            first_num +=\
    \ 1;\n        } else {\n            ret.push(&format!(\"{}\", num));\n       \
    \     i += 1;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmp3ju9pyaz.rs:36:59\n   |\n36 |\
    \                 ret.push(&format!(\"{}{}\", &format!(\"One\", &arr[pos]), &arr[size\
    \ - 1]));\n   |                                                    -----  ^^^^^^^^^\
    \ argument never used\n   |                                                  \
    \  |\n   |                                                    formatting specifier\
    \ missing\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ju9pyaz.rs:44:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n44 |     ret\n   |     ^^^ expected struct `String`, found `&String`\n  \
    \ |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort();\n    let mut retVec: Vec<String> = vec![];\n\
    \    for i in 0..(arr.len() / 10) {\n        let start = i * 10;\n        let\
    \ end = (i + 1) * 10;\n        \n        \n        let start = if start == arr.len()\
    \ / 10 { 0} else {start};\n        let end = if end == arr.len() / 10 { arr.len()\
    \ / 10 } else {end};\n        \n        \n        retVec.push((arr[start..end].iter().map(|x|{\n\
    \            get_name(x)\n        }).collect::<Vec<String>>()));\n    }\n    retVec\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_name` in this scope\n  --> /tmp/tmp3ezm4871.rs:30:13\n\
    \   |\n30 |             get_name(x)\n   |             ^^^^^^^^ not found in this\
    \ scope\n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmp3ezm4871.rs:29:21\n\
    \   |\n29 |         retVec.push((arr[start..end].iter().map(|x|{\n   |       \
    \              ^\n30 |             get_name(x)\n31 |         }).collect::<Vec<String>>()));\n\
    \   |                                    ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n29 ~         retVec.push(arr[start..end].iter().map(|x|{\n\
    30 |             get_name(x)\n31 ~         }).collect::<Vec<String>>());\n   |\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3ezm4871.rs:29:21\n   |\n29 |\
    \           retVec.push((arr[start..end].iter().map(|x|{\n   |  _____________________^\n\
    30 | |             get_name(x)\n31 | |         }).collect::<Vec<String>>()));\n\
    \   | |____________________________________^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `String`\n              found struct\
    \ `Vec<String>`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut len = arr.len();\n    if len == 1 {\n        return vec![\"One\"];\n\
    \    }\n    if len < 10 {\n        len = 10 - len;\n    }\n    let mut rev: Vec<isize>\
    \ = vec![];\n    for x in arr {\n        if x < 10 {\n            let revx = rev[rev.length\
    \ - 1];\n            if revx == (x - 10) + 1 {\n                rev[rev.length\
    \ - 1] = x + 1;\n            }\n            else {\n                rev[rev.length\
    \ - 1] = x;\n            }\n        } else {\n            if rev == vec![] {\n\
    \                rev = vec![x as isize];\n            } else {\n             \
    \   rev[rev.length - 1] = x;\n            }\n        }\n    }\n    let mut res\
    \ = vec![\"One\"];\n    for x in rev {\n        if x == 10 {\n            res.insert(0,\
    \ vec![\"Ten\"]);\n        } else {\n            res.insert(0, vec![by_digit(x)]);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmplo7ol8gc.rs:51:32\n\
    \   |\n51 |             res.insert(0, vec![by_digit(x)]);\n   |              \
    \                  ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplo7ol8gc.rs:23:21\n   |\n23 |         return vec![\"One\"\
    ];\n   |                     ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found `&str`\n\nerror[E0609]: no field `length` on type `Vec<isize>`\n  -->\
    \ /tmp/tmplo7ol8gc.rs:31:32\n   |\n31 |             let revx = rev[rev.length\
    \ - 1];\n   |                                ^^^^^^ unknown field\n\nerror[E0609]:\
    \ no field `length` on type `Vec<isize>`\n  --> /tmp/tmplo7ol8gc.rs:33:25\n  \
    \ |\n33 |                 rev[rev.length - 1] = x + 1;\n   |                 \
    \        ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `Vec<isize>`\n\
    \  --> /tmp/tmplo7ol8gc.rs:36:25\n   |\n36 |                 rev[rev.length -\
    \ 1] = x;\n   |                         ^^^^^^ unknown field\n\nerror[E0609]:\
    \ no field `length` on type `Vec<isize>`\n  --> /tmp/tmplo7ol8gc.rs:42:25\n  \
    \ |\n42 |                 rev[rev.length - 1] = x;\n   |                     \
    \    ^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplo7ol8gc.rs:49:27\n\
    \   |\n49 |             res.insert(0, vec![\"Ten\"]);\n   |                  \
    \         ^^^^^^^^^^^ expected `&str`, found struct `Vec`\n   |\n   = note: expected\
    \ reference `&str`\n                 found struct `Vec<&str>`\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplo7ol8gc.rs:51:27\n\
    \   |\n51 |             res.insert(0, vec![by_digit(x)]);\n   |              \
    \             ^^^^^^^^^^^^^^^^^ expected `&str`, found struct `Vec`\n   |\n  \
    \ = note: expected reference `&str`\n                 found struct `Vec<_, _>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more in"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr: Vec<String> = vec![];\n    let mut reverse_arr:\
    \ Vec<isize> = arr\n        .iter()\n        .cloned()\n        .enumerate()\n\
    \        .filter_map(|(idx, i)| {\n            if i < 10 {\n                Some(i)\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .collect();\n    reverse_arr.reverse();\n    for el in reverse_arr {\n   \
    \     new_arr.push(by_length(el));\n    }\n    for el in new_arr {\n        if\
    \ el != \"\" {\n            new_arr.push(&format!(\"{}\", el));\n        }\n \
    \   }\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4q89e58b.rs:33:32\n   |\n\
    33 |         new_arr.push(by_length(el));\n   |                              \
    \  ^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4q89e58b.rs:33:22\n\
    \   |\n33 |         new_arr.push(by_length(el));\n   |                      ^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4q89e58b.rs:37:26\n   |\n37 |             new_arr.push(&format!(\"\
    {}\", el));\n   |                          ^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n\
    37 -             new_arr.push(&format!(\"{}\", el));\n37 +             new_arr.push(format!(\"\
    {}\", el));\n   | \n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut i = 0;\n    while\
    \ i < arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j - 1] >\
    \ arr[j] {\n            j = j - 1;\n        }\n        res.push(names[j]);\n \
    \       j = i + 1;\n        while j < arr.len() && arr[j] > arr[j + 1] {\n   \
    \         j = j + 1;\n        }\n        i = j;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp_vlxvhyd.rs:25:18\n\
    \   |\n25 |         res.push(names[j]);\n   |                  ^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut a = arr.clone();\n    a.sort();\n    a.reverse();\n\n    let mut strs:\
    \ Vec<String> = vec![];\n    for n in a.iter() {\n        let name = match n {\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => return vec![],\n        };\n        strs.push(name);\n\
    \    }\n    return strs;\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptsgp_v0w.rs:39:19\n   |\n\
    39 |         strs.push(name);\n   |                   ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                   |\n   |          \
    \         expected struct `String`, found `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr\n        .iter()\n        .cloned()\n\
    \        .map(|i| if i % 10 == 1 && i % 10 != 0 {\n            i.to_string()\n\
    \        } else {\n            format!(\"{}\", i)\n        })\n        .collect();\n\
    \    let mut len = arr.len();\n    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n    len = len / 10;\n    let mut i = 0;\n    while i < len {\n       \
    \ arr[arr.len() - i] = arr[arr.len() - i].to_string() + vec![\n            \"\
    One\".to_string(),\n            \"Two\".to_string(),\n            \"Three\".to_string(),\n\
    \            \"Four\".to_string(),\n            \"Five\".to_string(),\n      \
    \      \"Six\".to_string(),\n            \"Seven\".to_string(),\n            \"\
    Eight\".to_string(),\n            \"Nine\".to_string(),\n        ][arr[i] as usize];\n\
    \        i += 1;\n    }\n    arr\n        .iter()\n        .cloned()\n       \
    \ .map(|i| format!(\"{}\", i))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp7tx20nyx.rs:27:19\n\
    \   |\n18 |     let mut arr = arr\n   |         ------- consider giving `arr`\
    \ a type\n...\n27 |     let mut len = arr.len();\n   |                   ^^^ cannot\
    \ infer type\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    for n in arr {\n       \
    \ if n > 0 && n <= 9 {\n            result.push(by_digit(n as u8));\n        }\
    \ else {\n            result.push(by_digit(n - 10));\n        }\n    }\n    result.reverse();\n\
    \    let mut i = 0;\n    for n in result {\n        i += n;\n    }\n    vec![by_digit(i\
    \ - 1), by_digit(i)]\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpm54cwjse.rs:21:25\n\
    \   |\n21 |             result.push(by_digit(n as u8));\n   |                \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `by_digit` in this scope\n  --> /tmp/tmpm54cwjse.rs:23:25\n   |\n23 |      \
    \       result.push(by_digit(n - 10));\n   |                         ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `by_digit` in\
    \ this scope\n  --> /tmp/tmpm54cwjse.rs:31:10\n   |\n31 |     vec![by_digit(i\
    \ - 1), by_digit(i)]\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `by_digit` in this scope\n  --> /tmp/tmpm54cwjse.rs:31:27\n\
    \   |\n31 |     vec![by_digit(i - 1), by_digit(i)]\n   |                     \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    debug_assert!(arr.len() > 0);\n    let mut result = vec![];\n\
    \    if arr.len() == 1 {\n        result.push(\"One\");\n    } else if arr.len()\
    \ == 2 {\n        result.push(\"Two\");\n    } else if arr.len() == 3 {\n    \
    \    result.push(\"Three\");\n    } else if arr.len() == 4 {\n        result.push(\"\
    Four\");\n    } else if arr.len() == 5 {\n        result.push(\"Five\");\n   \
    \ } else if arr.len() == 6 {\n        result.push(\"Six\");\n    } else if arr.len()\
    \ == 7 {\n        result.push(\"Seven\");\n    } else if arr.len() == 8 {\n  \
    \      result.push(\"Eight\");\n    } else if arr.len() == 9 {\n        result.push(\"\
    Nine\");\n    } else {\n        for i in (0..arr.len()).rev() {\n            if\
    \ i < (arr.len() - 1) {\n                result.push(by_length(arr.subvec(i +\
    \ 1, arr.len())));\n            } else {\n                break;\n           \
    \ }\n        }\n    }\n    result.rev()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `subvec` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpey22kwem.rs:41:43\n   |\n41 |             \
    \    result.push(by_length(arr.subvec(i + 1, arr.len())));\n   |             \
    \                              ^^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpey22kwem.rs:41:29\n   |\n41 |              \
    \   result.push(by_length(arr.subvec(i + 1, arr.len())));\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ struct `Vec`\n   |\n   = note: expected reference `&str`\n                 found\
    \ struct `Vec<String>`\n\nerror[E0599]: `Vec<&str>` is not an iterator\n   -->\
    \ /tmp/tmpey22kwem.rs:47:12\n    |\n47  |       result.rev()\n    |          \
    \    ^^^ `Vec<&str>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<&str>: Iterator`\n            which\
    \ is required by `&mut Vec<&str>: Iterator`\n            `[&str]: Iterator`\n\
    \            which is required by `&mut [&str]: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let mut result = vec![];\n    let mut num: isize = arr[0];\n    let mut num_digits\
    \ = 1;\n    for element in arr.iter().rev() {\n        if element >= 1 {\n   \
    \         result.push(format!(\"{}\", element));\n            num_digits += 1;\n\
    \        } else {\n            num_digits += 1;\n        }\n        if num_digits\
    \ > 9 {\n            num_digits = 1;\n            num = element % 10;\n      \
    \      result.push(by_digit(element));\n        }\n    }\n\n    result.push(by_digit(num));\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp_e6w729a.rs:35:25\n\
    \   |\n35 |             result.push(by_digit(element));\n   |                \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `by_digit` in this scope\n  --> /tmp/tmp_e6w729a.rs:39:17\n   |\n39 |     result.push(by_digit(num));\n\
    \   |                 ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_e6w729a.rs:26:23\n   |\n26 |         if element >= 1 {\n\
    \   |                       ^\n   |                       |\n   |            \
    \           expected `&isize`, found integer\n   |                       help:\
    \ consider borrowing here: `&1`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr;\n    arr.sort_unstable();\n    let mut i = 0;\n    let\
    \ len = arr.len();\n    while i < len {\n        if arr[i] == 1 || arr[i] == 9\
    \ {\n            arr.rev();\n            arr.insert(i, by_length_digit(arr[i]));\n\
    \        }\n        i += 1;\n    }\n    return arr\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_length_digit` in this scope\n  -->\
    \ /tmp/tmpwn4ti2u4.rs:28:27\n   |\n28 |             arr.insert(i, by_length_digit(arr[i]));\n\
    \   |                           ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpwn4ti2u4.rs:27:17\n    |\n27\
    \  |               arr.rev();\n    |                   ^^^ `Vec<isize>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwn4ti2u4.rs:32:12\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n32 |     return arr\n   |            ^^^ expected struct `String`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut result = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut reverse_iter = &arr.reverse();\n\
    \    let mut current_iter = reverse_iter;\n    let mut i = 0;\n    while i < 9\
    \ {\n        // ignore the very large negative number\n        if *current_iter\
    \ >= 0 && *current_iter < 10 {\n            let mut tmp = result.iter_mut().take(*current_iter).cloned().collect::<Vec<String>>();\n\
    \            result.truncate(*current_iter + 1);\n            result[*current_iter]\
    \ = tmp;\n        }\n        *current_iter += 1;\n        i += 1;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn34els5d.rs:27:29\n   |\n\
    27 |         if *current_iter >= 0 && *current_iter < 10 {\n   |             \
    \                ^ expected `()`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpn34els5d.rs:27:50\n   |\n27 |         if *current_iter >= 0 &&\
    \ *current_iter < 10 {\n   |                                                 \
    \ ^^ expected `()`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn34els5d.rs:28:50\n\
    \   |\n28 |             let mut tmp = result.iter_mut().take(*current_iter).cloned().collect::<Vec<String>>();\n\
    \   |                                                  ^^^^^^^^^^^^^ expected\
    \ `usize`, found `()`\n\nerror[E0271]: type mismatch resolving `<std::iter::Take<std::slice::IterMut<'_,\
    \ &str>> as Iterator>::Item == &_`\n    --> /tmp/tmpn34els5d.rs:28:65\n     |\n\
    28   |             let mut tmp = result.iter_mut().take(*current_iter).cloned().collect::<Vec<String>>();\n\
    \     |                                                                 ^^^^^^\
    \ types differ in mutability\n     |\n     = note:      expected reference `&_`\n\
    \             found mutable reference `&mut &str`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::iter::Take<std::slice::IterMut<'_,\
    \ &str>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpn34els5d.rs:28:74\n\
    \   |\n28 |                let mut tmp = result.iter_mut().take(*current_iter).cloned().collect::<Vec<String>>();\n\
    \   |                                                                        \
    \     ^^^^^^^ method cannot be called on `Cloned<std::iter::Take<std::slice::IterMut<'_,\
    \ &str>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<std::iter::Take<std::slice::IterMut<'_,\
    \ &str>> as Iterator>::Item = &_`\n           which is required by `Cloned<std::iter::Take<std::slice::IterMut<'_,\
    \ &str>>>: Iterator`\n           `Cloned<std::iter::Take<std::slice::IterMut<'_,\
    \ &str>>>: Iterator`\n           which is required by `&mut Cloned<"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut min_len = std::i32::MAX;\n    let mut max_len\
    \ = 0;\n    for &n in arr {\n        if n < min_len {\n            min_len = n;\n\
    \        }\n        if n > max_len {\n            max_len = n;\n        }\n  \
    \  }\n    let min_len = min_len as usize;\n    let mut counter = std::i32::MAX;\n\
    \    let mut digits = Vec::new();\n    let mut reversed = Vec::new();\n    for\
    \ &n in arr {\n        if n > 0 {\n            counter = counter + 1;\n      \
    \      if counter == min_len {\n                digits.push((n as usize - counter)\
    \ % 10);\n                counter = (n as usize - counter) / 10;\n           \
    \ } else if counter == 0 {\n                digits.push((n as usize - counter)\
    \ % 10);\n                counter = (n as usize - counter) / 10;\n           \
    \ } else if counter > 0 {\n                digits.push((n as usize - counter)\
    \ % 10);\n            }\n        }\n    }\n    let mut counter = std::i32::MAX;\n\
    \    let mut reversed = Vec::new();\n    for &n in arr {\n        if n > 0 {\n\
    \            counter = counter + 1;\n            if counter == min_len {\n   \
    \             reversed.push(digits.last().unwrap());\n                counter\
    \ = (n as usize - counter) / 10;\n            } else if counter == 0 {\n     \
    \           reversed.push(digits.last().unwrap());\n                counter =\
    \ (n as usize - counter) / 10;\n            } else if counter > 0 {\n        \
    \        reversed.push(digits.last().unwrap());\n            }\n        }\n  \
    \  }\n    let mut ones = Vec::new();\n    for i in 0..(min_len as usize) {\n \
    \       ones.push(i.to_string());\n    }\n    for i in (reversed.iter()).rev()\
    \ {\n        ones.insert(i, String::from(i.to_string()));\n    }\n    for n in\
    \ ones {\n        digits.push((n as usize - counter) % 10);\n        counter =\
    \ (n as usize - counter) / 10;\n    }\n    return digits;\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1tv689a1.rs:20:9\n   |\n\
    20 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1tv689a1.rs:32:9\n   |\n32 |     for &n in arr {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tv689a1.rs:35:27\n\
    \   |\n35 |             if counter == min_len {\n   |                        \
    \   ^^^^^^^ expected `i32`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `i32` and panic if the converted value doesn't fit\n   |\n35 |       \
    \      if counter == min_len.try_into().unwrap() {\n   |                     \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tv689a1.rs:36:43\n\
    \   |\n36 |                 digits.push((n as usize - counter) % 10);\n   |  \
    \                                         ^^^^^^^ expected `usize`, found `i32`\n\
    \nerror[E0277]: cannot subtract `i32` from `usize`\n  --> /tmp/tmp1tv689a1.rs:36:41\n\
    \   |\n36 |                 digits.push((n as usize - counter) % 10);\n   |  \
    \                                       ^ no implementation for `usize - i32`\n\
    \   |\n   = help: the trait `Sub<i32>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut reversed_arr = arr.clone(); // we assume that\
    \ it's already sorted\n    reversed_arr.reverse();\n    let mut ret: Vec<String>\
    \ = Vec::new();\n    let mut index = 0usize;\n    let mut one_index = 0usize;\n\
    \    let mut two_index = 1usize;\n    let mut three_index = 2usize;\n    let mut\
    \ four_index = 3usize;\n    let mut five_index = 4usize;\n    let mut six_index\
    \ = 5usize;\n    let mut seven_index = 6usize;\n    let mut eight_index = 7usize;\n\
    \    let mut nine_index = 8usize;\n    let mut ten_index = 9usize;\n    let mut\
    \ eleven_index = 10usize;\n    let mut twelve_index = 11usize;\n\n    // go through\
    \ all digits starting from the last one\n    while index < reversed_arr.len()\
    \ {\n        if reversed_arr[index] == 1 {\n            // if there's a '1' digit\
    \ found, save it to `one_index`\n            one_index = index;\n        } else\
    \ if reversed_arr[index] == 2 {\n            // if there's a '2' digit found,\
    \ save it to `two_index`\n            two_index = index;\n        } else if reversed_arr[index]\
    \ == 3 {\n            // if there's a '3' digit found, save it to `three_index`\n\
    \            three_index = index;\n        } else if reversed_arr[index] == 4\
    \ {\n            // if there's a '4' digit found, save it to `four_index`\n  \
    \          four_index = index;\n        } else if reversed_arr[index] == 5 {\n\
    \            // if there's a '5' digit found, save it to `five_index`\n      \
    \      five_index = index;\n        } else if reversed_arr[index] == 6 {\n   \
    \         // if there's a '6' digit found, save it to `six_index`\n          \
    \  six_index = index;\n        } else if reversed_arr[index] == 7 {\n        \
    \    // if there's a '7' digit found, save it to `seven_index`\n            seven_index\
    \ = index;\n        } else if reversed_arr[index] == 8 {\n            // if there's\
    \ a '8' digit found, save it to `eight_index`\n            eight_index = index;\n\
    \        } else if reversed_arr[index] == 9 {\n            // if there's a '9'\
    \ digit found, save it to `nine_index`\n            nine_index = index;\n    \
    \    } else if reversed_arr[index] == 10 {\n            // if there's a '10' digit\
    \ found, save it to `ten_index`\n            ten_index = index;\n        } else\
    \ if reversed_arr[index] == 11 {\n            // if there's a '11' digit found,\
    \ save it to `\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqlw5fsm5.rs:78:3\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n36 |     while index\
    \ < reversed_arr.len() {\n   |                                      - unclosed\
    \ delimiter\n...\n67 |         } else if reversed_arr[index] == 11 {\n   |   \
    \                                          - this delimiter might not be properly\
    \ closed...\n68 |             // if there's a '11' digit found, save it to `\n\
    69 | }\n   | - ...as it matches this but it has different indentation\n...\n78\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlw5fsm5.rs:36:5\n\
    \   |\n17 |   fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n36 | /     while index < reversed_arr.len() {\n37 | |         if\
    \ reversed_arr[index] == 1 {\n38 | |             // if there's a '1' digit found,\
    \ save it to `one_index`\n39 | |             one_index = index;\n...  |\n77 |\
    \ |     assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"\
    Eight\"), String::from(\"Four\")]);\n78 | | }\n   | |__^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<String>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut min_value = arr[0];\n    let mut max_value = arr[0];\n    for &x in\
    \ arr.iter() {\n        if x < min_value {\n            min_value = x;\n     \
    \   }\n        if x > max_value {\n            max_value = x;\n        }\n   \
    \ }\n    let mut new_arr = vec![];\n    for &x in arr.iter() {\n        if x >\
    \ max_value && x < min_value {\n            continue;\n        }\n        let\
    \ pos = x - min_value;\n        let mut new_pos = pos as usize;\n        let mut\
    \ index = arr.len() - 1;\n        while index >= 0 {\n            if arr[index]\
    \ == x {\n                new_pos = new_pos + 1;\n                break;\n   \
    \         }\n            index -= 1;\n        }\n        new_arr.push((One.to_str(new_pos)).to_owned());\n\
    \    }\n    new_arr.reverse();\n    new_arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `One` in this scope\n  --> /tmp/tmpe88wvr3k.rs:46:23\n\
    \   |\n46 |         new_arr.push((One.to_str(new_pos)).to_owned());\n   |    \
    \                   ^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    if arr.len() == 0 {\n\
    \        return result;\n    }\n    for i in arr.iter() {\n        match i {\n\
    \            i if i <= 9 => result.push(format!(\"{}\", i)),\n            _ =>\
    \ return result\n        }\n    }\n    for i in result.iter_mut() {\n        *i\
    \ =\n            if i[0] >= '0' && i[0] <= '9' {\n                i.to_ascii_lowercase()\n\
    \            } else if i[0] >= 'a' && i[0] <= 'z' {\n                i.to_ascii_uppercase()\n\
    \            } else {\n                i\n            };\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_3au85u.rs:24:23\n   |\n\
    24 |             i if i <= 9 => result.push(format!(\"{}\", i)),\n   |       \
    \                ^\n   |                       |\n   |                       expected\
    \ `&isize`, found integer\n   |                       help: consider borrowing\
    \ here: `&9`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpw_3au85u.rs:30:16\n   |\n30 |             if i[0] >= '0' && i[0]\
    \ <= '9' {\n   |                ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpw_3au85u.rs:30:31\n   |\n30 |             if i[0] >= '0' && i[0]\
    \ <= '9' {\n   |                               ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpw_3au85u.rs:32:23\n   |\n32 |             } else if i[0] >= 'a'\
    \ && i[0] <= 'z' {\n   |                       ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the fo"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr = arr.clone();\n    let mut sorted_arr2\
    \ = sorted_arr.clone();\n    for num in &sorted_arr {\n        // Find the index\n\
    \        let mut index = sorted_arr.iter().position(|n| *n == num);\n        if\
    \ index == 0 {\n            break;\n        }\n        // Move the index\n   \
    \     sorted_arr.swap(0, index);\n        // Swap the number\n        let tmp\
    \ = sorted_arr2[index];\n        sorted_arr2[index] = sorted_arr2[index - 1];\n\
    \        sorted_arr2[index - 1] = tmp;\n    }\n    sorted_arr.shrink_to_fit();\n\
    \    sorted_arr2.shrink_to_fit();\n    let mut result: Vec<String> = Vec::new();\n\
    \    for num in sorted_arr2 {\n        result.push(by_name(num));\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmpq0vzpw0k.rs:37:21\n\
    \   |\n37 |         result.push(by_name(num));\n   |                     ^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq0vzpw0k.rs:22:62\n\
    \   |\n22 |         let mut index = sorted_arr.iter().position(|n| *n == num);\n\
    \   |                                                              ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |         let mut index = sorted_arr.iter().position(|n| *n == *num);\n   |\
    \                                                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq0vzpw0k.rs:23:21\n   |\n23 |         if index\
    \ == 0 {\n   |                     ^ expected enum `Option`, found integer\n \
    \  |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n23 |         if index == Some(0)\
    \ {\n   |                     +++++ +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpq0vzpw0k.rs:27:28\n   |\n27 |         sorted_arr.swap(0, index);\n \
    \  |                            ^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `Option<usize>`\n  -->\
    \ /tmp/tmpq0vzpw0k.rs:29:19\n   |\n29 |         let tmp = sorted_arr2[index];\n\
    \   |                   ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `Option<usize>`\n   = note: required because of the requirements on the\
    \ impl of `Index<Option<usize>>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `Option<usize>`\n  --> /tmp/tmpq0vzpw0k.rs:30:9\n   |\n\
    30 |         sorted_arr2[index] = sorted_arr2[index - 1];\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<usize>`\n   = note:\
    \ requi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_unstable();\n    arr.reverse();\n    let mut\
    \ result = Vec::with_capacity(arr.len());\n    for element in &arr {\n       \
    \ if element >= 1 && element <= 9 {\n            result.push(name_of(&element));\n\
    \        } else {\n            result.push(\"Other\".to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `name_of` in this scope\n  --> /tmp/tmpfrk9q8nq.rs:23:25\n\
    \   |\n23 |             result.push(name_of(&element));\n   |                \
    \         ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfrk9q8nq.rs:22:23\n   |\n22 |         if element >= 1 && element\
    \ <= 9 {\n   |                       ^\n   |                       |\n   |   \
    \                    expected `&isize`, found integer\n   |                  \
    \     help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfrk9q8nq.rs:22:39\n   |\n22 |         if element >= 1 && element\
    \ <= 9 {\n   |                                       ^\n   |                 \
    \                      |\n   |                                       expected\
    \ `&isize`, found integer\n   |                                       help: consider\
    \ borrowing here: `&9`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec = vec![\"\".to_string()];\n    vec.resize(arr.len(),\
    \ &\"One\".to_string());\n    for i in (0..arr.len() - 1).rev() {\n        if\
    \ arr[i] < 10 {\n            vec[i] = &\"One\".to_string();\n        } else if\
    \ arr[i] < 36 {\n            vec[i] = &\"Two\".to_string();\n        } else if\
    \ arr[i] < 60 {\n            vec[i] = &\"Three\".to_string();\n        } else\
    \ if arr[i] < 90 {\n            vec[i] = &\"Four\".to_string();\n        } else\
    \ if arr[i] < 120 {\n            vec[i] = &\"Five\".to_string();\n        } else\
    \ if arr[i] < 150 {\n            vec[i] = &\"Six\".to_string();\n        } else\
    \ if arr[i] < 180 {\n            vec[i] = &\"Seven\".to_string();\n        } else\
    \ if arr[i] < 210 {\n            vec[i] = &\"Eight\".to_string();\n        } else\
    \ if arr[i] < 240 {\n            vec[i] = &\"Nine\".to_string();\n        } else\
    \ {\n            vec[i] = &\"Nine\".to_string();\n        }\n    }\n    vec.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg7s57z1a.rs:19:27\n   |\n\
    19 |     vec.resize(arr.len(), &\"One\".to_string());\n   |                  \
    \         ^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\n\
    help: consider removing the borrow\n   |\n19 -     vec.resize(arr.len(), &\"One\"\
    .to_string());\n19 +     vec.resize(arr.len(), \"One\".to_string());\n   | \n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpg7s57z1a.rs:22:22\n   |\n22 |  \
    \           vec[i] = &\"One\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |             |\n   |        \
    \     expected due to the type of this binding\n   |\nhelp: consider removing\
    \ the borrow\n   |\n22 -             vec[i] = &\"One\".to_string();\n22 +    \
    \         vec[i] = \"One\".to_string();\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg7s57z1a.rs:24:22\n   |\n24 |             vec[i] = &\"Two\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&String`\n   |             |\n   |             expected due to the type of\
    \ this binding\n   |\nhelp: consider removing the borrow\n   |\n24 -         \
    \    vec[i] = &\"Two\".to_string();\n24 +             vec[i] = \"Two\".to_string();\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg7s57z1a.rs:26:22\n  \
    \ |\n26 |             vec[i] = &\"Three\".to_string();\n   |             ------\
    \   ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |     \
    \        |\n   |             expected due to the type of this binding\n   |\n\
    help: consider removing the borrow\n   |\n26 -             vec[i] = &\"Three\"\
    .to_string();\n26 +             vec[i] = \"Three\".to_string();\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg7s57z1a.rs:28:22\n   |\n28 |             vec[i]\
    \ = &\"Four\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\nhelp: consider removing the borrow\n\
    \   |\n28 -             vec[i] = &\"Four\".to_string();\n28 +             vec[i]\
    \ = \"Four\".to_st"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \n    let mut reversed: Vec<isize> = arr.drain(..).rev();\n\n    let mut to_return\
    \ = Vec::new();\n\n    for i in 0..arr.len() {\n        match i {\n          \
    \  0 => to_return.push(String::from(\"One\")),\n            1 => to_return.push(String::from(\"\
    Two\")),\n            2 => to_return.push(String::from(\"Three\")),\n        \
    \    3 => to_return.push(String::from(\"Four\")),\n            4 => to_return.push(String::from(\"\
    Five\")),\n            5 => to_return.push(String::from(\"Six\")),\n         \
    \   6 => to_return.push(String::from(\"Seven\")),\n            7 => to_return.push(String::from(\"\
    Eight\")),\n            8 => to_return.push(String::from(\"Nine\")),\n       \
    \     _ => to_return.push(String::from(&reversed[i])),\n        }\n    }\n   \
    \ return to_return;\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpisz81erq.rs:22:36\n   |\n\
    22 |     let mut reversed: Vec<isize> = arr.drain(..).rev();\n   |           \
    \            ----------   ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `Rev`\n   |                       |\n   |                       expected due\
    \ to this\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Rev<std::vec::Drain<'_, isize>>`\n\nerror[E0277]: the trait bound `String:\
    \ From<&isize>` is not satisfied\n  --> /tmp/tmpisz81erq.rs:37:33\n   |\n37 |\
    \             _ => to_return.push(String::from(&reversed[i])),\n   |         \
    \                        ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr: Vec<String> = Vec::new();\n    let mut\
    \ reverse_arr: Vec<isize> = Vec::new();\n    arr.iter().enumerate().for_each(|index|{\n\
    \        if index >= 1 && index <= 9 {\n            new_arr.push(by_index(&index)?);\n\
    \        } else {\n            reverse_arr.push(*index);\n        }\n    });\n\
    \    reverse_arr.sort_unstable();\n    for i in reverse_arr {\n        new_arr.push(by_index(&i)?\
    \ as String);\n    }\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_index` in this scope\n  --> /tmp/tmpx67h1vyu.rs:22:26\n\
    \   |\n22 |             new_arr.push(by_index(&index)?);\n   |               \
    \           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `by_index` in this scope\n  --> /tmp/tmpx67h1vyu.rs:29:22\n   |\n29 |      \
    \   new_arr.push(by_index(&i)? as String);\n   |                      ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx67h1vyu.rs:21:21\n\
    \   |\n21 |         if index >= 1 && index <= 9 {\n   |                     ^\
    \ expected tuple, found integer\n   |\n   = note: expected tuple `(usize, &isize)`\n\
    \               found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx67h1vyu.rs:21:35\n   |\n21 |         if index >= 1 && index <= 9 {\n\
    \   |                                   ^ expected tuple, found integer\n   |\n\
    \   = note: expected tuple `(usize, &isize)`\n               found type `{integer}`\n\
    \nerror[E0277]: the `?` operator can only be used in a closure that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmpx67h1vyu.rs:22:42\n\
    \   |\n20 |       arr.iter().enumerate().for_each(|index|{\n   |  _____________________________________-\n\
    21 | |         if index >= 1 && index <= 9 {\n22 | |             new_arr.push(by_index(&index)?);\n\
    \   | |                                          ^ cannot use the `?` operator\
    \ in a closure that returns `()`\n23 | |         } else {\n24 | |            \
    \ reverse_arr.push(*index);\n25 | |         }\n26 | |     });\n   | |_____- this\
    \ function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<_>` is not implemented for `()`\n\nerror[E0614]: type\
    \ `(usize, &isize)` cannot be dereferenced\n  --> /tmp/tmpx67h1vyu.rs:24:30\n\
    \   |\n24 |             reverse_arr.push(*index);\n   |                      \
    \        ^^^^^^\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpx67h1vyu.rs:29:34\n   |\n17 |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_unstable_by(|a, b| b.cmp(a))\n        .iter()\n\
    \        .map(|i| {\n            match i {\n                1 => \"One\".to_string(),\n\
    \                2 => \"Two\".to_string(),\n                3 => \"Three\".to_string(),\n\
    \                4 => \"Four\".to_string(),\n                5 => \"Five\".to_string(),\n\
    \                6 => \"Six\".to_string(),\n                7 => \"Seven\".to_string(),\n\
    \                8 => \"Eight\".to_string(),\n                9 => \"Nine\".to_string(),\n\
    \                _ => String::new(),\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmph_g24prz.rs:19:10\n   |\n19 |         .iter()\n   |   \
    \       ^^^^ method not found in `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.to_owned();\n\n    arr.sort();\n\n \
    \   arr.reverse();\n\n    let mut res = [String::new()];\n\n    for &i in arr\
    \ {\n        match i {\n            0 => res.push(\"Zero\"),\n            1 =>\
    \ res.push(\"One\"),\n            2 => res.push(\"Two\"),\n            3 => res.push(\"\
    Three\"),\n            4 => res.push(\"Four\"),\n            5 => res.push(\"\
    Five\"),\n            6 => res.push(\"Six\"),\n            7 => res.push(\"Seven\"\
    ),\n            8 => res.push(\"Eight\"),\n            9 => res.push(\"Nine\"\
    ),\n            _ => ()\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzy2i7amk.rs:26:9\n   |\n\
    26 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:28:22\n\
    \   |\n28 |             0 => res.push(\"Zero\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:29:22\n\
    \   |\n29 |             1 => res.push(\"One\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:30:22\n\
    \   |\n30 |             2 => res.push(\"Two\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:31:22\n\
    \   |\n31 |             3 => res.push(\"Three\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:32:22\n\
    \   |\n32 |             4 => res.push(\"Four\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:33:22\n\
    \   |\n33 |             5 => res.push(\"Five\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the current scope\n  --> /tmp/tmpzy2i7amk.rs:34:22\n\
    \   |\n34 |             6 => res.push(\"Six\"),\n   |                      ^^^^\
    \ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found\
    \ for array `[String; 1]` in the "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    for i in\
    \ arr.iter() {\n        if i <  1 && i > 9 {\n            let index = i as usize;\n\
    \            result.push((\n                match index {\n                  \
    \  1 => \"One\",\n                    2 => \"Two\",\n                    3 =>\
    \ \"Three\",\n                    4 => \"Four\",\n                    5 => \"\
    Five\",\n                    6 => \"Six\",\n                    7 => \"Seven\"\
    ,\n                    8 => \"Eight\",\n                    9 => \"Nine\",\n \
    \                   _ => \"Invalid\"\n                }\n            ))\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp53aea3j4.rs:22:25\n\
    \   |\n22 |               result.push((\n   |  _________________________^\n23\
    \ | |                 match index {\n   | |________________^\n...\n34 |      \
    \             }\n   |  __________________^\n35 | |             ))\n   | |_____________^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n22 ~             result.push(match index {\n23 |                     1\
    \ => \"One\",\n24 |                     2 => \"Two\",\n25 |                  \
    \   3 => \"Three\",\n26 |                     4 => \"Four\",\n27 |           \
    \          5 => \"Five\",\n ...\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp53aea3j4.rs:20:17\n\
    \   |\n20 |         if i <  1 && i > 9 {\n   |                 ^\n   |       \
    \          |\n   |                 expected `&isize`, found integer\n   |    \
    \             help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp53aea3j4.rs:20:26\n   |\n20 |         if i <  1 && i >\
    \ 9 {\n   |                          ^\n   |                          |\n   |\
    \                          expected `&isize`, found integer\n   |            \
    \              help: consider borrowing here: `&9`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp53aea3j4.rs:24:26\n   |\n24 |                     1 =>\
    \ \"One\",\n   |                          ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                          |\n   |              \
    \            expected struct `String`, found `&str`\n\nerror[E0606]: casting `&isize`\
    \ as `usize` is invalid\n  --> /tmp/tmp53aea3j4.rs:21:25\n   |\n21 |         \
    \    let index = i as usize;\n   |                         -^^^^^^^^^\n   |  \
    \                       |\n   |                         cannot cast `&isize` as\
    \ `usize`\n   |                         help: dereference the expression: `*i`\n\
    \nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0308, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut sorted_arr = arr.clone();\n    let mut reversed_arr = arr.clone();\n\
    \n    sorted_arr.rev();\n    reversed_arr.rev();\n\n    let mut result: Vec<String>\
    \ = vec![];\n    let mut i = 0;\n    while i < sorted_arr.len() {\n        let\
    \ mut j = i;\n        let mut k: usize = 0;\n        while j < reversed_arr.len()\
    \ && reversed_arr[j] >= 1 && reversed_arr[j] <= 9 {\n            k += 1;\n   \
    \         j += 1;\n        }\n        if k > 0 {\n            let num = String::from_str(&sorted_arr[i].to_string()).unwrap();\n\
    \            let res = String::from_str(&reversed_arr[j].to_string()).unwrap();\n\
    \            let index = num.find(&res);\n            if index > 0 {\n       \
    \         let s = num.clone();\n                num.replace(index, s.len() as\
    \ u32, &res.to_string());\n                result.push(num);\n            } else\
    \ {\n                result.push(num);\n            }\n        }\n        i +=\
    \ 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpgkfk_t5e.rs:25:16\n\
    \    |\n25  |       sorted_arr.rev();\n    |                  ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmpgkfk_t5e.rs:26:18\n    |\n26  |       reversed_arr.rev();\n  \
    \  |                    ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ no function or associated item named `from_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpgkfk_t5e.rs:38:31\n   |\n38 |             let\
    \ num = String::from_str(&sorted_arr[i].to_string()).unwrap();\n   |         \
    \                      ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpgkfk_t5e.rs:39:31\n   |\n39 |             let res = String::from_str(&reversed_arr[j].to_string()).unwrap();\n\
    \   |                               ^^^^^^^^ function or associated item not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_by_key(|x| x.clone());\n    arr.reverse();\n\
    \    let mut ans = Vec::new();\n    for elem in &arr {\n        if elem < 10 {\n\
    \            ans.push(String::from(\"One\"));\n        } else if elem < 100 {\n\
    \            ans.push(String::from(\"Two\"));\n        } else if elem < 1000 {\n\
    \            ans.push(String::from(\"Three\"));\n        } else if elem < 10000\
    \ {\n            ans.push(String::from(\"Four\"));\n        } else if elem < 100000\
    \ {\n            ans.push(String::from(\"Five\"));\n        } else if elem < 1000000\
    \ {\n            ans.push(String::from(\"Six\"));\n        } else if elem < 10000000\
    \ {\n            ans.push(String::from(\"Seven\"));\n        } else if elem <\
    \ 100000000 {\n            ans.push(String::from(\"Eight\"));\n        } else\
    \ if elem < 1000000000 {\n            ans.push(String::from(\"Nine\"));\n    \
    \    } else {\n            ans.push(String::from(\"???\"));\n        }\n    }\n\
    \    ans\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpli8ngduy.rs:22:19\n   |\n\
    22 |         if elem < 10 {\n   |                   ^^\n   |                 \
    \  |\n   |                   expected `&isize`, found integer\n   |          \
    \         help: consider borrowing here: `&10`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpli8ngduy.rs:24:26\n   |\n24 |         } else if elem < 100 {\n\
    \   |                          ^^^\n   |                          |\n   |    \
    \                      expected `&isize`, found integer\n   |                \
    \          help: consider borrowing here: `&100`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpli8ngduy.rs:26:26\n   |\n26 |         } else if elem < 1000 {\n\
    \   |                          ^^^^\n   |                          |\n   |   \
    \                       expected `&isize`, found integer\n   |               \
    \           help: consider borrowing here: `&1000`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpli8ngduy.rs:28:26\n   |\n28 |         } else if elem <\
    \ 10000 {\n   |                          ^^^^^\n   |                         \
    \ |\n   |                          expected `&isize`, found integer\n   |    \
    \                      help: consider borrowing here: `&10000`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpli8ngduy.rs:30:26\n   |\n30 |         } else\
    \ if elem < 100000 {\n   |                          ^^^^^^\n   |             \
    \             |\n   |                          expected `&isize`, found integer\n\
    \   |                          help: consider borrowing here: `&100000`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpli8ngduy.rs:32:26\n   |\n32 |         } else\
    \ if elem < 1000000 {\n   |                          ^^^^^^^\n   |           \
    \               |\n   |                          expected `&isize`, found integer\n\
    \   |                          help: consider borrowing here: `&1000000`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpli8ngduy.rs:34:26\n   |\n34 |         } else\
    \ if elem < 10000000 {\n   |                          ^^^^^^^^\n   |         \
    \                 |\n   |                          expected `&isize`, found integer\n\
    \ "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort().reverse().iter().map(|n| {\n        match n\
    \ % 10 {\n            0 => \"Zero\".to_string(),\n            1 => \"One\".to_string(),\n\
    \            2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(\"Not a strange number {}\", n),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpg_78v_90.rs:18:16\n   |\n18 |     arr.sort().reverse().iter().map(|n|\
    \ {\n   |                ^^^^^^^ method not found in `()`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr\n        .iter()\n        .filter(|&i| 1 <= i && i\
    \ <= 9)\n        .cloned()\n        .sort_by_key(|x| x.to_digit(10))\n       \
    \ .reversed()\n        .map(|x| format!(\"{}\", x))\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpendbd6zr.rs:20:24\n\
    \   |\n20 |         .filter(|&i| 1 <= i && i <= 9)\n   |                     \
    \   ^^ no implementation for `isize < &isize` and `isize > &isize`\n   |\n   =\
    \ help: the trait `PartialOrd<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialOrd<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpendbd6zr.rs:20:37\n   |\n20 |\
    \         .filter(|&i| 1 <= i && i <= 9)\n   |                               \
    \      ^\n   |                                     |\n   |                   \
    \                  expected `&isize`, found integer\n   |                    \
    \                 help: consider borrowing here: `&9`\n\nerror[E0599]: no method\
    \ named `sort_by_key` found for struct `Cloned` in the current scope\n  --> /tmp/tmpendbd6zr.rs:22:10\n\
    \   |\n22 |         .sort_by_key(|x| x.to_digit(10))\n   |          ^^^^^^^^^^^\
    \ method not found in `Cloned<Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpendbd6zr.rs:20:17:\
    \ 20:38]>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        a.cmp(b)\n    });\n    sorted.reverse();\n    let mut result =\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"];\n    let mut index = 0;\n    for val in sorted {\n       \
    \ if index < result.len() {\n            result[index] = &result[index] + \" \"\
    \ + to_name(val);\n        }\n        index += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_name` in this scope\n  --> /tmp/tmphmsnbwec.rs:27:52\n\
    \   |\n27 |             result[index] = &result[index] + \" \" + to_name(val);\n\
    \   |                                                    ^^^^^^^ not found in\
    \ this scope\n\nerror[E0369]: cannot add `&str` to `&&str`\n  --> /tmp/tmphmsnbwec.rs:27:44\n\
    \   |\n27 |             result[index] = &result[index] + \" \" + to_name(val);\n\
    \   |                             -------------- ^ --- &str\n   |            \
    \                 |\n   |                             &&str\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphmsnbwec.rs:31:5\n   |\n17 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n31 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut arr = arr.clone();\n    let mut len = arr.len();\n    loop {\n  \
    \      let min = arr.iter().min().unwrap();\n        let max = arr.iter().max().unwrap();\n\
    \        if min == 1 || max == 9 {\n            // if min == 1 and max == 9\n\
    \            arr.retain(|i| i < 1 || i > 9);\n            arr.sort_unstable();\n\
    \            arr.reverse();\n            arr.iter().for_each(|i| if i == 1 { write!(&mut\
    \ arr, \"One\") } else { write!(&mut arr, \"Two\") });\n            arr.retain(|i|\
    \ i < 1 || i > 9);\n        }\n        if len == arr.len() {\n            break;\n\
    \        }\n        len = arr.len();\n    }\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpgxkm25d6.rs:26:16\n\
    \   |\n26 |         if min == 1 || max == 9 {\n   |                ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpgxkm25d6.rs:26:28\n   |\n26 |         if min\
    \ == 1 || max == 9 {\n   |                            ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgxkm25d6.rs:28:32\n   |\n28 |             arr.retain(|i| i < 1 || i\
    \ > 9);\n   |                                ^\n   |                         \
    \       |\n   |                                expected `&isize`, found integer\n\
    \   |                                help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgxkm25d6.rs:28:41\n   |\n28 |             arr.retain(|i|\
    \ i < 1 || i > 9);\n   |                                         ^\n   |     \
    \                                    |\n   |                                 \
    \        expected `&isize`, found integer\n   |                              \
    \           help: consider borrowing here: `&9`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpgxkm25d6.rs:31:42\n   |\n31 |     \
    \        arr.iter().for_each(|i| if i == 1 { write!(&mut arr, \"One\") } else\
    \ { write!(&mut arr, \"Two\") });\n   |                                      \
    \    ^^ no implementation for `&isize == {integer}`\n   |\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    for num in\
    \ arr {\n        let mut res = String::new();\n        res.push_str(one_digit(num));\n\
    \        result.push(res);\n    }\n    result.reverse();\n    let mut res: Vec<String>\
    \ = vec![];\n    for r in result {\n        res.push_str(r[r.len() - 1].to_string());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `one_digit` in this scope\n  --> /tmp/tmpku95eoe0.rs:21:22\n\
    \   |\n21 |         res.push_str(one_digit(num));\n   |                      ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `push_str` found for\
    \ struct `Vec<String>` in the current scope\n  --> /tmp/tmpku95eoe0.rs:27:13\n\
    \   |\n27 |         res.push_str(r[r.len() - 1].to_string());\n   |          \
    \   ^^^^^^^^ help: there is an associated function with a similar name: `push`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpku95eoe0.rs:27:22\n\
    \   |\n27 |         res.push_str(r[r.len() - 1].to_string());\n   |          \
    \            ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ret: Vec<String> = Vec::new();\n    let mut tmp:\
    \ Vec<isize> = Vec::new();\n    for num in arr.iter().rev() {\n        if num\
    \ < 1 || num > 9 {\n            continue;\n        }\n        tmp.push(num);\n\
    \    }\n    while !tmp.is_empty() {\n        let mut tmp2: Vec<isize> = Vec::new();\n\
    \        let mut num = 0;\n        while !tmp.is_empty() {\n            num =\
    \ tmp.pop();\n            tmp2.push(num);\n        }\n        let mut reversed:\
    \ Vec<isize> = tmp2.iter().cloned()\n            .rev()\n            .collect();\n\
    \        let mut num2 = 0;\n        let mut first = true;\n        while !reversed.is_empty()\
    \ {\n            let mut num3 = reversed.pop();\n            ret.push(first\n\
    \                ? \"One\"\n                : \"Two\"\n                + \"Three\"\
    \n                + \"Four\"\n                + \"Five\"\n                + \"\
    Six\"\n                + \"Seven\"\n                + \"Eight\"\n            \
    \    + \"Nine\"\n                + &num3.to_string());\n            first = false;\n\
    \            num2 = num3;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `\"One\"\
    `\n  --> /tmp/tmpinlx14b6.rs:41:19\n   |\n41 |                 ? \"One\"\n   |\
    \                   ^^^^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \nerror: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `...`, `.`, `;`, `<`,\
    \ `?`, `[`, `_`, `async`, `const`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`,\
    \ `}`, `~`, an operator, lifetime, or path, found `\"Two\"`\n  --> /tmp/tmpinlx14b6.rs:42:19\n\
    \   |\n42 |                 : \"Two\"\n   |                   ^^^^^ expected one\
    \ of 26 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpinlx14b6.rs:21:18\n\
    \   |\n21 |         if num < 1 || num > 9 {\n   |                  ^\n   |   \
    \               |\n   |                  expected `&isize`, found integer\n  \
    \ |                  help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpinlx14b6.rs:21:29\n   |\n21 |         if num < 1 || num\
    \ > 9 {\n   |                             ^\n   |                            \
    \ |\n   |                             expected `&isize`, found integer\n   | \
    \                            help: consider borrowing here: `&9`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpinlx14b6.rs:24:18\n   |\n24 |         tmp.push(num);\n\
    \   |                  ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |         tmp.push(*num);\n   |         \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpinlx14b6.rs:30:19\n\
    \   |\n28 |         let mut num = 0;\n   |                       - expected due\
    \ to this value\n29 |         while !tmp.is_empty() {\n30 |             num =\
    \ tmp.pop();\n   |                   ^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort().reverse();\n    let mut new_arr = Vec::new();\n\
    \    for x in arr {\n        let mut new_x = x;\n        let mut pos = &new_x;\n\
    \        match x % 10 {\n            1 => new_x /= 10,\n            2 => new_x\
    \ /= 10,\n            3 => new_x /= 10,\n            4 => new_x /= 10,\n     \
    \       5 => new_x /= 10,\n            6 => new_x /= 10,\n            7 => new_x\
    \ /= 10,\n            8 => new_x /= 10,\n            9 => new_x /= 10,\n     \
    \       _ => continue,\n        };\n        *pos = by_letter_of(new_x);\n    \
    \    new_arr.push(format!(\"{}\", new_x));\n    }\n    new_arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_letter_of` in this scope\n  -->\
    \ /tmp/tmpcxtoxppn.rs:35:16\n   |\n35 |         *pos = by_letter_of(new_x);\n\
    \   |                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no\
    \ method named `reverse` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpcxtoxppn.rs:18:16\n   |\n18 |     arr.sort().reverse();\n   |      \
    \          ^^^^^^^ method not found in `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() < 1 {\n        return vec![];\n    }\n\n\
    \    if arr.len() == 1 {\n        return vec![\n            \"One\"\n        ];\n\
    \    }\n\n    if arr.len() == 2 {\n        return vec![\n            \"Two\",\n\
    \            \"One\"\n        ];\n    }\n\n    if arr.len() == 3 {\n        return\
    \ vec![\n            \"Three\",\n            \"Two\",\n            \"One\"\n \
    \       ];\n    }\n\n    if arr.len() == 4 {\n        return vec![\n         \
    \   \"Four\",\n            \"Three\",\n            \"Two\",\n            \"One\"\
    \n        ];\n    }\n\n    if arr.len() == 5 {\n        return vec![\n       \
    \     \"Five\",\n            \"Four\",\n            \"Three\",\n            \"\
    Two\",\n            \"One\"\n        ];\n    }\n\n    if arr.len() == 6 {\n  \
    \      return vec![\n            \"Six\",\n            \"Five\",\n           \
    \ \"Four\",\n            \"Three\",\n            \"Two\",\n            \"One\"\
    \n        ];\n    }\n\n    if arr.len() == 7 {\n        return vec![\n       \
    \     \"Seven\",\n            \"Six\",\n            \"Five\",\n            \"\
    Four\",\n            \"Three\",\n            \"Two\",\n            \"One\"\n \
    \       ];\n    }\n\n    if arr.len() == 8 {\n        return vec![\n         \
    \   \"Eight\",\n            \"Seven\",\n            \"Six\",\n            \"Five\"\
    ,\n            \"Four\",\n            \"Three\",\n            \"Two\",\n     \
    \       \"One\"\n        ];\n    }\n\n    if arr.len() == 9 {\n        return\
    \ vec![\n            \"Nine\",\n            \"Eight\",\n            \"Seven\"\
    ,\n            \"Six\",\n            \"Five\",\n            \"Four\",\n      \
    \      \"Three\",\n            \"Two\",\n            \"One\"\n        ];\n   \
    \ }\n\n    return vec![\n        \"One\",\n        \"Two\",\n        \"Three\"\
    ,\n        \"Four\",\n        \"Five\",\n        \"Six\",\n        \"Seven\",\n\
    \        \"Eight\",\n        \"Nine\",\n    ];\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:24:13\n   |\n\
    24 |             \"One\"\n   |             ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |             |\n   |             expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:30:13\n\
    \   |\n30 |             \"Two\",\n   |             ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |             |\n   |             expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:37:13\n\
    \   |\n37 |             \"Three\",\n   |             ^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |             |\n   |             expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:45:13\n\
    \   |\n45 |             \"Four\",\n   |             ^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |             |\n   |             expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:54:13\n\
    \   |\n54 |             \"Five\",\n   |             ^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |             |\n   |             expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:64:13\n\
    \   |\n64 |             \"Six\",\n   |             ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |             |\n   |             expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:75:13\n\
    \   |\n75 |             \"Seven\",\n   |             ^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |             |\n   |             expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0zi8z77.rs:87:13\n\
    \   |\n87 |             \"Eight\",\n   |             ^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |             |\n   |             expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp_0zi8z77.rs:100:13\n\
    \    |\n100 |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    arr.sort();\n    let mut arr = arr.rev();\n    let mut result: Vec<String>\
    \ = vec![];\n    for i in arr {\n        if i <= 9 {\n            result.push(format!(\"\
    One\", i));\n        } else if i <= 99 {\n            result.push(format!(\"Two\"\
    , i - 10));\n        } else if i <= 999 {\n            result.push(format!(\"\
    Three\", i - 100));\n        } else if i <= 9999 {\n            result.push(format!(\"\
    Four\", i - 1000));\n        } else if i <= 99999999 {\n            result.push(format!(\"\
    Five\", i - 10000));\n        } else if i <= 999999999 {\n            result.push(format!(\"\
    Six\", i - 100000));\n        } else if i <= 99999999999 {\n            result.push(format!(\"\
    Seven\", i - 1000000));\n        } else if i <= 999999999999 {\n            result.push(format!(\"\
    Eight\", i - 10000000));\n        } else if i <= 99999999999999 {\n          \
    \  result.push(format!(\"Nine\", i - 1000000000));\n        } else {\n       \
    \     assert!(false);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmpk79_mc0d.rs:27:40\n   |\n27 |\
    \             result.push(format!(\"One\", i));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpk79_mc0d.rs:29:40\n   |\n29 |             result.push(format!(\"\
    Two\", i - 10));\n   |                                 -----  ^^^^^^ argument\
    \ never used\n   |                                 |\n   |                   \
    \              formatting specifier missing\n\nerror: argument never used\n  -->\
    \ /tmp/tmpk79_mc0d.rs:31:42\n   |\n31 |             result.push(format!(\"Three\"\
    , i - 100));\n   |                                 -------  ^^^^^^^ argument never\
    \ used\n   |                                 |\n   |                         \
    \        formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpk79_mc0d.rs:33:41\n\
    \   |\n33 |             result.push(format!(\"Four\", i - 1000));\n   |      \
    \                           ------  ^^^^^^^^ argument never used\n   |       \
    \                          |\n   |                                 formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpk79_mc0d.rs:35:41\n\
    \   |\n35 |             result.push(format!(\"Five\", i - 10000));\n   |     \
    \                            ------  ^^^^^^^^^ argument never used\n   |     \
    \                            |\n   |                                 formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpk79_mc0d.rs:37:40\n\
    \   |\n37 |             result.push(format!(\"Six\", i - 100000));\n   |     \
    \                            -----  ^^^^^^^^^^ argument never used\n   |     \
    \                            |\n   |                                 formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpk79_mc0d.rs:39:42\n\
    \   |\n39 |             result.push(format!(\"Seven\", i - 1000000));\n   |  \
    \                               -------  ^^^^^^^^^^^ argument never used\n   |\
    \                                 |\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter().map(|x| x % 10).rev().map(|x| {\n        match\
    \ x {\n            0 => \"Zero\",\n            1 => \"One\",\n            2 =>\
    \ \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n        \
    \    5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n\
    \            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"\
    Unexpected element {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpwiad2_xv.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut result = vec![\"One\"];\n    for i in arr {\n        if i < 1 || i\
    \ > 9 {\n            continue;\n        }\n        result.push(by_digit(i));\n\
    \    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp6nqo70dv.rs:26:21\n\
    \   |\n26 |         result.push(by_digit(i));\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6nqo70dv.rs:29:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    use std::cmp::Ordering;\n    let mut reversed: Vec<String>\
    \ = Vec::new();\n    if arr.is_empty() {\n        return reversed;\n    }\n  \
    \  for &x in arr {\n        let index = x.saturating_add((10 * (arr.len() - x.saturating_sub(1)))\
    \ as usize);\n        match index {\n            0 => reversed.push(\"One\"),\n\
    \            1 => reversed.push(\"Two\"),\n            2 => reversed.push(\"Three\"\
    ),\n            3 => reversed.push(\"Four\"),\n            4 => reversed.push(\"\
    Five\"),\n            5 => reversed.push(\"Six\"),\n            6 => reversed.push(\"\
    Seven\"),\n            7 => reversed.push(\"Eight\"),\n            8 => reversed.push(\"\
    Nine\"),\n            _ => unreachable!(),\n        }\n    }\n    reversed.reverse();\n\
    \    return reversed\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpnlv0xtr3.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnlv0xtr3.rs:23:9\n   |\n23 |     for &x in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlv0xtr3.rs:26:32\n\
    \   |\n26 |             0 => reversed.push(\"One\"),\n   |                   \
    \             ^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                                |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlv0xtr3.rs:27:32\n\
    \   |\n27 |             1 => reversed.push(\"Two\"),\n   |                   \
    \             ^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                                |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlv0xtr3.rs:28:32\n\
    \   |\n28 |             2 => reversed.push(\"Three\"),\n   |                 \
    \               ^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlv0xtr3.rs:29:32\n\
    \   |\n29 |             3 => reversed.push(\"Four\"),\n   |                  \
    \              ^^^^^^- help: try using a conversion method: `.to_string()`\n \
    \  |                                |\n   |                                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlv0xtr3.rs:30:32\n\
    \   |\n30 |             4 => reversed.push(\"Five\"),\n   |                  \
    \              ^^^^^^- help: try using a conversion method: `."
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort_by_key(|x| {\n        let mut len = 0\n     \
    \   while x < 10 {\n            len += 1;\n            x *= 10;\n        }\n \
    \       len\n    })\n    .reverse_iter().map(|x| {\n        let mut s = String::new();\n\
    \        for x in (0..9).rev() {\n            s.push_str(&format!(\"{}\", x));\n\
    \        }\n        s\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `while`\n  --> /tmp/tmpnyrg09ih.rs:19:24\n\
    \   |\n19 |         let mut len = 0\n   |                        ^ help: add `;`\
    \ here\n20 |         while x < 10 {\n   |         ----- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnyrg09ih.rs:20:19\n   |\n20 |         while\
    \ x < 10 {\n   |                   ^^\n   |                   |\n   |        \
    \           expected `&isize`, found integer\n   |                   help: consider\
    \ borrowing here: `&10`\n\nerror[E0368]: binary assignment operation `*=` cannot\
    \ be applied to type `&isize`\n  --> /tmp/tmpnyrg09ih.rs:22:13\n   |\n22 |   \
    \          x *= 10;\n   |             -^^^^^^\n   |             |\n   |      \
    \       cannot use `*=` on type `&isize`\n   |\nhelp: `*=` can be used on `isize`,\
    \ you can dereference `x`\n   |\n22 |             *x *= 10;\n   |            \
    \ +\n\nerror[E0599]: no method named `reverse_iter` found for unit type `()` in\
    \ the current scope\n  --> /tmp/tmpnyrg09ih.rs:26:6\n   |\n26 |     .reverse_iter().map(|x|\
    \ {\n   |      ^^^^^^^^^^^^ method not found in `()`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut list = Vec::new();\n    list.resize(9, String::new());\n\
    \    \n    for x in arr {\n        if 1 <= x <= 9 {\n            list[x].push(\"\
    One\");\n        } else if x > 9 {\n            list[x].push(\"Five\");\n    \
    \    }\n    }\n    list.resize(9, String::new());\n    for i in 0..(9..=arr.len())\
    \ {\n        let (j, v) = list.iter().enumerate().find(|(_, v)| v == &arr[..i]);\n\
    \        if j != None {\n            list[j].push(\"Nine\");\n        }\n    }\n\
    \    list.resize(9, String::new());\n    \n    for v in &list {\n        v.resize(3,\
    \ String::new());\n        v[v.len()-1] = \"Eight\";\n        v[v.len()-2] = \"\
    Six\";\n        v[v.len()-3] = \"Five\";\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpt87tkgre.rs:22:14\n\
    \   |\n22 |         if 1 <= x <= 9 {\n   |              ^^   ^^\n   |\nhelp: split\
    \ the comparison into two\n   |\n22 |         if 1 <= x && x <= 9 {\n   |    \
    \               ++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt87tkgre.rs:22:22\n\
    \   |\n22 |         if 1 <= x <= 9 {\n   |                      ^ expected `bool`,\
    \ found integer\n\nerror[E0277]: the type `[String]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpt87tkgre.rs:23:13\n   |\n23 |             list[x].push(\"One\"\
    );\n   |             ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[String]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmpt87tkgre.rs:25:13\n\
    \   |\n25 |             list[x].push(\"Five\");\n   |             ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt87tkgre.rs:29:17\n   |\n29 |     for i in 0..(9..=arr.len())\
    \ {\n   |                 ^^^^^^^^^^^^^^^ expected integer, found struct `RangeInclusive`\n\
    \   |\n   = note: expected type `{integer}`\n            found struct `RangeInclusive<usize>`\n\
    \nerror[E0277]: can't compare `&String` with `[isize]`\n  --> /tmp/tmpt87tkgre.rs:30:62\n\
    \   |\n30 |         let (j, v) = list.iter().enumerate().find(|(_, v)| v == &arr[..i]);\n\
    \   |                                                              ^^ no implementation\
    \ for `&String == [isize]`\n   |\n   = help: the trait `PartialEq<[isize]>` is\
    \ not implemented for `&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \    if arr.is_empty() {\n        vec![]\n    } else if arr.len() < 9 {\n    \
    \    vec![]\n    } else {\n        let len = arr.len() as isize;\n        let\
    \ mut count = 0;\n        let mut name = String::from(\"One\");\n        for i\
    \ in 0..len {\n            if arr[i] < 1 || arr[i] > 9 {\n                continue;\n\
    \            }\n            let new_count = (arr[i] - 1) as isize + count;\n \
    \           count = new_count as isize;\n            name = format!(\"{}{}\",\
    \ name, digits[new_count]);\n        }\n        vec![String::from(name)]\n   \
    \ }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digits` in this scope\n  --> /tmp/tmpumu3gptl.rs:33:42\n\
    \   |\n33 |             name = format!(\"{}{}\", name, digits[new_count]);\n \
    \  |                                          ^^^^^^ not found in this scope\n\
    \nerror[E0282]: type annotations needed\n  --> /tmp/tmpumu3gptl.rs:19:8\n   |\n\
    18 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n   |  \
    \       ------- consider giving `arr` a type\n19 |     if arr.is_empty() {\n \
    \  |        ^^^ cannot infer type\n   |\n   = note: type must be known at this\
    \ point\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let mut nums = arr;\n  \
    \  nums.sort_unstable_by_key(|&x| x);\n    for i in 0..nums.len() - 1 {\n    \
    \    result.push((nums[i] - 1).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"0\", \"0\", \"1\", \"1\", \"2\", \"3\", \"4\"]`,\n right: `[\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp0_err1og.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let mut digits = String::new();\n    let mut reverse = String::new();\n \
    \   let mut count = 0;\n\n    arr.sort_by_key(|x| {\n        if x > 1 && x < 9\
    \ {\n            count++;\n            digits.push_str(format!(\"{}\", x));\n\
    \        }\n        String::from_str(&digits[..count]).unwrap()\n    });\n\n \
    \   digits.reverse();\n\n    reverse.push_str(&digits[..count]);\n\n    reverse.chars().map(|x|\
    \ {\n        match x {\n            '0' => String::from(\"Zero\"),\n         \
    \   '1' => String::from(\"One\"),\n            '2' => String::from(\"Two\"),\n\
    \            '3' => String::from(\"Three\"),\n            '4' => String::from(\"\
    Four\"),\n            '5' => String::from(\"Five\"),\n            '6' => String::from(\"\
    Six\"),\n            '7' => String::from(\"Seven\"),\n            '8' => String::from(\"\
    Eight\"),\n            '9' => String::from(\"Nine\"),\n            _ => unreachable!(),\n\
    \        }\n    }).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_e48c9nc.rs:28:18\n\
    \   |\n28 |             count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |             { let tmp =\
    \ count; count += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    28 -             count++;\n28 +             count += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_e48c9nc.rs:27:16\n   |\n27 |         if x >\
    \ 1 && x < 9 {\n   |                ^\n   |                |\n   |           \
    \     expected `&isize`, found integer\n   |                help: consider borrowing\
    \ here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_e48c9nc.rs:27:25\n\
    \   |\n27 |         if x > 1 && x < 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0599]: no function or associated item named `from_str` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp_e48c9nc.rs:31:17\n   |\n31 | \
    \        String::from_str(&digits[..count]).unwrap()\n   |                 ^^^^^^^^\
    \ function or associated item not found in `String`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::str::FromStr;\n   |\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp_e48c9nc.rs:34:12\n   |\n\
    34 |     digits.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.sort();\n    let mut reversed = arr.clone();\n   \
    \ reversed.reverse();\n    let mut result: Vec<String> = Vec::new();\n    for\
    \ i in rev {\n        result.push(by_name(i).unwrap_or(\"One\"));\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `rev` in this scope\n  --> /tmp/tmpvin6lexa.rs:22:14\n\
    \   |\n22 |     for i in rev {\n   |              ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmpvin6lexa.rs:23:21\n\
    \   |\n23 |         result.push(by_name(i).unwrap_or(\"One\"));\n   |        \
    \             ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    \n    // sort by length from longest to shortest\n   \
    \ arr.sort_by(|a, b| a.cmp(b).reverse());\n\n    // reverse the order\n    arr.reverse();\n\
    \n    // get string from index 1 to 10\n    arr.rev().iter().map(|&num| {\n  \
    \      if num == 0 || num == 1 {\n            return String::from(&name);\n  \
    \      }\n        if num == 2 || num == 3 {\n            return String::from(&name2);\n\
    \        }\n        if num == 4 || num == 5 {\n            return String::from(&name3);\n\
    \        }\n        if num == 6 || num == 7 {\n            return String::from(&name4);\n\
    \        }\n        if num == 8 || num == 9 {\n            return String::from(&name5);\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmp650euhjl.rs:28:34\n\
    \   |\n28 |             return String::from(&name);\n   |                    \
    \              ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `name2` in this scope\n  --> /tmp/tmp650euhjl.rs:31:34\n   |\n31 |         \
    \    return String::from(&name2);\n   |                                  ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `name3` in this scope\n\
    \  --> /tmp/tmp650euhjl.rs:34:34\n   |\n34 |             return String::from(&name3);\n\
    \   |                                  ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `name4` in this scope\n  --> /tmp/tmp650euhjl.rs:37:34\n \
    \  |\n37 |             return String::from(&name4);\n   |                    \
    \              ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `name5` in this scope\n  --> /tmp/tmp650euhjl.rs:40:34\n   |\n40 |         \
    \    return String::from(&name5);\n   |                                  ^^^^^\
    \ not found in this scope\n\nerror[E0599]: `Vec<isize>` is not an iterator\n \
    \  --> /tmp/tmp650euhjl.rs:26:9\n    |\n26  |       arr.rev().iter().map(|&num|\
    \ {\n    |           ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        vec![]\n    }\n    else {\n\
    \        let mut counter = vec![0; 10];\n        let mut reversed = vec![0; 10];\n\
    \        let mut str: Vec<String> = vec![];\n        let mut current = arr[0];\n\
    \        for num in arr {\n            counter[num as usize]++;\n            if\
    \ counter[num as usize] == 1 {\n                str.push((num as usize).to_string());\n\
    \            } else {\n                let index = num as usize - 1;\n       \
    \         reversed[index] = current;\n                current = num;\n       \
    \     }\n        }\n        str.push((current as usize).to_string());\n      \
    \  reversed.reverse();\n        for index in 0..10 {\n            let n = index\
    \ as usize;\n            let name = format!(\"{}\", n);\n            str[index]\
    \ = name;\n        }\n        str\n    }\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpss_u7j20.rs:27:34\n\
    \   |\n27 |             counter[num as usize]++;\n   |                       \
    \           ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n27 |             { let tmp = counter[num as usize]; counter[num as usize]\
    \ += 1; tmp };\n   |             +++++++++++                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    27 -             counter[num as usize]++;\n27 +             counter[num as usize]\
    \ += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        if arr[i] < 1 && arr[i] > 9 {\n            break;\n \
    \       }\n        let mut last = i;\n        let mut count = 0;\n        while\
    \ last < arr.len() && arr[last] > arr[i] {\n            count += 1;\n        \
    \    last += 1;\n        }\n        let mut j = last;\n        while j > 0 &&\
    \ arr[j] < arr[i] {\n            j -= 1;\n        }\n        res.push((&arr[last..j]).map(|x|\
    \ digit2name[x - 1]).collect::<String>());\n        i += count - 1;\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digit2name` in this scope\n  --> /tmp/tmpgfq6y_8d.rs:34:42\n\
    \   |\n34 |         res.push((&arr[last..j]).map(|x| digit2name[x - 1]).collect::<String>());\n\
    \   |                                          ^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: `&[isize]` is not an iterator\n  --> /tmp/tmpgfq6y_8d.rs:34:34\n\
    \   |\n34 |         res.push((&arr[last..j]).map(|x| digit2name[x - 1]).collect::<String>());\n\
    \   |                                  ^^^ `&[isize]` is not an iterator; try\
    \ calling `.iter()`\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&[isize]: Iterator`\n           which is required by `&mut &[isize]:\
    \ Iterator`\n           `[isize]: Iterator`\n           which is required by `&mut\
    \ [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut temp = vec![String::new(), String::new(), String::new(), String::new(),\
    \ String::new(), String::new(), String::new(), String::new(), String::new()];\n\
    \    let mut count = 0;\n\n    for x in arr {\n        if x % 10 > 9 {\n     \
    \       count += 1;\n            temp[count].push_str(&by_length_digit[x - 10]);\n\
    \        } else {\n            count += 1;\n            temp[count].push_str(&by_length_digit[x\
    \ - 1]);\n        }\n    }\n\n    for x in 0..count {\n        temp[count].push(',');\n\
    \    }\n\n    temp[0].push_str(\"One\");\n    temp[1].push_str(\"Two\");\n   \
    \ temp[2].push_str(\"Three\");\n    temp[3].push_str(\"Four\");\n    temp[4].push_str(\"\
    Five\");\n    temp[5].push_str(\"Six\");\n    temp[6].push_str(\"Seven\");\n \
    \   temp[7].push_str(\"Eight\");\n    temp[8].push_str(\"Nine\");\n\n    temp\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `by_length_digit` in this scope\n  -->\
    \ /tmp/tmps4yj885l.rs:28:35\n   |\n28 |             temp[count].push_str(&by_length_digit[x\
    \ - 10]);\n   |                                   ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `by_length_digit` in this scope\n\
    \  --> /tmp/tmps4yj885l.rs:31:35\n   |\n31 |             temp[count].push_str(&by_length_digit[x\
    \ - 1]);\n   |                                   ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    if arr.len()\
    \ == 0 {\n        return result;\n    }\n    let mut number = 0;\n    let mut\
    \ i = arr.len();\n    while i > 0{\n        let n = arr.remove(i).unwrap();\n\
    \        number *= 10;\n        number += n;\n        if (number >= 1) && (number\
    \ <= 9) {\n            i = i - 1;\n        }\n        else {\n            result.push((number\
    \ - 1) as char);\n            number = 0;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpvxww3gy_.rs:25:31\n   |\n25 |         let n = arr.remove(i).unwrap();\n\
    \   |                               ^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvxww3gy_.rs:32:25\n   |\n32 |             result.push((number\
    \ - 1) as char);\n   |                         ^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\nhelp: try using a conversion method\n   |\n32\
    \ |             result.push(((number - 1) as char).to_string());\n   |       \
    \                  +                    +++++++++++++\n\nerror[E0604]: only `u8`\
    \ can be cast as `char`, not `{integer}`\n  --> /tmp/tmpvxww3gy_.rs:32:25\n  \
    \ |\n32 |             result.push((number - 1) as char);\n   |               \
    \          ^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpvxww3gy_.rs:32:25\n   |\n32 |         \
    \    result.push((number - 1) as char);\n   |                         ^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0604.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.clone();\n    let mut reversed_arr =\
    \ arr.clone();\n    arr.sort();\n    reversed_arr.reverse();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmptxalm8mv.rs:35:8\n     |\n35 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut digits = String::new();\n    let mut reverse = String::new();\n \
    \   let mut i = 0;\n    let mut j = arr.len();\n    while i < j {\n        if\
    \ arr[i] > 9 {\n            let tmp = &arr[i..j];\n            let len = tmp.len();\n\
    \            let mut result = String::new();\n            for i in 0..len {\n\
    \                if tmp[i] > 9 {\n                    result.append(&arr[i - len..i]);\n\
    \                    break;\n                }\n                result.append_str(&ones[tmp[i]\
    \ - 10]);\n            }\n            i += len;\n            j -= len;\n     \
    \       continue;\n        }\n        digits.append(&arr[i .. (i + 1)].to_string());\n\
    \        i += 1;\n    }\n    let mut reverse = digits.clone();\n    reverse.insert(0,\
    \ &ones[(reverse[0].parse::<isize>().unwrap() as isize) - 10]);\n    reverse =\
    \ reverse.reverse();\n    reverse.extend_from_slice(&digits);\n    reverse\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ones` in this scope\n  --> /tmp/tmp24n783xh.rs:35:36\n\
    \   |\n35 |                 result.append_str(&ones[tmp[i] - 10]);\n   |     \
    \                               ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ones` in this scope\n  --> /tmp/tmp24n783xh.rs:45:24\n  \
    \ |\n45 |     reverse.insert(0, &ones[(reverse[0].parse::<isize>().unwrap() as\
    \ isize) - 10]);\n   |                        ^^^^ not found in this scope\n\n\
    error[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp24n783xh.rs:32:28\n   |\n32 |                     result.append(&arr[i\
    \ - len..i]);\n   |                            ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `append_str` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp24n783xh.rs:35:24\n   |\n35 |                 result.append_str(&ones[tmp[i]\
    \ - 10]);\n   |                        ^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `as_str`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp24n783xh.rs:41:16\n\
    \   |\n41 |         digits.append(&arr[i .. (i + 1)].to_string());\n   |     \
    \           ^^^^^^ method not found in `String`\n\nerror[E0599]: `[isize]` doesn't\
    \ implement `std::fmt::Display`\n  --> /tmp/tmp24n783xh.rs:41:42\n   |\n41 | \
    \        digits.append(&arr[i .. (i + 1)].to_string());\n   |                \
    \                          ^^^^^^^^^ `[isize]` cannot be formatted with the default\
    \ formatter\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[isize]: std::fmt::Display`\n           which is required by `[isize]:\
    \ ToString`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp24n783xh.rs:45:30\n   |\n45 |     reverse.insert(0, &ones[(reverse[0].parse::<isize>().unwrap()\
    \ as isize) - 10]);\n   |                              ^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the followin"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr2 = arr.clone();\n    arr2.sort();\n    arr2.reverse();\n    let\
    \ mut arr3 = vec![];\n    for i in arr2 {\n        if i >= 1 && i <= 9 {\n   \
    \         arr3.push(by_length_one[i]);\n        } else if i >= 10 && i <= 99 {\n\
    \            arr3.push(by_length_two[i]);\n        } else {\n            arr3.push(by_length_three[i]);\n\
    \        }\n    }\n    arr3\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `by_length_one` in this scope\n  --> /tmp/tmpg_x5ityv.rs:27:23\n\
    \   |\n27 |             arr3.push(by_length_one[i]);\n   |                   \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `by_length_two` in this scope\n  --> /tmp/tmpg_x5ityv.rs:29:23\n   |\n29 | \
    \            arr3.push(by_length_two[i]);\n   |                       ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `by_length_three`\
    \ in this scope\n  --> /tmp/tmpg_x5ityv.rs:31:23\n   |\n31 |             arr3.push(by_length_three[i]);\n\
    \   |                       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for i in arr {\n      \
    \  if i > 1 && i < 9 {\n            res.insert(0, str::from_str(\"One\")[i - 1].to_owned());\n\
    \        } else if i > 9 {\n            res.insert(0, str::from_str(\"Nine\")[i\
    \ - 9].to_owned());\n        } else if i < 1 {\n            res.insert(0, str::from_str(\"\
    One\")[i].to_owned());\n        } else {\n            res.insert(0, str::from_str(\"\
    Zero\")[i].to_owned());\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ type `str` in the current scope\n  --> /tmp/tmpfc7yql55.rs:21:32\n   |\n21 |\
    \             res.insert(0, str::from_str(\"One\")[i - 1].to_owned());\n   | \
    \                               ^^^^^^^^ function or associated item not found\
    \ in `str`\n\nerror[E0599]: no function or associated item named `from_str` found\
    \ for type `str` in the current scope\n  --> /tmp/tmpfc7yql55.rs:23:32\n   |\n\
    23 |             res.insert(0, str::from_str(\"Nine\")[i - 9].to_owned());\n \
    \  |                                ^^^^^^^^ function or associated item not found\
    \ in `str`\n\nerror[E0599]: no function or associated item named `from_str` found\
    \ for type `str` in the current scope\n  --> /tmp/tmpfc7yql55.rs:25:32\n   |\n\
    25 |             res.insert(0, str::from_str(\"One\")[i].to_owned());\n   |  \
    \                              ^^^^^^^^ function or associated item not found\
    \ in `str`\n\nerror[E0599]: no function or associated item named `from_str` found\
    \ for type `str` in the current scope\n  --> /tmp/tmpfc7yql55.rs:27:32\n   |\n\
    27 |             res.insert(0, str::from_str(\"Zero\")[i].to_owned());\n   | \
    \                               ^^^^^^^^ function or associated item not found\
    \ in `str`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    arr.sort();\n    arr.iter().filter(|x| x >= 1 && x <= 9).for_each(|x|{\n\
    \        arr.swap(arr.iter().position(|y| y >= 1 && y <= 9).unwrap(), x);\n  \
    \  });\n    arr.sort_unstable();\n    let mut names: Vec<String> = vec![];\n \
    \   for &x in arr {\n        let name = match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\".to_string(),\n        };\n        names.push(name);\n    }\n    names\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrvwiz0j.rs:20:32\n   |\n\
    20 |     arr.iter().filter(|x| x >= 1 && x <= 9).for_each(|x|{\n   |         \
    \                       ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsrvwiz0j.rs:20:42\n   |\n20 |     arr.iter().filter(|x|\
    \ x >= 1 && x <= 9).for_each(|x|{\n   |                                      \
    \    ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpsrvwiz0j.rs:21:47\n   |\n21 |         arr.swap(arr.iter().position(|y|\
    \ y >= 1 && y <= 9).unwrap(), x);\n   |                                      \
    \         ^\n   |                                               |\n   |      \
    \                                         expected `&isize`, found integer\n \
    \  |                                               help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsrvwiz0j.rs:21:57\n  \
    \ |\n21 |         arr.swap(arr.iter().position(|y| y >= 1 && y <= 9).unwrap(),\
    \ x);\n   |                                                         ^\n   |  \
    \                                                       |\n   |              \
    \                                           expected `&isize`, found integer\n\
    \   |                                                         help: consider borrowing\
    \ here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsrvwiz0j.rs:21:70\n\
    \   |\n21 |         arr.swap(arr.iter().position(|y| y >= 1 && y <= 9).unwrap(),\
    \ x);\n   |                                                                  \
    \    ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsrvwiz0j.rs:25:9\n   |\n25 |     for &x in arr {\n   |         ^^  \
    \  --- this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: `match` arms have incompatible types\n\
    \  --> /tmp/tmpsrvwiz0j.rs:36:18\n   |\n26 |           let name = match x {\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut a = arr;\n    let mut reverse = a.clone();\n    // reverse the whole\
    \ array\n    let mut cur = 0;\n    while reverse.is_empty() {\n        reverse\
    \ = &a[cur..].iter().cloned().collect();\n        cur += 1;\n    }\n    reverse.reverse();\n\
    \n    debug_assert!(cur < 10);\n    let mut result = vec![];\n    for i in reverse\
    \ {\n        let mut result = vec![];\n        match i {\n            1 => result.push(\"\
    One\"),\n            2 => result.push(\"Two\"),\n            3 => result.push(\"\
    Three\"),\n            4 => result.push(\"Four\"),\n            5 => result.push(\"\
    Five\"),\n            6 => result.push(\"Six\"),\n            7 => result.push(\"\
    Seven\"),\n            8 => result.push(\"Eight\"),\n            9 => result.push(\"\
    Nine\"),\n            _ => return vec![],\n        };\n        result.push(i);\n\
    \        result.push(&a[0..cur].iter().cloned().collect());\n        cur += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbie41utj.rs:26:19\n   |\n\
    22 |     let mut reverse = a.clone();\n   |                       --------- expected\
    \ due to this value\n...\n26 |         reverse = &a[cur..].iter().cloned().collect();\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found reference\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n26 -         reverse\
    \ = &a[cur..].iter().cloned().collect();\n26 +         reverse = a[cur..].iter().cloned().collect();\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbie41utj.rs:47:21\n  \
    \ |\n47 |         result.push(i);\n   |                     ^ expected `&str`,\
    \ found `isize`\n\nerror[E0277]: a value of type `str` cannot be built from an\
    \ iterator over elements of type `isize`\n    --> /tmp/tmpbie41utj.rs:48:48\n\
    \     |\n48   |         result.push(&a[0..cur].iter().cloned().collect());\n \
    \    |                                                ^^^^^^^ value of type `str`\
    \ cannot be built from `std::iter::Iterator<Item=isize>`\n     |\n     = help:\
    \ the trait `FromIterator<isize>` is not implemented for `str`\n     = help: the\
    \ following other types implement trait `FromIterator<A>`:\n               <String\
    \ as FromIterator<&'a char>>\n               <String as FromIterator<&'a str>>\n\
    \               <String as FromIterator<Box<str>>>\n               <String as\
    \ FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr_size = arr.len();\n    let mut arr1 = Vec::new();\n\
    \    let mut arr2 = Vec::new();\n    let mut result: Vec<String> = Vec::new();\n\
    \n    for i in 0..arr_size {\n        if arr[i] >= 1 && arr[i] <= 9 {\n      \
    \      arr1.push(arr[arr[i] - 1]);\n        } else {\n            arr2.push(arr[arr[i]\
    \ - 1]);\n        }\n    }\n\n    for i in 0..(arr_size - 1) {\n        result.push(\"\
    One\");\n    }\n    for i in 0..(arr_size - 1) {\n        result.push(\"Two\"\
    );\n    }\n    for i in 0..(arr_size - 1) {\n        result.push(\"Three\");\n\
    \    }\n    for i in 0..(arr_size - 1) {\n        result.push(\"Four\");\n   \
    \ }\n    for i in 0..(arr_size - 1) {\n        result.push(\"Five\");\n    }\n\
    \    for i in 0..(arr_size - 1) {\n        result.push(\"Six\");\n    }\n    for\
    \ i in 0..(arr_size - 1) {\n        result.push(\"Seven\");\n    }\n    for i\
    \ in 0..(arr_size - 1) {\n        result.push(\"Eight\");\n    }\n    for i in\
    \ 0..(arr_size - 1) {\n        result.push(\"Nine\");\n    }\n    for i in 0..(arr_size\
    \ - 1) {\n        result.push(&arr1[arr1[i] - 1]);\n    }\n    for i in 0..(arr_size\
    \ - 1) {\n        result.push(&arr2[arr2[i] - 1]);\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprf179dfo.rs:25:23\n\
    \   |\n25 |             arr1.push(arr[arr[i] - 1]);\n   |                    \
    \   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprf179dfo.rs:27:23\n\
    \   |\n27 |             arr2.push(arr[arr[i] - 1]);\n   |                    \
    \   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprf179dfo.rs:32:21\n   |\n32 |\
    \         result.push(\"One\");\n   |                     ^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                     |\n   |      \
    \               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprf179dfo.rs:35:21\n   |\n35 |         result.push(\"Two\"\
    );\n   |                     ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprf179dfo.rs:38:21\n\
    \   |\n38 |         result.push(\"Three\");\n   |                     ^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |\n   |                     expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprf179dfo.rs:41:21\n   |\n41 |         result.push(\"\
    Four\");\n   |                     ^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                     |\n   |                     expected"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    assert!(arr.len() > 0);\n    let mut new_arr = vec![String::new();\
    \ 11];\n    new_arr[0] = String::from(\"One\");\n    new_arr[1] = String::from(\"\
    Two\");\n    new_arr[2] = String::from(\"Three\");\n    new_arr[3] = String::from(\"\
    Four\");\n    new_arr[4] = String::from(\"Five\");\n    new_arr[5] = String::from(\"\
    Six\");\n    new_arr[6] = String::from(\"Seven\");\n    new_arr[7] = String::from(\"\
    Eight\");\n    new_arr[8] = String::from(\"Nine\");\n    new_arr[9] = String::from(\"\
    Ten\");\n    new_arr[10] = String::from(\"Eleven\");\n    new_arr[11] = String::from(\"\
    Twelve\");\n    new_arr.sort();\n    if arr.len() <= 12 {\n        new_arr.resize(arr.len(),\
    \ false);\n    }\n    for i in arr.iter().rev() {\n        let index = i as isize;\n\
    \        new_arr[index] = new_arr[index].to_string();\n        new_arr[index]\
    \ = new_arr[index][3..4];\n        new_arr[index] = new_arr[index][1..5];\n  \
    \  }\n    new_arr.resize(12, false);\n    new_arr.rev();\n    new_arr.iter().map(|x|\
    \ *x).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwg_gelpc.rs:34:35\n   |\n\
    34 |         new_arr.resize(arr.len(), false);\n   |                         \
    \          ^^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                                 |\n   |                                   expected\
    \ struct `String`, found `bool`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpwg_gelpc.rs:38:9\n   |\n38 |         new_arr[index]\
    \ = new_arr[index].to_string();\n   |         ^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<String>`\n\nerror[E0277]: the type `[String]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpwg_gelpc.rs:38:26\n   |\n38 |         new_arr[index]\
    \ = new_arr[index].to_string();\n   |                          ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmpwg_gelpc.rs:39:9\n\
    \   |\n39 |         new_arr[index] = new_arr[index][3..4];\n   |         ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmpwg_gelpc.rs:39:26\n\
    \   |\n39 |         new_arr[index] = new_arr[index][3..4];\n   |             \
    \             ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() { return vec![] }\n    arr.sort_by_key(|&x|\
    \ x.abs() as isize);\n    arr.iter().rev().cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `isize`\n    --> /tmp/tmpud5iye4n.rs:20:31\n     |\n20\
    \   |     arr.iter().rev().cloned().collect()\n     |                        \
    \       ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut vec = vec![\"\".to_string(), \"\".to_string()];\n\n    for i in arr.iter().rev()\
    \ {\n        if i >= 1 && i <= 9 {\n            vec[i - 1].push(format!(\"{}\"\
    , i));\n        }\n    }\n\n    if vec[1].len() > 1 {\n        vec[1].reverse();\n\
    \    }\n\n    for i in 0..vec.len() {\n        vec[i] = vec[i].chars().collect::<Vec<&str>>().join(\"\
    , \");\n    }\n\n    vec[0]\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ww_yi0o.rs:25:17\n   |\n\
    25 |         if i >= 1 && i <= 9 {\n   |                 ^\n   |             \
    \    |\n   |                 expected `&isize`, found integer\n   |          \
    \       help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2ww_yi0o.rs:25:27\n   |\n25 |         if i >= 1 && i <= 9 {\n \
    \  |                           ^\n   |                           |\n   |     \
    \                      expected `&isize`, found integer\n   |                \
    \           help: consider borrowing here: `&9`\n\nerror[E0277]: the type `[String]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp2ww_yi0o.rs:26:13\n   |\n26 |  \
    \           vec[i - 1].push(format!(\"{}\", i));\n   |             ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp2ww_yi0o.rs:31:16\n   |\n31 |         vec[1].reverse();\n   |  \
    \              ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp2ww_yi0o.rs:35:33\n\
    \     |\n35   |         vec[i] = vec[i].chars().collect::<Vec<&str>>().join(\"\
    , \");\n     |                                 ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ww_yi0o.rs:38:5\n\
    \   |\n17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut length = arr.len();\n    let mut result = Vec::with_capacity(length);\n\
    \    while length > 0 {\n        length = length - 1;\n        result.push(arr[length]);\n\
    \    }\n    let mut rev = reverse(result);\n    rev.iter().for_each(|i| replace(i,\
    \ \"One\", \"One\"));\n    rev.iter().for_each(|i| replace(i, \"Two\", \"Two\"\
    ));\n    rev.iter().for_each(|i| replace(i, \"Three\", \"Three\"));\n    rev.iter().for_each(|i|\
    \ replace(i, \"Four\", \"Four\"));\n    rev.iter().for_each(|i| replace(i, \"\
    Five\", \"Five\"));\n    rev.iter().for_each(|i| replace(i, \"Six\", \"Six\"));\n\
    \    rev.iter().for_each(|i| replace(i, \"Seven\", \"Seven\"));\n    rev.iter().for_each(|i|\
    \ replace(i, \"Eight\", \"Eight\"));\n    rev.iter().for_each(|i| replace(i, \"\
    Nine\", \"Nine\"));\n    rev\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpguc1ss1d.rs:24:19\n\
    \   |\n24 |     let mut rev = reverse(result);\n   |                   ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `replace` in this\
    \ scope\n  --> /tmp/tmpguc1ss1d.rs:25:29\n   |\n25 |     rev.iter().for_each(|i|\
    \ replace(i, \"One\", \"One\"));\n   |                             ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::replace;\n   |\n1  | use std::ptr::replace;\n   |\n\nerror[E0425]:\
    \ cannot find function `replace` in this scope\n  --> /tmp/tmpguc1ss1d.rs:26:29\n\
    \   |\n26 |     rev.iter().for_each(|i| replace(i, \"Two\", \"Two\"));\n   | \
    \                            ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::mem::replace;\n   |\n1  |\
    \ use std::ptr::replace;\n   |\n\nerror[E0425]: cannot find function `replace`\
    \ in this scope\n  --> /tmp/tmpguc1ss1d.rs:27:29\n   |\n27 |     rev.iter().for_each(|i|\
    \ replace(i, \"Three\", \"Three\"));\n   |                             ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::replace;\n   |\n1  | use std::ptr::replace;\n   |\n\n\
    error[E0425]: cannot find function `replace` in this scope\n  --> /tmp/tmpguc1ss1d.rs:28:29\n\
    \   |\n28 |     rev.iter().for_each(|i| replace(i, \"Four\", \"Four\"));\n   |\
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::mem::replace;\n   |\n1  |\
    \ use std::ptr::replace;\n   |\n\nerror[E0425]: cannot find function `replace`\
    \ in this scope\n  --> /tmp/tmpguc1ss1d.rs:29:29\n   |\n29 |     rev.iter().for_each(|i|\
    \ replace(i, \"Five\", \"Five\"));\n   |                             ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::replace;\n   |\n1  | use std::ptr::replace;\n   |\n\nerror[E0425]:\
    \ cannot find function `replace` in this scope\n  --> /tmp/tmpguc1ss1d.rs:30:29\n\
    \   |\n30 |     rev.iter().for_each(|i| replace(i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ans = vec![];\n    let mut rev = rev::reverse_ordering();\n\
    \    let mut i = 1;\n    for i in arr {\n        while rev.contains(&i) {\n  \
    \          ans.push(i.to_string());\n        }\n        rev.push(i);\n    }\n\
    \    ans\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rev`\n\
    \  --> /tmp/tmpifbfiqxi.rs:19:19\n   |\n19 |     let mut rev = rev::reverse_ordering();\n\
    \   |                   ^^^ use of undeclared crate or module `rev`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr.to_vec();\n    arr.sort();\n    arr.reverse();\n\
    \    let mut return = vec![];\n    for i in arr.iter() {\n        let mut return\
    \ = vec![];\n        let val = i;\n        let str = get_str(val as u8);\n   \
    \     let mut n = String::new();\n        for i in str.chars().skip(1).take(6)\
    \ {\n            match i {\n                '0' => n.push(\"Zero\"),\n       \
    \         '1' => n.push(\"One\"),\n                '2' => n.push(\"Two\"),\n \
    \               '3' => n.push(\"Three\"),\n                '4' => n.push(\"Four\"\
    ),\n                '5' => n.push(\"Five\"),\n                '6' => n.push(\"\
    Six\"),\n                '7' => n.push(\"Seven\"),\n                '8' => n.push(\"\
    Eight\"),\n                '9' => n.push(\"Nine\"),\n                _ => continue,\n\
    \            };\n        }\n        return.push(n);\n    }\n    return return\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `return`\n  --> /tmp/tmp2vob5yzf.rs:21:13\n\
    \   |\n21 |     let mut return = vec![];\n   |             ^^^^^^ expected identifier,\
    \ found keyword\n   |\nhelp: escape `return` to use it as an identifier\n   |\n\
    21 |     let mut r#return = vec![];\n   |             ++\n\nerror: expected identifier,\
    \ found keyword `return`\n  --> /tmp/tmp2vob5yzf.rs:23:17\n   |\n23 |        \
    \ let mut return = vec![];\n   |                 ^^^^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `return` to use it as an identifier\n   |\n23 |\
    \         let mut r#return = vec![];\n   |                 ++\n\nerror[E0425]:\
    \ cannot find function `get_str` in this scope\n  --> /tmp/tmp2vob5yzf.rs:25:19\n\
    \   |\n25 |         let str = get_str(val as u8);\n   |                   ^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2vob5yzf.rs:29:31\n\
    \   |\n29 |                 '0' => n.push(\"Zero\"),\n   |                   \
    \            ^^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2vob5yzf.rs:30:31\n   |\n30 |                 '1' => n.push(\"\
    One\"),\n   |                               ^^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2vob5yzf.rs:31:31\n   |\n31 |\
    \                 '2' => n.push(\"Two\"),\n   |                              \
    \ ^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2vob5yzf.rs:32:31\n   |\n32 |                 '3' => n.push(\"Three\"\
    ),\n   |                               ^^^^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2vob5yzf.rs:33:31\n   |\n33 |\
    \                 '4' => n.push(\"Four\"),\n   |                             \
    \  ^^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2vob5yzf.rs:34:31\n   |\n34 |                 '5' => n.push(\"Five\"\
    ),\n   |                               ^^^^^^ expected `char`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2vob5yzf.rs:35:31\n   |\n35 |  \
    \               '6' => n.push(\"Six\"),\n   |                    "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = vec![];\n    arr.sort_unstable_by(|a,\
    \ b| a < b);\n    for i in 0..arr.len() {\n        let val = arr[i];\n       \
    \ sorted.push((val % 10) as usize + (val / 10).to_string());\n    }\n    let mut\
    \ reversed = vec![];\n    for i in sorted.rev() {\n        reversed.push(i.to_string());\n\
    \    }\n    if sorted.is_empty() && reversed.is_empty() {\n        return vec![];\n\
    \    }\n    if sorted.is_empty() {\n        return reversed;\n    }\n    if reversed.is_empty()\
    \ {\n        return sorted;\n    }\n    let mut iter = reversed.iter();\n    let\
    \ mut i = 0;\n    for v in iter.by_ref() {\n        sorted.insert(i, v);\n   \
    \     i += 1;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4jjud5sv.rs:19:33\n   |\n\
    19 |     arr.sort_unstable_by(|a, b| a < b);\n   |                           \
    \      ^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0277]:\
    \ cannot add `String` to `usize`\n  --> /tmp/tmp4jjud5sv.rs:22:41\n   |\n22 |\
    \         sorted.push((val % 10) as usize + (val / 10).to_string());\n   |   \
    \                                      ^ no implementation for `usize + String`\n\
    \   |\n   = help: the trait `Add<String>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Add<Rhs>`:\n             <&'a\
    \ f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128\
    \ as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as\
    \ Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0599]:\
    \ `Vec<_>` is not an iterator\n   --> /tmp/tmp4jjud5sv.rs:25:21\n    |\n25  |\
    \       for i in sorted.rev() {\n    |                       ^^^ `Vec<_>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<_>: Iterator`\n            which is required by `&mut Vec<_>:\
    \ Iterator`\n            `[_]: Iterator`\n            which is required by `&mut\
    \ [_]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4jjud5sv.rs:40:26\n\
    \   |\n40 |         sorted.insert(i, v);\n   |                          ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut numbers = arr;\n    let mut result: Vec<String>\
    \ = vec![];\n\n    // Sorting by length (longest first)\n    numbers.sort_by_key(|num|\
    \ num.len());\n\n    // Reverse the sorted array\n    let mut reversed = numbers[..numbers.len()].iter().cloned().rev();\n\
    \n    // Look up each digit in 'reversed' with the original numbers. Ignore strange\
    \ numbers\n    // and empty numbers\n    for i in reversed.cloned().take(numbers.len()).cloned()\
    \ {\n        if let Some(val) = (i as isize).checked_sub(10).unwrap() {\n    \
    \        result.push(by_name_and_index(val));\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_name_and_index` in this scope\n\
    \  --> /tmp/tmpg5y8bqjq.rs:31:25\n   |\n31 |             result.push(by_name_and_index(val));\n\
    \   |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `len` found for reference `&isize` in the current scope\n  -->\
    \ /tmp/tmpg5y8bqjq.rs:22:35\n   |\n22 |     numbers.sort_by_key(|num| num.len());\n\
    \   |                                   ^^^ method not found in `&isize`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::slice::Iter<'_, isize> as Iterator>::Item ==\
    \ &&_`\n    --> /tmp/tmpg5y8bqjq.rs:29:23\n     |\n29   |     for i in reversed.cloned().take(numbers.len()).cloned()\
    \ {\n     |                       ^^^^^^ expected reference, found `isize`\n \
    \    |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `take` exists for struct `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpg5y8bqjq.rs:29:32\n\
    \   |\n29 |       for i in reversed.cloned().take(numbers.len()).cloned() {\n\
    \   |                                  ^^^^ method cannot be called on `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Rev<Cloned<std::slice::Iter<'_, isize>>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n           `Cloned<Rev<Cloned<std::slice::Iter<'_, isize>>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5y8bqjq.rs:30:16\n\
    \   |\n30 |         if let Some(val) = (i as isize).checked_sub(10).unwrap() {\n\
    \   |                ^^^^^^^^^   ------------------------------------- this expression\
    \ has type `isize`\n   | "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut res = vec![];\n    let mut i = 0;\n    let mut n = arr.len();\n  \
    \  while i < n {\n        let m = if i + 1 < n {\n            i + 1;\n       \
    \ } else {\n            i;\n        }\n        let mut j = m;\n        while j\
    \ > 0 {\n            let (mut d, mut k) = if arr[j] > arr[j - 1] {\n         \
    \       (arr[j], j)\n            } else {\n                (arr[j - 1], j - 1)\n\
    \            };\n            res.push((d as i32).to_string());\n            j\
    \ = k;\n        }\n        i = m;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpx9of0mrs.rs:29:10\n\
    \   |\n29 |         }\n   |          ^ help: add `;` here\n30 |         let mut\
    \ j = m;\n   |         --- unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx9of0mrs.rs:31:19\n   |\n31 |         while j > 0 {\n   |     \
    \              ^ expected `()`, found integer\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `()`\n  --> /tmp/tmpx9of0mrs.rs:32:37\n   |\n32 |     \
    \        let (mut d, mut k) = if arr[j] > arr[j - 1] {\n   |                 \
    \                    ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `()`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `(Bound<usize>, Bound<usize>)`\n\
    \   = note: required because of the requirements on the impl of `Index<()>` for\
    \ `Vec<isize>`\n\nerror[E0369]: cannot subtract `{integer}` from `()`\n  --> /tmp/tmpx9of0mrs.rs:32:52\n\
    \   |\n32 |             let (mut d, mut k) = if arr[j] > arr[j - 1] {\n   |  \
    \                                                - ^ - {integer}\n   |       \
    \                                           |\n   |                          \
    \                        ()\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `()`\n  --> /tmp/tmpx9of0mrs.rs:33:18\n   |\n33 |                 (arr[j],\
    \ j)\n   |                  ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `()`\n   = help: the trait `SliceIndex<[T]>` is implemented for `(Bound<usize>,\
    \ Bound<usize>)`\n   = note: required because of the requirements on the impl\
    \ of `Index<()>` for `Vec<isize>`\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `()`\n  --> /tmp/tmpx9of0mrs.rs:35:24\n   |\n35 |                 (arr[j\
    \ - 1], j - 1)\n   |                      - ^ - {integer}\n   |              \
    \        |\n   |                      ()\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `()`\n  --> /tmp/tmpx9of0mrs.rs:35:32\n   |\n35 |                 (arr[j\
    \ - 1], j - 1)\n   |                "
  exit_code: 1
  status: SyntaxError
