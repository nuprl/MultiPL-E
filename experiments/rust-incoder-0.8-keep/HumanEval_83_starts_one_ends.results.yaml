name: HumanEval_83_starts_one_ends
language: rust
results:
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // `1`s occur exactly `n` times.\n    (1..n).filter(|&i| i ==\
    \ 1).count()\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp27c8raz6.rs:5:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     // `1`s occur exactly\
    \ `n` times.\n5 |     (1..n).filter(|&i| i == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n5 |     (1..n).filter(|&i|\
    \ i == 1).count().try_into().unwrap()\n  |                                   \
    \    ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpttqe2oco.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n    let mut n = n.to_string();\n    n.pop();\n\
    \    for i in 0..n.len() {\n        if n[i] == b'1' {\n            counter +=\
    \ 1;\n            if n[n.len() - i] == b'1' {\n                counter += 1;\n\
    \            }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp4wanz5qt.rs:8:12\n\
    \  |\n8 |         if n[i] == b'1' {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4wanz5qt.rs:10:16\n\
    \   |\n10 |             if n[n.len() - i] == b'1' {\n   |                ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match (n / 10_isize).checked_mul((n / 10_isize).checked_sub(1)\
    \ as usize).unwrap() {\n        Some(n) => {\n            let n = n.checked_mul((n\
    \ / 10_isize).checked_sub(1) as usize);\n            n.is_some() && n.unwrap()\
    \ * 10\n        }\n        None => 0,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnl9_vn_l.rs:4:38\n  |\n4 |\
    \     match (n / 10_isize).checked_mul((n / 10_isize).checked_sub(1) as usize).unwrap()\
    \ {\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     match (n\
    \ / 10_isize).checked_mul(((n / 10_isize).checked_sub(1) as usize).try_into().unwrap()).unwrap()\
    \ {\n  |                                      +                              \
    \        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnl9_vn_l.rs:5:9\n\
    \  |\n4 |     match (n / 10_isize).checked_mul((n / 10_isize).checked_sub(1) as\
    \ usize).unwrap() {\n  |           ---------------------------------------------------------------------------\
    \ this expression has type `isize`\n5 |         Some(n) => {\n  |         ^^^^^^^\
    \ expected `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n\
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnl9_vn_l.rs:9:9\n\
    \  |\n4 |     match (n / 10_isize).checked_mul((n / 10_isize).checked_sub(1) as\
    \ usize).unwrap() {\n  |           ---------------------------------------------------------------------------\
    \ this expression has type `isize`\n...\n9 |         None => 0,\n  |         ^^^^\
    \ expected `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n\
    \             found enum `Option<_>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnl9_vn_l.rs:7:13\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                       \
    \          ----- expected `isize` because of return type\n...\n7 |           \
    \  n.is_some() && n.unwrap() * 10\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror[E0605]: non-primitive cast: `Option<isize>`\
    \ as `usize`\n --> /tmp/tmpnl9_vn_l.rs:4:38\n  |\n4 |     match (n / 10_isize).checked_mul((n\
    \ / 10_isize).checked_sub(1) as usize).unwrap() {\n  |                       \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut n2 = n;\n    n2 += (n2 & !n1) as isize;\n    n2 += (n2\
    \ & !n1) as isize;\n    n2 += (n2 & !n1) as isize;\n    n2 += (n2 & !n1) as isize;\n\
    \    n2 += (n2 & !n1) as isize;\n    n2 += (n2 & !n1) as isize;\n    n2 += (n2\
    \ & !n1) as isize;\n    n2 += (n2 & !n1) as isize;\n    n2 += (n2 & !n1) as isize;\n\
    \    n2 += (n2 & !n1) as isize;\n    n2\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `n1` in this scope\n --> /tmp/tmp7t7vdg2o.rs:5:18\n\
    \  |\n5 |     n2 += (n2 & !n1) as isize;\n  |                  ^^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0425]: cannot find value\
    \ `n1` in this scope\n --> /tmp/tmp7t7vdg2o.rs:6:18\n  |\n6 |     n2 += (n2 &\
    \ !n1) as isize;\n  |                  ^^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror[E0425]: cannot find value `n1` in this scope\n -->\
    \ /tmp/tmp7t7vdg2o.rs:7:18\n  |\n7 |     n2 += (n2 & !n1) as isize;\n  |     \
    \             ^^ help: a local variable with a similar name exists: `n`\n\nerror[E0425]:\
    \ cannot find value `n1` in this scope\n --> /tmp/tmp7t7vdg2o.rs:8:18\n  |\n8\
    \ |     n2 += (n2 & !n1) as isize;\n  |                  ^^ help: a local variable\
    \ with a similar name exists: `n`\n\nerror[E0425]: cannot find value `n1` in this\
    \ scope\n --> /tmp/tmp7t7vdg2o.rs:9:18\n  |\n9 |     n2 += (n2 & !n1) as isize;\n\
    \  |                  ^^ help: a local variable with a similar name exists: `n`\n\
    \nerror[E0425]: cannot find value `n1` in this scope\n  --> /tmp/tmp7t7vdg2o.rs:10:18\n\
    \   |\n10 |     n2 += (n2 & !n1) as isize;\n   |                  ^^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0425]: cannot find value\
    \ `n1` in this scope\n  --> /tmp/tmp7t7vdg2o.rs:11:18\n   |\n11 |     n2 += (n2\
    \ & !n1) as isize;\n   |                  ^^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror[E0425]: cannot find value `n1` in this scope\n  -->\
    \ /tmp/tmp7t7vdg2o.rs:12:18\n   |\n12 |     n2 += (n2 & !n1) as isize;\n   | \
    \                 ^^ help: a local variable with a similar name exists: `n`\n\n\
    error[E0425]: cannot find value `n1` in this scope\n  --> /tmp/tmp7t7vdg2o.rs:13:18\n\
    \   |\n13 |     n2 += (n2 & !n1) as isize;\n   |                  ^^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0425]: cannot find value\
    \ `n1` in this scope\n  --> /tmp/tmp7t7vdg2o.rs:14:18\n   |\n14 |     n2 += (n2\
    \ & !n1) as isize;\n   |                  ^^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror: aborting due to "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 0 { return 0; }\n\n    let mut count = 0;\n\n    //\
    \ find first number that doesn't start with 1\n    let i = n.checked_add(1).unwrap();\n\
    \    i += 1;\n    while i <= n {\n        if i != 1 && i % (i + 1) == 0 {\n  \
    \          count += 1;\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n\n    // find last number that doesn't end with 1\n  \
    \  i += 1;\n    while i <= n {\n        if i != n {\n            count += 1;\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \n    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp8bjn015d.rs:10:5\n\
    \   |\n9  |     let i = n.checked_add(1).unwrap();\n   |         -\n   |     \
    \    |\n   |         first assignment to `i`\n   |         help: consider making\
    \ this binding mutable: `mut i`\n10 |     i += 1;\n   |     ^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `i`\n  --> /tmp/tmp8bjn015d.rs:14:13\n   |\n9  |     let i = n.checked_add(1).unwrap();\n\
    \   |         -\n   |         |\n   |         first assignment to `i`\n   |  \
    \       help: consider making this binding mutable: `mut i`\n...\n14 |       \
    \      i += 1;\n   |             ^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp8bjn015d.rs:16:13\n\
    \   |\n9  |     let i = n.checked_add(1).unwrap();\n   |         -\n   |     \
    \    |\n   |         first assignment to `i`\n   |         help: consider making\
    \ this binding mutable: `mut i`\n...\n16 |             i += 1;\n   |         \
    \    ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `i`\n  --> /tmp/tmp8bjn015d.rs:21:5\n   |\n\
    9  |     let i = n.checked_add(1).unwrap();\n   |         -\n   |         |\n\
    \   |         first assignment to `i`\n   |         help: consider making this\
    \ binding mutable: `mut i`\n...\n21 |     i += 1;\n   |     ^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `i`\n  --> /tmp/tmp8bjn015d.rs:25:13\n   |\n9  |     let i = n.checked_add(1).unwrap();\n\
    \   |         -\n   |         |\n   |         first assignment to `i`\n   |  \
    \       help: consider making this binding mutable: `mut i`\n...\n25 |       \
    \      i += 1;\n   |             ^^^^^^ cannot assign twice to immutable variable\n\
    \nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp8bjn015d.rs:27:13\n\
    \   |\n9  |     let i = n.checked_add(1).unwrap();\n   |         -\n   |     \
    \    |\n   |         first assignment to `i`\n   |         help: consider makin"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    loop {\n        count += n % 10 == 1;\n\
    \        n /= 10;\n        if n == 0 {\n            break;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `bool` to `{integer}`\n --> /tmp/tmpvskajwzt.rs:6:15\n\
    \  |\n6 |         count += n % 10 == 1;\n  |               ^^ no implementation\
    \ for `{integer} += bool`\n  |\n  = help: the trait `AddAssign<bool>` is not implemented\
    \ for `{integer}`\n  = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \            <f32 as AddAssign<&f32>>\n            <f32 as AddAssign>\n      \
    \      <f64 as AddAssign<&f64>>\n            <f64 as AddAssign>\n            <i128\
    \ as AddAssign<&i128>>\n            <i128 as AddAssign>\n            <i16 as AddAssign<&i16>>\n\
    \            <i16 as AddAssign>\n          and 20 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n / 10 + 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmpll_044a8.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n.trailing_zeros() / 2\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphxnjl5jt.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     n.trailing_zeros() /\
    \ 2\n  |     ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `u32`\n  |\nhelp:\
    \ you can convert a `u32` to an `isize` and panic if the converted value doesn't\
    \ fit\n  |\n4 |     (n.trailing_zeros() / 2).try_into().unwrap()\n  |     +  \
    \                    +++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|&i| i & 1 == 1).count()\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4drvg30o.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..=n).filter(|&i|\
    \ i & 1 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (1..=n).filter(|&i| i\
    \ & 1 == 1).count().try_into().unwrap()\n  |                                 \
    \           ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        let mut i = n;\n        while i > 0 {\n    \
    \        if i % 10 == 1 {\n                return i;\n            }\n        \
    \    i /= 10;\n        }\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut num = 1;\n\
    \    while num < n {\n        num *= 10;\n    }\n    let mut num2 = 1;\n    while\
    \ num2 < n {\n        num2 *= 10;\n    }\n    if num == 1 && num2 == n {\n   \
    \     return 1;\n    }\n    if num2 == n && num == n {\n        return 1;\n  \
    \  }\n    if num > num2 {\n        while num < n {\n            num += 1;\n  \
    \      }\n        while num2 < n {\n            num2 += 1;\n        }\n    }\n\
    \    while num < n {\n        num += 1;\n        while num2 < n {\n          \
    \  num2 += 1;\n        }\n    }\n    while num2 < n {\n        num2 += 1;\n  \
    \      while num < n {\n            num += 1;\n        }\n    }\n    n - num -\
    \ 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpu3sg25ky.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n >= 1);\n\n    let mut n = 1isize;\n\n    while\
    \ n % 10 == 1 && n != 1 {\n        n /= 10;\n        n += 1;\n    }\n\n    n.abs()\
    \ + 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpo3d1nahw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n == 1);\n    (*n).saturating_sub(1).trailing_zeros()\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpv2cmj9dk.rs:5:5\n\
    \  |\n5 |     (*n).saturating_sub(1).trailing_zeros()\n  |     ^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n\n    for i in 0..n {\n        counter\
    \ += if i == 1 || i == n - 1 { 1 } else { 0 };\n    }\n\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp4ayqinka.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        panic!(\"starts_one_ends: Negative number\
    \ passed!\");\n    }\n\n    let mut counter = 0;\n\n    if n % 10 == 1 {\n   \
    \     counter += 1;\n    }\n\n    for d in (10..=n).rev() {\n        if n % d\
    \ == 1 {\n            counter += 1;\n        }\n    }\n\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `18`', /tmp/tmp87ob8let.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n.checked_add((n - 1).checked_mul(10).unwrap()).unwrap()\n}\n\
    \nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `18`', /tmp/tmp9m7v9hse.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = n as usize;\n\n    while n > 0 {\n        count\
    \ += n & 1 != 0;\n        n >>= 1;\n    }\n\n    count\n}\n\nfn main() {\n   \
    \ let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `bool` to `usize`\n --> /tmp/tmpphfstnmq.rs:7:15\n\
    \  |\n7 |         count += n & 1 != 0;\n  |               ^^ no implementation\
    \ for `usize += bool`\n  |\n  = help: the trait `AddAssign<bool>` is not implemented\
    \ for `usize`\n  = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \            <f32 as AddAssign<&f32>>\n            <f32 as AddAssign>\n      \
    \      <f64 as AddAssign<&f64>>\n            <f64 as AddAssign>\n            <i128\
    \ as AddAssign<&i128>>\n            <i128 as AddAssign>\n            <i16 as AddAssign<&i16>>\n\
    \            <i16 as AddAssign>\n          and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpphfstnmq.rs:11:5\n   |\n3  | fn starts_one_ends(n: isize)\
    \ -> isize {\n   |                                 ----- expected `isize` because\
    \ of return type\n...\n11 |     count\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     count.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|i| i / (i as usize).cmp(&1) == 0).count()\n}\n\
    \nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `&isize` by `std::cmp::Ordering`\n --> /tmp/tmpdi_0bowo.rs:4:25\n\
    \  |\n4 |     (1..n).filter(|i| i / (i as usize).cmp(&1) == 0).count()\n  |  \
    \                       ^ no implementation for `&isize / std::cmp::Ordering`\n\
    \  |\n  = help: the trait `Div<std::cmp::Ordering>` is not implemented for `&isize`\n\
    \  = help: the following other types implement trait `Div<Rhs>`:\n           \
    \ <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128\
    \ as Div<i128>>\n            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n\
    \            <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n        \
    \    <&'a isize as Div<isize>>\n          and 54 others\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpdi_0bowo.rs:4:5\n  |\n3 | fn starts_one_ends(n: isize) ->\
    \ isize {\n  |                                 ----- expected `isize` because\
    \ of return type\n4 |     (1..n).filter(|i| i / (i as usize).cmp(&1) == 0).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n4 |     (1..n).filter(|i| i / (i as\
    \ usize).cmp(&1) == 0).count().try_into().unwrap()\n  |                      \
    \                                       ++++++++++++++++++++\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n --> /tmp/tmpdi_0bowo.rs:4:27\n  |\n\
    4 |     (1..n).filter(|i| i / (i as usize).cmp(&1) == 0).count()\n  |        \
    \                   ^-^^^^^^^^^^\n  |                           ||\n  |      \
    \                     |help: dereference the expression: `*i`\n  |           \
    \                cannot cast `&isize` as `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0606.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|x| *x == 1).count()\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphp5doprw.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..=n).filter(|x| *x\
    \ == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n4 |     (1..=n).filter(|x| *x == 1).count().try_into().unwrap()\n\
    \  |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    for d in n.to_string().chars().nth(2).unwrap().to_string()\
    \ {\n        if d == \"1\" {\n            count += 1;\n        }\n        if d\
    \ == \"0\" {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmpsacg9cek.rs:5:14\n\
    \  |\n5 |     for d in n.to_string().chars().nth(2).unwrap().to_string() {\n \
    \ |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait\
    \ `Iterator` is not implemented for `String`\n  = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    loop {\n        if n <= 1 {\n      \
    \      count++;\n            break;\n        }\n        let tmp = n - 1;\n   \
    \     let digit = tmp % 10;\n        if digit == 1 {\n            count++;\n \
    \       }\n        n /= 10;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n --> /tmp/tmpd714hq6n.rs:7:18\n\
    \  |\n7 |             count++;\n  |                  ^^ not a valid postfix operator\n\
    \  |\nhelp: use `+= 1` instead\n  |\n7 |             { let tmp = count; count\
    \ += 1; tmp };\n  |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n7 -    \
    \         count++;\n7 +             count += 1;\n  | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmpd714hq6n.rs:13:18\n   |\n13 |            \
    \ count++;\n   |                  ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n13 |             { let tmp = count; count += 1; tmp\
    \ };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n13 -            \
    \ count++;\n13 +             count += 1;\n   | \n\nwarning: unreachable expression\n\
    \  --> /tmp/tmpd714hq6n.rs:17:5\n   |\n5  | /     loop {\n6  | |         if n\
    \ <= 1 {\n7  | |             count++;\n8  | |             break;\n...  |\n15 |\
    \ |         n /= 10;\n16 | |     }\n   | |_____- any code following this expression\
    \ is unreachable\n17 |       count\n   |       ^^^^^ unreachable expression\n\
    \   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (0..n).filter(|&x| x % 10 == 1).count()\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6yadf_u4.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (0..n).filter(|&x| x\
    \ % 10 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (0..n).filter(|&x| x\
    \ % 10 == 1).count().try_into().unwrap()\n  |                                \
    \            ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n - 1).checked_mul(10).checked_mul(10).checked_mul(10).unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_mul` found for enum `Option` in\
    \ the current scope\n --> /tmp/tmp_1su7_tm.rs:4:29\n  |\n4 |     (n - 1).checked_mul(10).checked_mul(10).checked_mul(10).unwrap_or(0)\n\
    \  |                             ^^^^^^^^^^^ method not found in `Option<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        0 => 1,\n        1 => 0,\n        n if n\
    \ < 10 => 1\n        | n if n < 100 => n - 1,\n        | n if n < 1000 => n -\
    \ 2,\n        | n if n < 10000 => n - 3,\n        | n if n < 100000 => n - 4,\n\
    \        | n if n < 1000000 => n - 5,\n        | n if n < 10000000 => n - 6,\n\
    \        | n if n < 100000000 => n - 7,\n        | n if n < 1000000000 => n -\
    \ 8,\n        | n if n < 10000000000 => n - 9,\n        | n if n < 100000000000\
    \ => n - 10,\n        | n if n < 1000000000000 => n - 11,\n        | n if n <\
    \ 10000000000000 => n - 12,\n        | n if n < 100000000000000 => n - 13,\n \
    \       | n if n < 1000000000000000 => n - 14,\n        | n if n < 10000000000000000\
    \ => n - 15,\n        | n if n < 100000000000000000 => n - 16,\n        | n if\
    \ n < 1000000000000000000 => n - 17,\n        | n if n < 10000000000000000000\
    \ => n - 18,\n        | n if n < 100000000000000000000 => n - 19,\n        | n\
    \ if n < 1000000000000000000000 => n - 20,\n        | n if n < 10000000000000000000000\
    \ => n - 21,\n        | n if n < 100000000000000000000000 => n - 22,\n       \
    \ | n if n < 1000000000000000000000000 => n - 23,\n        | n if n < 10000000000000000000000000\
    \ => n - 24,\n        | n if n < 100000000000000000000000000 => n - 25,\n    \
    \    | n if n < 1000000000000000000000000000 => n - 26,\n        | n if n < 10000000000000000000000000000\
    \ => n - 27,\n        | n if n < 100000000000000000000000000000 => n - 28,\n \
    \       | n if n < 1000000000000000000000000000000 => n - 29,\n        | n if\
    \ n < 10000000000000000000000000000000 => n - 30,\n        | n if n < 100000000000000000000000000000000\
    \ => n - 31,\n        | n if n < 1000000000000000000000000000000000 => n - 32,\n\
    \        | n if n < 10000000000000000000000000000000000 => n - 33,\n        |\
    \ n if n < 100000000000000000000000000000000000 => n - 34,\n        | n if n <\
    \ 1000000000000000000000000000000000000 => n - 35,\n        | n if n < 10000000000000000000000000000000000000\
    \ => n - 36,\n        | n if n < 100000000000000000000000000000000000000 => n\
    \ - 37,\n        | n if n < 1000000000000000000000000000000000000000 => n - 38,\n\
    \        | n if n < 10000000000000000000000000000000000000000 => n - 39,\n   \
    \     | n if n < 100000000000000000000000000000000000000000 => n - 40,\n     \
    \   | n if n < 1000000000000000000000000000000000000000000 => n - 41,\n      \
    \  | n if n < \n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2py8vg4b.rs:59:3\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \                   - unclosed delimiter\n4  |     match n {\n   |           \
    \  - this delimiter might not be properly closed...\n...\n50 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n59 | }\n   |   ^\n\n\
    error: expected one of `!`, `,`, `.`, `::`, `?`, `{`, `}`, or an operator, found\
    \ keyword `if`\n --> /tmp/tmp2py8vg4b.rs:3:39\n  |\n3 | fn starts_one_ends(n:\
    \ isize) -> isize {\n  |                                       ^ unclosed delimiter\n\
    ...\n7 |         n if n < 10 => 1\n  |                     -- while parsing the\
    \ `match` arm starting here\n8 |         | n if n < 100 => n - 1,\n  |       \
    \     -^^ expected one of 8 possible tokens\n  |            |\n  |           \
    \ help: `}` may belong here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2py8vg4b.rs:4:5\n\
    \   |\n4  | /     match n {\n5  | |         0 => 1,\n6  | |         1 => 0,\n\
    7  | |         n if n < 10 => 1\n...  |\n49 | |         | n if n < \n50 | | }\n\
    \   | | ^- help: consider using a semicolon here\n   | |_|\n   |   expected `()`,\
    \ found integer\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2py8vg4b.rs:3:33\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |    ---------------    \
    \          ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 {\n        return n;\n    }\n    if n%10 == 1 && n%100\
    \ != 11 && n%100 != 9 && n%100 != 8 {\n        return 1;\n    }\n    let mut sum\
    \ = 0;\n    while n != 0 {\n        sum += n % 10;\n        n /= 10;\n    }\n\
    \    if sum < 10 {\n        return 1;\n    }\n    sum\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpn8tysb8e.rs:13:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n13 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 {\n        return 0;\n    }\n    if n < 100 {\n  \
    \      return 1;\n    }\n    if n < 1000 {\n        return 2;\n    }\n    if n\
    \ < 10000 {\n        return 3;\n    }\n    if n < 100000 {\n        return 4;\n\
    \    }\n    if n < 1000000 {\n        return 5;\n    }\n    if n < 10000000 {\n\
    \        return 6;\n    }\n    if n < 100000000 {\n        return 7;\n    }\n\
    \    if n < 1000000000 {\n        return 8;\n    }\n    if n < 10000000000 {\n\
    \        return 9;\n    }\n    if n < 100000000000 {\n        return 10;\n   \
    \ }\n    if n < 1000000000000 {\n        return 11;\n    }\n    if n < 10000000000000\
    \ {\n        return 12;\n    }\n    if n < 100000000000000 {\n        return 13;\n\
    \    }\n    if n < 1000000000000000 {\n        return 14;\n    }\n    if n < 10000000000000000\
    \ {\n        return 15;\n    }\n    if n < 100000000000000000 {\n        return\
    \ 16;\n    }\n    if n < 1000000000000000000 {\n        return 17;\n    }\n  \
    \  if n < 10000000000000000000 {\n        return 18;\n    }\n    if n < 100000000000000000000\
    \ {\n        return 19;\n    }\n    if n < 1000000000000000000000 {\n        return\
    \ 20;\n    }\n    if n < 10000000000000000000000 {\n        return 21;\n    }\n\
    \    if n < 100000000000000000000000 {\n        return 22;\n    }\n    if n <\
    \ 1000000000000000000000000 {\n        return 23;\n    }\n    if n < 10000000000000000000000000\
    \ {\n        return 24;\n    }\n    if n < 100000000000000000000000000 {\n   \
    \     return 25;\n    }\n    if n < 1000000000000000000000000000 {\n        return\
    \ 26;\n    }\n    if n < 10000000000000000000000000000 {\n        return 27;\n\
    \    }\n    if n < 100000000000000000000000000000 {\n        return 28;\n    }\n\
    \    if n < 1000000000000000000000000000000 {\n        return 29;\n    }\n   \
    \ if n < 10000000000000000000000000000000 {\n        return 30;\n    }\n    if\
    \ n < 100000000000000000000000000000000 {\n        return 31;\n    }\n    if n\
    \ < 1000000000000000000000000000000000 {\n        return 32;\n    }\n    if n\
    \ < 10000000000000000000000000000000000 {\n        return 33;\n    }\n    if n\
    \ < 100000000000000000000000000000000000 {\n        return 34;\n    }\n    if\
    \ n < 1000000000000000000000000000000000000 {\n        return 35;\n    }\n   \
    \ if n < 10000000000000000000000000000000000000 {\n        return 36;\n    }\n\
    \    if n < 100000000000000000000000000000000000000 {\n        return 37;\n  \
    \  }\n    if n < 1000000000000000000000000000000000000000 {\n        return 38;\n\
    \    }\n    if n < 10000000000000000000000000000000000000000 {\n        return\
    \ 39;\n    }\n    if n < 100000000000000000000000000000000000000000 {\n      \
    \  return 40;\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error: integer literal is too large\n   --> /tmp/tmp_eookmf6.rs:118:12\n\
    \    |\n118 |     if n < 1000000000000000000000000000000000000000 {\n    |   \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: integer literal is\
    \ too large\n   --> /tmp/tmp_eookmf6.rs:121:12\n    |\n121 |     if n < 10000000000000000000000000000000000000000\
    \ {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: integer\
    \ literal is too large\n   --> /tmp/tmp_eookmf6.rs:124:12\n    |\n124 |     if\
    \ n < 100000000000000000000000000000000000000000 {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0317]: `if` may be missing an `else` clause\n   --> /tmp/tmp_eookmf6.rs:124:5\n\
    \    |\n3   |   fn starts_one_ends(n: isize) -> isize {\n    |               \
    \                    ----- expected `isize` because of this return type\n...\n\
    124 | /     if n < 100000000000000000000000000000000000000000 {\n125 | |     \
    \    return 40;\n126 | |     }\n    | |_____^ expected `isize`, found `()`\n \
    \   |\n    = note: `if` expressions without `else` evaluate to `()`\n    = help:\
    \ consider adding an `else` block that evaluates to the expected type\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n + 1).count_range(|x| x % 10 == 1)\n}\n\nfn main() {\n   \
    \ let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `count_range` found for type `isize` in the\
    \ current scope\n --> /tmp/tmpcnnecaae.rs:4:13\n  |\n4 |     (n + 1).count_range(|x|\
    \ x % 10 == 1)\n  |             ^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|&n| n % 10 == 1).count()\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2oeyu1le.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..n).filter(|&n| n\
    \ % 10 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (1..n).filter(|&n| n\
    \ % 10 == 1).count().try_into().unwrap()\n  |                                \
    \            ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n.abs() / DIGITS_PER_NUMBER + 1\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `DIGITS_PER_NUMBER` in this scope\n -->\
    \ /tmp/tmpw6i4jccd.rs:4:15\n  |\n4 |     n.abs() / DIGITS_PER_NUMBER + 1\n  |\
    \               ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut s = 1;\n    let mut c = 0;\n    while c < n {\n    \
    \    if n % s == 0 {\n            c += 1;\n        } else {\n            s +=\
    \ 1;\n        }\n    }\n    c\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpos0v65hu.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n\n    let mut count = 0;\n    while n\
    \ != 1 {\n        if n % 10 == 1 {\n            n /= 10;\n            count +=\
    \ 1;\n        }\n        else {\n            n /= 10;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp67ujrx8v.rs:9:13\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |             n /= 10;\n\
    \  |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp67ujrx8v.rs:13:13\n \
    \  |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n13 |             n\
    \ /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut num_starts_one_ends = 0;\n    for digit in n.digits()\
    \ {\n        if *digit == 1 {\n            num_starts_one_ends += 1;\n       \
    \ }\n    }\n    num_starts_one_ends\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n --> /tmp/tmp8v_auk33.rs:5:20\n  |\n5 |     for digit in n.digits() {\n\
    \  |                    ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n >= 0);\n    (n / DIGIT_COUNT).ceil() as isize\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `DIGIT_COUNT` in this scope\n --> /tmp/tmpnirgg9sy.rs:5:10\n\
    \  |\n5 |     (n / DIGIT_COUNT).ceil() as isize\n  |          ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `ceil` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpnirgg9sy.rs:5:23\n  |\n5 |     (n / DIGIT_COUNT).ceil()\
    \ as isize\n  |                       ^^^^ help: there is an associated function\
    \ with a similar name: `div_ceil`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut c = 0.;\n    for _i in 0..n {\n        if ((_i & 1)\
    \ == 1) {\n            c += 1;\n        }\n    }\n    c\n}\n\nfn main() {\n  \
    \  let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n --> /tmp/tmpu3yuf1f2.rs:6:12\n\
    \  |\n6 |         if ((_i & 1) == 1) {\n  |            ^             ^\n  |\n\
    \  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \  |\n6 -         if ((_i & 1) == 1) {\n6 +         if (_i & 1) == 1 {\n  | \n\
    \nerror[E0277]: cannot add-assign `{integer}` to `{float}`\n --> /tmp/tmpu3yuf1f2.rs:7:15\n\
    \  |\n7 |             c += 1;\n  |               ^^ no implementation for `{float}\
    \ += {integer}`\n  |\n  = help: the trait `AddAssign<{integer}>` is not implemented\
    \ for `{float}`\n  = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \            <f32 as AddAssign<&f32>>\n            <f32 as AddAssign>\n      \
    \      <f64 as AddAssign<&f64>>\n            <f64 as AddAssign>\n            <i128\
    \ as AddAssign<&i128>>\n            <i128 as AddAssign>\n            <i16 as AddAssign<&i16>>\n\
    \            <i16 as AddAssign>\n          and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu3yuf1f2.rs:10:5\n   |\n3  | fn starts_one_ends(n: isize)\
    \ -> isize {\n   |                                 ----- expected `isize` because\
    \ of return type\n...\n10 |     c\n   |     ^ expected `isize`, found floating-point\
    \ number\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n<1 {\n        0\n    } else {\n        (n as isize / 10).floor()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n  \
    \  assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpjuoaywty.rs:7:27\n  |\n7 |         (n as isize / 10).floor()\
    \ as isize\n  |                           ^^^^^ help: there is an associated function\
    \ with a similar name: `div_floor`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    assert!(n > 0, \"expected n > 0\");\n    let mut count = 0;\n\
    \    let mut last = 0;\n    for i in 1..n {\n        if i == 1:\n            count\
    \ += 1;\n        } else {\n            if last == 1 {\n                count +=\
    \ 1;\n            }\n            last = 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpuzj5a7_8.rs:18:1\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \                   - this opening brace...\n...\n16 |     }\n   |     - ...matches\
    \ this closing brace\n17 |     count\n18 | }\n   | ^ unexpected closing delimiter\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // We want to start counting at `1`, so the first digit needs\
    \ to be a 1.\n    let n = if n > 0 { n } else { 1 };\n    let mut count = 0;\n\
    \    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n      \
    \  }\n        n /= 10;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpcacndcp6.rs:11:9\n\
    \   |\n5  |     let n = if n > 0 { n } else { 1 };\n   |         -\n   |     \
    \    |\n   |         first assignment to `n`\n   |         help: consider making\
    \ this binding mutable: `mut n`\n...\n11 |         n /= 10;\n   |         ^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut result = 1; // 1 starts with 1, n ends with 1\n    for\
    \ num in 0..n {\n        if num & 0x1 == 1 { // if number starts with 1\n    \
    \        result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp7hb6guwy.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut starts_one\
    \ = 0;\n    let mut ends_one = 0;\n    let mut limit = n * (n / 10) + 1;\n   \
    \ while limit > 0 {\n        let next = limit / n;\n        if limit % n == 0\
    \ {\n            ends_one += 1;\n        }\n        if limit % n == 1 && limit\
    \ >= n {\n            starts_one += 1;\n        }\n        limit = next;\n   \
    \ }\n    (starts_one, ends_one)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_y6c0iti.rs:20:5\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n...\n20 |     (starts_one,\
    \ ends_one)\n   |     ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n \
    \  |\n   = note: expected type `isize`\n             found tuple `({integer},\
    \ {integer})`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    fn one_starts_one(start: usize) -> usize {\n        (1u64 <<\
    \ start) >> start - 1\n    }\n    n / one_starts_one(n).0\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp35e720fo.rs:7:24\n  |\n7 |\
    \     n / one_starts_one(n).0\n  |                        ^ expected `usize`,\
    \ found `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n  |\n7 |     n / one_starts_one(n.try_into().unwrap()).0\n\
    \  |                         ++++++++++++++++++++\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n --> /tmp/tmp35e720fo.rs:7:27\n\
    \  |\n7 |     n / one_starts_one(n).0\n  |                           ^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp35e720fo.rs:5:9\n  |\n4 |     fn one_starts_one(start:\
    \ usize) -> usize {\n  |                                        ----- expected\
    \ `usize` because of return type\n5 |         (1u64 << start) >> start - 1\n \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`\n  |\n\
    help: you can convert a `u64` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n5 |         ((1u64 << start) >> start - 1).try_into().unwrap()\n \
    \ |         +                            +++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    loop {\n        assert!(n\
    \ % 10 == 1);\n        n /= 10;\n        if n == 1 {\n            return n;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n  \
    \  assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmplh2nbikf.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 0 { return 0; }\n    let mut count = 1;\n    for _ in\
    \ 0..n {\n        if n == 1 { break; }\n        if n % 10 == 1 {\n           \
    \ count += 1;\n            n /= 10;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2of6lzoh.rs:10:13\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n10 |             n\
    \ /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    use std::cmp::Ordering;\n    match n < 10 {\n        0 => 0,\n\
    \        1 => 1,\n        _ => {\n            let mut starts: usize = 0;\n   \
    \         let mut ends: usize = 1;\n            loop {\n                let i\
    \ = n % 10;\n                if i == 1 && starts == ends {\n                 \
    \   return starts as isize;\n                }\n                starts += 1;\n\
    \                ends += 1;\n                if i == 0 {\n                   \
    \ break;\n                }\n                n /= 10;\n            }\n       \
    \ }\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmp3hae_9px.rs:4:9\n\
    \  |\n4 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp3hae_9px.rs:6:9\n  |\n5 |     match n < 10 {\n  |      \
    \     ------ this expression has type `bool`\n6 |         0 => 0,\n  |       \
    \  ^ expected `bool`, found integer\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3hae_9px.rs:7:9\n\
    \  |\n5 |     match n < 10 {\n  |           ------ this expression has type `bool`\n\
    6 |         0 => 0,\n7 |         1 => 1,\n  |         ^ expected `bool`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3hae_9px.rs:19:21\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \             ----- expected `isize` because of return type\n...\n19 |       \
    \              break;\n   |                     ^^^^^\n   |                  \
    \   |\n   |                     expected `isize`, found `()`\n   |           \
    \          help: give it a value of the expected type: `break 42`\n\nerror: aborting\
    \ due to 3 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        return 0;\n    }\n\n    let mut count =\
    \ 0;\n    let mut max_count = -1;\n    while n % 10 == 1 {\n        count += 1;\n\
    \        max_count = std::cmp::max(max_count, count);\n        n = n / 10;\n \
    \   }\n\n    if max_count < 2 {\n        return 1;\n    }\n\n    count + starts_one_ends(n\
    \ - 10) + starts_one_ends(n % 10)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphu223ya5.rs:13:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n13 |         n = n\
    \ / 10;\n   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n\n        .checked_mul(10)\n        .expect(\"Integer overflow\"\
    )\n        .checked_sub(100)\n        .expect(\"Integer overflow\")\n        .checked_sub(10)\n\
    \        .expect(\"Integer overflow\")\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-100`,\n right: `1`', /tmp/tmpnb9rq4ke.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // If n is less than 10, then no 1-digit integers exist with\
    \ it.\n    if n < 10 {\n        return 0;\n    }\n\n    // For each n-digit integer\
    \ starting with 1, count the number of digits of\n    // that integer.\n    let\
    \ mut counts = Vec::new();\n    for &n in &mut [1isize; n] {\n        let mut\
    \ digits = String::new();\n        for i in 1..=n {\n            digits.push_str(&format!(\"\
    {}{}\", i, digits[i..]));\n        }\n        counts.push((digits.len() - 1).to_string());\n\
    \    }\n\n    counts.iter().filter(|&count| count.starts_with(\"1\")).count()\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmps45co44b.rs:12:29\n   |\n3  | fn starts_one_ends(n: isize) -> isize\
    \ {\n   |                    - this would need to be a `const`\n...\n12 |    \
    \ for &n in &mut [1isize; n] {\n   |                             ^\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmps45co44b.rs:15:49\n    |\n15  |             digits.push_str(&format!(\"\
    {}{}\", i, digits[i..]));\n    |                                             \
    \    ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `ArgumentV1::<'a>::new_display`\n    = note: this error originates in the macro\
    \ `$crate::__export::format_args` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps45co44b.rs:20:5\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \             ----- expected `isize` because of return type\n...\n20 |     counts.iter().filter(|&count|\
    \ count.starts_with(\"1\")).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n20 |     counts.iter().filter(|&count|\
    \ count.starts_with(\"1\")).count().try_into().unwrap()\n   |                \
    \                                                  ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0435.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n    for &i in 1..=n {\n        if i ==\
    \ 1 {\n            counter += 1\n        } else {\n            if i % 2 == 1 {\n\
    \                counter += 1;\n            }\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsx8m21s2.rs:5:9\n  |\n5 |\
    \     for &i in 1..=n {\n  |         ^^    ----- this expression has type `Option<isize>`\n\
    \  |         |\n  |         expected `isize`, found reference\n  |         help:\
    \ you can probably remove the explicit borrow: `i`\n  |\n  = note:   expected\
    \ type `isize`\n          found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n.leading_zeros() {\n        1 => n,\n        _ => 0,\n\
    \    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmprvzzhjos.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut n1 = n;\n    while n1 % 10 == 1 {\n        n1 /= 10;\n\
    \        n1 *= 10;\n    }\n    n1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpfruqfck5.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    for (i, _) in n.iter().enumerate() {\n\
    \        count += if i == 0 { 1 } else { 0 };\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n --> /tmp/tmp362xntu0.rs:5:21\n  |\n5 |     for (i, _) in n.iter().enumerate()\
    \ {\n  |                     ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        panic!(\"starts_one_ends: n must be positive\"\
    );\n    }\n    if n == 0 {\n        return 0;\n    }\n    // Start by adding all\
    \ positive integers ending with 1:\n    let mut num_ones = 0;\n    for i in 1..=n\
    \ {\n        if i % 10 == 1 {\n            num_ones += 1;\n        }\n    }\n\
    \    // Now add all positive integers starting with 1:\n    for i in 1..=n {\n\
    \        if i % 10 == 0 {\n            num_ones += 1;\n        }\n    }\n    num_ones\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmpqke1mroj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 || n == 1 {\n        return 0;\n    }\n    if n ==\
    \ 2 || n == 3 {\n        return 1;\n    }\n    if n > 3 {\n        n = 1;\n  \
    \  }\n\n    (n - 1).checked_mul(3).ok_or(\"n must be between 2 and 3\")\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsf4sx931.rs:14:5\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n...\n14 |     (n - 1).checked_mul(3).ok_or(\"\
    n must be between 2 and 3\")\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Result`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Result<isize, &str>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut i = 0;\n\
    \    while i * 10 + 1 < n && n % i == 0 {\n        i += 1;\n    }\n    i + (n\
    \ - i * 10 + 1)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpps0pk3if.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n    loop {\n        counter += 1;\n  \
    \      if n / 10 == 1 {\n            break;\n        }\n        n /= 10;\n   \
    \ }\n    counter\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n   \
    \ assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpev2geeo3.rs:10:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n10 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut c = 0;\n    while n >= 10 {\n        c += 1;\n     \
    \   n /= 10;\n    }\n    c\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp6y41qypn.rs:7:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|x| x % 10 == 1 && x % 10 != 0 && !x.is_power_of_two()).count()\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmpxx8nhqxf.rs:4:56\n  |\n4 |     (1..n).filter(|x|\
    \ x % 10 == 1 && x % 10 != 0 && !x.is_power_of_two()).count()\n  |           \
    \                                             ^^^^^^^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxx8nhqxf.rs:4:5\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                       \
    \          ----- expected `isize` because of return type\n4 |     (1..n).filter(|x|\
    \ x % 10 == 1 && x % 10 != 0 && !x.is_power_of_two()).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     (1..n).filter(|x|\
    \ x % 10 == 1 && x % 10 != 0 && !x.is_power_of_two()).count().try_into().unwrap()\n\
    \  |                                                                         \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut cnt = 0;\n    while n != 0 {\n        if n % 10 == 1\
    \ {\n            cnt += 1;\n        }\n        n /= 10;\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpdpka3dwq.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut ones = 0;\n    while n > 1 {\n        if n % 10 == 1\
    \ {\n            ones += 1;\n        }\n        n /= 10;\n    }\n    ones\n}\n\
    \nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp5tuqgjhc.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 {\n        return 0\n    }\n\n    let mut count =\
    \ 0;\n    let mut starts = vec![];\n    let mut ends = vec![];\n\n    for i in\
    \ 1..=n {\n        if i > 1 || i >= n {\n            count += 1;\n           \
    \ starts.push(i as isize);\n        }\n    }\n\n    for i in n+1..=n {\n     \
    \   if i <= 0 || i >= n {\n            count += 1;\n            ends.push(i as\
    \ isize);\n        }\n    }\n\n    if let Some(start) = starts.iter().find(|i|\
    \ *i == 1) {\n        count += 1;\n    }\n\n    if let Some(end) = ends.iter().find(|i|\
    \ *i == n) {\n        count += 1;\n    }\n\n    count\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpadwu029u.rs:26:52\n\
    \   |\n26 |     if let Some(start) = starts.iter().find(|i| *i == 1) {\n   | \
    \                                                   ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  -->\
    \ /tmp/tmpadwu029u.rs:30:48\n   |\n30 |     if let Some(end) = ends.iter().find(|i|\
    \ *i == n) {\n   |                                                ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n < 10\
    \ {\n        starts_one_ends(n - 1) + starts_one_ends(n + 1)\n    } else if n\
    \ % 2 == 1 {\n        starts_one_ends((n / 2) - 1)\n    } else {\n        starts_one_ends((n\
    \ / 2) - 1) + starts_one_ends((n / 2) + 1)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n as i64).checked_div(10).expect(\"n must be between 0 and\
    \ 9 inclusive\")\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n   \
    \ assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpva5u129z.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (n as i64).checked_div(10).expect(\"\
    n must be between 0 and 9 inclusive\")\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i64`\n  |\nhelp: you can convert an `i64` to an `isize`\
    \ and panic if the converted value doesn't fit\n  |\n4 |     (n as i64).checked_div(10).expect(\"\
    n must be between 0 and 9 inclusive\").try_into().unwrap()\n  |              \
    \                                                               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // If n is 1, there's nothing to count.\n    if n == 1 {\n \
    \       return 0;\n    }\n    // If n is even, there are 0 counts of 1-digit numbers\
    \ starting with 1.\n    if n % 2 == 0 {\n        return 0;\n    }\n    // If n\
    \ is odd, there are 1 counts of 1-digit numbers starting with 1.\n    return n\
    \ - 1;\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpsygl4qll.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    while n >= 10 {\n        if n % 10 ==\
    \ 1 {\n            count += 1\n        }\n        n /= 10\n    }\n    if n ==\
    \ 0 {\n        count\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpsl05ca7r.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10\n  |\
    \         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n\n    // Loop through all positive integers\
    \ 1 to n\n    for number in 1..n {\n        // Check if the number has a zero\
    \ digit at its beginning or end\n        if number.is_zero() || number.is_negative()\
    \ {\n            counter = counter + 1;\n        }\n    }\n\n    // Return the\
    \ count\n    counter\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n --> /tmp/tmp0akz0dly.rs:9:19\n  |\n9 |         if number.is_zero() ||\
    \ number.is_negative() {\n  |                   ^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n - n % 10 + (n / 10) % 10 + 1\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp8h_quibb.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    if n&1 == 1 {\n\
    \        return 1;\n    }\n\n    let mut count = 1;\n    for _ in 0..=n {\n  \
    \      count += 1;\n    }\n\n    count\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `18`', /tmp/tmpggrwrfm1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut result = 0;\n    for i in 1..=n {\n        if i <= n\
    \ % 10 {\n            result += 1;\n        }\n        if i != n%10 {\n      \
    \      result -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmpq2e_dn70.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 { return 0 }\n    if n < 100 { return 1 }\n    if\
    \ n < 1000 { return 2 }\n    if n < 10000 { return 3 }\n    if n < 100000 { return\
    \ 4 }\n    if n < 1000000 { return 5 }\n    if n < 10000000 { return 6 }\n   \
    \ if n < 100000000 { return 7 }\n    if n < 1000000000 { return 8 }\n    if n\
    \ < 10000000000 { return 9 }\n    if n < 100000000000 { return 10 }\n    if n\
    \ < 1000000000000 { return 11 }\n    if n < 10000000000000 { return 12 }\n   \
    \ if n < 100000000000000 { return 13 }\n    if n < 1000000000000000 { return 14\
    \ }\n    if n < 10000000000000000 { return 15 }\n    if n < 100000000000000000\
    \ { return 16 }\n    if n < 1000000000000000000 { return 17 }\n    if n < 10000000000000000000\
    \ { return 18 }\n    if n < 100000000000000000000 { return 19 }\n    if n < 1000000000000000000000\
    \ { return 20 }\n    if n < 10000000000000000000000 { return 21 }\n    if n <\
    \ 100000000000000000000000 { return 22 }\n    if n < 1000000000000000000000000\
    \ { return 23 }\n    if n < 10000000000000000000000000 { return 24 }\n    if n\
    \ < 1000000000000000000 { return 25 }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmp06x3jbqx.rs:29:5\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \             ----- expected `isize` because of this return type\n...\n29 |  \
    \   if n < 1000000000000000000 { return 25 }\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n   |\n   = note: `if` expressions without `else`\
    \ evaluate to `()`\n   = help: consider adding an `else` block that evaluates\
    \ to the expected type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 {\n        0\n    } else {\n        (n % 10).checked_mul(10).expect(\"\
    n out of range\").cmp(n) < 0\n            ? 1\n            : n.checked_mul(10).expect(\"\
    n out of range\").cmp(10) < 0\n            ? 1\n            : n.checked_mul(10).expect(\"\
    n out of range\").cmp(100) < 0\n            ? 1\n            : starts_one_ends(n.checked_mul(10).expect(\"\
    n out of range\"))\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \ --> /tmp/tmpje9w7zfc.rs:8:15\n  |\n8 |             ? 1\n  |               ^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 {\n        return 0;\n    }\n    let mut count = 1;\n\
    \    let mut last_digit = n % 10;\n    while n > 10 {\n        last_digit = n\
    \ % 10;\n        count += 1;\n        n /= 10;\n    }\n    if last_digit == 1\
    \ {\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2pysjyaq.rs:12:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n12 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter: isize = 0;\n    while n != 0 {\n        counter\
    \ += n / 10;\n        n %= 10;\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpuipnxhc6.rs:7:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |         n %= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        n /= 10\n        if n == 1 { break }\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n --> /tmp/tmpi1s2swuj.rs:5:16\n\
    \  |\n5 |         n /= 10\n  |                ^ help: add `;` here\n6 |      \
    \   if n == 1 { break }\n  |         -- unexpected token\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    for d in 1..=n {\n        if n % d ==\
    \ 0 && d == 1 {\n            count += 1\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmpb0im_75g.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|i| i % 10 == 1).count()\n}\n\nfn main() {\n \
    \   let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7eqoh71g.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..n).filter(|i| i\
    \ % 10 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (1..n).filter(|i| i %\
    \ 10 == 1).count().try_into().unwrap()\n  |                                  \
    \         ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut i = n;\n    let mut count = 1;\n    while i > 0 {\n\
    \        if i & 1 == 0 {\n            count += 1;\n        }\n        i >>= 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n  \
    \  assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp0m9lyzvc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    while n != 1 {\n        if n % 10 ==\
    \ 1 {\n            n /= 10;\n            count += 1;\n        }\n        else\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpy423jb18.rs:7:13\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |             n /= 10;\n\
    \  |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|i| i % 10 == 1).count()\n}\n\nfn main() {\n \
    \   let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp46nc6lwj.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..n).filter(|i| i\
    \ % 10 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (1..n).filter(|i| i %\
    \ 10 == 1).count().try_into().unwrap()\n  |                                  \
    \         ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n)\n        .filter(|&i| i % 10 == 1)\n        .filter(|&i|\
    \ i % 10 == 1 && i / 10 != 1)\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_k_bbm0f.rs:4:5\n  |\n3 |\
    \   fn starts_one_ends(n: isize) -> isize {\n  |                             \
    \      ----- expected `isize` because of return type\n4 | /     (1..n)\n5 | |\
    \         .filter(|&i| i % 10 == 1)\n6 | |         .filter(|&i| i % 10 == 1 &&\
    \ i / 10 != 1)\n7 | |         .count()\n  | |________________^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n7 |         .count().try_into().unwrap()\n\
    \  |                 ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n > 0 {\n        if n % 10 == 1 {\n            n / 10\n \
    \       } else {\n            0\n        }\n    } else {\n        if n / 10 ==\
    \ 0 {\n            0\n        } else {\n            n\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpqbvpr_79.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n as isize\n        .checked_add(1)\n        .unwrap()\n   \
    \     .checked_mul(10)\n        .unwrap()\n        .checked_mul(100)\n       \
    \ .unwrap()\n        .checked_mul(1000)\n        .unwrap()\n        .checked_mul(10000)\n\
    \        .unwrap()\n        .checked_mul(100000)\n        .unwrap()\n        .checked_mul(1000000)\n\
    \        .unwrap()\n        .checked_mul(10000000)\n        .unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n --> /tmp/tmpwny_xe_l.rs:4:5\n\
    \  |\n4 |     n as isize\n  |     ^^^^^^^^^^\n  |\nhelp: try surrounding the expression\
    \ in parentheses\n  |\n4 |     (n as isize)\n  |     +          +\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        0\n    } else {\n        let mut count =\
    \ 0\n        for d in n.step_by(10) {\n            if d != 1 && d != 0 {\n   \
    \             count += 1\n            }\n        }\n        count\n    }\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n --> /tmp/tmplcmny5du.rs:7:26\n\
    \  |\n7 |         let mut count = 0\n  |                          ^ help: add\
    \ `;` here\n8 |         for d in n.step_by(10) {\n  |         --- unexpected token\n\
    \nerror[E0599]: `isize` is not an iterator\n --> /tmp/tmplcmny5du.rs:8:20\n  |\n\
    8 |         for d in n.step_by(10) {\n  |                    ^^^^^^^ `isize` is\
    \ not an iterator\n  |\n  = note: the following trait bounds were not satisfied:\n\
    \          `isize: Iterator`\n          which is required by `&mut isize: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 0 { return 0; }\n\n    let mut count = 0;\n    for (i,\
    \ &digit) in n.iter().enumerate() {\n        if digit == 1 && i != 0 {\n     \
    \       count += 1;\n        }\n    }\n\n    return count;\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpszljhjjt.rs:7:26\n  |\n7 |     for (i, &digit) in n.iter().enumerate()\
    \ {\n  |                          ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n + 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpfceqpfht.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        0 => 0,\n        _ => 1,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmptiv_m_3f.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 0 {\n        0\n    } else {\n        (&n).count_range(|&i|\
    \ i & 1) == 0\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `count_range` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmpvrl7vxcm.rs:7:14\n  |\n7 |         (&n).count_range(|&i|\
    \ i & 1) == 0\n  |              ^^^^^^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvrl7vxcm.rs:7:9\n  |\n3 | fn starts_one_ends(n:\
    \ isize) -> isize {\n  |                                 ----- expected `isize`\
    \ because of return type\n...\n7 |         (&n).count_range(|&i| i & 1) == 0\n\
    \  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `bool`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n\n        .checked_add(1)\n        .and_then(|v| v % 10)\n\
    \        .fold(0, 0, |acc, _| {\n            acc + if v == 1 {\n             \
    \   1\n            } else {\n                0\n            }\n        })\n}\n\
    \nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `v` in this scope\n --> /tmp/tmpo2r9tg01.rs:8:22\n\
    \  |\n8 |             acc + if v == 1 {\n  |                      ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpo2r9tg01.rs:6:23\n  |\n6 |         .and_then(|v| v % 10)\n  |  \
    \                     ^^^^^^ expected enum `Option`, found `isize`\n  |\n  = note:\
    \ expected enum `Option<_>`\n             found type `isize`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n6 |         .and_then(|v| Some(v % 10))\n  |\
    \                       +++++      +\n\nerror[E0599]: `Option<_>` is not an iterator\n\
    \   --> /tmp/tmpo2r9tg01.rs:7:10\n    |\n7   |           .fold(0, 0, |acc, _|\
    \ {\n    |            ^^^^ `Option<_>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<_>: Iterator`\n\
    \            which is required by `&mut Option<_>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|x| x.starts_with(\"1\")).count()\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `starts_with` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmplnjhs6c4.rs:4:25\n  |\n4 |     (1..n).filter(|x|\
    \ x.starts_with(\"1\")).count()\n  |                         ^^^^^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmplnjhs6c4.rs:4:5\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                       \
    \          ----- expected `isize` because of return type\n4 |     (1..n).filter(|x|\
    \ x.starts_with(\"1\")).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     (1..n).filter(|x|\
    \ x.starts_with(\"1\")).count().try_into().unwrap()\n  |                     \
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        let mut cnt = 0;\n        cnt += if n / 10 ==\
    \ 1 {\n            1\n        } else {\n            0\n        };\n        cnt\
    \ += if n / 100 == 1 {\n            1\n        } else {\n            0\n     \
    \   };\n        cnt += if n / 1000 == 1 {\n            1\n        } else {\n \
    \           0\n        };\n        cnt += if n / 10000 == 1 {\n            1\n\
    \        } else {\n            0\n        };\n        cnt += if n / 100000 ==\
    \ 1 {\n            1\n        } else {\n            0\n        };\n        cnt\
    \ += if n / 1000000 == 1 {\n            1\n        } else {\n            0\n \
    \       };\n        cnt += if n / 10000000 == 1 {\n            1\n        } else\
    \ {\n            0\n        };\n        cnt += if n / 100000000 == 1 {\n     \
    \       1\n        } else {\n            0\n        };\n        cnt += if n /\
    \ 1000000000 == 1 {\n            1\n        } else {\n            0\n        };\n\
    \        cnt += if n / 10000000000 == 1 {\n            1\n        } else {\n \
    \           0\n        };\n        cnt += if n / 100000000000 == 1 {\n       \
    \     1\n        } else {\n            0\n        };\n        cnt += if n / 1000000000000\
    \ == 1 {\n            1\n        } else {\n            0\n        };\n       \
    \ cnt += if n / 10000000000000 == 1 {\n            1\n        } else {\n     \
    \       0\n        };\n        cnt += if n / 100000000000000 == 1 {\n        \
    \    1\n        } else {\n            0\n        };\n        cnt += if n / 1000000000000000\
    \ == 1 {\n            1\n        } else {\n            0\n        };\n       \
    \ cnt += if n / 10000000000000000 == 1 {\n            1\n        } else {\n  \
    \          0\n        };\n        cnt += if n / 100000000000000000 == 1 {\n  \
    \          1\n        } else {\n            0\n        };\n        cnt += if n\
    \ / 1000000000000000000 == 1 {\n            1\n        } else {\n            0\n\
    \        };\n        if n == 0 {\n            break;\n        }\n        n /=\
    \ 10;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `cnt` in this scope\n   --> /tmp/tmpdmmqizux.rs:101:5\n\
    \    |\n101 |     cnt\n    |     ^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0u64;\n    let mut last = 0u64;\n    while n\
    \ != 0 {\n        last = n.checked_sub(1);\n        count += last.checked_mul(10).unwrap()\
    \ as isize;\n        n = last.checked_mul(n).unwrap();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv_m7l818.rs:7:16\n  |\n5 |\
    \     let mut last = 0u64;\n  |                    ---- expected due to this value\n\
    6 |     while n != 0 {\n7 |         last = n.checked_sub(1);\n  |            \
    \    ^^^^^^^^^^^^^^^^ expected `u64`, found enum `Option`\n  |\n  = note: expected\
    \ type `u64`\n             found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpv_m7l818.rs:8:18\n  |\n8 |         count += last.checked_mul(10).unwrap()\
    \ as isize;\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `u64`, found `isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpv_m7l818.rs:9:30\n\
    \  |\n9 |         n = last.checked_mul(n).unwrap();\n  |                     \
    \         ^ expected `u64`, found `isize`\n  |\nhelp: you can convert an `isize`\
    \ to a `u64` and panic if the converted value doesn't fit\n  |\n9 |         n\
    \ = last.checked_mul(n.try_into().unwrap()).unwrap();\n  |                   \
    \            ++++++++++++++++++++\n\nerror[E0277]: cannot add-assign `isize` to\
    \ `u64`\n --> /tmp/tmpv_m7l818.rs:8:15\n  |\n8 |         count += last.checked_mul(10).unwrap()\
    \ as isize;\n  |               ^^ no implementation for `u64 += isize`\n  |\n\
    \  = help: the trait `AddAssign<isize>` is not implemented for `u64`\n  = help:\
    \ the following other types implement trait `AddAssign<Rhs>`:\n            <f32\
    \ as AddAssign<&f32>>\n            <f32 as AddAssign>\n            <f64 as AddAssign<&f64>>\n\
    \            <f64 as AddAssign>\n            <i128 as AddAssign<&i128>>\n    \
    \        <i128 as AddAssign>\n            <i16 as AddAssign<&i16>>\n         \
    \   <i16 as AddAssign>\n          and 20 others\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpv_m7l818.rs:9:13\n  |\n3 | fn starts_one_ends(n: isize) -> isize\
    \ {\n  |                       ----- expected due to this parameter type\n...\n\
    9 |         n = last.checked_mul(n).unwrap();\n  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `u64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_m7l818.rs:11:5\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n    while n != 0 {\n        n >>= 1;\n\
    \        counter += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpfhbpccq4.rs:6:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n6 |         n >>= 1;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n > 0 {\n        if n % 10 == 1 {\n            1\n      \
    \  } else {\n            (starts_one_ends(n / 10) + 1) * 10\n        }\n    }\
    \ else {\n        0\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `18`', /tmp/tmpx4pkm66r.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut ns: isize = 0;\n    while n > 9 {\n        ns += n /\
    \ 10;\n        n %= 10;\n    }\n    ns\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpitltg1r2.rs:7:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |         n %= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut cnt = 0;\n    while n > 0 {\n        cnt += n%10 ==\
    \ 1;\n        n /= 10;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `bool` to `{integer}`\n --> /tmp/tmpl1oe2pjw.rs:6:13\n\
    \  |\n6 |         cnt += n%10 == 1;\n  |             ^^ no implementation for\
    \ `{integer} += bool`\n  |\n  = help: the trait `AddAssign<bool>` is not implemented\
    \ for `{integer}`\n  = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \            <f32 as AddAssign<&f32>>\n            <f32 as AddAssign>\n      \
    \      <f64 as AddAssign<&f64>>\n            <f64 as AddAssign>\n            <i128\
    \ as AddAssign<&i128>>\n            <i128 as AddAssign>\n            <i16 as AddAssign<&i16>>\n\
    \            <i16 as AddAssign>\n          and 20 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 { return n; }\n\n    let mut cnt = 0;\n    while n\
    \ >= 10 {\n        n %= 10;\n        cnt += 1;\n    }\n    if n == 1 && cnt >\
    \ 0 { cnt -= 1 }\n    cnt\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpaa6uxnto.rs:8:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n8 |         n %= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (0..n).filter(|n| n.is_power_of_two() && n.leading().is_power_of_two())\n\
    \        .map(|n| n.trailing().trailing())\n        .count(|n| n.is_power_of_two())\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmpm18eeg8f.rs:4:25\n  |\n4 |     (0..n).filter(|n|\
    \ n.is_power_of_two() && n.leading().is_power_of_two())\n  |                 \
    \        ^^^^^^^^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method\
    \ named `leading` found for reference `&isize` in the current scope\n --> /tmp/tmpm18eeg8f.rs:4:48\n\
    \  |\n4 |     (0..n).filter(|n| n.is_power_of_two() && n.leading().is_power_of_two())\n\
    \  |                                                ^^^^^^^ help: there is an\
    \ associated function with a similar name: `leading_ones`\n\nerror[E0599]: no\
    \ method named `trailing` found for type `isize` in the current scope\n --> /tmp/tmpm18eeg8f.rs:5:20\n\
    \  |\n5 |         .map(|n| n.trailing().trailing())\n  |                    ^^^^^^^^\
    \ help: there is an associated function with a similar name: `trailing_ones`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpm18eeg8f.rs:6:10\n    |\n6   |         .count(|n| n.is_power_of_two())\n\
    \    |          ^^^^^ ----------------------- supplied 1 argument\n    |     \
    \     |\n    |          expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n --> /tmp/tmpm18eeg8f.rs:4:5\n\
    \  |\n3 |   fn starts_one_ends(n: isize) -> isize {\n  |                     \
    \              ----- expected `isize` because of return type\n4 | /     (0..n).filter(|n|\
    \ n.is_power_of_two() && n.leading().is_power_of_two())\n5 | |         .map(|n|\
    \ n.trailing().trailing())\n6 | |         .count(|n| n.is_power_of_two())\n  |\
    \ |_______________________________________^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n6 |         .count(|n| n.is_power_of_two()).try_into().unwrap()\n\
    \  |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 9 {\n        0\n    } else if n % 9 == 0 {\n        n\n\
    \    } else {\n        n + 9\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp3ad8a643.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        let i = n / 10;\n        if n == i || n == (i\
    \ * 10 + 1) {\n            return i;\n        }\n        n -= i;\n    }\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp_w31do2g.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n -= i;\n  |\
    \         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    while n > 9 {\n        n /= 10;\n  \
    \      count++;\n    }\n    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n --> /tmp/tmpybbmzwu0.rs:7:14\n\
    \  |\n7 |         count++;\n  |              ^^ not a valid postfix operator\n\
    \  |\nhelp: use `+= 1` instead\n  |\n7 |         { let tmp = count; count += 1;\
    \ tmp };\n  |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n7 -         count++;\n\
    7 +         count += 1;\n  | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    while n > 0 {\n        count += n /\
    \ 10;\n        n /= 10;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp0cxl3frh.rs:7:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|x| {\n        x % 10 == 1 || x % 10 == 0 &&\
    \ (x % 100 != 0 || x / 100 == 0)\n    }).count()\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsc5gc_yq.rs:4:5\n  |\n3 |\
    \   fn starts_one_ends(n: isize) -> isize {\n  |                             \
    \      ----- expected `isize` because of return type\n4 | /     (1..=n).filter(|x|\
    \ {\n5 | |         x % 10 == 1 || x % 10 == 0 && (x % 100 != 0 || x / 100 == 0)\n\
    6 | |     }).count()\n  | |______________^ expected `isize`, found `usize`\n \
    \ |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n6 |     }).count().try_into().unwrap()\n  |        \
    \       ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|x| x % 10 == 1).count()\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0m9vb6vd.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..=n).filter(|x| x\
    \ % 10 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (1..=n).filter(|x| x\
    \ % 10 == 1).count().try_into().unwrap()\n  |                                \
    \            ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // If n is 1, return 1 as well.\n    if n <= 1 {\n        return\
    \ 1;\n    }\n\n    // A number ending with 1 has 1 mod 10 and 9 digits in the\
    \ end whereas\n    // a number starting with 1 has 1 mod 10 and 9 digits in the\
    \ start\n    // (we only need to check if n is divisible by 10).\n    let remainder\
    \ = n % 10;\n    if remainder == 1 {\n        return 1 + starts_one_ends(n/divisor(n/10));\n\
    \    }\n\n    // For numbers ending with 1, the counts of n-digit numbers that\
    \ start\n    // with 1 are the same as the count of n-digit numbers that end with\
    \ 1.\n    let mut count = 0;\n    let mut mod = n;\n    loop {\n        count\
    \ += 1;\n        mod /= 10;\n        if mod == 1 {\n            break;\n     \
    \   }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmpwbvz0jgc.rs:20:13\n\
    \   |\n20 |     let mut mod = n;\n   |             ^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `mod` to use it as an identifier\n   |\n20 |   \
    \  let mut r#mod = n;\n   |             ++\n\nerror: expected identifier, found\
    \ `/=`\n  --> /tmp/tmpwbvz0jgc.rs:23:13\n   |\n23 |         mod /= 10;\n   | \
    \            ^^ expected identifier\n\nerror[E0425]: cannot find function `divisor`\
    \ in this scope\n  --> /tmp/tmpwbvz0jgc.rs:14:38\n   |\n14 |         return 1\
    \ + starts_one_ends(n/divisor(n/10));\n   |                                  \
    \    ^^^^^^^ not found in this scope\n\nwarning: unreachable statement\n  -->\
    \ /tmp/tmpwbvz0jgc.rs:28:5\n   |\n21 | /     loop {\n22 | |         count += 1;\n\
    23 | |         mod /= 10;\n24 | |         if mod == 1 {\n25 | |             break;\n\
    26 | |         }\n27 | |     }\n   | |_____- any code following this expression\
    \ is unreachable\n28 |       return count;\n   |       ^^^^^^^^^^^^^ unreachable\
    \ statement\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror:\
    \ aborting due to 3 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n    let mut count = 0;\n    for x in\
    \ 1..n {\n        if x == 1 {\n            count += 1;\n        }\n        else\
    \ {\n            count -= 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpomwhpf66.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n.checked_mul(&isize::MAX).unwrap().checked_sub(isize::MAX)\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpigzoac73.rs:4:19\n  |\n4 |\
    \     n.checked_mul(&isize::MAX).unwrap().checked_sub(isize::MAX)\n  |       \
    \            ^^^^^^^^^^^ expected `isize`, found `&isize`\n  |\nhelp: consider\
    \ removing the borrow\n  |\n4 -     n.checked_mul(&isize::MAX).unwrap().checked_sub(isize::MAX)\n\
    4 +     n.checked_mul(isize::MAX).unwrap().checked_sub(isize::MAX)\n  | \n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpigzoac73.rs:4:5\n  |\n3 | fn starts_one_ends(n:\
    \ isize) -> isize {\n  |                                 ----- expected `isize`\
    \ because of return type\n4 |     n.checked_mul(&isize::MAX).unwrap().checked_sub(isize::MAX)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n       \
    \      found enum `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n > 0 {\n        starts_one_ends(n - 1) + n - 1\n    } else\
    \ if n < 0 {\n        starts_one_ends(-n) + -n\n    } else {\n        0\n    }\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp6z_fnn2n.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    use std::cmp::Ordering;\n    n.iter()\n        .windows(2)\n\
    \        .filter(|(a, b)| {\n            Ordering::Less.eq(&*a, &*b)\n       \
    \ })\n        .count()\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n --> /tmp/tmptnqxf8uu.rs:5:7\n  |\n5 |     n.iter()\n  |       ^^^^ method\
    \ not found in `isize`\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmptnqxf8uu.rs:8:28\n    |\n8   |             Ordering::Less.eq(&*a,\
    \ &*b)\n    |                            ^^ ---  --- supplied 2 arguments\n  \
    \  |                            |\n    |                            expected 1\
    \ argument\n    |\nnote: associated function defined here\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n % 10 == 0);\n    debug_assert!(n > 0);\n   \
    \ (n - 1) / 10 + 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n \
    \   assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: n % 10 == 0', /tmp/tmpi4529xj0.rs:4:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n % 10 {\n        0 | 1 => 1,\n        _ => n,\n    }\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpgg6_id5k.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut starts: isize = 0;\n    let mut ends: isize = 0;\n \
    \   let mut i = 1;\n    while i < n {\n        if *i % 10 == 1 {\n           \
    \ starts += 1;\n        } else {\n            ends += 1;\n        }\n        i\
    \ += 1;\n    }\n    starts\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpojp7opjs.rs:8:12\n\
    \  |\n8 |         if *i % 10 == 1 {\n  |            ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!((n >= 0) && (n <= 100));\n    let mut count =\
    \ 0;\n    let mut limit: isize = n - 1;\n    while limit >= 1 && !(limit & 1)\
    \ {\n        count += 1;\n        limit /= 2;\n    }\n    return count;\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4u50v_iq.rs:7:25\n  |\n7 |\
    \     while limit >= 1 && !(limit & 1) {\n  |                         ^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // count the number of 0s starting from the first\n    let mut\
    \ zero_count = n;\n    let mut ones = 0;\n\n    while zero_count > 0 {\n     \
    \   if zero_count == 1 {\n            ones += 1;\n        }\n        zero_count\
    \ -= 1;\n    }\n\n    ones\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmphtye28qi.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 {\n        return 0;\n    }\n    if n == 1 || n ==\
    \ 2 {\n        return 1;\n    }\n    let mut count = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    while n != 1 {\n        let mut k = n;\n        while\
    \ k % 10 == 1 {\n            k /= 10;\n            count += 1;\n        }\n  \
    \      m += 1;\n        n /= 10;\n    }\n    let mut n2 = n;\n    while n2 !=\
    \ 1 {\n        let mut k = n2;\n        while k % 10 == 1 {\n            k /=\
    \ 10;\n            count += 1;\n        }\n        m += 1;\n        n2 /= 10;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n  \
    \  assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp8e7b3psz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n\n    let mut count = 0;\n    for i in\
    \ 0..(n - 1) {\n        if ((n % i) == 0) {\n            count += 1;\n       \
    \ }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpx7599blw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 { return n }\n    let mut counter = n as usize;\n\
    \    while counter > 0 {\n        if n % 10 == 1 {\n            counter -= 1;\n\
    \        } else {\n            break;\n        }\n        n /= 10;\n    }\n  \
    \  counter\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprtmzh12v.rs:14:5\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n...\n14 |     counter\n\
    \   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    14 |     counter.try_into().unwrap()\n   |            ++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n&1 == 0 {\n        return n\n    }\n\n    let mut i = 1;\n\
    \    while i < n {\n        if n%i == 0 {\n            return i + 1;\n       \
    \ }\n\n        i += 1;\n    }\n\n    n\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp4gjmptbq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut cnt = 0;\n    while n > 0 && cnt < n {\n        if n\
    \ % 10 == 1 {\n            cnt += 1;\n        }\n        n /= 10;\n    }\n   \
    \ cnt\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp4dq8zwuq.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        1 => 1,\n        _ => n,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp1gup7fm1.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|i| i % 10 == 1).count() * n\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp65imw1ps.rs:4:46\n  |\n4 |\
    \     (1..n).filter(|i| i % 10 == 1).count() * n\n  |                        \
    \                      ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp65imw1ps.rs:4:5\n  |\n3 | fn starts_one_ends(n: isize) ->\
    \ isize {\n  |                                 ----- expected `isize` because\
    \ of return type\n4 |     (1..n).filter(|i| i % 10 == 1).count() * n\n  |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n4 |     ((1..n).filter(|i| i % 10 == 1).count() * n).try_into().unwrap()\n\
    \  |     +                                          +++++++++++++++++++++\n\n\
    error[E0277]: cannot multiply `usize` by `isize`\n --> /tmp/tmp65imw1ps.rs:4:44\n\
    \  |\n4 |     (1..n).filter(|i| i % 10 == 1).count() * n\n  |                \
    \                            ^ no implementation for `usize * isize`\n  |\n  =\
    \ help: the trait `Mul<isize>` is not implemented for `usize`\n  = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n            <&'a f32 as Mul<f32>>\n\
    \            <&'a f64 as Mul<f64>>\n            <&'a i128 as Mul<i128>>\n    \
    \        <&'a i16 as Mul<i16>>\n            <&'a i32 as Mul<i32>>\n          \
    \  <&'a i64 as Mul<i64>>\n            <&'a i8 as Mul<i8>>\n            <&'a isize\
    \ as Mul<isize>>\n          and 49 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|x| x.is_positive()).count() - 1 // n\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc8l19v_i.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..n).filter(|x| x.is_positive()).count()\
    \ - 1 // n\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n4 |     ((1..n).filter(|x| x.is_positive()).count()\
    \ - 1).try_into().unwrap() // n\n  |     +                                   \
    \           +++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n + 1)/2 - 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp3z3a5mup.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n % 10 {\n        1 => 1,\n        _ => 1 + starts_one_ends(n\
    \ / 10),\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        let mut iter = n.digits.iter().cloned();\n \
    \       if iter.next().unwrap() == 1 {\n            n -= 1;\n        } else {\n\
    \            break;\n        }\n    }\n\n    n - 1\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \ --> /tmp/tmpqq3ffgfu.rs:5:26\n  |\n5 |         let mut iter = n.digits.iter().cloned();\n\
    \  |                          ^^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 1 {\n        return 0;\n    }\n\n    if n <= 10 {\n \
    \       return 1 + starts_one_ends(n - 1);\n    }\n\n    if n % 10 == 1 {\n  \
    \      return 1 + starts_one_ends(n / 10 - 1);\n    }\n\n    1 + starts_one_ends(n\
    \ / 10) - starts_one_ends(n % 10 - 1)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp_67qv17g.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 1 {\n        return 0\n    }\n    n.checked_div(10_usize).expect(\"\
    n must be positive\")\n        .checked_sub(1)\n        .expect(\"n must be positive\"\
    )\n        .checked_mul(10_usize)\n        .expect(\"n must be positive\")\n \
    \       .unwrap_or(n.checked_mul(_isize::MAX))\n        .checked_div(_isize::MAX)\n\
    \        .expect(\"n must be positive\")\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `_isize`\n\
    \  --> /tmp/tmpzkkd037s.rs:12:34\n   |\n12 |         .unwrap_or(n.checked_mul(_isize::MAX))\n\
    \   |                                  ^^^^^^ use of undeclared crate or module\
    \ `_isize`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `_isize`\n  --> /tmp/tmpzkkd037s.rs:13:22\n   |\n13 |         .checked_div(_isize::MAX)\n\
    \   |                      ^^^^^^ use of undeclared crate or module `_isize`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpzkkd037s.rs:7:19\n  |\n7 |    \
    \ n.checked_div(10_usize).expect(\"n must be positive\")\n  |                \
    \   ^^^^^^^^ expected `isize`, found `usize`\n  |\nhelp: change the type of the\
    \ numeric literal from `usize` to `isize`\n  |\n7 |     n.checked_div(10_isize).expect(\"\
    n must be positive\")\n  |                      ~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzkkd037s.rs:10:22\n   |\n10 |         .checked_mul(10_usize)\n\
    \   |                      ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ change the type of the numeric literal from `usize` to `isize`\n   |\n10 | \
    \        .checked_mul(10_isize)\n   |                         ~~~~~\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpzkkd037s.rs:12:10\n   |\n12 |         .unwrap_or(n.checked_mul(_isize::MAX))\n\
    \   |          ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut i = 1;\n    while i <= n {\n        if i / 10 == 1 {\n\
    \            i += 1;\n        } else {\n            break;\n        }\n    }\n\
    \    if i >= n {\n        0\n    } else {\n        i\n    }\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpko9un4c2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 3 {\n        return 1;\n    }\n    if n == 3 {\n    \
    \    return 2;\n    }\n\n    (1..=n).filter(|x| *x == 1).count() - 1\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40gms_7i.rs:11:5\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n...\n11 |     (1..=n).filter(|x|\
    \ *x == 1).count() - 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     ((1..=n).filter(|x|\
    \ *x == 1).count() - 1).try_into().unwrap()\n   |     +                      \
    \                 +++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n)\n        .filter(|&x| x.is_power_of_two())\n        .filter(|x|\
    \ x.pow2() % 10 == 1)\n        .count()\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n --> /tmp/tmp1tqklg9r.rs:5:24\n  |\n5 |         .filter(|&x|\
    \ x.is_power_of_two())\n  |                        ^^^^^^^^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `pow2` found for reference\
    \ `&isize` in the current scope\n --> /tmp/tmp1tqklg9r.rs:6:23\n  |\n6 |     \
    \    .filter(|x| x.pow2() % 10 == 1)\n  |                       ^^^^ help: there\
    \ is an associated function with a similar name: `pow`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp1tqklg9r.rs:4:5\n  |\n3 |   fn starts_one_ends(n: isize)\
    \ -> isize {\n  |                                   ----- expected `isize` because\
    \ of return type\n4 | /     (1..n)\n5 | |         .filter(|&x| x.is_power_of_two())\n\
    6 | |         .filter(|x| x.pow2() % 10 == 1)\n7 | |         .count()\n  | |________________^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n7 |         .count().try_into().unwrap()\n\
    \  |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // n / 10 means \"the integer part of n\"\n    // if n is divisible\
    \ by 10, then all integers are divisible by 10\n    // because 10 divides all\
    \ the other integers.\n    // if n is not divisible by 10, then n is divisible\
    \ by 10 because\n    // n is not divisible by 10.\n    // so n/10 means \"the\
    \ integer part of n\"\n    (n % 10).count_range(10, n - n%10)\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `count_range` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp27i_dxtk.rs:10:14\n   |\n10 |     (n % 10).count_range(10,\
    \ n - n%10)\n   |              ^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 { return 0; }\n    \n    if n <= 10 { return n; }\n\
    \    \n    let mut n1: isize = 1;\n    let mut n2: isize = 1;\n    let mut n3:\
    \ isize = 1;\n    \n    while n2 <= n {\n        if n % n1 == 0 {\n          \
    \  *n1 = n1 * 10 + n2;\n            n1 += 1;\n        }\n        \n        if\
    \ n % n2 == 0 {\n            *n2 = n2 * 10 + n3;\n            n2 += 1;\n     \
    \   }\n        \n        if n % n3 == 0 {\n            *n3 = n3;\n           \
    \ n3 += 1;\n        }\n        \n        if n3 > n2 {\n            n2 = 1;\n \
    \           n3 += 1;\n        }\n    }\n    \n    if n1 == 1 { 0 } else { n1 -\
    \ 1 }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpo8aosntx.rs:14:13\n\
    \   |\n14 |             *n1 = n1 * 10 + n2;\n   |             ^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpo8aosntx.rs:19:13\n   |\n\
    19 |             *n2 = n2 * 10 + n3;\n   |             ^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpo8aosntx.rs:24:13\n   |\n24 |\
    \             *n3 = n3;\n   |             ^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n\
    \        if n % i == 0 {\n            count += 1;\n            i += 1;\n     \
    \   }\n        else {\n            i += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpfniypvoq.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 0);\n\n \
    \   (n - 1) * 10 + 1 + starts_one_ends(n - 1)\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: n % 10 == 0', /tmp/tmpste04lq_.rs:5:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        0 => 1,\n        1 => 1,\n        _ => n\
    \ - 1,\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp4n926an_.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    for digit in n.digits() - 1 {\n    \
    \    if digit % 2 == 1 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpjvw5_f1_.rs:5:20\n  |\n5 |     for digit in n.digits() -\
    \ 1 {\n  |                    ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 1 {\n        return 1\n    } else {\n        (n - 1).count_if(|&i|\
    \ i.is_positive())\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `count_if` found for type `isize` in the\
    \ current scope\n --> /tmp/tmphik6r8sn.rs:7:17\n  |\n7 |         (n - 1).count_if(|&i|\
    \ i.is_positive())\n  |                 ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    let mut count =\
    \ 1;\n    while n > 1 {\n        if n % 10 == 1 {\n            count += 1;\n \
    \       }\n        n /= 10;\n    }\n\n    if n == 1 {\n        count += 1;\n \
    \   }\n\n    count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n \
    \   assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpi2uyzoy3.rs:13:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n13 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n / 10_0) - 1 as isize\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `1`', /tmp/tmpy23zfuqy.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 1;\n    for i in n..=0 {\n        if !(i ==\
    \ 1 || i % 10 == 1) {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp3li_3q6b.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|x| *x % 10 == 1).count()\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpeqyw3xyc.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..=n).filter(|x| *x\
    \ % 10 == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and\
    \ panic if the converted value doesn't fit\n  |\n4 |     (1..=n).filter(|x| *x\
    \ % 10 == 1).count().try_into().unwrap()\n  |                                \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n / 10 * 10 + n % 10 + 1 | 0\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpj66fr8ds.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 1 {\n        0\n    } else {\n        if n % 10 == 1\
    \ && n % 10 != 0 {\n            // a negative multiple of 10\n            n.count().checked_mul(10).expect(\"\
    should never overflow\")\n        } else {\n            // a multiple of 10\n\
    \            n.checked_mul(10).expect(\"should never overflow\")\n           \
    \     .count() / 10.checked_mul(10).expect(\"should never overflow\")\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n --> /tmp/tmpzbf9e6bv.rs:9:15\n\
    \  |\n9 |             n.count().checked_mul(10).expect(\"should never overflow\"\
    )\n  |               ^^^^^ `isize` is not an iterator\n  |\n  = note: the following\
    \ trait bounds were not satisfied:\n          `isize: Iterator`\n          which\
    \ is required by `&mut isize: Iterator`\n\nerror[E0599]: `isize` is not an iterator\n\
    \  --> /tmp/tmpzbf9e6bv.rs:13:18\n   |\n13 |                 .count() / 10.checked_mul(10).expect(\"\
    should never overflow\")\n   |                  ^^^^^ `isize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `isize:\
    \ Iterator`\n           which is required by `&mut isize: Iterator`\n\nerror[E0689]:\
    \ can't call method `checked_mul` on ambiguous numeric type `{integer}`\n  -->\
    \ /tmp/tmpzbf9e6bv.rs:13:31\n   |\n13 |                 .count() / 10.checked_mul(10).expect(\"\
    should never overflow\")\n   |                               ^^^^^^^^^^^\n   |\n\
    help: you must specify a concrete type for this numeric value, like `i32`\n  \
    \ |\n13 |                 .count() / 10_i32.checked_mul(10).expect(\"should never\
    \ overflow\")\n   |                            ~~~~~~\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0599, E0689.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        if n%i == 0\
    \ || i == n {\n            count += 1;\n            if i == n || i == n+1 {\n\
    \                count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmp5hwgln0r.rs:6:12\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    fn ones_up_to_n(start: isize) -> isize {\n        let mut count\
    \ = 0;\n        while start > 0 {\n            if start % 10 == 1 {\n        \
    \        count += 1;\n            }\n            start /= 10;\n        }\n   \
    \     count\n    }\n\n    if n == 0 {\n        0\n    } else if n == 1:\n    \
    \    1\n    } else if n == 2 {\n        0\n    } else if n == 3 {\n        1\n\
    \    } else if n == 4 {\n        2\n    } else if n == 5 {\n        3\n    } else\
    \ if n == 6 {\n        4\n    } else if n == 7 {\n        5\n    } else if n ==\
    \ 8 {\n        6\n    } else if n == 9 {\n        7\n    } else if n >= 10 {\n\
    \        ones_up_to_n(n - 10)\n    } else {\n        panic!()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpseaf2ly5.rs:40:1\n\
    \   |\n37 |     } else {\n   |            - this opening brace...\n38 |      \
    \   panic!()\n39 |     }\n   |     - ...matches this closing brace\n40 | }\n \
    \  | ^ unexpected closing delimiter\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 1 {\n        return 0;\n    }\n\n    if n % 10 == 1\
    \ {\n        return starts_one_ends(n - 1);\n    }\n\n    starts_one_ends(n /\
    \ 10) + 1;\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw_xi4xdi.rs:3:33\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |    ---------------        \
    \      ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n...\n12 |     starts_one_ends(n\
    \ / 10) + 1;\n   |                                - help: remove this semicolon\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 || n > 1000 {\n        panic!(\"Cannot determine number\
    \ of 1's starting or ending at position {:?}\", n);\n    }\n    if n < 100 {\n\
    \        return 0;\n    }\n\n    let mut count = 0;\n    let mut i = n;\n    while\
    \ i > 0 {\n        if i % 10 == 1 {\n            i += 1;\n            continue;\n\
    \        }\n        if i % 10 == 0 {\n            count += 1;\n        }\n   \
    \     i /= 10;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmphtw34by4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // O(log(n))\n    let mut i = 1;\n    let mut count = 0;\n \
    \   while i <= n {\n        if n % i == 0 {\n            count += 1;\n       \
    \ }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpwsdfihc1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    use std::mem::size_of;\n    let mut ones = 0;\n\n    while n\
    \ > 0 {\n        if n % 10 == 1 {\n            ones +=\n                (size_of::<usize>()\
    \ / size_of::<isize>()) *\n                    (n as usize / 10 as\n         \
    \            isize / 10);\n        }\n        n /= 10;\n    }\n    ones\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp33dqsri.rs:11:35\n   |\n\
    11 |                       (n as usize / 10 as\n   |  ___________________________________^\n\
    12 | |                      isize / 10);\n   | |__________________________^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot divide `usize` by `isize`\n \
    \ --> /tmp/tmpp33dqsri.rs:11:33\n   |\n11 |                     (n as usize /\
    \ 10 as\n   |                                 ^ no implementation for `usize /\
    \ isize`\n   |\n   = help: the trait `Div<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Div<Rhs>`:\n          \
    \   <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp33dqsri.rs:16:5\n   |\n3  | fn starts_one_ends(n:\
    \ isize) -> isize {\n   |                                 ----- expected `isize`\
    \ because of return type\n...\n16 |     ones\n   |     ^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |     ones.try_into().unwrap()\n\
    \   |         ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    // This implementation is O(n), but in practice it will be close\
    \ to O(1).\n    // The trick is that we count the number of digits that end in\
    \ 1,\n    // multiply it by 2, subtract 1 from the digits, and then add 1\n  \
    \  // to that number to get the number of numbers with that many digits.\n   \
    \ let mut count = 0;\n    for i in 0..n {\n        if n % 10 == 1 {\n        \
    \    count += 2;\n            n /= 10;\n        } else {\n            n /= 10;\n\
    \            count += 1;\n        }\n    }\n    count + 1\n}\n\nfn main() {\n\
    \    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n --> /tmp/tmpy1w8_oer.rs:9:9\n  |\n9 | \
    \    for i in 0..n {\n  |         ^ help: if this is intentional, prefix it with\
    \ an underscore: `_i`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpy1w8_oer.rs:12:13\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n12 |             n\
    \ /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpy1w8_oer.rs:14:13\n \
    \  |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n14 |             n\
    \ /= 10;\n   |             ^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n    (n as usize - 1).trailing_zeros()\
    \ as isize\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `1`', /tmp/tmpi5t61bqi.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        return 0\n    }\n    let mut count = 0;\n\
    \    let mut last = n;\n    while last > 0 {\n        let mut tmp = last % 10;\n\
    \        if tmp == 1 {\n            count += 1\n        }\n        last /= 10;\n\
    \    }\n    return count\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `18`', /tmp/tmpb1odt7ey.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    while n > 0 && n % 10 == 1 {\n     \
    \   n /= 10;\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmppm_nd8ly.rs:6:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n6 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n<1 {\n        return 0\n    }\n    \n    let mut s = n.checked_mul(n);\n\
    \    let mut c = 1;\n    while s.is_positive() {\n        if s.checked_add(1).is_zero()\
    \ {\n            break;\n        }\n        c += 1;\n        s *= n;\n    }\n\
    \    c\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_positive` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpjilsc5rm.rs:10:13\n   |\n10 |     while s.is_positive()\
    \ {\n   |             ^^^^^^^^^^^ method not found in `Option<isize>`\n\nerror[E0599]:\
    \ no method named `checked_add` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpjilsc5rm.rs:11:14\n   |\n11 |         if s.checked_add(1).is_zero()\
    \ {\n   |              ^^^^^^^^^^^ method not found in `Option<isize>`\n\nerror[E0368]:\
    \ binary assignment operation `*=` cannot be applied to type `Option<isize>`\n\
    \  --> /tmp/tmpjilsc5rm.rs:15:9\n   |\n15 |         s *= n;\n   |         -^^^^^\n\
    \   |         |\n   |         cannot use `*=` on type `Option<isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n * 2) as isize + n / 2\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpfm7o8bah.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n / starts_one::<usize>() / n % starts_one::<usize>() + (n %\
    \ starts_one::<usize>() == 0)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `starts_one` in this scope\n --> /tmp/tmpjpkvirjh.rs:4:9\n\
    \  |\n4 |     n / starts_one::<usize>() / n % starts_one::<usize>() + (n % starts_one::<usize>()\
    \ == 0)\n  |         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `starts_one` in this scope\n --> /tmp/tmpjpkvirjh.rs:4:37\n  |\n\
    4 |     n / starts_one::<usize>() / n % starts_one::<usize>() + (n % starts_one::<usize>()\
    \ == 0)\n  |                                     ^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `starts_one` in this scope\n -->\
    \ /tmp/tmpjpkvirjh.rs:4:66\n  |\n4 |     n / starts_one::<usize>() / n % starts_one::<usize>()\
    \ + (n % starts_one::<usize>() == 0)\n  |                                    \
    \                              ^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ cannot add `bool` to `isize`\n --> /tmp/tmpjpkvirjh.rs:4:59\n  |\n4 |     n\
    \ / starts_one::<usize>() / n % starts_one::<usize>() + (n % starts_one::<usize>()\
    \ == 0)\n  |                                                           ^ no implementation\
    \ for `isize + bool`\n  |\n  = help: the trait `Add<bool>` is not implemented\
    \ for `isize`\n  = help: the following other types implement trait `Add<Rhs>`:\n\
    \            <&'a f32 as Add<f32>>\n            <&'a f64 as Add<f64>>\n      \
    \      <&'a i128 as Add<i128>>\n            <&'a i16 as Add<i16>>\n          \
    \  <&'a i32 as Add<i32>>\n            <&'a i64 as Add<i64>>\n            <&'a\
    \ i8 as Add<i8>>\n            <&'a isize as Add<isize>>\n          and 48 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut s = n - 1;\n    let mut starts = 1;\n    let mut ends\
    \ = 1;\n    while s >= 10 {\n        starts += 1;\n        s -= 10;\n    }\n \
    \   while s < 10 {\n        ends += 1;\n        s += 10;\n    }\n    starts\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp9hb46wvi.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|x| x > 0 && n % x == 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuqzn_e8i.rs:4:28\n  |\n4 |\
    \     (1..=n).filter(|x| x > 0 && n % x == 0).count()\n  |                   \
    \         ^\n  |                            |\n  |                           \
    \ expected `&isize`, found integer\n  |                            help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuqzn_e8i.rs:4:5\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                       \
    \          ----- expected `isize` because of return type\n4 |     (1..=n).filter(|x|\
    \ x > 0 && n % x == 0).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     (1..=n).filter(|x|\
    \ x > 0 && n % x == 0).count().try_into().unwrap()\n  |                      \
    \                              ++++++++++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 { return 1 }\n    let mut starts_one_ends = 0;\n \
    \   let mut n_digits = n.leading_zeros() as usize;\n    while n_digits > 0 {\n\
    \        if n % 10 == 1 {\n            ++starts_one_ends;\n        }\n       \
    \ n /= 10;\n        --n_digits;\n    }\n    return starts_one_ends;\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: Rust has no prefix increment operator\n --> /tmp/tmpjr54bnyk.rs:9:13\n\
    \  |\n9 |             ++starts_one_ends;\n  |             ^^ not a valid prefix\
    \ operator\n  |\nhelp: use `+= 1` instead\n  |\n9 |             { starts_one_ends\
    \ += 1; starts_one_ends };\n  |             ~                 +++++++++++++++++++++++\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpjr54bnyk.rs:12:10\n\
    \   |\n12 |         --n_digits;\n   |          ^^^^^^^^^ cannot apply unary operator\
    \ `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmpjr54bnyk.rs:12:9\n \
    \  |\n12 |         --n_digits;\n   |         ^^^^^^^^^^ cannot apply unary operator\
    \ `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0600`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    fn one_up_to_n(n: isize) -> isize {\n        if n == 1 {\n \
    \           0\n        } else {\n            one_up_to_n(n - 1) + 1\n        }\n\
    \    }\n    one_up_to_n(n) + 1\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp2uw31s5y.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        0 => 0,\n        _ if n < 10 => n,\n    \
    \    n if n > 9 => 0,\n        _ => {\n            let mut count = 0;\n      \
    \      while n >= 10 {\n                n -= 10;\n                count += 1;\n\
    \            }\n            count\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpykb1x9sa.rs:11:17\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n11 |             \
    \    n -= 10;\n   |                 ^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        let mut num = n;\n        if num == 1 {\n  \
    \          return 1;\n        }\n        if num < 10 {\n            return num;\n\
    \        }\n        num = num / 10;\n        if num == 1 {\n            return\
    \ num;\n        }\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp3fbjl4j8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n&1 == 0 {\n        return n / 2;\n    }\n    else {\n  \
    \      n/2 + 1 as isize\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmp11t09mv2.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    fn is_one_or_ends_with(v: u8) -> bool {\n        (v == 1) ||\
    \ (v & !0xFF == v)\n    }\n\n    (1..n).filter(|&i| is_one_or_ends_with(i)).count()\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_rpt5ety.rs:8:44\n  |\n8 |\
    \     (1..n).filter(|&i| is_one_or_ends_with(i)).count()\n  |                \
    \                            ^ expected `u8`, found `isize`\n  |\nhelp: you can\
    \ convert an `isize` to a `u8` and panic if the converted value doesn't fit\n\
    \  |\n8 |     (1..n).filter(|&i| is_one_or_ends_with(i.try_into().unwrap())).count()\n\
    \  |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp_rpt5ety.rs:8:5\n  |\n3 | fn starts_one_ends(n:\
    \ isize) -> isize {\n  |                                 ----- expected `isize`\
    \ because of return type\n...\n8 |     (1..n).filter(|&i| is_one_or_ends_with(i)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n8 |     (1..n).filter(|&i| is_one_or_ends_with(i)).count().try_into().unwrap()\n\
    \  |                                                       ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n % 10 {\n        0 => n - 10,\n        1 => n - 1,\n\
    \        _ => 0,\n    }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp_x3ymczd.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|i| i % 10 == 1).count() - n - 1\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpghafdlum.rs:4:46\n  |\n4 |\
    \     (1..n).filter(|i| i % 10 == 1).count() - n - 1\n  |                    \
    \                          ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n --> /tmp/tmpghafdlum.rs:4:44\n  |\n4\
    \ |     (1..n).filter(|i| i % 10 == 1).count() - n - 1\n  |                  \
    \                          ^ no implementation for `usize - isize`\n  |\n  = help:\
    \ the trait `Sub<isize>` is not implemented for `usize`\n  = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n            <&'a f32 as Sub<f32>>\n\
    \            <&'a f64 as Sub<f64>>\n            <&'a i128 as Sub<i128>>\n    \
    \        <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n          \
    \  <&'a i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n            <&'a isize\
    \ as Sub<isize>>\n          and 48 others\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpghafdlum.rs:4:5\n  |\n3 | fn starts_one_ends(n: isize) -> isize\
    \ {\n  |                                 ----- expected `isize` because of return\
    \ type\n4 |     (1..n).filter(|i| i % 10 == 1).count() - n - 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n4 |     ((1..n).filter(|i|\
    \ i % 10 == 1).count() - n - 1).try_into().unwrap()\n  |     +               \
    \                               +++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut num_starts = 0;\n    let mut num_ends = 0;\n    while\
    \ n > 0 {\n        if n % 10 == 1 {\n            num_starts += 1;\n        }\n\
    \        if n % 10 == 0 {\n            num_ends += 1;\n        }\n        n /=\
    \ 10;\n    }\n    2 * num_starts + num_ends\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpbj2dubu3.rs:13:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n13 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n.checked_add( // count starting or ending 1\n        1 +\n\
    \            n.checked_mul(\n                1 +\n                    n.checked_mul(\n\
    \                        1 +\n                            n.checked_mul(\n   \
    \                             1 +\n                                    n.checked_mul(\n\
    \                                        1 +\n                               \
    \             n.checked_mul(\n                                               \
    \ 1 +\n                                                    n.checked_mul(\n  \
    \                                                      1 +\n                 \
    \                                           n.checked_mul(\n                 \
    \                                               1 +\n                        \
    \                                            n.checked_mul(\n                \
    \                                                        1 +\n               \
    \                                                             n.checked_mul(\n\
    \                                                                            \
    \    1 +\n                                                                   \
    \                 n.checked_mul(\n                                           \
    \                                             1 +\n                          \
    \                                                                  n.checked_mul(\n\
    \                                                                            \
    \                    1 +\n                                                   \
    \                                                 n.checked_mul(\n           \
    \                                                                            \
    \                 1 +\n                                                      \
    \                                                      n.checked_mul(\n      \
    \                                                                            \
    \                              1 +\n                                         \
    \                                                                           n.checked_mul(\n\
    \                                                                            \
    \                                            1 +\n                           \
    \                                                                            \
    \                     n.checked_mul(\n                                       \
    \                                                                            \
    \             1 +\n                                                          \
    \                                                                          n.checked_mul(\n\
    \                                                                            \
    \                                                            1 +\n           \
    \                                                                            \
    \                                                     n.checked_mul(\n       \
    \                                                                            \
    \                                                             1 +\n          \
    \                                                                            \
    \                                                              n.checked_mul(\n\
    \                                                                            \
    \                                                                            1\
    \ +\n                                                                        \
    \                                                                            \
    \        n.checked_mul(\n                                                    \
    \                                                                            \
    \                                1 +\n                                       \
    \                                                                            \
    \                                                 n.checked_mul(\n           \
    \                                                                            \
    \                                                                            \
    \     1 +\n                                                                  \
    \                                                                            \
    \                              n.checked_mul(\n                              \
    \                                                                            \
    \                                                                      1 +\n \
    \                                                                            \
    \                                                                            \
    \                           n.checked_mul(\n                                 \
    \                                                                            \
    \                                                                           1\
    \ +\n                                                                        \
    \                                                                            \
    \                                        n.checked_mul(\n                    \
    \                                                                            \
    \                                                                            \
    \                    1 +\n                                                   \
    \                                                                            \
    \                                                                     n.checked_mul(\n\
    \                                                                            \
    \                                                                            \
    \                                                1 +\n                       \
    \                                                                            \
    \                                                                            \
    \                             n.checked_mul(\n                               \
    \                                                                            \
    \                                                                            \
    \                         1 +\n                                              \
    \                                                                            \
    \                                                                            \
    \              n.checked_mul(\n                                              \
    \                                                                            \
    \                                                                            \
    \                  1 +\n                                                     \
    \                                                                            \
    \                                                                            \
    \               n.checked_mul(\n                                             \
    \                                                                            \
    \                                                                            \
    \                           1 +\n                                            \
    \                                                                            \
    \                                                                            \
    \                                n.checked_mul(\n                            \
    \                                                                            \
    \                                                                            \
    \                                                    1 +\n                   \
    \                                                                            \
    \                                                                            \
    \                                                                 n.checked_mul(\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \            1 +\n                                                           \
    \                                                                            \
    \                                                                            \
    \                                 n.checked_mul(\n                           \
    \                                                                            \
    \                                                                            \
    \                                                                     1 +\n  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                      n.checked_mul(\n                                      \
    \                                                                            \
    \                                                                            \
    \                                                                  1 +\n     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                           n.checked_mul(\n                                 \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   1 +\n                                                                    \
    \                                                                            \
    \                                                                            \
    \                                                n.checked_mul(\n            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                1 +\n                                       \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \         n.checked_mul(\n                                                   \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \ 1 +\n                                                                      \
    \                                                                            \
    \                                                                            \
    \                                                              n.checked_mul(\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                            1 +\n           \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                     n.checked_mul(\n       \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                             1 +\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp2dcshggx.rs:78:1\n\
    \   |\n78 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp2dcshggx.rs:76:306\n   |\n3  | fn starts_one_ends(n: isize)\
    \ -> isize {\n   |                                       - closing delimiter possibly\
    \ meant for this\n...\n76 |                                                  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \               n.checked_mul(\n   |                                         \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                     ^ unclosed delimiter\n77 |             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                        1 +\n78 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n <= 0 {\n        0\n    } else if n <= 9 {\n        n\n\
    \    } else {\n        (n - 10) * 10 + 10\n    }\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmp68utt6mx.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    fn one_starts_one(n: isize) -> isize {\n        n / 10 + 1\n\
    \    }\n\n    one_starts_one(n) * 10\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `1`', /tmp/tmpm8w8g8mf.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        1 => 1,\n        _ => n,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpyghdkmyj.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 10 { return 1 }\n    if n < 100 { return 2 }\n    if\
    \ n < 1000 { return 3 }\n    if n < 10000 { return 4 }\n    if n < 100000 { return\
    \ 5 }\n    if n < 1000000 { return 6 }\n    if n < 10000000 { return 7 }\n   \
    \ if n < 100000000 { return 8 }\n    if n < 1000000000 { return 9 }\n    if n\
    \ < 10000000000 { return 10 }\n    if n < 100000000000 { return 11 }\n    if n\
    \ < 1000000000000 { return 12 }\n    if n < 10000000000000 { return 13 }\n   \
    \ if n < 100000000000000 { return 14 }\n    if n < 1000000000000000 { return 15\
    \ }\n    if n < 10000000000000000 { return 16 }\n    if n < 100000000000000000\
    \ { return 17 }\n    if n < 1000000000000000000 { return 18 }\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmprut43tmc.rs:21:5\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \             ----- expected `isize` because of this return type\n...\n21 |  \
    \   if n < 1000000000000000000 { return 18 }\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n   |\n   = note: `if` expressions without `else`\
    \ evaluate to `()`\n   = help: consider adding an `else` block that evaluates\
    \ to the expected type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut counter = 0;\n    while n > 1 {\n        if n % 10 ==\
    \ 1 {\n            n /= 10;\n            counter += 1;\n        }\n        else\
    \ {\n            break;\n        }\n    }\n    counter\n}\n\nfn main() {\n   \
    \ let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp59t_0k9o.rs:7:13\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |             n /= 10;\n\
    \  |             ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    fn ones<T: Default>(x: T) -> T {\n        x\n    }\n    (1..n).filter(ones).count()\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `for<'r> <fn(&isize) -> &isize {ones::<&isize>}\
    \ as FnOnce<(&'r isize,)>>::Output == bool`\n   --> /tmp/tmpm3jtq6t8.rs:7:12\n\
    \    |\n7   |     (1..n).filter(ones).count()\n    |            ^^^^^^ expected\
    \ `bool`, found `&isize`\n    |\nnote: required by a bound in `filter`\n\nerror[E0277]:\
    \ the trait bound `&isize: Default` is not satisfied\n --> /tmp/tmpm3jtq6t8.rs:7:19\n\
    \  |\n7 |     (1..n).filter(ones).count()\n  |                   ^^^^ the trait\
    \ `Default` is not implemented for `&isize`\n  |\n  = help: the following other\
    \ types implement trait `Default`:\n            f32\n            f64\n       \
    \     i128\n            i16\n            i32\n            i64\n            i8\n\
    \            isize\n          and 6 others\nnote: required by a bound in `ones`\n\
    \ --> /tmp/tmpm3jtq6t8.rs:4:16\n  |\n4 |     fn ones<T: Default>(x: T) -> T {\n\
    \  |                ^^^^^^^ required by this bound in `ones`\n\nerror[E0277]:\
    \ the trait bound `&isize: Default` is not satisfied\n --> /tmp/tmpm3jtq6t8.rs:7:5\n\
    \  |\n7 |     (1..n).filter(ones).count()\n  |     ^^^^^^^^^^^^^^^^^^^ the trait\
    \ `Default` is not implemented for `&isize`\n  |\n  = help: the following other\
    \ types implement trait `Default`:\n            f32\n            f64\n       \
    \     i128\n            i16\n            i32\n            i64\n            i8\n\
    \            isize\n          and 6 others\nnote: required by a bound in `ones`\n\
    \ --> /tmp/tmpm3jtq6t8.rs:4:16\n  |\n4 |     fn ones<T: Default>(x: T) -> T {\n\
    \  |                ^^^^^^^ required by this bound in `ones`\n\nerror[E0599]:\
    \ the method `count` exists for struct `Filter<std::ops::Range<isize>, fn(&isize)\
    \ -> &isize {ones::<&isize>}>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpm3jtq6t8.rs:7:25\n   |\n7  |       (1..n).filter(ones).count()\n   |\
    \                           ^^^^^ method cannot be called on `Filter<std::ops::Range<isize>,\
    \ fn(&isize) -> &isize {ones::<&isize>}>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<fn(&isize)\
    \ -> &isize {ones::<&isize>} as FnOnce<"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    let mut ndigits = n.trailing_zeros();\n\
    \    while ndigits > 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \            ndigits -= 1;\n        }\n        n /= 10;\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_jpuxgfz.rs:11:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n11 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 {\n        return 0;\n    }\n    if n%10 == 1 && n%100\
    \ != 11 {\n        return 1;\n    }\n    if n%10 != 1 && n%100 != 11 {\n     \
    \   return 0;\n    }\n    if n == 1 || n == 11 {\n        return 1;\n    }\n \
    \   starts_one_ends(n / 10) + starts_one_ends(n / 100) + starts_one_ends(n / 1000)\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `18`', /tmp/tmpaxfc307z.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).count(|x| x >= n)\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp6piyw7bx.rs:4:12\n    |\n4   |     (1..n).count(|x| x >= n)\n\
    \    |            ^^^^^ ---------- supplied 1 argument\n    |            |\n \
    \   |            expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6piyw7bx.rs:4:5\n  |\n\
    3 | fn starts_one_ends(n: isize) -> isize {\n  |                             \
    \    ----- expected `isize` because of return type\n4 |     (1..n).count(|x| x\
    \ >= n)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n  |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n  |\n4 |     (1..n).count(|x| x >= n).try_into().unwrap()\n  |\
    \                             ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    use std::cmp::Ordering;\n    let mut ns: Vec<_> = Vec::new();\n\
    \    ns.push((n - 1) % 10);\n    while n > 0 {\n        ns.push((n - 1) % 10);\n\
    \        n /= 10;\n    }\n    let mut zeroes = 0;\n    for n in ns {\n       \
    \ if n == 1 {\n            zeroes += 1;\n        } else {\n            break;\n\
    \        }\n    }\n    zeroes\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n --> /tmp/tmpuz7pn6zg.rs:4:9\n\
    \  |\n4 |     use std::cmp::Ordering;\n  |         ^^^^^^^^^^^^^^^^^^\n  |\n \
    \ = note: `#[warn(unused_imports)]` on by default\n\nerror[E0384]: cannot assign\
    \ to immutable argument `n`\n --> /tmp/tmpuz7pn6zg.rs:9:9\n  |\n3 | fn starts_one_ends(n:\
    \ isize) -> isize {\n  |                    - help: consider making this binding\
    \ mutable: `mut n`\n...\n9 |         n /= 10;\n  |         ^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    loop {\n        n /= 10\n        if n == 0 {\n            return\
    \ n\n        }\n        if n % 10 == 1 {\n            return n\n        }\n  \
    \  }\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n --> /tmp/tmp57si6ez3.rs:5:16\n\
    \  |\n5 |         n /= 10\n  |                ^ help: add `;` here\n6 |      \
    \   if n == 0 {\n  |         -- unexpected token\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut count =\
    \ 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n \
    \       }\n        n /= 10;\n    }\n\n    count\n}\n\nfn main() {\n    let candidate\
    \ = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpy5704j8y.rs:13:9\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    -\
    \ help: consider making this binding mutable: `mut n`\n...\n13 |         n /=\
    \ 10;\n   |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..n).filter(|n| n.is_one_end())\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_one_end` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmpz_5c27ta.rs:4:25\n  |\n4 |     (1..n).filter(|n|\
    \ n.is_one_end())\n  |                         ^^^^^^^^^^ method not found in\
    \ `&isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpz_5c27ta.rs:4:5\n \
    \ |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                        \
    \         ----- expected `isize` because of return type\n4 |     (1..n).filter(|n|\
    \ n.is_one_end())\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `Filter`\n  |\n  = note: expected type `isize`\n           found\
    \ struct `Filter<std::ops::Range<isize>, [closure@/tmp/tmpz_5c27ta.rs:4:19: 4:37]>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        panic!(\"Can't count the integers from 0\
    \ to -n.\")\n    }\n    if n == 1:\n        1\n    } else if n == 2 {\n      \
    \  0\n    } else {\n        starts_one_ends(n - 2) + 1\n    }\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp63qn7jhf.rs:14:1\n\
    \   |\n11 |     } else {\n   |            - this opening brace...\n12 |      \
    \   starts_one_ends(n - 2) + 1\n13 |     }\n   |     - ...matches this closing\
    \ brace\n14 | }\n   | ^ unexpected closing delimiter\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    if n < 0 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    fn one_start(n: isize) -> bool {\n        count += n >= 100;\n        count\
    \ += n % 10 == 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n\
    \        count += n >= 100;\n        count += n % 10 == 1;\n        count += n\
    \ >= 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n       \
    \ count += n % 10 == 1;\n        count += n >= 100;\n        count += n % 10 ==\
    \ 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n        count\
    \ += n >= 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n  \
    \      count += n % 10 == 1;\n        count += n >= 100;\n        count += n %\
    \ 10 == 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n      \
    \  count += n >= 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n\
    \        count += n % 10 == 1;\n        count += n >= 100;\n        count += n\
    \ % 10 == 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n    \
    \    count += n >= 100;\n        count += n % 10 == 1;\n        count += n >=\
    \ 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n        count\
    \ += n % 10 == 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n\
    \        count += n >= 100;\n        count += n % 10 == 1;\n        count += n\
    \ >= 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n       \
    \ count += n % 10 == 1;\n        count += n >= 100;\n        count += n % 10 ==\
    \ 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n        count\
    \ += n >= 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n  \
    \      count += n % 10 == 1;\n        count += n >= 100;\n        count += n %\
    \ 10 == 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n      \
    \  count += n >= 100;\n        count += n % 10 == 1;\n        count += n >= 100;\n\
    \        count += n % 10 == 1;\n        count += n >= 100;\n        count += n\
    \ % 10 == 1;\n        count += n >= 100;\n        count += n % 10 == 1;\n    \
    \    count += n >= 100;\n\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmperd0jr6i.rs:84:3\n\
    \   |\n3  | fn starts_one_ends(n: isize) -> isize {\n   |                    \
    \                   - unclosed delimiter\n...\n8  |     fn one_start(n: isize)\
    \ -> bool {\n   |                                    - this delimiter might not\
    \ be properly closed...\n...\n75 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n84 | }\n   |   ^\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n --> /tmp/tmperd0jr6i.rs:9:9\n  |\n9 |   \
    \      count += n >= 100;\n  |         ^^^^^\n  |\n  = help: use the `|| { ...\
    \ }` closure form instead\n\nerror[E0434]: can't capture dynamic environment in\
    \ a fn item\n  --> /tmp/tmperd0jr6i.rs:10:9\n   |\n10 |         count += n % 10\
    \ == 1;\n   |         ^^^^^\n   |\n   = help: use the `|| { ... }` closure form\
    \ instead\n\nerror[E0434]: can't capture dynamic environment in a fn item\n  -->\
    \ /tmp/tmperd0jr6i.rs:11:9\n   |\n11 |         count += n >= 100;\n   |      \
    \   ^^^^^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n  --> /tmp/tmperd0jr6i.rs:12:9\n\
    \   |\n12 |         count += n % 10 == 1;\n   |         ^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmperd0jr6i.rs:13:9\n   |\n13 |       \
    \  count += n >= 100;\n   |         ^^^^^\n   |\n   = help: use the `|| { ...\
    \ }` closure form instead\n\nerror[E0434]: can't capture dynamic environment in\
    \ a fn item\n  --> /tmp/tmperd0jr6i.rs:14:9\n   |\n14 |         count += n % 10\
    \ == 1;\n   |         ^^^^^\n   |\n   = help: use the `|| { ... }` closure form\
    \ instead\n\nerror[E0434]: can't capture dynamic environment in a fn item\n  -->\
    \ /tmp/tmperd0jr6i.rs:15:9\n   |\n15 |         count += n >= 100;\n   |      \
    \   ^^^^^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n  --> /tmp/tmperd0jr6i.rs:16:9\n\
    \   |\n16 |         count += n % 10 == 1;\n   |         ^^^^^\n   |\n   = help:\
    \ use the "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 1);\n    (n as f64).floor() as isize\n}\n\n\
    fn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: n > 1', /tmp/tmp4csdtgxj.rs:4:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut i = 0;\n    while i <= n {\n        if i % 2 == 0 {\n\
    \            i += 1;\n        } else {\n            i += 3;\n        }\n    }\n\
    \    i\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `1`', /tmp/tmph918rfdt.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n == 0 || (n % 100 == 0 && n % 1000 == 0));\n\
    \    if n == 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n\
    \    }\n    if n == 3 {\n        return 3;\n    }\n    if n % 3 == 0 {\n     \
    \   return n;\n    }\n    return starts_one_ends(n / 3) * 3 + n % 3;\n}\n\nfn\
    \ main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: n == 0 || (n % 100 == 0 &&\
    \ n % 1000 == 0)', /tmp/tmp1db6pd5j.rs:4:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n    let mut ndigits = count_digits(n);\n\
    \    let mut n_ones = 0;\n    while ndigits > 0 {\n        n >>= 10;\n       \
    \ ndigits -= 1;\n        n_ones += 1;\n    }\n    n_ones\n}\n\nfn main() {\n \
    \   let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_digits` in this scope\n --> /tmp/tmps2eoag8v.rs:5:23\n\
    \  |\n5 |     let mut ndigits = count_digits(n);\n  |                       ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp7mq1mwjj.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n)\n        .filter(|i| i % 10 == 1)\n        .filter(|i|\
    \ i % 10 != 9)\n        .count()\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptonximn0.rs:4:5\n  |\n3 |\
    \   fn starts_one_ends(n: isize) -> isize {\n  |                             \
    \      ----- expected `isize` because of return type\n4 | /     (1..=n)\n5 | |\
    \         .filter(|i| i % 10 == 1)\n6 | |         .filter(|i| i % 10 != 9)\n7\
    \ | |         .count()\n  | |________________^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n7 |         .count().try_into().unwrap()\n  |      \
    \           ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    match n {\n        1 => 1,\n        2 => 2,\n        _ => 1\
    \ + starts_one_ends(n>>1) - starts_one_ends(n>>1) - 1,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n\
    \    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4),\
    \ 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `18`', /tmp/tmpp6odxnyc.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n\n    let mut ndigits: usize = 0;\n \
    \   let mut ndigits_so_far: usize = 0;\n    while n != 0 {\n        if n & 1 !=\
    \ 0 {\n            n >>= 1;\n            ndigits += 1;\n            ndigits_so_far\
    \ += 1;\n        }\n        n >>= 1;\n        ndigits_so_far += 1;\n    }\n  \
    \  (ndigits, ndigits_so_far)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8958h6_.rs:17:5\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n...\n17 |     (ndigits,\
    \ ndigits_so_far)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `(usize,\
    \ usize)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (1..=n).filter(|i| *i == 1).count()\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1yxioff_.rs:4:5\n  |\n3 |\
    \ fn starts_one_ends(n: isize) -> isize {\n  |                               \
    \  ----- expected `isize` because of return type\n4 |     (1..=n).filter(|i| *i\
    \ == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n4 |     (1..=n).filter(|i| *i == 1).count().try_into().unwrap()\n\
    \  |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    (n + 1) / (n + 1)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n\
    \    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3),\
    \ 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmpyhdp7q59.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut cnt = 0;\n    for _ in 0..n {\n        if n % 10 ==\
    \ 1 {\n            cnt += 1;\n        }\n        n /= 10;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpl581uphq.rs:9:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n9 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut n = 0;\n    while n < n {\n        n += 1;\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp6aa6y73t.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut c = 0;\n    while n >= 10 {\n        c += n % 10;\n\
    \        n /= 10;\n    }\n    c += n; // n is guaranteed to be non-zero\n    c\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp2yw7uwpo.rs:7:9\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                    - help:\
    \ consider making this binding mutable: `mut n`\n...\n7 |         n /= 10;\n \
    \ |         ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n > 0);\n    (1..=n).filter(|x| x == 1).count()\n\
    }\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n --> /tmp/tmp1vgxeole.rs:5:26\n\
    \  |\n5 |     (1..=n).filter(|x| x == 1).count()\n  |                        \
    \  ^^ no implementation for `&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1vgxeole.rs:5:5\n\
    \  |\n3 | fn starts_one_ends(n: isize) -> isize {\n  |                       \
    \          ----- expected `isize` because of return type\n4 |     debug_assert!(n\
    \ > 0);\n5 |     (1..=n).filter(|x| x == 1).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n5 |     (1..=n).filter(|x|\
    \ x == 1).count().try_into().unwrap()\n  |                                   \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut cnt = 0;\n    while n >= 10 {\n        if n % 10 ==\
    \ 1 {\n            cnt += 1;\n            n -= 10;\n        } else {\n       \
    \     break;\n        }\n    }\n    cnt += 1;\n    n\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "warning: variable `cnt` is assigned to, but never used\n --> /tmp/tmpgukypiy8.rs:4:13\n\
    \  |\n4 |     let mut cnt = 0;\n  |             ^^^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_cnt` instead\n\nwarning: value assigned\
    \ to `cnt` is never read\n  --> /tmp/tmpgukypiy8.rs:13:5\n   |\n13 |     cnt +=\
    \ 1;\n   |     ^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n\
    \   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n --> /tmp/tmpgukypiy8.rs:8:13\n  |\n3 | fn\
    \ starts_one_ends(n: isize) -> isize {\n  |                    - help: consider\
    \ making this binding mutable: `mut n`\n...\n8 |             n -= 10;\n  |   \
    \          ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    n % 10 == 0\n        ? 1\n        : (n/10).count_if(|&x| x ==\
    \ 1 && x != 0)\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \ --> /tmp/tmppe1vhqw6.rs:5:11\n  |\n5 |         ? 1\n  |           ^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut n1 = 1;\n    let mut n2 = 1;\n    while n1 < n || n2\
    \ < n {\n        n1 = n1 + 1;\n        if n1 == n || n2 == n {\n            return\
    \ n1;\n        }\n        n2 = n2 + 1;\n    }\n    0\n}\n\nfn main() {\n    let\
    \ candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2),\
    \ 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n\
    \    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp183xcv0t.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    debug_assert!(n >= 0);\n\n    let mut starts = 0usize;\n   \
    \ let mut ends = 0usize;\n\n    while n > 0 {\n        if n % 10 == 1 {\n    \
    \        starts += 1;\n        }\n\n        if n % 10 == 0 {\n            ends\
    \ += 1;\n        }\n\n        n /= 10;\n    }\n\n    debug_assert!(starts == ends);\n\
    \n    starts\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy4q9lwac.rs:23:5\n   |\n\
    3  | fn starts_one_ends(n: isize) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n...\n23 |     starts\n \
    \  |     ^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23\
    \ |     starts.try_into().unwrap()\n   |           ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
    /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize)\
    \ -> isize {\n    let mut num = 1;\n    while num < n {\n        if n % num ==\
    \ 0 {\n            return num;\n        }\n        num <<= 1;\n    }\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
    \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n\
    \    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `18`', /tmp/tmpfk1_y70w.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
