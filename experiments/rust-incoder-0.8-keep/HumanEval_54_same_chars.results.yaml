name: HumanEval_54_same_chars
language: rust
results:
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmper48wmu3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s1.len() != s0.len() {\n        return\
    \ false;\n    }\n    let mut counter = 0;\n    for i in 0..s0.len() {\n      \
    \  if s0[i] != s1[i] {\n            counter += 1;\n            if counter == 2\
    \ {\n                return true;\n            }\n        }\n    }\n    counter\
    \ == 2\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7o1dy2i3.rs:20:12\n\
    \   |\n20 |         if s0[i] != s1[i] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7o1dy2i3.rs:20:21\n   |\n20 |         if s0[i] != s1[i] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1 = s1.chars();\n    let mut s0\
    \ = s0.chars();\n    let mut c = false;\n    while !s1.is_empty() {\n        if\
    \ !s0.is_empty() {\n            if c == s0.as_str().chars().count() {\n      \
    \          c = false;\n            } else {\n                c = true;\n     \
    \       }\n        }\n        if !s0.is_empty() || !s1.is_empty() {\n        \
    \    c.cmp(s1.as_str().chars().count()) < 0;\n        }\n        match s1.next()\
    \ {\n            Some(c) => s0 = s0.chars().take(c),\n            None => break,\n\
    \        }\n    }\n    c\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp28z8z113.rs:18:15\n   |\n18 |     while !s1.is_empty()\
    \ {\n   |               ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `is_empty` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmp28z8z113.rs:19:16\n   |\n19 |         if !s0.is_empty() {\n   |\
    \                ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp28z8z113.rs:20:21\n   |\n20 |             if c == s0.as_str().chars().count()\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ `usize`\n\nerror[E0599]: no method named `is_empty` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp28z8z113.rs:26:16\n   |\n26 |         if\
    \ !s0.is_empty() || !s1.is_empty() {\n   |                ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror[E0599]: no method named `is_empty` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmp28z8z113.rs:26:34\n   |\n26 |  \
    \       if !s0.is_empty() || !s1.is_empty() {\n   |                          \
    \        ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp28z8z113.rs:27:19\n   |\n27 |             c.cmp(s1.as_str().chars().count())\
    \ < 0;\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&bool`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp28z8z113.rs:27:50\n\
    \   |\n27 |             c.cmp(s1.as_str().chars().count()) < 0;\n   |        \
    \                                          ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0599]: no method named `chars` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp28z8z113.rs:30:32\n   |\n30 |          \
    \   Some(c) => s0 = s0.chars().take(c),\n   |                                ^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to 8 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = s0.len();\n    let mut j = s1.len();\n\
    \    let mut same = 0;\n    while i >= 0 && j >= 0 {\n        if s0[i..].chars().nth(0)\
    \ != s1[j..].chars().nth(0) {\n            break;\n        }\n        i += 1;\n\
    \        j += 1;\n        same += 1;\n    }\n    same == 0\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `eabcdzzzz`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp984s8sub.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(c0, c1)|\
    \ c0 == c1)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp655ksjdn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0..s0.len();\n    let mut j =\
    \ 0..s1.len();\n    while i < s0.len() && j < s1.len() {\n        if s0[i] !=\
    \ s1[j] {\n            return false;\n        }\n        i += 1;\n        j +=\
    \ 1;\n    }\n    i == s0.len() && j == s1.len()\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `<` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmprj332m8t.rs:17:13\n   |\n17 |     while i < s0.len() && j < s1.len()\
    \ {\n   |           - ^ -------- usize\n   |           |\n   |           std::ops::Range<usize>\n\
    \nerror[E0369]: binary operation `<` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmprj332m8t.rs:17:29\n   |\n17 |     while i < s0.len() && j < s1.len()\
    \ {\n   |                           - ^ -------- usize\n   |                 \
    \          |\n   |                           std::ops::Range<usize>\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmprj332m8t.rs:21:9\n   |\n21 |         i += 1;\n   |         -^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `std::ops::Range<usize>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmprj332m8t.rs:22:9\n   |\n22 |         j += 1;\n   |         -^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `std::ops::Range<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprj332m8t.rs:24:10\n   |\n24 |\
    \     i == s0.len() && j == s1.len()\n   |          ^^^^^^^^ expected struct `std::ops::Range`,\
    \ found `usize`\n   |\n   = note: expected struct `std::ops::Range<usize>`\n \
    \               found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprj332m8t.rs:24:27\n\
    \   |\n24 |     i == s0.len() && j == s1.len()\n   |                         \
    \  ^^^^^^^^ expected struct `std::ops::Range`, found `usize`\n   |\n   = note:\
    \ expected struct `std::ops::Range<usize>`\n                found type `usize`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbf22ox_l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(c0, c1)|\
    \ c0 == c1)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5j03ob0r.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (a\
    \ == b) || (a as usize != b as usize))\n}\n\nfn main() {\n    let candidate =\
    \ same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx9453tmp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut chars = HashMap::new();\n    for\
    \ c in s0.chars().cloned() {\n        let index = chars.get_mut(&c).unwrap();\n\
    \        if index == Some(0) {\n            chars.insert(c.clone(), 0);\n    \
    \    }\n    }\n    for c in s1.chars().cloned() {\n        let index = chars.get_mut(&c).unwrap();\n\
    \        if index == Some(0) {\n            chars.insert(c.clone(), 0);\n    \
    \    }\n    }\n    for v in chars.values() {\n        if v == 0 {\n          \
    \  return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp933jpqvx.rs:15:21\n   |\n15 |     let mut chars = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp933jpqvx.rs:16:25\n\
    \     |\n16   |     for c in s0.chars().cloned() {\n     |                   \
    \      ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmp933jpqvx.rs:16:14\n   |\n16 |     for c in s0.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp933jpqvx.rs:16:14\n   |\n16 |     for\
    \ c in s0.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp933jpqvx.rs:22:25\n     |\n22   |\
    \     for c in s1.chars().cloned() {\n     |                         ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp933jpqvx.rs:22:14\n   |\n22 |     for c in s1.chars().cloned()\
    \ {\n   |       "
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| (a\
    \ == b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeuodtxjm.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzox5p6wl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1_index = 0;\n    for (c1, c2) in\
    \ s0.chars().zip(s1.chars()) {\n        if c1 != c2 {\n            s1_index +=\
    \ 1;\n            if s1_index >= s2.len() {\n                break;\n        \
    \    }\n        }\n    }\n    !s1_index\n}\n\nfn main() {\n    let candidate =\
    \ same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `s2` in this scope\n  --> /tmp/tmpyhxovrtj.rs:19:28\n\
    \   |\n19 |             if s1_index >= s2.len() {\n   |                      \
    \      ^^ help: a local variable with a similar name exists: `c2`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyhxovrtj.rs:24:5\n   |\n14 | fn same_chars(s0:\
    \ String, s1: String) -> bool {\n   |                                        \
    \  ---- expected `bool` because of return type\n...\n24 |     !s1_index\n   |\
    \     ^^^^^^^^^ expected `bool`, found integer\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjcv4d893.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpox3snheh.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (*a)\
    \ == (*b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpft73l1tv.rs:15:45\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(a, b)| (*a) == (*b))\n   |  \
    \                                           ^^^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpft73l1tv.rs:15:53\n   |\n15 |     s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| (*a) == (*b))\n   |                                                    \
    \ ^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut c = s0.chars();\n    let mut d =\
    \ s1.chars();\n    while c.next().unwrap() != d.next().unwrap() {\n        if\
    \ c.next().unwrap() != d.next().unwrap() {\n            return false;\n      \
    \  }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppqb9ckov.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcztcunzn.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.len() == s1.len() && s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmanvsql7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = s0.chars().enumerate().zip(io::BufReader::new(s1))\n\
    \        .find_map(|(_, c)| c.unwrap());\n\n    match i.take_while(|c| c.is_some())\
    \ {\n        Some((i, j)) => i >= j,\n        None => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `io`\n\
    \  --> /tmp/tmpe3veecog.rs:15:48\n   |\n15 |     let mut i = s0.chars().enumerate().zip(io::BufReader::new(s1))\n\
    \   |                                                ^^^^^^^^^ not found in `io`\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::io::BufReader;\n\
    \   |\nhelp: if you import `BufReader`, refer to it directly\n   |\n15 -     let\
    \ mut i = s0.chars().enumerate().zip(io::BufReader::new(s1))\n15 +     let mut\
    \ i = s0.chars().enumerate().zip(BufReader::new(s1))\n   | \n\nerror[E0599]: `Option<_>`\
    \ is not an iterator\n   --> /tmp/tmpe3veecog.rs:18:13\n    |\n18  |       match\
    \ i.take_while(|c| c.is_some()) {\n    |               ^^^^^^^^^^ `Option<_>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<_>: Iterator`\n            which is required by `&mut Option<_>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    same_chars_impl(s0, s1)\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `same_chars_impl` in this scope\n  -->\
    \ /tmp/tmpu060iu1g.rs:15:5\n   |\n15 |     same_chars_impl(s0, s1)\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbnc8ugl9.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (*a)\
    \ == (*b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp5bk3f8mz.rs:15:45\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(a, b)| (*a) == (*b))\n   |  \
    \                                           ^^^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp5bk3f8mz.rs:15:53\n   |\n15 |     s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| (*a) == (*b))\n   |                                                    \
    \ ^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut it0 = s0.char_indices();\n    let mut it1 = s1.char_indices();\n\
    \    while let Some((i0, i1)) = (it0.next(), it1.next()) {\n        if i0 != i1\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp01qvs9de.rs:20:15\n   |\n\
    20 |     while let Some((i0, i1)) = (it0.next(), it1.next()) {\n   |         \
    \      ^^^^^^^^^^^^^^   ------------------------ this expression has type `(Option<(usize,\
    \ char)>, Option<(usize, char)>)`\n   |               |\n   |               expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(Option<(usize,\
    \ char)>, Option<(usize, char)>)`\n               found enum `Option<_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let n0 = s0.chars().count();\n    let n1\
    \ = s1.chars().count();\n\n    if n0 < n1 {\n        return false;\n    }\n\n\
    \    if n0 == n1 {\n        return true;\n    }\n\n    for (&x, &y) in zip(n0.iter().cloned(),\
    \ n1.iter().cloned()) {\n        if x != y {\n            return false;\n    \
    \    }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmpu28__zrq.rs:26:21\n\
    \   |\n26 |     for (&x, &y) in zip(n0.iter().cloned(), n1.iter().cloned()) {\n\
    \   |                     ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::iter::zip;\n   |\n\nerror[E0599]: no method\
    \ named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpu28__zrq.rs:26:28\n\
    \   |\n26 |     for (&x, &y) in zip(n0.iter().cloned(), n1.iter().cloned()) {\n\
    \   |                            ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `usize` in the current scope\n  --> /tmp/tmpu28__zrq.rs:26:48\n\
    \   |\n26 |     for (&x, &y) in zip(n0.iter().cloned(), n1.iter().cloned()) {\n\
    \   |                                                ^^^^ method not found in\
    \ `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdpccb2q1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    same_chars_impl(s0.chars(), s1.chars()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `same_chars_impl` in this scope\n  -->\
    \ /tmp/tmpd82243w7.rs:15:5\n   |\n15 |     same_chars_impl(s0.chars(), s1.chars()).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // TODO(burnik): check if these methods get\
    \ inlined better in any way\n    let mut i0 = s0.iter().count();\n    let mut\
    \ i1 = s1.iter().count();\n    while i0 < i1 {\n        if i0 < i1 && (*i0 !=\
    \ *i1) {\n            return false;\n        }\n        i0++;\n        i1++;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxa69k5y7.rs:22:11\n\
    \   |\n22 |         i0++;\n   |           ^^ not a valid postfix operator\n  \
    \ |\nhelp: use `+= 1` instead\n   |\n22 |         { let tmp = i0; i0 += 1; tmp\
    \ };\n   |         +++++++++++   ~~~~~~~~~~~~~~~~\n22 -         i0++;\n22 +  \
    \       i0 += 1;\n   | \n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpxa69k5y7.rs:16:21\n   |\n16 | \
    \    let mut i0 = s0.iter().count();\n   |                     ^^^^ method not\
    \ found in `String`\n   |\nhelp: because of the in-memory representation of `&str`,\
    \ to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n\
    16 |     let mut i0 = s0.chars().count();\n   |                     ~~~~~\n\n\
    error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpxa69k5y7.rs:17:21\n   |\n17 |     let mut i1 = s1.iter().count();\n\
    \   |                     ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n17 |     let mut i1 = s1.chars().count();\n\
    \   |                     ~~~~~\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n\n    let mut chars = HashMap::new();\n    for char in s0.chars()\
    \ {\n        let c = char.clone();\n        chars.insert(c, char);\n    }\n\n\
    \    for char in s1.chars() {\n        let c = char.clone();\n        let existing\
    \ = chars.get(&c);\n        chars.insert(c, existing);\n    }\n\n    let mut has_duplicates\
    \ = false;\n    for (key, value) in chars.iter().filter(|(_key, value)| value\
    \ != key) {\n        has_duplicates = true;\n        break;\n    }\n    !has_duplicates\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6gqvei4t.rs:19:21\n   |\n19 |     let mut chars = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `key` in this scope\n  --> /tmp/tmp6gqvei4t.rs:32:70\n   |\n\
    32 |     for (key, value) in chars.iter().filter(|(_key, value)| value != key)\
    \ {\n   |                                                                    \
    \  ^^^ help: a local variable with a similar name exists: `_key`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip1(s1.chars()).all(|(a, b)|\
    \ a == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip1` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpbp7bqdc_.rs:15:16\n   |\n15 |     s0.chars().zip1(s1.chars()).all(|(a,\
    \ b)| a == b)\n   |                ^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    match chars(s0) {\n        0 => match chars(s1)\
    \ {\n            0 => true,\n            c => c == s1[1..],\n        },\n    \
    \    c => c == s0[1..],\n    }\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `chars` in this scope\n  --> /tmp/tmpxgr7s2ri.rs:15:11\n\
    \   |\n15 |     match chars(s0) {\n   |           ^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `chars` in this scope\n  --> /tmp/tmpxgr7s2ri.rs:16:20\n\
    \   |\n16 |         0 => match chars(s1) {\n   |                    ^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // Special case for empty strings so that\
    \ we don't need to worry about\n    // terminating null characters.\n    if s0\
    \ == \"\" && s1 == \"\" {\n        return true;\n    }\n\n    // Special case\
    \ for equal lengths.\n    if s0.len() != s1.len() {\n        return false;\n \
    \   }\n\n    for (a, b) in zip(s0.chars(), s1.chars()) {\n        if a != b {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmpgnxjdmnt.rs:26:19\n\
    \   |\n26 |     for (a, b) in zip(s0.chars(), s1.chars()) {\n   |            \
    \       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::iter::zip;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(sc0, sc1)|\
    \ sc0 == sc1)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe1jek3be.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)\n}\n\nfn\
    \ main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu0elspoc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    for (c0, c1) in s0.chars().zip(s1.chars())\
    \ {\n        if (c0 == c1) {\n            i += 1;\n            i += 1;\n     \
    \   } else {\n            if i == 0 {\n                return false;\n       \
    \     }\n            if j == 0 {\n                return false;\n            }\n\
    \            if j == i {\n                return c0 == c1;\n            }\n  \
    \      }\n        i += 1;\n        j += 1;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps9pxus0y.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1).any(|&(a, b)| a == b)\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprljoxdjg.rs:15:20\n\
    \   |\n15 |     s0.chars().zip(s1).any(|&(a, b)| a == b)\n   |               \
    \ --- ^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n \
    \  |                |\n   |                required by a bound introduced by this\
    \ call\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0599]: the method `any` exists for struct `Zip<Chars<'_>,\
    \ String>`, but its trait bounds were not satisfied\n   --> /tmp/tmprljoxdjg.rs:15:24\n\
    \    |\n15  |       s0.chars().zip(s1).any(|&(a, b)| a == b)\n    |          \
    \                ^^^ method cannot be called on `Zip<Chars<'_>, String>` due to\
    \ unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `Zip<Chars<'_>, String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut char_count = 0;\n    let mut other_char_count\
    \ = 0;\n\n    let mut i = 0;\n    let mut j = 0;\n    while i < s0.len() && j\
    \ < s1.len() {\n        char_count = char_count + s0.len() - i;\n        other_char_count\
    \ = other_char_count + s1.len() - j;\n        if s0[i] == s1[j] {\n          \
    \  i += 1;\n            i += 1;\n            j += 1;\n        } else {\n     \
    \       if char_count < other_char_count {\n                return false;\n  \
    \          }\n            break;\n        }\n    }\n    if i == s0.len() {\n \
    \       return true;\n    }\n    if j == s1.len() {\n        return false;\n \
    \   }\n\n    // We reach here\n    // Check if first word is longer\n    if char_count\
    \ < other_char_count {\n        return false;\n    }\n    // Check if first word\
    \ is longer\n    return s1[j] == s0[i];\n}\n\nfn main() {\n    let candidate =\
    \ same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyhczz3sw.rs:23:12\n\
    \   |\n23 |         if s0[i] == s1[j] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyhczz3sw.rs:23:21\n   |\n23 |         if s0[i] == s1[j] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyhczz3sw.rs:47:12\n\
    \   |\n47 |     return s1[j] == s0[i];\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be "
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut chars = String::new();\n    let mut\
    \ len = s0.chars().count();\n    while len > 0 && s1.chars().count() > 0 {\n \
    \       if s0[len - 1] != s1[s1.chars().count() - 1] {\n            break;\n \
    \       }\n        chars.push('1');\n        len -= 1;\n        s1 = &s1[s1.chars().count()\
    \ - 1];\n    }\n    chars.into_owned().eq_ignore_ascii_case(s0)\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwbfsrksp.rs:18:12\n\
    \   |\n18 |         if s0[len - 1] != s1[s1.chars().count() - 1] {\n   |     \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwbfsrksp.rs:18:27\n   |\n18 |         if s0[len - 1] != s1[s1.chars().count()\
    \ - 1] {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwbfsrksp.rs:23:15\n   |\n23 |         s1 = &s1[s1.chars().count()\
    \ - 1];\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n\n    for (x0, x1) in zip!(s0.chars(), s1.chars()) {\n      \
    \  if x0 != x1 {\n            return false;\n        }\n    }\n\n    true\n}\n\
    \nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `zip` in this scope\n  --> /tmp/tmpwzlj8fmv.rs:19:21\n\
    \   |\n19 |     for (x0, x1) in zip!(s0.chars(), s1.chars()) {\n   |         \
    \            ^^^\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for (a, b) in s1.chars().zip(s0.chars()).skip(1)\
    \ {\n        if *a != *b { return false; }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpzz6rmuf3.rs:16:12\n\
    \   |\n16 |         if *a != *b { return false; }\n   |            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpzz6rmuf3.rs:16:18\n   |\n\
    16 |         if *a != *b { return false; }\n   |                  ^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp62czuorc.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_yq92jjd.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpak23rt08.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(mut a, mut\
    \ b)| (a == b) || !a.is_ascii() && !b.is_ascii())\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplg3ec3nl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0;\n    while i < s1.chars().count()\
    \ && i < s0.chars().count() {\n        assert!(\n            s1.chars()[i] >=\
    \ s0.chars()[i],\n            \"{0} is not smaller than {1}\",\n            s1[i..(i\
    \ + s0.len() - i)].chars().next(),\n            s0.chars()[i..(i + s1.len() -\
    \ i)].chars().next()\n        );\n        i += 1;\n    }\n    i == s1.len() &&\
    \ i == s0.len()\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpdrm1u8hq.rs:18:13\n\
    \   |\n18 |             s1.chars()[i] >= s0.chars()[i],\n   |             ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpdrm1u8hq.rs:18:30\n\
    \   |\n18 |             s1.chars()[i] >= s0.chars()[i],\n   |                \
    \              ^^^^^^^^^^^^^\n\nerror[E0277]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n  --> /tmp/tmpdrm1u8hq.rs:20:13\n   |\n20 |           \
    \  s1[i..(i + s0.len() - i)].chars().next(),\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `Option<char>` cannot be formatted with the default formatter\n   |\n   = help:\
    \ the trait `std::fmt::Display` is not implemented for `Option<char>`\n   = note:\
    \ in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::const_format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpdrm1u8hq.rs:21:13\n\
    \   |\n21 |             s0.chars()[i..(i + s1.len() - i)].chars().next()\n   |\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    (s0[..] == s1[..]) == (s0.len() == s1.len())\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcppuskxh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < s0.len() && j < s1.len() {\n        if s0[i] != s1[j] {\n            return\
    \ false;\n        }\n        i += 1;\n        j += 1;\n    }\n    (i == s0.len()\
    \ && j == s1.len()) || (i == s0.len() && j != s1.len())\n}\n\nfn main() {\n  \
    \  let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpor1_u_8k.rs:18:12\n\
    \   |\n18 |         if s0[i] != s1[j] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpor1_u_8k.rs:18:21\n   |\n18 |         if s0[i] != s1[j] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnagcl02d.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let len0 = s0.len();\n    let len1 = s1.len();\n\
    \    if len0 != len1 {\n        return false;\n    }\n\n    let mut i0 = 0;\n\
    \    let mut i1 = 0;\n    while i0 < len0 || i1 < len1 {\n        if i0 < len0\
    \ {\n            if s0[i0] != s1[i1] {\n                return false;\n      \
    \      }\n            i0 += 1;\n        }\n\n        if i1 < len1 {\n        \
    \    if s0[i0] != s1[i1] {\n                return false;\n            }\n   \
    \         i1 += 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb56o1_y4.rs:25:16\n\
    \   |\n25 |             if s0[i0] != s1[i1] {\n   |                ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb56o1_y4.rs:25:26\n   |\n25 |             if s0[i0] != s1[i1] {\n\
    \   |                          ^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb56o1_y4.rs:32:16\n   |\n32 |             if s0[i0] != s1[i1] {\n\
    \   |                ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut len0 = s0.chars().count();\n    let\
    \ mut len1 = s1.chars().count();\n    while len0 < len1 {\n        len0 += 1;\n\
    \    }\n    while len1 < len0 {\n        len1 += 1;\n    }\n    for (c1, c2) in\
    \ zip(0..len0, (0..len1).rev()) {\n        if s0.chars().nth(c1) != s1.chars().nth(c2)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmp1xsqi1kk.rs:23:21\n\
    \   |\n23 |     for (c1, c2) in zip(0..len0, (0..len1).rev()) {\n   |        \
    \             ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::iter::zip;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(&x, &y)|\
    \ x == y)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8j_5q6tv.rs:15:38\n   |\n\
    15 |     s0.chars().zip(s1.chars()).all(|(&x, &y)| x == y)\n   |             \
    \                         ^^    - expected due to this\n   |                 \
    \                     |\n   |                                      expected `char`,\
    \ found reference\n   |                                      help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8j_5q6tv.rs:15:42\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(&x, &y)| x == y)\n   |      \
    \                                    ^^- expected due to this\n   |          \
    \                                |\n   |                                     \
    \     expected `char`, found reference\n   |                                 \
    \         help: you can probably remove the explicit borrow: `y`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s1.chars().zip2(s0.chars()).any(|(a,b)|\
    \ (a != b)) {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip2` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpr2kqvtk4.rs:15:19\n   |\n15 |     if s1.chars().zip2(s0.chars()).any(|(a,b)|\
    \ (a != b)) {\n   |                   ^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    (s0.len() == s1.len()) && (s0.chars() ==\
    \ s1.chars()).all(|c| *c == 0)\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Chars<'_>`\n\
    \  --> /tmp/tmpxjvkecip.rs:15:43\n   |\n15 |     (s0.len() == s1.len()) && (s0.chars()\
    \ == s1.chars()).all(|c| *c == 0)\n   |                                ----------\
    \ ^^ ---------- Chars<'_>\n   |                                |\n   |       \
    \                         Chars<'_>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i0 = 0;\n    let mut i1 = 0;\n  \
    \  while i0 < s0.len() && i1 < s1.len() {\n        if s0[i0] != s1[i1] {\n   \
    \         return false;\n        }\n        i0 += 1;\n        i1 += 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_v7cvr3x.rs:18:12\n\
    \   |\n18 |         if s0[i0] != s1[i1] {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_v7cvr3x.rs:18:22\n   |\n18 |         if s0[i0] != s1[i1] {\n \
    \  |                      ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut map0 = HashMap::new();\n    let mut\
    \ map1 = HashMap::new();\n    for &c in s0.chars() {\n        if map0.contains_key(&c)\
    \ { map0[c].0 += 1; }\n        else { map0.insert(c, (0, 1)); }\n    }\n    for\
    \ &c in s1.chars() {\n        if map1.contains_key(&c) { map1[c].0 += 1; }\n \
    \       else { map1.insert(c, (0, 1)); }\n    }\n    for k in &map0 {\n      \
    \  if !map1.contains_key(&k.key) {\n            return false;\n        }\n   \
    \ }\n    for k in &map1 {\n        if !map0.contains_key(&k.key) {\n         \
    \   return false;\n        }\n    }\n    for k in &map0 {\n        if map1[k.key].0\
    \ != k.0 {\n            return false;\n        }\n    }\n    for k in &map1 {\n\
    \        if map0[k.key].0 != k.0 {\n            return false;\n        }\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp3kyk7c8k.rs:15:20\n   |\n15 |     let mut map0 = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp3kyk7c8k.rs:16:20\n\
    \   |\n16 |     let mut map1 = HashMap::new();\n   |                    ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3kyk7c8k.rs:17:9\n   |\n17 |     for &c in s0.chars() {\n   | \
    \        ^^    ---------- this expression has type `Option<char>`\n   |      \
    \   |\n   |         expected `char`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3kyk7c8k.rs:21:9\n\
    \   |\n21 |     for &c in s1.chars() {\n   |         ^^    ---------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj8tutao8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s0 = s0.to_owned();\n    let mut\
    \ s1 = s1.to_owned();\n\n    let mut i = 0;\n    while i < s0.len() && i < s1.len()\
    \ {\n        if s0[i] == s1[i] {\n            i += 1;\n            continue;\n\
    \        }\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph17r7y_x.rs:20:12\n\
    \   |\n20 |         if s0[i] == s1[i] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph17r7y_x.rs:20:21\n   |\n20 |         if s0[i] == s1[i] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let s0_len = s0.len();\n    let s1_len =\
    \ s1.len();\n    let mut i = 0;\n    while i < s0_len && i < s1_len {\n      \
    \  if s0.chars().nth(i) != s1.chars().nth(i) {\n            return false;\n  \
    \      }\n        i += 1;\n    }\n    i == s0_len && i == s1_len\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeecvvyk6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let len0 = s0.len();\n    let len1 = s1.len();\n\
    \    if len0 != len1 {\n        return false;\n    }\n\n    for i in 0..(len0\
    \ - 1) {\n        if s0[i] != s1[i] {\n            return false;\n        }\n\
    \    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk83h54j1.rs:22:12\n\
    \   |\n22 |         if s0[i] != s1[i] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk83h54j1.rs:22:21\n   |\n22 |         if s0[i] != s1[i] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars())\n        .all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp01bey1sa.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplz3v2rp_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < s0.len() && j < s1.len() {\n        if s0[i] != s1[j] {\n            return\
    \ false;\n        }\n        i += 1;\n        j += 1;\n    }\n    s0.len() ==\
    \ 0 && s1.len() == 0 || s0[i..].is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdu_t0ln1.rs:18:12\n\
    \   |\n18 |         if s0[i] != s1[j] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdu_t0ln1.rs:18:21\n   |\n18 |         if s0[i] != s1[j] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1[..]).all(|(a,b)| a == b)\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpbhbk7u9d.rs:15:20\n    |\n15  |     s0.chars().zip(s1[..]).all(|(a,b)|\
    \ a == b)\n    |                --- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `std::iter::Iterator::zip`\n\nerror[E0277]: `str`\
    \ is not an iterator\n  --> /tmp/tmpbhbk7u9d.rs:15:20\n   |\n15 |     s0.chars().zip(s1[..]).all(|(a,b)|\
    \ a == b)\n   |                --- ^^^^^^ `str` is not an iterator\n   |     \
    \           |\n   |                required by a bound introduced by this call\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `str`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `str`\n\
    \nerror[E0599]: the method `all` exists for struct `Zip<Chars<'_>, str>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpbhbk7u9d.rs:15:28\n   |\n\
    15 |       s0.chars().zip(s1[..]).all(|(a,b)| a == b)\n   |                  \
    \            ^^^ method cannot be called on `Zip<Chars<'_>, str>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `str: Sized`\n           which is required by `Zip<Chars<'_>, str>:\
    \ Iterator`\n           `str: Iterator`\n           which is required by `Zip<Chars<'_>,\
    \ str>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s0_len = s0.len();\n    let mut s1_len\
    \ = s1.len();\n    while s0_len > 0 && (s1[s0_len - 1] == '.' || s1[s0_len - 1]\
    \ == '?') {\n        s0_len -= 1;\n    }\n    while s1_len > 0 && (s0[s1_len -\
    \ 1] == '.' || s0[s1_len - 1] == '?') {\n        s1_len -= 1;\n    }\n    s0.as_bytes()[..s0_len]\
    \ == s1.as_bytes()[..s1_len]\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbi_6aqop.rs:17:26\n\
    \   |\n17 |     while s0_len > 0 && (s1[s0_len - 1] == '.' || s1[s0_len - 1] ==\
    \ '?') {\n   |                          ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbi_6aqop.rs:17:51\n   |\n17 |     while s0_len > 0 && (s1[s0_len\
    \ - 1] == '.' || s1[s0_len - 1] == '?') {\n   |                              \
    \                     ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbi_6aqop.rs:20:26\n   |\n20 |     while s1_len > 0 && (s0[s1_len\
    \ - 1] == '.' || s0[s1_len - 1] == '?') {\n   |                          ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (*a\
    \ as u8) == (*b as u8))\n}\n\nfn main() {\n    let candidate = same_chars;\n \
    \   assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpi2nml5yq.rs:15:46\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(a, b)| (*a as u8) == (*b as u8))\n\
    \   |                                              ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpi2nml5yq.rs:15:60\n   |\n15 |     s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| (*a as u8) == (*b as u8))\n   |                                        \
    \                    ^^\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    if s0.is_empty() || s1.is_empty() {\n        return true;\n\
    \    }\n    for (a, b) in s0.chars().zip(s1.chars()) {\n        if *a != *b {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp067zdlm7.rs:22:12\n\
    \   |\n22 |         if *a != *b {\n   |            ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmp067zdlm7.rs:22:18\n   |\n22 |        \
    \ if *a != *b {\n   |                  ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoolfrzzx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1).all(|(a, b)| a == b)\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpu53rq_eq.rs:15:20\n\
    \   |\n15 |     s0.chars().zip(s1).all(|(a, b)| a == b)\n   |                ---\
    \ ^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   | \
    \               |\n   |                required by a bound introduced by this\
    \ call\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0599]: the method `all` exists for struct `Zip<Chars<'_>,\
    \ String>`, but its trait bounds were not satisfied\n   --> /tmp/tmpu53rq_eq.rs:15:24\n\
    \    |\n15  |       s0.chars().zip(s1).all(|(a, b)| a == b)\n    |           \
    \               ^^^ method cannot be called on `Zip<Chars<'_>, String>` due to\
    \ unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `Zip<Chars<'_>, String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp60q1dedz.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1_idx = 0;\n    let mut s0_idx =\
    \ 0;\n    while s0_idx < s0.len() && s1_idx < s1.len() {\n        if s0[s0_idx]\
    \ != s1[s1_idx] {\n            break;\n        }\n        s0_idx += 1;\n     \
    \   s1_idx += 1;\n    }\n    s0_idx < s0.len() && s1_idx < s1.len()\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpujn814vf.rs:18:12\n\
    \   |\n18 |         if s0[s0_idx] != s1[s1_idx] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpujn814vf.rs:18:26\n   |\n18 |         if s0[s0_idx] != s1[s1_idx]\
    \ {\n   |                          ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i: usize = 0;\n    let mut j: usize\
    \ = 0;\n    while i < s0.len() && j < s1.len() {\n        if s0[i] != s1[j] {\n\
    \            return false;\n        }\n        i += 1;\n        j += 1;\n    }\n\
    \    i == s0.len() && j == s1.len()\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvzzdf6j3.rs:18:12\n\
    \   |\n18 |         if s0[i] != s1[j] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvzzdf6j3.rs:18:21\n   |\n18 |         if s0[i] != s1[j] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2dlj48lg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.len() == s1.len() && s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxq0cohqq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppaoi77zx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0;\n    let mut j = s0.len();\n\
    \    while i < j {\n        if s0[i] != s1[j] {\n            return false;\n \
    \       }\n        i += 1;\n        j -= 1;\n    }\n    return true;\n}\n\nfn\
    \ main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjj54ok1c.rs:18:12\n\
    \   |\n18 |         if s0[i] != s1[j] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjj54ok1c.rs:18:21\n   |\n18 |         if s0[i] != s1[j] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() { return false; }\n\
    \    for i in 0..s0.len() {\n        if s0[i] != s1[i] { return false; }\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg8_xmzbl.rs:17:12\n\
    \   |\n17 |         if s0[i] != s1[i] { return false; }\n   |            ^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg8_xmzbl.rs:17:21\n   |\n17 |         if s0[i] != s1[i] { return\
    \ false; }\n   |                     ^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for ((i, j), c) in zip((0..s0.len()).rev(),\
    \ (0..s1.len()).rev()) {\n        if c0(&s0, i) != c0(&s1, j) {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmpgejvshnd.rs:15:24\n\
    \   |\n15 |     for ((i, j), c) in zip((0..s0.len()).rev(), (0..s1.len()).rev())\
    \ {\n   |                        ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::iter::zip;\n   |\n\nerror[E0425]:\
    \ cannot find function `c0` in this scope\n  --> /tmp/tmpgejvshnd.rs:16:12\n \
    \  |\n16 |         if c0(&s0, i) != c0(&s1, j) {\n   |            ^^ help: a local\
    \ variable with a similar name exists: `c`\n\nerror[E0425]: cannot find function\
    \ `c0` in this scope\n  --> /tmp/tmpgejvshnd.rs:16:26\n   |\n16 |         if c0(&s0,\
    \ i) != c0(&s1, j) {\n   |                          ^^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s0.chars()).all(|(c0, c1)|\
    \ c0 == c1)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn46_osd0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s0_len = s0.chars().count();\n  \
    \  let mut s1_len = s1.chars().count();\n\n    for i in 0..=s0_len {\n       \
    \ for j in 0..=s1_len {\n            if s0.chars().nth(i) == s1.chars().nth(j)\
    \ {\n                s0_len -= 1;\n                s1_len -= 1;\n            }\n\
    \        }\n    }\n    if s0_len != s1_len {\n        return false;\n    }\n \
    \   return true;\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpedbx65rq.rs:21:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpann9wohp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdi9hcmdj.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip2(s1.chars(), |(a, b)| (*a)\
    \ == (*b)).fold(\n        true,\n        |a, (_b, c)| a == b,\n    )\n}\n\nfn\
    \ main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpcq1ar41a.rs:17:27\n\
    \   |\n17 |         |a, (_b, c)| a == b,\n   |                           ^ help:\
    \ a local variable with a similar name exists: `_b`\n\nerror[E0599]: no method\
    \ named `zip2` found for struct `Chars` in the current scope\n  --> /tmp/tmpcq1ar41a.rs:15:16\n\
    \   |\n15 |     s0.chars().zip2(s1.chars(), |(a, b)| (*a) == (*b)).fold(\n   |\
    \                ^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut len0 = s0.len();\n    let mut len1\
    \ = s1.len();\n    let mut i = 0;\n    while i < len0 && i < len1 {\n        if\
    \ s0[i] != s1[i] {\n            return false;\n        }\n        i += 1;\n  \
    \  }\n    len0 >= len1\n}\n\nfn main() {\n    let candidate = same_chars;\n  \
    \  assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp372cpthz.rs:19:12\n\
    \   |\n19 |         if s0[i] != s1[i] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp372cpthz.rs:19:21\n   |\n19 |         if s0[i] != s1[i] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6wodlp99.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0;\n    while i < s0.len() &&\
    \ i < s1.len() {\n        if s0[i..].iter().any(|c| c != s1[i..].iter().any())\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n\n    i ==\
    \ s0.len() || i == s1.len()\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n  --> /tmp/tmp9k873k33.rs:17:20\n   |\n17 |         if s0[i..].iter().any(|c|\
    \ c != s1[i..].iter().any()) {\n   |                    ^^^^ method not found\
    \ in `str`\n\nerror[E0599]: no method named `iter` found for type `str` in the\
    \ current scope\n  --> /tmp/tmp9k873k33.rs:17:48\n   |\n17 |         if s0[i..].iter().any(|c|\
    \ c != s1[i..].iter().any()) {\n   |                                         \
    \       ^^^^ method not found in `str`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i = 0;\n    while i < s0.chars().len()\
    \ && i < s1.chars().len() {\n        if s0[i] != s1[i] {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    i == s0.chars().len() && i == s1.chars().len()\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp_ys7koyv.rs:16:26\n   |\n16 |     while i < s0.chars().len()\
    \ && i < s1.chars().len() {\n   |                          ^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `len` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp_ys7koyv.rs:16:50\n   |\n16 |     while\
    \ i < s0.chars().len() && i < s1.chars().len() {\n   |                       \
    \                           ^^^ method not found in `Chars<'_>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_ys7koyv.rs:17:12\n\
    \   |\n17 |         if s0[i] != s1[i] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp_ys7koyv.rs:17:21\n   |\n17 |         if s0[i] != s1[i] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp_ys7koyv.rs:22:21\n   |\n22 |     i == s0.chars().len()\
    \ && i == s1.ch"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (a\
    \ == b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy52hcqkv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    for c in s0.chars() {\n        if s1.find(c) == String::npos\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpntwqjwnf.rs:19:34\n   |\n19 | \
    \        if s1.find(c) == String::npos {\n   |                               \
    \   ^^^^ function or associated item not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1).all(|(a, b)| (a == b)\
    \ || !a.is_whitespace() || !b.is_whitespace())\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpjxphg56e.rs:15:20\n\
    \   |\n15 |     s0.chars().zip(s1).all(|(a, b)| (a == b) || !a.is_whitespace()\
    \ || !b.is_whitespace())\n   |                --- ^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |                |\n   |          \
    \      required by a bound introduced by this call\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: the\
    \ method `all` exists for struct `Zip<Chars<'_>, String>`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmpjxphg56e.rs:15:24\n    |\n15  |       s0.chars().zip(s1).all(|(a,\
    \ b)| (a == b) || !a.is_whitespace() || !b.is_whitespace())\n    |           \
    \               ^^^ method cannot be called on `Zip<Chars<'_>, String>` due to\
    \ unsatisfied trait bounds\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `Zip<Chars<'_>, String>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut c0 = String::new();\n    let mut\
    \ c1 = String::new();\n    s0.chars().for_each(|x| *mut c0.push(x));\n    s1.chars().for_each(|x|\
    \ *mut c1.push(x));\n    c0 == c1\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found keyword `mut`\n  --> /tmp/tmpcfi7hrzs.rs:17:30\n\
    \   |\n17 |     s0.chars().for_each(|x| *mut c0.push(x));\n   |              \
    \                ^^^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv8hp3zx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    (s0.chars()\n        .zip(s1.chars())\n \
    \       .any(|(a, b)| a == b)\n    )\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4c_5rehn.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm8cqh5xm.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6ouebp4g.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    debug_assert!(s0.len() == s1.len());\n  \
    \  for (a, b) in zip(s0.chars(), s1.chars()) {\n        if a != b {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmpfrr9cpgh.rs:16:19\n\
    \   |\n16 |     for (a, b) in zip(s0.chars(), s1.chars()) {\n   |            \
    \       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::iter::zip;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut s0_iter = s0.chars();\n    let mut s1_iter = s1.chars();\n\
    \    while (s0_iter.any() || s1_iter.any()) {\n        let char0 = s0_iter.next()?;\n\
    \        let char1 = s1_iter.next()?;\n        if char0 != char1 {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvwvb1j5o.rs:20:11\n\
    \   |\n20 |     while (s0_iter.any() || s1_iter.any()) {\n   |           ^   \
    \                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by\
    \ default\nhelp: remove these parentheses\n   |\n20 -     while (s0_iter.any()\
    \ || s1_iter.any()) {\n20 +     while s0_iter.any() || s1_iter.any() {\n   | \n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpvwvb1j5o.rs:20:20\n     |\n20   |     while (s0_iter.any() ||\
    \ s1_iter.any()) {\n     |                    ^^^- supplied 0 arguments\n    \
    \ |                    |\n     |                    expected 1 argument\n    \
    \ |\nnote: associated function defined here\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n    --> /tmp/tmpvwvb1j5o.rs:20:37\n\
    \     |\n20   |     while (s0_iter.any() || s1_iter.any()) {\n     |         \
    \                            ^^^- supplied 0 arguments\n     |               \
    \                      |\n     |                                     expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpvwvb1j5o.rs:21:35\n\
    \   |\n14 | / fn same_chars(s0: String, s1: String) -> bool {\n15 | |     if s0.len()\
    \ != s1.len() {\n16 | |         return false;\n17 | |     }\n...  |\n21 | |  \
    \       let char0 = s0_iter.next()?;\n   | |                                 \
    \  ^ cannot use the `?` operator in a function that returns `bool`\n...  |\n27\
    \ | |     true\n28 | | }\n   | |_- this function should return `Result` or `Option`\
    \ to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `bool`\n\nerror[E0277]: the `?` operator can only be\
    \ used in a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpvwvb1j5o.rs:22:35\n   |\n14 | / fn same_chars(s0:\
    \ String, s1: String) -> bool {\n15 | |     if s0.len("
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s0_str = (s0.len() * 'a' as usize).to_string();\n\
    \    let mut s1_str = (s1.len() * 'a' as usize).to_string();\n    s0_str.extend(s0.chars());\n\
    \    s1_str.extend(s1.chars());\n    s0_str.pop(s0_str.len() - 1);\n    s1_str.pop(s1_str.len()\
    \ - 1);\n    s0_str == s1_str\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpeamo78fu.rs:19:12\n     |\n19   |     s0_str.pop(s0_str.len()\
    \ - 1);\n     |            ^^^ ---------------- supplied 1 argument\n     |  \
    \          |\n     |            expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n    --> /tmp/tmpeamo78fu.rs:20:12\n     |\n20   |   \
    \  s1_str.pop(s1_str.len() - 1);\n     |            ^^^ ---------------- supplied\
    \ 1 argument\n     |            |\n     |            expected 0 arguments\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1[..]).all(|(a, b)| a ==\
    \ b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp2kufc0zh.rs:15:20\n    |\n15  |     s0.chars().zip(s1[..]).all(|(a,\
    \ b)| a == b)\n    |                --- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `std::iter::Iterator::zip`\n\nerror[E0277]: `str`\
    \ is not an iterator\n  --> /tmp/tmp2kufc0zh.rs:15:20\n   |\n15 |     s0.chars().zip(s1[..]).all(|(a,\
    \ b)| a == b)\n   |                --- ^^^^^^ `str` is not an iterator\n   | \
    \               |\n   |                required by a bound introduced by this\
    \ call\n   |\n   = help: the trait `Iterator` is not implemented for `str`\n \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `str`\n\nerror[E0599]: the method `all` exists for struct `Zip<Chars<'_>,\
    \ str>`, but its trait bounds were not satisfied\n  --> /tmp/tmp2kufc0zh.rs:15:28\n\
    \   |\n15 |       s0.chars().zip(s1[..]).all(|(a, b)| a == b)\n   |          \
    \                    ^^^ method cannot be called on `Zip<Chars<'_>, str>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `str: Sized`\n           which is required by `Zip<Chars<'_>,\
    \ str>: Iterator`\n           `str: Iterator`\n           which is required by\
    \ `Zip<Chars<'_>, str>: Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp02l2g359.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (a\
    \ == b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp723imqlr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s1.chars().count() != s0.chars().count()\
    \ {\n        return false;\n    }\n    for (i0, c0) in s0.chars().enumerate()\
    \ {\n        if s1[c0].char() == c0 {\n            continue;\n        }\n    \
    \    for (i1, c1) in s1.chars().enumerate() {\n            if s1[c1].char() ==\
    \ c0 {\n                continue;\n            }\n            if c1 == c0 {\n\
    \                continue;\n            }\n            return false;\n       \
    \ }\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpao_slays.rs:19:12\n\
    \   |\n19 |         if s1[c0].char() == c0 {\n   |            ^^^^^^ `String`\
    \ cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n \
    \ --> /tmp/tmpao_slays.rs:23:16\n   |\n23 |             if s1[c1].char() == c0\
    \ {\n   |                ^^^^^^ `String` cannot be indexed by `char`\n   |\n \
    \  = help: the trait `Index<char>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i0 = 0;\n    let mut i1 = 0;\n\n\
    \    while i0 < s0.len() && i1 < s1.len() {\n        if s0[i0] != s1[i1] {\n \
    \           break;\n        }\n\n        i0 += 1;\n        i1 += 1;\n    }\n\n\
    \    i0 == s0.len() && i1 == s1.len()\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprleznxyv.rs:19:12\n\
    \   |\n19 |         if s0[i0] != s1[i1] {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprleznxyv.rs:19:22\n   |\n19 |         if s0[i0] != s1[i1] {\n \
    \  |                      ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.len() == s1.len() && {\n        let mut\
    \ s0_iter = s0.char_indices().rev();\n        let mut s1_iter = s1.char_indices().rev();\n\
    \        let mut a = s0.chars().count();\n        let mut b = s1.chars().count();\n\
    \        let mut c = 0;\n        while c < a.len() && c < b.len() {\n        \
    \    if let Some((i, _)) = s0_iter.next() {\n                if let Some((j, _))\
    \ = s1_iter.next() {\n                    if i == j {\n                      \
    \  c++;\n                    }\n                }\n            }\n        }\n\
    \        a == b\n    }\n}\n\nfn main() {\n    let candidate = same_chars;\n  \
    \  assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp6maljyy2.rs:25:26\n\
    \   |\n25 |                         c++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |       \
    \                  { let tmp = c; c += 1; tmp };\n   |                       \
    \  +++++++++++  ~~~~~~~~~~~~~~~\n25 -                         c++;\n25 +     \
    \                    c += 1;\n   | \n\nerror[E0599]: no method named `len` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmp6maljyy2.rs:21:21\n   |\n\
    21 |         while c < a.len() && c < b.len() {\n   |                     ^^^\
    \ method not found in `usize`\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp6maljyy2.rs:21:36\n   |\n21\
    \ |         while c < a.len() && c < b.len() {\n   |                         \
    \           ^^^ method not found in `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut chars = String::new();\n    let mut\
    \ chars1 = String::new();\n    for c in s0.chars() {\n        if c == s1[s0.char_indices(&c)].char()\
    \ {\n            chars.push_str(&chars[..s0.char_indices(&c)].iter().cloned().collect());\n\
    \        }\n    }\n    for c in s1.chars() {\n        if c == s0[s1.char_indices(&c)].char()\
    \ {\n            chars1.push_str(&chars1[..s1.char_indices(&c)].iter().cloned().collect());\n\
    \        }\n    }\n    chars == chars1\n}\n\nfn main() {\n    let candidate =\
    \ same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp1jx7rpem.rs:18:23\n    |\n18  |         if c == s1[s0.char_indices(&c)].char()\
    \ {\n    |                       ^^^^^^^^^^^^ -- supplied 1 argument\n    |  \
    \                     |\n    |                       expected 0 arguments\n  \
    \  |\nnote: associated function defined here\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `CharIndices<'_>`\n  --> /tmp/tmp1jx7rpem.rs:18:17\n  \
    \ |\n18 |         if c == s1[s0.char_indices(&c)].char() {\n   |             \
    \    ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `CharIndices<'_>`\n\
    \   |\n   = help: the trait `Index<CharIndices<'_>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmp1jx7rpem.rs:19:40\n    |\n19  |             chars.push_str(&chars[..s0.char_indices(&c)].iter().cloned().collect());\n\
    \    |                                        ^^^^^^^^^^^^ -- supplied 1 argument\n\
    \    |                                        |\n    |                       \
    \                 expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<CharIndices<'_>>`\n\
    \  --> /tmp/tmp1jx7rpem.rs:19:29\n   |\n19 |             chars.push_str(&chars[..s0.char_indices(&c)].iter().cloned().collect());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `RangeTo<CharIndices<'_>>`\n   |\n   = help: the trait `Index<RangeTo<CharIndices<'_>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String a"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy2tnf15x.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (*a)\
    \ == (*b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpt68ldbsn.rs:15:45\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(a, b)| (*a) == (*b))\n   |  \
    \                                           ^^^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpt68ldbsn.rs:15:53\n   |\n15 |     s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| (*a) == (*b))\n   |                                                    \
    \ ^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_udk8407.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4jdugeed.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for (c0, s0) in s0.chars().zip(s1) {\n  \
    \      if (c0 != c1) {\n            return false;\n        }\n    }\n    for (c0,\
    \ s0) in s0.chars().zip(s1) {\n        if (c0 != c0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c1` in this scope\n  --> /tmp/tmpro26706l.rs:16:19\n\
    \   |\n16 |         if (c0 != c1) {\n   |                   ^^ help: a local variable\
    \ with a similar name exists: `c0`\n\nwarning: unnecessary parentheses around\
    \ `if` condition\n  --> /tmp/tmpro26706l.rs:16:12\n   |\n16 |         if (c0 !=\
    \ c1) {\n   |            ^        ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n16 -         if (c0 !=\
    \ c1) {\n16 +         if c0 != c1 {\n   | \n\nwarning: unnecessary parentheses\
    \ around `if` condition\n  --> /tmp/tmpro26706l.rs:21:12\n   |\n21 |         if\
    \ (c0 != c0) {\n   |            ^        ^\n   |\nhelp: remove these parentheses\n\
    \   |\n21 -         if (c0 != c0) {\n21 +         if c0 != c0 {\n   | \n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpro26706l.rs:15:36\n   |\n15 |   \
    \  for (c0, s0) in s0.chars().zip(s1) {\n   |                                ---\
    \ ^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   | \
    \                               |\n   |                                required\
    \ by a bound introduced by this call\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmpro26706l.rs:15:21\n   |\n15 |     for (c0, s0) in\
    \ s0.chars().zip(s1) {\n   |                     ^^^^^^^^^^^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Zip<Chars<'_>, String>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Zip<Chars<'_>, String>`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpro26706l.rs:15:32\n   |\n15 |     for (c0, s0) in s0.chars().zip(s1)\
    \ {\n   |                                ^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    loop {\n        if s0[..] == s1[..] {\n \
    \           return true;\n        }\n\n        if s0[..] == b'z' {\n         \
    \   s0 += 'z';\n            s1 += 'z';\n        }\n\n        if s0.len() == s1.len()\
    \ {\n            return false;\n        }\n\n        assert!(s1.len() <= 7);\n\
    \        s1 += b'y';\n    }\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `u8`\n  --> /tmp/tmpk7q0daz6.rs:20:19\n\
    \   |\n20 |         if s0[..] == b'z' {\n   |                   ^^ no implementation\
    \ for `str == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk7q0daz6.rs:21:19\n   |\n21 |             s0 += 'z';\n\
    \   |                   ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n21 |             s0\
    \ += \"z\";\n   |                   ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk7q0daz6.rs:22:19\n   |\n22 |             s1 += 'z';\n   |         \
    \          ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n22 |             s1 += \"z\";\n  \
    \ |                   ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk7q0daz6.rs:30:15\n\
    \   |\n30 |         s1 += b'y';\n   |               ^^^^ expected `&str`, found\
    \ `u8`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7kbx2h6d.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut c = s0.chars().enumerate();\n    c.zip(s1.chars().enumerate()).all(|(&(&i,\
    \ c1), (&(&i), c2))| {\n        if c1 != c2 {\n            false\n        } else\
    \ {\n            i as usize == i\n        }\n    });\n}\n\nfn main() {\n    let\
    \ candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0415]: identifier `i` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmpp8aec6gr.rs:19:56\n   |\n19 |     c.zip(s1.chars().enumerate()).all(|(&(&i,\
    \ c1), (&(&i), c2))| {\n   |                                                 \
    \       ^ used as parameter more than once\n\nwarning: unnecessary parentheses\
    \ around pattern\n  --> /tmp/tmpp8aec6gr.rs:19:54\n   |\n19 |     c.zip(s1.chars().enumerate()).all(|(&(&i,\
    \ c1), (&(&i), c2))| {\n   |                                                 \
    \     ^  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n19 -     c.zip(s1.chars().enumerate()).all(|(&(&i,\
    \ c1), (&(&i), c2))| {\n19 +     c.zip(s1.chars().enumerate()).all(|(&(&i, c1),\
    \ (&&i, c2))| {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8aec6gr.rs:19:41\n\
    \   |\n19 |     c.zip(s1.chars().enumerate()).all(|(&(&i, c1), (&(&i), c2))| {\n\
    \   |                                         ^^^^^^^^^             - expected\
    \ due to this\n   |                                         |\n   |          \
    \                               expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(usize, char)`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp8aec6gr.rs:19:53\n   |\n19 |     c.zip(s1.chars().enumerate()).all(|(&(&i,\
    \ c1), (&(&i), c2))| {\n   |                                                 \
    \    ^^^^^     - expected due to this\n   |                                  \
    \                   |\n   |                                                  \
    \   expected `usize`, found reference\n   |\n   = note:   expected type `usize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8aec6gr.rs:14:42\n\
    \   |\n14 | fn same_chars(s0: String, s1: String) -> bool {\n   |    ----------\
    \                            ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n25 |     });\n   |       - help: remove this semicolon\n\nerror: aborting\
    \ due to 4 previous errors; 1 warning emitted\n\nSome error"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut a = s0.chars();\n    let mut b = s1.chars();\n  \
    \  loop {\n        if a.next().unwrap() != b.next().unwrap() {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfuq697zm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut it = s0.chars().zip(s1.chars()).enumerate();\n  \
    \  let mut chars1 = 0;\n    let mut chars2 = 0;\n    for ((x, y), (i1, i2)) in\
    \ it.by_ref() {\n        if i1 == i2 {\n            if x == y {\n            \
    \    chars1 += 1;\n                chars2 += 1;\n            }\n        }\n  \
    \      else {\n            return false;\n        }\n    }\n    if chars1 == chars2\
    \ {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdo0iidzz.rs:21:10\n   |\n\
    21 |     for ((x, y), (i1, i2)) in it.by_ref() {\n   |          ^^^^^^       \
    \        ----------- this expression has type `Option<(usize, (char, char))>`\n\
    \   |          |\n   |          expected `usize`, found tuple\n   |\n   = note:\
    \ expected type `usize`\n             found tuple `(_, _)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars())\n        .all(|(a,\
    \ b)| (*a) == (*b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpmvk1ferm.rs:16:23\n\
    \   |\n16 |         .all(|(a, b)| (*a) == (*b))\n   |                       ^^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpmvk1ferm.rs:16:31\n\
    \   |\n16 |         .all(|(a, b)| (*a) == (*b))\n   |                        \
    \       ^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i0 = 0;\n    let mut i1 = 0;\n  \
    \  while i0 < s0.len() && i1 < s1.len() {\n        let c0 = s0.chars().nth(i0);\n\
    \        let c1 = s1.chars().nth(i1);\n        if c0 == c1 {\n            i0 +=\
    \ 1;\n            i1 += 1;\n        } else if c0 != c1 {\n            return false;\n\
    \        }\n    }\n    (i0 == s0.len()) && (i1 == s1.len())\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa2mlh509.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // First count the differences.\n    let\
    \ mut num_diffs: usize = 0;\n    for (c0, c1) in s0.chars().zip(s1.chars()) {\n\
    \        if c0 != c1 {\n            num_diffs += 1;\n        }\n    }\n    //\
    \ If we counted more differences than we expected, then this isn't a match.\n\
    \    num_diffs <= s2.chars().len()\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `s2` in this scope\n  --> /tmp/tmps6nkm1fe.rs:23:18\n\
    \   |\n23 |     num_diffs <= s2.chars().len()\n   |                  ^^ help:\
    \ a local variable with a similar name exists: `s0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1 = s1.chars();\n    let mut s2:\
    \ Vec<_> = s2.into_iter().map(|c| c.to_digit(10)).collect();\n    let mut s0 =\
    \ s0.chars();\n    let mut s1d = s1.clone().into_iter().map(|c| c.to_digit(10)).collect();\n\
    \    let mut s1d = s1.clone().into_iter().map(|c| c.to_digit(10)).collect();\n\
    \n    let mut s2d = s2.clone().into_iter().map(|c| c.to_digit(10)).collect();\n\
    \    let mut s2d = s2.clone().into_iter().map(|c| c.to_digit(10)).collect();\n\
    \n    let mut i = 0;\n    while i < s1.len() {\n        if s1[i] == '.' {\n  \
    \          if i == s1.len() - 1 {\n                continue;\n            }\n\
    \            let mut j = i;\n            s2d.push(s2[j]);\n            s2d.push(s2[j\
    \ + 1]);\n            s2d.push(s2[j + 2]);\n            i += 3;\n        } else\
    \ if s1d[i] == s2d[i] {\n            i += 1;\n        } else {\n            break;\n\
    \        }\n    }\n\n    i > 0\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `s2` in this scope\n  --> /tmp/tmp32dnd990.rs:16:26\n\
    \   |\n16 |     let mut s2: Vec<_> = s2.into_iter().map(|c| c.to_digit(10)).collect();\n\
    \   |                          ^^ help: a local variable with a similar name exists:\
    \ `s0`\n\nerror[E0599]: no method named `len` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp32dnd990.rs:25:18\n   |\n25 |     while i < s1.len()\
    \ {\n   |                  ^^^ method not found in `Chars<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp32dnd990.rs:26:12\n\
    \   |\n26 |         if s1[i] == '.' {\n   |            ^^^^^\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp32dnd990.rs:27:24\n\
    \   |\n27 |             if i == s1.len() - 1 {\n   |                        ^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1 = s1.chars();\n    let mut s =\
    \ s0.chars();\n    let mut i = 0;\n    while !s.is_empty() {\n        let d =\
    \ s1.next();\n        if i >= s.len() {\n            return false;\n        }\n\
    \        if d != s[i] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpgekhjkb6.rs:18:14\n   |\n18 |     while !s.is_empty()\
    \ {\n   |              ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpgekhjkb6.rs:20:19\n\
    \   |\n20 |         if i >= s.len() {\n   |                   ^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpgekhjkb6.rs:23:17\n   |\n23 |         if d != s[i] {\n   |    \
    \             ^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let s1 = s0.chars().collect::<String>();\n\
    \    let s2 = s1.chars().collect::<String>();\n\n    s1.cmp(&s2) == EquEqual &&\
    \ s0.cmp(&s1) == EquEqual && *s0 == *s1\n}\n\nfn main() {\n    let candidate =\
    \ same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `EquEqual` in this scope\n  --> /tmp/tmp_2jvquzm.rs:18:20\n\
    \   |\n18 |     s1.cmp(&s2) == EquEqual && s0.cmp(&s1) == EquEqual && *s0 == *s1\n\
    \   |                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `EquEqual` in this scope\n  --> /tmp/tmp_2jvquzm.rs:18:47\n   |\n\
    18 |     s1.cmp(&s2) == EquEqual && s0.cmp(&s1) == EquEqual && *s0 == *s1\n  \
    \ |                                               ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s0_iter = s0.chars();\n    let mut\
    \ s1_iter = s1.chars();\n    loop {\n        if !s0_iter.next().eq(s1_iter.next())\
    \ {\n            return false;\n        }\n        if !s1_iter.next().eq(s0_iter.next())\
    \ {\n            return false;\n        }\n        if s0_iter.peek().is_none()\
    \ && !s1_iter.peek().is_none() {\n            return false;\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx449fmta.rs:18:31\n   |\n\
    18 |         if !s0_iter.next().eq(s1_iter.next()) {\n   |                   \
    \            ^^^^^^^^^^^^^^\n   |                               |\n   |      \
    \                         expected `&Option<char>`, found enum `Option`\n   |\
    \                               help: consider borrowing here: `&s1_iter.next()`\n\
    \   |\n   = note: expected reference `&Option<char>`\n                   found\
    \ enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx449fmta.rs:21:31\n\
    \   |\n21 |         if !s1_iter.next().eq(s0_iter.next()) {\n   |            \
    \                   ^^^^^^^^^^^^^^\n   |                               |\n   |\
    \                               expected `&Option<char>`, found enum `Option`\n\
    \   |                               help: consider borrowing here: `&s0_iter.next()`\n\
    \   |\n   = note: expected reference `&Option<char>`\n                   found\
    \ enum `Option<char>`\n\nerror[E0599]: no method named `peek` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpx449fmta.rs:24:20\n   |\n24 |  \
    \       if s0_iter.peek().is_none() && !s1_iter.peek().is_none() {\n   |     \
    \               ^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Chars` in the current scope\n  --> /tmp/tmpx449fmta.rs:24:49\n\
    \   |\n24 |         if s0_iter.peek().is_none() && !s1_iter.peek().is_none() {\n\
    \   |                                                 ^^^^ method not found in\
    \ `Chars<'_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyl7r744s.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() { return false; }\n\
    \    for (a0, a1) in s0.chars().zip(s1.chars()) {\n        if a0 != a1 { return\
    \ false; }\n    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwl9eds08.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjl1_niol.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi24vk72a.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2wuaa1wo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeokboyyw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip2(s1.chars(), |(c1, c2)| c1\
    \ == c2).all(|b| b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `zip2` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp8s1pvd95.rs:15:16\n   |\n15 |     s0.chars().zip2(s1.chars(),\
    \ |(c1, c2)| c1 == c2).all(|b| b)\n   |                ^^^^ method not found in\
    \ `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2jxpn2rb.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut len = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    for (s0c, s1c) in zip!(s0.chars(), s1.chars()) {\n        if s0c == s1c {\n\
    \            len += 1;\n            i += 1;\n            j += 1;\n        } else\
    \ {\n            if len > 0 {\n                if i < len {\n                \
    \    i += 1;\n                } else if j > len {\n                    j += 1;\n\
    \                } else {\n                    break;\n                }\n   \
    \             len = 0;\n            }\n        }\n    }\n    if len > 0 {\n  \
    \      return false;\n    }\n    len == s0.len()\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `zip` in this scope\n  --> /tmp/tmpnom2pumu.rs:21:23\n\
    \   |\n21 |     for (s0c, s1c) in zip!(s0.chars(), s1.chars()) {\n   |       \
    \                ^^^\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnkp1bjr3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut hash0 = Hashing::hash(s0);\n    let\
    \ mut hash1 = Hashing::hash(s1);\n    while let Some(idx) = hash0.find_prefix(&mut\
    \ hash1) {\n        if idx > 0 {\n            hash1.write_u32(idx);\n        }\n\
    \    }\n    hash1.end()\n        .zip(hash0.end())\n        .any(|(&idx1, &idx2)|\
    \ idx1 == idx2)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Hashing`\n  -->\
    \ /tmp/tmpwdas3fmo.rs:15:21\n   |\n15 |     let mut hash0 = Hashing::hash(s0);\n\
    \   |                     ^^^^^^^ use of undeclared type `Hashing`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Hashing`\n  --> /tmp/tmpwdas3fmo.rs:16:21\n\
    \   |\n16 |     let mut hash1 = Hashing::hash(s1);\n   |                     ^^^^^^^\
    \ use of undeclared type `Hashing`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphgw_zu6d.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for &c0 &in s0.chars() {\n        if c0 !=\
    \ *s1 {\n            break;\n        }\n        s1 = s1.chars().next();\n    }\n\
    \    s1.is_none()\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpi4a8mcw7.rs:15:12\n  \
    \ |\n15 |     for &c0 &in s0.chars() {\n   |            ^ help: try adding `in`\
    \ here\n\nerror: expected expression, found keyword `in`\n  --> /tmp/tmpi4a8mcw7.rs:15:14\n\
    \   |\n15 |     for &c0 &in s0.chars() {\n   |              ^^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    for (a, b) in s0.chars().zip(s1) {\n        if a != b {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmptga694ll.rs:18:34\n\
    \   |\n18 |     for (a, b) in s0.chars().zip(s1) {\n   |                     \
    \         --- ^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |                              |\n   |                              required\
    \ by a bound introduced by this call\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmptga694ll.rs:18:19\n   |\n18 |     for (a, b) in s0.chars().zip(s1)\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `Iterator` for `Zip<Chars<'_>, String>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Zip<Chars<'_>, String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    for (i, c0) in s0.chars().enumerate() {\n        let c1 =\
    \ s1.chars()\n            .nth(i)\n            .unwrap()\n            .unwrap();\n\
    \        if c0 != c1 {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpr4wea5dd.rs:22:14\n   |\n22 |             .unwrap();\n\
    \   |              ^^^^^^ method not found in `char`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzgfmux6n.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4n6q6j_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcicj24b3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut iter = s0.chars().zip(s1.chars());\n\
    \    let mut prev = char::None;\n    let mut current = char::None;\n    loop {\n\
    \        match iter.next() {\n            Some(&(s0c, s1c)) if s0c != s1c => return\
    \ false,\n            Some(&(s0c, s1c)) if prev != s0c => prev = s0c,\n      \
    \      Some(&(s0c, s1c)) => current = s0c,\n            None => return false\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `None` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpqkynqzh1.rs:16:26\n   |\n16 |     let mut prev\
    \ = char::None;\n   |                          ^^^^ associated item not found\
    \ in `char`\n\nerror[E0599]: no associated item named `None` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpqkynqzh1.rs:17:29\n   |\n17 |     let mut\
    \ current = char::None;\n   |                             ^^^^ associated item\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkynqzh1.rs:20:18\n\
    \   |\n19 |         match iter.next() {\n   |               ----------- this expression\
    \ has type `Option<(char, char)>`\n20 |             Some(&(s0c, s1c)) if s0c !=\
    \ s1c => return false,\n   |                  ^^^^^^^^^^^ expected tuple, found\
    \ reference\n   |\n   = note:  expected tuple `(char, char)`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkynqzh1.rs:21:18\n\
    \   |\n19 |         match iter.next() {\n   |               ----------- this expression\
    \ has type `Option<(char, char)>`\n20 |             Some(&(s0c, s1c)) if s0c !=\
    \ s1c => return false,\n21 |             Some(&(s0c, s1c)) if prev != s0c => prev\
    \ = s0c,\n   |                  ^^^^^^^^^^^ expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(char, char)`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqkynqzh1.rs:22:18\n   |\n19 |\
    \         match iter.next() {\n   |               ----------- this expression\
    \ has type `Option<(char, char)>`\n...\n22 |             Some(&(s0c, s1c)) =>\
    \ current = s0c,\n   |                  ^^^^^^^^^^^ expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(char, char)`\n           found reference `&_`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp092_n1pi.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let s0_len = s0.chars().count();\n    let\
    \ s1_len = s1.chars().count();\n    if s0_len != s1_len {\n        return false;\n\
    \    }\n    for i in s0.chars() {\n        if i != s1[i] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp_6vytkk3.rs:21:17\n\
    \   |\n21 |         if i != s1[i] {\n   |                 ^^^^^ `String` cannot\
    \ be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars())\n        .all(|(&a0,\
    \ &a1)| a0 == a1)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6htxf31h.rs:16:16\n   |\n\
    16 |         .all(|(&a0, &a1)| a0 == a1)\n   |                ^^^     - expected\
    \ due to this\n   |                |\n   |                expected `char`, found\
    \ reference\n   |                help: you can probably remove the explicit borrow:\
    \ `a0`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6htxf31h.rs:16:21\n   |\n16 |\
    \         .all(|(&a0, &a1)| a0 == a1)\n   |                     ^^^- expected\
    \ due to this\n   |                     |\n   |                     expected `char`,\
    \ found reference\n   |                     help: you can probably remove the\
    \ explicit borrow: `a1`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw7s3yy2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // TODO: replace with str::char_indices\n\
    \    for (a, b) in s0.chars().zip(s1.chars()) {\n        if a != b {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_d5vfdwv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0v1jd6ij.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| *a\
    \ == *b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmptu8bs_2j.rs:15:45\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(a, b)| *a == *b)\n   |      \
    \                                       ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmptu8bs_2j.rs:15:51\n   |\n15 |     s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| *a == *b)\n   |                                                   ^^\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if !s0.is_char() && !s1.is_char() {\n   \
    \     return false;\n    }\n    if !s0.is_char() {\n        return true;\n   \
    \ }\n    if !s1.is_char() {\n        return false;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < s0.len() && j < s1.len() {\n        if s0.chars().next().unwrap()\
    \ != s1.chars().next().unwrap() {\n            break;\n        }\n        i +=\
    \ 1;\n        j += 1;\n    }\n    j == s1.len();\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_char` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmwc9b7zp.rs:15:12\n   |\n15 |     if !s0.is_char()\
    \ && !s1.is_char() {\n   |            ^^^^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `is_char` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpmwc9b7zp.rs:15:29\n   |\n15 |     if !s0.is_char() && !s1.is_char()\
    \ {\n   |                             ^^^^^^^ method not found in `String`\n\n\
    error[E0599]: no method named `is_char` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpmwc9b7zp.rs:18:12\n   |\n18 |     if !s0.is_char() {\n\
    \   |            ^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `is_char` found for struct `String` in the current scope\n  --> /tmp/tmpmwc9b7zp.rs:21:12\n\
    \   |\n21 |     if !s1.is_char() {\n   |            ^^^^^^^ method not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmwc9b7zp.rs:14:42\n\
    \   |\n14 | fn same_chars(s0: String, s1: String) -> bool {\n   |    ----------\
    \                            ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n33 |     j == s1.len();\n   |                  - help: remove this semicolon\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    same_chars_chars_unordered(s0, s1)\n}\n\n\
    fn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `same_chars_chars_unordered` in this\
    \ scope\n  --> /tmp/tmplu52ulr3.rs:15:5\n   |\n15 |     same_chars_chars_unordered(s0,\
    \ s1)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s = s0;\n    for c in s1 {\n    \
    \    if c != s[s.len() - 1] {\n            return false;\n        }\n        s\
    \ = &c.to_string();\n    }\n    s.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp5qk_nxt9.rs:16:14\n\
    \   |\n16 |     for c in s1 {\n   |              ^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp5qk_nxt9.rs:17:17\n   |\n17 |  \
    \       if c != s[s.len() - 1] {\n   |                 ^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    loop {\n        let mut s1 = s1.chars();\n\
    \        let mut s2 = s0.chars();\n        if s2.len() != s1.len() {\n       \
    \     return false;\n        }\n        let (mut c1, mut c2) = (s1.next(), s2.next());\n\
    \        if c1 != c2 {\n            return false;\n        }\n        if c1 !=\
    \ b'\\0' {\n            return false;\n        }\n    }\n}\n\nfn main() {\n  \
    \  let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp_2l9f69k.rs:18:15\n   |\n18 |         if s2.len() != s1.len()\
    \ {\n   |               ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp_2l9f69k.rs:18:27\n\
    \   |\n18 |         if s2.len() != s1.len() {\n   |                          \
    \ ^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_2l9f69k.rs:25:18\n   |\n25 |         if c1 != b'\\0' {\n   |      \
    \            ^^^^^ expected enum `Option`, found `u8`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `u8`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut chars1 = 0;\n    let mut chars2 =\
    \ 0;\n\n    s0.chars()\n        .zip(s1.chars())\n        .for_each(|(c0, c1)|\
    \ {\n            if c0 != c1 {\n                return false;\n            }\n\
    \            chars1 += 1;\n            chars2 += 1;\n        });\n\n    chars1\
    \ == chars2\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7u4lg_6z.rs:22:24\n   |\n\
    22 |                 return false;\n   |                        ^^^^^ expected\
    \ `()`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfc5tnewu.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for (_, s2) in zip!(s0.chars(), s1.chars())\
    \ {\n        if s0 != s1 { break; }\n    }\n    s0 == s1\n}\n\nfn main() {\n \
    \   let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `zip` in this scope\n  --> /tmp/tmpu5kfg_yp.rs:15:20\n\
    \   |\n15 |     for (_, s2) in zip!(s0.chars(), s1.chars()) {\n   |          \
    \          ^^^\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut result = 0;\n    for c in s0 {\n        result |=\
    \ 1 << c;\n    }\n    for c in s1 {\n        result |= 1 << c;\n    }\n    result\
    \ == 0\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpylplg4nk.rs:19:14\n\
    \   |\n19 |     for c in s0 {\n   |              ^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmpylplg4nk.rs:22:14\n   |\n22 |     for c in s1 {\n\
    \   |              ^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1[..]).all(|(a, b)| a ==\
    \ b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpabchi4wu.rs:15:20\n    |\n15  |     s0.chars().zip(s1[..]).all(|(a,\
    \ b)| a == b)\n    |                --- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `std::iter::Iterator::zip`\n\nerror[E0277]: `str`\
    \ is not an iterator\n  --> /tmp/tmpabchi4wu.rs:15:20\n   |\n15 |     s0.chars().zip(s1[..]).all(|(a,\
    \ b)| a == b)\n   |                --- ^^^^^^ `str` is not an iterator\n   | \
    \               |\n   |                required by a bound introduced by this\
    \ call\n   |\n   = help: the trait `Iterator` is not implemented for `str`\n \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `str`\n\nerror[E0599]: the method `all` exists for struct `Zip<Chars<'_>,\
    \ str>`, but its trait bounds were not satisfied\n  --> /tmp/tmpabchi4wu.rs:15:28\n\
    \   |\n15 |       s0.chars().zip(s1[..]).all(|(a, b)| a == b)\n   |          \
    \                    ^^^ method cannot be called on `Zip<Chars<'_>, str>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `str: Sized`\n           which is required by `Zip<Chars<'_>,\
    \ str>: Iterator`\n           `str: Iterator`\n           which is required by\
    \ `Zip<Chars<'_>, str>: Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps70plkwy.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbki2zv33.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for (a, b) in zip(s0.chars(), s1.chars())\
    \ {\n        if *a != *b {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `zip` in this scope\n  --> /tmp/tmpl5i897gt.rs:15:19\n\
    \   |\n15 |     for (a, b) in zip(s0.chars(), s1.chars()) {\n   |            \
    \       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::iter::zip;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (*a\
    \ as u8)==(*b as u8))\n}\n\nfn main() {\n    let candidate = same_chars;\n   \
    \ assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphb2ep_rk.rs:15:46\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(a, b)| (*a as u8)==(*b as u8))\n\
    \   |                                              ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmphb2ep_rk.rs:15:58\n   |\n15 |     s0.chars().zip(s1.chars()).all(|(a,\
    \ b)| (*a as u8)==(*b as u8))\n   |                                          \
    \                ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiohoqtb5.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut i: usize = 0;\n    let mut j: usize\
    \ = 0;\n\n    if s0.len() != s1.len() {\n        return false;\n    }\n\n    for\
    \ i = 0; i != s0.len(); ++i) {\n        if s0[i] != s1[j] {\n            return\
    \ false;\n        }\n\n        i += 1;\n        j += 1;\n    }\n\n    true\n}\n\
    \nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmphx1bh751.rs:32:1\n\
    \   |\n22 |     for i = 0; i != s0.len(); ++i) {\n   |                       \
    \             - this opening brace...\n...\n29 |     }\n   |     - ...matches\
    \ this closing brace\n...\n32 | }\n   | ^ unexpected closing delimiter\n\nerror:\
    \ mismatched closing delimiter: `)`\n  --> /tmp/tmphx1bh751.rs:14:47\n   |\n14\
    \ | fn same_chars(s0: String, s1: String) -> bool {\n   |                    \
    \                           ^ unclosed delimiter\n...\n22 |     for i = 0; i !=\
    \ s0.len(); ++i) {\n   |                                  ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // Compare each pair of char.\n    let mut\
    \ is_same = true;\n    for (i, chr) in s0.chars().zip(s1.chars()) {\n        if\
    \ i != 0 {\n            if chr != s0[i] || chr != s1[i] {\n                is_same\
    \ = false;\n                break;\n            }\n        } else {\n        \
    \    if chr != s0[i] {\n                is_same = false;\n                break;\n\
    \            }\n        }\n    }\n    is_same\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxhns9k56.rs:18:17\n   |\n\
    18 |         if i != 0 {\n   |                 ^ expected `char`, found `u8`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpxhns9k56.rs:19:23\n\
    \   |\n19 |             if chr != s0[i] || chr != s1[i] {\n   |              \
    \         ^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait\
    \ `Index<char>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n \
    \ --> /tmp/tmpxhns9k56.rs:19:39\n   |\n19 |             if chr != s0[i] || chr\
    \ != s1[i] {\n   |                                       ^^^^^ `String` cannot\
    \ be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n \
    \ --> /tmp/tmpxhns9k56.rs:24:23\n   |\n24 |             if chr != s0[i] {\n  \
    \ |                       ^^^^^ `String` cannot be indexed by `char`\n   |\n \
    \  = help: the trait `Index<char>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <Str"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    if s0.len() == 0 {\n        return true;\n    }\n    for\
    \ i in 0..s0.len() {\n        if s0[i] != s1[i] {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwuhxuesf.rs:22:12\n\
    \   |\n22 |         if s0[i] != s1[i] {\n   |            ^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwuhxuesf.rs:22:21\n   |\n22 |         if s0[i] != s1[i] {\n   |\
    \                     ^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut seen = HashSet::new();\n    for &(c0, c1) in &(s0,\
    \ s1) {\n        if !seen.contains(c0) {\n            return false;\n        }\n\
    \        seen.insert(c1);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpre7midxa.rs:18:20\n   |\n18 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ `&(String, String)` is not an iterator\n  --> /tmp/tmpre7midxa.rs:19:22\n  \
    \ |\n19 |     for &(c0, c1) in &(s0, s1) {\n   |                      ^^^^^^^^^\
    \ `&(String, String)` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&(String, String)`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&(String, String)`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    loop {\n        if s0.len() == s1.len() {\n\
    \            return s0.chars().zip(s1.chars()).all(|(a, b)| a == b);\n       \
    \ }\n        if s0.len() < s1.len() {\n            return false;\n        }\n\
    \        if s0.len() > s1.len() {\n            return true;\n        }\n     \
    \   s0 = s0.chars().next();\n        s1 = s1.chars().next();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph9j9f7dh.rs:25:14\n   |\n\
    14 | fn same_chars(s0: String, s1: String) -> bool {\n   |                   ------\
    \ expected due to this parameter type\n...\n25 |         s0 = s0.chars().next();\n\
    \   |              ^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph9j9f7dh.rs:26:14\n   |\n14 |\
    \ fn same_chars(s0: String, s1: String) -> bool {\n   |                      \
    \         ------ expected due to this parameter type\n...\n26 |         s1 = s1.chars().next();\n\
    \   |              ^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)\n}\n\nfn\
    \ main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8caw49et.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu0zd5e4n.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppe5yy_xl.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s0c = String::new();\n    s0.chars().for_each(|c|\
    \ *s0c += c);\n    let mut s1c = String::new();\n    s1.chars().for_each(|c| *s1c\
    \ += c);\n    s0c == s1c\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `str`\n  --> /tmp/tmpg2_ppens.rs:16:29\n   |\n16 |     s0.chars().for_each(|c|\
    \ *s0c += c);\n   |                             ----^^^^^\n   |              \
    \               |\n   |                             cannot use `+=` on type `str`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `str`\n\
    \  --> /tmp/tmpg2_ppens.rs:18:29\n   |\n18 |     s1.chars().for_each(|c| *s1c\
    \ += c);\n   |                             ----^^^^^\n   |                   \
    \          |\n   |                             cannot use `+=` on type `str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a,b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkrzzfrdv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1 = String::from(s1);\n    let mut\
    \ s0 = String::from(s0);\n    let mut res = false;\n    while !(res && (s0.len()\
    \ != s1.len())) {\n        let mut s0_iter = s0.chars();\n        let mut s1_iter\
    \ = s1.chars();\n        let mut diff = 0;\n        while let Some(el) = s0_iter.next()\
    \ {\n            if el != s1_iter.next() {\n                diff += 1;\n     \
    \       }\n        }\n        if diff == 0 {\n            res = true;\n      \
    \  } else {\n            s0 = s1.into_iter().collect();\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvyehbblt.rs:23:22\n   |\n\
    23 |             if el != s1_iter.next() {\n   |                      ^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0599]: the method `into_iter`\
    \ exists for struct `String`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpvyehbblt.rs:30:21\n    |\n30  |               s0 = s1.into_iter().collect();\n\
    \    |                       ^^^^^^^^^\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `String: IntoIterator`\n            `&String: Iterator`\n   \
    \         which is required by `&String: IntoIterator`\n            `&mut String:\
    \ Iterator`\n            which is required by `&mut String: IntoIterator`\n  \
    \          `str: Sized`\n            which is required by `str: IntoIterator`\n\
    \            `str: Iterator`\n            which is required by `str: IntoIterator`\n\
    \            `&str: Iterator`\n            which is required by `&str: IntoIterator`\n\
    \            `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    for ((a, _), (b, _)) in zip((s0.chars(),\
    \ s1.chars()), (0, 0), (s0.len(), s1.len())) ||| {\n        if *a != *b {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected parameter name, found `{`\n  --> /tmp/tmptc1d1w_0.rs:15:93\n\
    \   |\n15 |     for ((a, _), (b, _)) in zip((s0.chars(), s1.chars()), (0, 0),\
    \ (s0.len(), s1.len())) ||| {\n   |                                          \
    \                                                   ^ expected parameter name\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // Check lengths.\n    if s0.len() != s1.len()\
    \ {\n        return false;\n    }\n    // Check first characters.\n    for &ch\
    \ in s0.chars() {\n        if s1 !~ &ch\n            || s0.chars().any(|&_| _\
    \ != ch)\n            || s1.chars().any(|&_| _ != ch)\n        {\n           \
    \ return false;\n        }\n    }\n    // Check other characters.\n    for &ch\
    \ in s1.chars() {\n        if s0 !~ &ch\n            || s0.chars().any(|&_| _\
    \ != ch)\n            || s1.chars().any(|&_| _ != ch)\n        {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"\
    dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"\
    ), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `~`\n  --> /tmp/tmp6k5fub81.rs:21:16\n\
    \   |\n21 |         if s1 !~ &ch\n   |                ^ expected one of `(`, `[`,\
    \ or `{`\n\nerror: expected one of `(`, `[`, or `{`, found `~`\n  --> /tmp/tmp6k5fub81.rs:30:16\n\
    \   |\n30 |         if s0 !~ &ch\n   |                ^ expected one of `(`, `[`,\
    \ or `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6k5fub81.rs:20:9\n \
    \  |\n20 |     for &ch in s0.chars() {\n   |         ^^^    ---------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `ch`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6k5fub81.rs:29:9\n   |\n29 |   \
    \  for &ch in s1.chars() {\n   |         ^^^    ---------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `ch`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    for &(c0, c1) in s0.chars().zip(s1.chars()) {\n        if\
    \ c0 != c1 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkp0ejh73.rs:18:9\n   |\n\
    18 |     for &(c0, c1) in s0.chars().zip(s1.chars()) {\n   |         ^^^^^^^^^\
    \    -------------------------- this expression has type `Option<(char, char)>`\n\
    \   |         |\n   |         expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(char, char)`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars())\n        .all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwfr2njd3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    // O(n) algorithm to count the characters\
    \ in string s1 that appear in string s0.\n    let mut same_count = 0;\n    for\
    \ c in s1 {\n        if s0[c] == c {\n            same_count += 1;\n        }\n\
    \    }\n    same_count == s1.len()\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpnbngovcq.rs:17:14\n\
    \   |\n17 |     for c in s1 {\n   |              ^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() { return false; }\n\
    \    for &(ch, &c) in s0.chars().zip(s1.chars()) {\n        if c != ch { return\
    \ false; }\n    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n\
    \    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9csb2vns.rs:16:9\n   |\n\
    16 |     for &(ch, &c) in s0.chars().zip(s1.chars()) {\n   |         ^^^^^^^^^\
    \    -------------------------- this expression has type `Option<(char, char)>`\n\
    \   |         |\n   |         expected tuple, found reference\n   |\n   = note:\
    \  expected tuple `(char, char)`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3jc4viz0.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw2ngxq77.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    let mut chars = s0.chars().chain(s1.chars());\n    if chars.count()\
    \ != 0 {\n        return false;\n    }\n    let mut seen = chars.collect::<Vec<_>>();\n\
    \    seen.pop();\n    let mut next_seen = chars.cloned().chain(s1.chars());\n\
    \    while next_seen.len() > 0 {\n        if seen.contains(&next_seen[0]) {\n\
    \            return false;\n        }\n        seen.pop();\n        next_seen.pop();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<std::iter::Chain<Chars<'_>, Chars<'_>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpjl02tjn7.rs:24:31\n     |\n24   |\
    \     let mut next_seen = chars.cloned().chain(s1.chars());\n     |          \
    \                     ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `chain` exists for\
    \ struct `Cloned<std::iter::Chain<Chars<'_>, Chars<'_>>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpjl02tjn7.rs:24:40\n   |\n24 |       let mut\
    \ next_seen = chars.cloned().chain(s1.chars());\n   |                        \
    \                  ^^^^^ method cannot be called on `Cloned<std::iter::Chain<Chars<'_>,\
    \ Chars<'_>>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<std::iter::Chain<Chars<'_>, Chars<'_>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::iter::Chain<Chars<'_>,\
    \ Chars<'_>>>: Iterator`\n           `Cloned<std::iter::Chain<Chars<'_>, Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<std::iter::Chain<Chars<'_>,\
    \ Chars<'_>>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    if s0.len() != s1.len() {\n        return\
    \ false;\n    }\n    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)\n}\n\nfn\
    \ main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv7ow9bi6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1_idx = 0;\n    let mut s0_idx =\
    \ 0;\n    while s0_idx < s0.len() && s1_idx < s1.len() {\n        if s0[s0_idx]\
    \ != s1[s1_idx] {\n            break;\n        }\n        s0_idx += 1;\n     \
    \   s1_idx += 1;\n    }\n    s0_idx == s0.len() && s1_idx == s1.len()\n}\n\nfn\
    \ main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx0mwllyi.rs:18:12\n\
    \   |\n18 |         if s0[s0_idx] != s1[s1_idx] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx0mwllyi.rs:18:26\n   |\n18 |         if s0[s0_idx] != s1[s1_idx]\
    \ {\n   |                          ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4n07o9_i.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut t = 0;\n    for (c1, c2) in s0.chars().zip(s1.chars())\
    \ {\n        if c1 != c2 {\n            return false;\n        }\n        t +=\
    \ 1;\n    }\n    t == 0\n}\n\nfn main() {\n    let candidate = same_chars;\n \
    \   assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp6q5hblv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(c0, c1)|\
    \ c0 == c1)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfljlzw6j.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut chars = chars::HashMap::new();\n\
    \    let mut char_iter1 = s0.chars().enumerate() + s1.chars().enumerate();\n \
    \   let mut char_iter2 = s0.chars().enumerate().chain(s1.chars().enumerate());\n\
    \    while char_iter1.any() || char_iter2.any() {\n        if char_iter1.any()\
    \ {\n            if let Some((i1, ch)) = char_iter1.next() {\n               \
    \ if !char_iter2.any() {\n                    return false;\n                }\n\
    \                let i2 = char_iter2.next().unwrap();\n                chars.insert(i1,\
    \ i2, ch);\n            }\n        } else {\n            if let Some((i2, ch))\
    \ = char_iter2.next() {\n                if !char_iter1.any() {\n            \
    \        return false;\n                }\n                let i1 = char_iter1.next().unwrap();\n\
    \                chars.insert(i2, i1, ch);\n            }\n        }\n    }\n\
    \    chars.is_empty()\n}\n\nfn main() {\n    let candidate = same_chars;\n   \
    \ assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\"\
    )), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"\
    dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"\
    dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpf70qi3jz.rs:15:28\n   |\n15 |     let mut chars = chars::HashMap::new();\n\
    \   |                            ^^^^^^^ not found in `chars`\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\nhelp:\
    \ if you import `HashMap`, refer to it directly\n   |\n15 -     let mut chars\
    \ = chars::HashMap::new();\n15 +     let mut chars = HashMap::new();\n   | \n\n\
    error[E0369]: cannot add `Enumerate<Chars<'_>>` to `Enumerate<Chars<'_>>`\n  -->\
    \ /tmp/tmpf70qi3jz.rs:16:49\n   |\n16 |     let mut char_iter1 = s0.chars().enumerate()\
    \ + s1.chars().enumerate();\n   |                          ----------------------\
    \ ^ ---------------------- Enumerate<Chars<'_>>\n   |                        \
    \  |\n   |                          Enumerate<Chars<'_>>\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpf70qi3jz.rs:18:42\n\
    \     |\n18   |     while char_iter1.any() || char_iter2.any() {\n     |     \
    \                                     ^^^- supplied 0 arguments\n     |      \
    \                                    |\n     |                               \
    \           expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpf70qi3jz.rs:21:32\n     |\n21   |                 if !char_iter2.any()\
    \ {\n     |                                ^^^- supplied 0 arguments\n     | \
    \                               |\n     |                                expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0369,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (a\
    \ == b) || (a < b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph4ebd2xi.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz7vy69gt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9y_xka8g.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    use std::mem::replace;\n    if s0.len() !=\
    \ s1.len() {\n        return false;\n    }\n\n    let mut char_counter: usize\
    \ = 0;\n    let mut byte_counter: usize = 0;\n    let mut byte_counter: usize\
    \ = 0;\n    let mut previous_byte: u8 = 0;\n    for ch in s0.chars() {\n     \
    \   if char_counter == 0 {\n            if ch != previous_byte {\n           \
    \     return false;\n            }\n        } else {\n            if ch != s1[byte_counter]\
    \ {\n                return false;\n            }\n        }\n        byte_counter\
    \ += 1;\n        char_counter += 1;\n        previous_byte = ch;\n    }\n    byte_counter\
    \ < s1.len()\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::mem::replace`\n  --> /tmp/tmp9n9bvif3.rs:15:9\n\
    \   |\n15 |     use std::mem::replace;\n   |         ^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9n9bvif3.rs:26:22\n   |\n26 |             if ch != previous_byte\
    \ {\n   |                      ^^^^^^^^^^^^^ expected `char`, found `u8`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9n9bvif3.rs:30:22\n\
    \   |\n30 |             if ch != s1[byte_counter] {\n   |                    \
    \  ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9n9bvif3.rs:36:25\n\
    \   |\n23 |     let mut previous_byte: u8 = 0;\n   |                         \
    \   -- expected due to this type\n...\n36 |         previous_byte = ch;\n   |\
    \                         ^^ expected `u8`, found `char`\n\nerror: aborting due\
    \ to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let len = s0.len();\n    let mut i = 0;\n\
    \    while i < len {\n        let c0 = s0.chars().nth(i).unwrap();\n        let\
    \ c1 = s1.chars().nth(i).unwrap();\n        if c0 != c1 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpep9z8ou1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(mut a, _)|\
    \ a == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpj0kw_hwn.rs:15:54\n\
    \   |\n15 |     s0.chars().zip(s1.chars()).all(|(mut a, _)| a == b)\n   |    \
    \                                                  ^ help: a local variable with\
    \ a similar name exists: `a`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut chars = String::new();\n    s0.chars().for_each(|c|\
    \ *chars.push(c));\n    s1.chars().for_each(|c| *chars.push(c));\n    if chars\
    \ == s0 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `()` cannot be dereferenced\n  --> /tmp/tmpogxoyy2e.rs:16:29\n\
    \   |\n16 |     s0.chars().for_each(|c| *chars.push(c));\n   |               \
    \              ^^^^^^^^^^^^^^\n\nerror[E0614]: type `()` cannot be dereferenced\n\
    \  --> /tmp/tmpogxoyy2e.rs:17:29\n   |\n17 |     s1.chars().for_each(|c| *chars.push(c));\n\
    \   |                             ^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s0.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_f6hgf41.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| (a\
    \ == b))\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfy_633vm.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    match (s0.chars(), s1.chars()) {\n      \
    \  (Some(c0), Some(c1)) => {\n            c0 == c1\n        }\n        _ => true,\n\
    \    }\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7dhxs4z.rs:16:10\n   |\n\
    15 |     match (s0.chars(), s1.chars()) {\n   |           ------------------------\
    \ this expression has type `(Chars<'_>, Chars<'_>)`\n16 |         (Some(c0), Some(c1))\
    \ => {\n   |          ^^^^^^^^ expected struct `Chars`, found enum `Option`\n\
    \   |\n   = note: expected struct `Chars<'_>`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph7dhxs4z.rs:16:20\n   |\n15 |\
    \     match (s0.chars(), s1.chars()) {\n   |           ------------------------\
    \ this expression has type `(Chars<'_>, Chars<'_>)`\n16 |         (Some(c0), Some(c1))\
    \ => {\n   |                    ^^^^^^^^ expected struct `Chars`, found enum `Option`\n\
    \   |\n   = note: expected struct `Chars<'_>`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    let mut s1 = String::from(s1);\n    s1.chars().for_each(|c|\
    \ {\n        s0.chars().any(|c| c == c);\n    });\n    true\n}\n\nfn main() {\n\
    \    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"\
    ), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcwcgeqwl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Check if two words have the same characters.\n/// >>> same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc')\n/// True\n/// >>> same_chars('abcd', 'dddddddabc')\n\
    /// True\n/// >>> same_chars('dddddddabc', 'abcd')\n/// True\n/// >>> same_chars('eabcd',\
    \ 'dddddddabc')\n/// False\n/// >>> same_chars('abcd', 'dddddddabce')\n/// False\n\
    /// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n/// False\nfn same_chars(s0:\
    \ String, s1: String) -> bool {\n    s0.chars().zip(s1.chars()).all(|(a, b)| a\
    \ == b)\n}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
    dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
    eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
    eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
    aabb\"), String::from(\"aaccc\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1zdglbzo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
