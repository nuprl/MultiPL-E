name: HumanEval_6_parse_nested_parens
language: rust
results:
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_group_sizes\
    \ = Vec::new();\n    let mut paren_group_counts = Vec::new();\n\n    paren_string.char_indices()\n\
    \        .filter_map(|(_, c)| {\n            if c == '(' {\n                paren_group_sizes.push(paren_level);\n\
    \                paren_group_sizes.push(0);\n                paren_group_counts.push(0);\n\
    \                paren_group_counts.push(0);\n                paren_level += 1;\n\
    \            } else if c == ')' {\n                paren_group_sizes.push(paren_level);\n\
    \                paren_group_sizes.push(0);\n                paren_group_counts.push(0);\n\
    \                paren_group_counts.push(0);\n                if paren_level >\
    \ 0 {\n                    paren_level -= 1;\n                } else {\n     \
    \               paren_group_counts.push((paren_group_sizes.len() as usize) - ((paren_group_counts.pop()\
    \ as usize) + 1));\n                }\n            }\n\n            if paren_level\
    \ == 0 {\n                None\n            } else {\n                let mut\
    \ i = 0;\n                while i < paren_group_sizes.len() {\n              \
    \      if paren_group_sizes[i] == paren_group_sizes[i + 1] {\n               \
    \         i += 1;\n                    } else {\n                        break;\n\
    \                    }\n                }\n                Some(i + paren_group_sizes.len()\
    \ as usize)\n            }\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmp9bee_4vh.rs:45:10\n     |\n45\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0605]: non-primitive cast: `Option<usize>` as `usize`\n\
    \  --> /tmp/tmp9bee_4vh.rs:27:83\n   |\n27 |                     paren_group_counts.push((paren_group_sizes.len()\
    \ as usize) - ((paren_group_counts.pop() as usize) + 1));\n   |              \
    \                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_string = paren_string.trim();\n    paren_string\
    \ = paren_string.chars().take(paren_string.len()).collect();\n\n    let mut max_depth\
    \ = 0;\n    let mut max_level = -1;\n    let mut i = 0;\n    while i < paren_string.len()\
    \ {\n        match paren_string[i] {\n            '(' | '[' => {\n           \
    \     max_level = std::cmp::max(max_level, (i - 1) - max_depth);\n           \
    \     max_depth = i - 1;\n            }\n            '(' | '[' | ')' => {\n  \
    \              max_depth = std::cmp::max(max_depth, i - 1 - max_level);\n    \
    \        }\n            '(' | ')' => {\n                max_depth = std::cmp::max(max_depth,\
    \ i - 1);\n            }\n            _ => {}\n        }\n        i += 1;\n  \
    \  }\n    Vec::from(max_level + 1)\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpy41lwcmn.rs:8:66\n     |\n8    |  \
    \   paren_string = paren_string.chars().take(paren_string.len()).collect();\n\
    \     |                                                                  ^^^^^^^\
    \ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpy41lwcmn.rs:14:15\n\
    \   |\n14 |         match paren_string[i] {\n   |               ^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpy41lwcmn.rs:11:25\n   |\n11 |     let mut max_level\
    \ = -1;\n   |                         ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `Vec<_, _>: From<usize>`\
    \ is not satisfied\n  --> /tmp/tmpy41lwcmn.rs:29:5\n   |\n29 |     Vec::from(max_level\
    \ + 1)\n   |     ^^^^^^^^^ the trait `From<usize>` is not implemented for `Vec<_,\
    \ _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = paren_string.chars().map(|c| c).count();\n\
    \    let mut nesting_level = 0;\n    let mut current_paren = 0;\n    let mut depth\
    \ = 0;\n    let mut group: Vec<isize> = vec![];\n    while paren_count > 0 {\n\
    \        if paren_count > 1 { // there are multiple groups for this level of parens\n\
    \            let mut current_group: Vec<isize> = vec![];\n            for i in\
    \ 0..paren_count {\n                if paren_count == 1 {\n                  \
    \  current_group.push(i); //push the level into the current group\n          \
    \      } else {\n                    if paren_count == 2 {\n                 \
    \       if current_paren == i {\n                            current_group.push(i);\
    \ //push the level into the current group\n                        }\n       \
    \             } else {\n                        if current_paren == i {\n    \
    \                        current_group.push(i); //push the level into the current\
    \ group\n                        } else if current_paren != i {\n            \
    \                current_group.push(i); //push the level into the current group\n\
    \                        }\n                    }\n                }\n       \
    \         paren_count -= 1;\n            }\n            group.extend(current_group);\n\
    \        }\n        if paren_count == 1 {\n            nesting_level = group.len();\n\
    \        } else {\n            current_paren = group.len();\n            nesting_level\
    \ = group.len();\n        }\n        group.clear();\n        paren_count -= 1;\n\
    \        depth += 1;\n    }\n    depth\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp88koa_uj.rs:17:40\n   |\n\
    17 |                     current_group.push(i); //push the level into the current\
    \ group\n   |                                        ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |                     current_group.push(i.try_into().unwrap());\
    \ //push the level into the current group\n   |                              \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp88koa_uj.rs:21:48\n\
    \   |\n21 | ...                   current_group.push(i); //push the level into\
    \ the current group\n   |                                          ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |                   \
    \          current_group.push(i.try_into().unwrap()); //push the level into the\
    \ current group\n   |                                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp88koa_uj.rs:25:48\n   |\n25 |\
    \ ...                   current_group.push(i); //push the level into the current\
    \ group\n   |                                          ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |                             current_group.push(i.try_into().unwrap());\
    \ //push the level into the current group\n   |                              \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp88koa_uj.rs:27:48\n   |\n27 | ...                   current_group.push(i);\
    \ //push the level into the current group\n   |                              \
    \            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n27\
    \ |                             current_group.push(i.try_into().unwrap()); //push\
    \ the level into the current group\n   |                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars().filter_map(|c| {\n        if c ==\
    \ '(' {\n            1\n        } else if c == ')' {\n            0\n        }\
    \ else {\n            -1\n        }\n    })\n    .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprjxsnah9.rs:9:13\n  |\n9 |\
    \             1\n  |             ^ expected enum `Option`, found integer\n  |\n\
    \  = note: expected enum `Option<_>`\n             found type `{integer}`\nhelp:\
    \ try wrapping the expression in `Some`\n  |\n9 |             Some(1)\n  |   \
    \          +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjxsnah9.rs:11:13\n\
    \   |\n11 |             0\n   |             ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n11 |             Some(0)\n\
    \   |             +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjxsnah9.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `Option`, found\
    \ integer\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |       \
    \      Some(-1)\n   |             +++++  +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = vec![];\n    paren_string.split(' ').each(|s|\
    \ {\n        match s {\n            \"(\" => {\n                result.push(1)\n\
    \            }\n            \"{\" => {\n                result.push(2)\n     \
    \       }\n            \"[\" => {\n                result.push(3)\n          \
    \  }\n            _ => {\n                result.push(0)\n            }\n    \
    \    }\n    })\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `result`\n  --> /tmp/tmpc47du34v.rs:23:7\n \
    \  |\n23 |     })\n   |       ^ help: add `;` here\n24 |     result\n   |    \
    \ ------ unexpected token\n\nerror[E0599]: no method named `each` found for struct\
    \ `std::str::Split` in the current scope\n --> /tmp/tmpc47du34v.rs:8:29\n  |\n\
    8 |     paren_string.split(' ').each(|s| {\n  |                             ^^^^\
    \ method not found in `std::str::Split<'_, char>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // 'n' is how many opening parens have been found in the\
    \ input\n    // 'i' is how many nested levels have been found in the input\n \
    \   let mut n = 0;\n    let mut i = 0;\n    let mut paren_depth = 0;\n    let\
    \ mut paren_stack = Vec::new();\n\n    for ch in paren_string.chars() {\n    \
    \    paren_stack.resize(paren_depth, 0);\n\n        // 'n' is the number of opening\
    \ parentheses we encounter so far.\n        // If it's equal to 'i', we found\
    \ a closing parenthesis, so we increment 'i'.\n        // If it reaches 0, we\
    \ found a closing parenthesis without opening one.\n        // 'paren_depth' is\
    \ the number of nesting levels of parenthesis that we encounter so far.\n    \
    \    // If we encounter a '(' with 'paren_depth' equal to 'i', we encountered\
    \ a closing parenthesis\n        // without an opening one, so we increment 'paren_depth'\
    \ to 1.\n        // If we encounter a closing parenthesis and do not have an opening\
    \ one already,\n        // we increase 'paren_depth' to 0, and push parentheses\
    \ onto the stack.\n        //\n        // If 'paren_depth' is 1 when we encounter\
    \ an opening parenthesis, we increase 'n'.\n        if paren_depth == i {\n  \
    \          i += 1;\n        } else if paren_depth == 0 {\n            paren_depth\
    \ += 1;\n            paren_stack.push(1);\n        } else if paren_depth == 1\
    \ {\n            n += 1;\n        }\n\n        if ch == '(' {\n            paren_stack.push(0);\n\
    \        } else if ch == ')' {\n            paren_depth -= 1;\n            paren_stack.push(paren_depth);\n\
    \        }\n    }\n    if paren_depth > 0 {\n        panic!(\"Unmatched closing\
    \ parenthesis while parsing nested parens\");\n    }\n    paren_stack\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3lqrvm3k.rs:46:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n46 |     paren_stack\n   |     ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut level = 0;\n    let\
    \ mut current_level = 0;\n    let mut paren_count = 0;\n    let mut open_paren_index:\
    \ usize = 0;\n    let mut char_iter = paren_string.char_indices().rev();\n\n \
    \   for paren in char_iter.by_ref() {\n        open_paren_index += paren.1;\n\n\
    \        if open_paren_index == paren_string.len() {\n            break;\n   \
    \     }\n\n        if paren_count > max_level {\n            max_level = paren_count;\n\
    \        }\n\n        level = open_paren_index - paren.1;\n        char_iter.next_back();\n\
    \        paren_count = level;\n\n        current_level += 1;\n    }\n\n    vec![current_level\
    \ + max_level]\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `char` to `usize`\n  --> /tmp/tmpmxzjcojt.rs:15:26\n\
    \   |\n15 |         open_paren_index += paren.1;\n   |                       \
    \   ^^ no implementation for `usize += char`\n   |\n   = help: the trait `AddAssign<char>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0277]: cannot subtract `char` from `usize`\n\
    \  --> /tmp/tmpmxzjcojt.rs:25:34\n   |\n25 |         level = open_paren_index\
    \ - paren.1;\n   |                                  ^ no implementation for `usize\
    \ - char`\n   |\n   = help: the trait `Sub<char>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 1; // number of opening brackets\n    let\
    \ mut pos = 0; // position of opening bracket\n    let mut open_paren_groups =\
    \ 0; // number of opening paren groups currently in paren string for this level\n\
    \    let mut cur_open_paren_groups = open_paren_groups;\n\n    // If `pos` is\
    \ at the end of the string, return an empty string\n    if paren_string[pos] ==\
    \ '(' {\n        return vec![];\n    }\n\n    // Iterate through the paren string,\
    \ keeping track of nesting level\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            open_paren_groups += 1;\n        } else\
    \ if c == ')' {\n            open_paren_groups -= 1;\n            if open_paren_groups\
    \ == 0 {\n                level += 1;\n            }\n        } else if c == '{'\
    \ {\n            level += 1;\n        } else if c == '}' {\n            level\
    \ -= 1;\n            if level < 0 {\n                return vec![];\n        \
    \    }\n        } else {\n            if open_paren_groups != 0 {\n          \
    \      return vec![];\n            }\n        }\n        pos += 1;\n    }\n\n\
    \    // If `pos` is at the end of the string, return an empty string\n    if paren_string[pos]\
    \ == ')' {\n        return vec![];\n    }\n\n    vec![level]\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpvdw9vc1k.rs:13:8\n   |\n13 |     if paren_string[pos] == '(' {\n   |\
    \        ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n \
    \  = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpvdw9vc1k.rs:42:8\n   |\n42 |     if paren_string[pos] == ')' {\n\
    \   |        ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .map(|c| c.to_digit(10).unwrap_or(0))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `u32`\n    --> /tmp/tmpxmq3q5sr.rs:10:10\n     |\n10 \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=u32>`\n     |\n     = help: the trait\
    \ `FromIterator<u32>` is not implemented for `Vec<isize>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count: isize = 0;\n    for ch in paren_string.chars()\
    \ {\n        if ch == ')' {\n            paren_count = paren_count - 1;\n    \
    \    } else if ch == '(' {\n            paren_count = paren_count + 1;\n     \
    \   } else {\n            // This char should be the closing paren we see.\n \
    \           return vec![paren_count];\n        }\n    }\n    // If we reach the\
    \ end of the string, return an empty vector.\n    vec![]\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp7yu5lwef.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parentheses = paren_string.chars().enumerate().filter(|&(_,\
    \ c)| c == '(' || c == '[' || c == '{');\n    parentheses.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \    let mut depth = 0;\n    let mut max_depth = 0;\n    for (_, (_, c)) in &parentheses\
    \ {\n        if c == '(' {\n            depth += 1;\n        }\n        if c ==\
    \ '[' {\n            depth += 1;\n        }\n        if c == '{' {\n         \
    \   depth += 1;\n        }\n        if c == '}' {\n            depth -= 1;\n \
    \       }\n        if depth > max_depth {\n            max_depth = depth;\n  \
    \      }\n    }\n    Vec::from(max_depth..)\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Filter` in the\
    \ current scope\n --> /tmp/tmpe6k_eqvy.rs:8:17\n  |\n8 |     parentheses.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n  |                 ^^^^^^^ method not found in `Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpe6k_eqvy.rs:7:67: 7:109]>`\n\nerror[E0277]: `&Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpe6k_eqvy.rs:7:67: 7:109]>` is not an iterator\n  --> /tmp/tmpe6k_eqvy.rs:11:24\n\
    \   |\n11 |     for (_, (_, c)) in &parentheses {\n   |                      \
    \  -^^^^^^^^^^^\n   |                        |\n   |                        `&Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpe6k_eqvy.rs:7:67: 7:109]>` is not an iterator\n   |       \
    \                 help: consider removing the leading `&`-reference\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `&Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpe6k_eqvy.rs:7:67: 7:109]>`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpe6k_eqvy.rs:7:67: 7:109]>`\n\nerror[E0277]: the trait bound\
    \ `Vec<_, _>: From<RangeFrom<{integer}>>` is not satisfied\n  --> /tmp/tmpe6k_eqvy.rs:28:5\n\
    \   |\n28 |     Vec::from(max_depth..)\n   |     ^^^^^^^^^ the trait `From<RangeFrom<{integer}>>`\
    \ is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n\
    \             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n\
    \             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n\
    \             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T;\
    \ N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = paren_string.chars().map(|c| c.to_digit(10)).collect::<Vec<_>>();\n\
    \    let mut level = 0;\n    for (i, char) in paren_string.chars().enumerate()\
    \ {\n        if char == '(' {\n            level += 1;\n            levels.push(level);\n\
    \        }\n        if char == ')' {\n            if level == 0 {\n          \
    \      panic!(\"Nested parenthesis in wrong place\");\n            }\n       \
    \     level -= 1;\n            levels.push(level);\n        }\n    }\n    levels.sort_unstable();\n\
    \    levels.reverse();\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9wgkv43.rs:12:25\n   |\n\
    12 |             levels.push(level);\n   |                         ^^^^^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<u32>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |             levels.push(Some(level));\n   |                      \
    \   +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt9wgkv43.rs:19:25\n\
    \   |\n19 |             levels.push(level);\n   |                         ^^^^^\
    \ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<u32>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |             levels.push(Some(level));\n   |                      \
    \   +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt9wgkv43.rs:24:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n24 |     levels\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<u32>>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting = 1; // level 1 parenthesis\n    let mut\
    \ current_level = 1; // level 1 parenthesis\n\n    let mut result = vec![]; //\
    \ result of the grouping\n    for paren in paren_string.chars() {\n        if\
    \ paren == '(' {\n            if nesting > current_level {\n                current_level\
    \ = nesting;\n            }\n            nesting += 1;\n            result.push(current_level);\n\
    \        } else if paren == ')' {\n            nesting -= 1;\n            if nesting\
    \ == 1 {\n                current_level = result.last().unwrap_or(0);\n      \
    \      }\n        } else {\n            if nesting > 1 {\n                current_level\
    \ = nesting;\n            }\n            result.push(current_level);\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv100l8cq.rs:21:57\n   |\n\
    21 |                 current_level = result.last().unwrap_or(0);\n   |       \
    \                                                  ^\n   |                   \
    \                                      |\n   |                               \
    \                          expected `&{integer}`, found integer\n   |        \
    \                                                 help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv100l8cq.rs:21:33\n  \
    \ |\n8  |     let mut current_level = 1; // level 1 parenthesis\n   |        \
    \                     - expected due to this value\n...\n21 |                \
    \ current_level = result.last().unwrap_or(0);\n   |                          \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&{integer}`\n   |\n\
    help: consider dereferencing the borrow\n   |\n21 |                 current_level\
    \ = *result.last().unwrap_or(0);\n   |                                 +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 1;\n    let mut paren_stack = Vec::new();\n\
    \    for ch in paren_string.chars() {\n        if ch == ')' {\n            if\
    \ paren_stack.len() >= level {\n                paren_stack.pop();\n         \
    \   }\n            level -= 1;\n        } else if ch == '(' {\n            if\
    \ paren_stack.len() < level {\n                paren_stack.push(level);\n    \
    \        }\n            level += 1;\n        } else {\n            if paren_stack.len()\
    \ > 0 {\n                paren_stack.pop();\n            }\n        }\n    }\n\
    \    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpri9nnfgk.rs:26:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     paren_stack\n   |     ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting = 0;\n    let mut max_nesting = 1;\n  \
    \  let mut parens: Vec<isize> = vec![];\n    for ch in paren_string.chars() {\n\
    \        if ch == '(' {\n            nesting++;\n            parens.push(nesting);\n\
    \        } else if ch == ')' {\n            nesting--;\n            parens.remove(nesting);\n\
    \        } else {\n            parens.push(nesting);\n            max_nesting\
    \ = std::cmp::max(nesting, max_nesting);\n        }\n    }\n\n    parens\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpc2qvvlj_.rs:12:20\n\
    \   |\n12 |             nesting++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n12 |             { let tmp =\
    \ nesting; nesting += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    12 -             nesting++;\n12 +             nesting += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmpc2qvvlj_.rs:15:22\n   |\n15 |         \
    \    nesting--;\n   |                      ^ expected expression\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = 0;\n    let mut group = 0;\n    let mut\
    \ parens_depth = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            parens_depth++;\n        } else if c == ')' {\n            parens_depth--;\n\
    \            if parens_depth == 0 {\n                group++;\n            }\n\
    \        }\n\n        if parens_depth > levels {\n            levels = parens_depth;\n\
    \        }\n    }\n\n    levels.max() + group.max() + 1\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7l1_3f_3.rs:12:25\n\
    \   |\n12 |             parens_depth++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n12 |         \
    \    { let tmp = parens_depth; parens_depth += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n12 -             parens_depth++;\n12\
    \ +             parens_depth += 1;\n   | \n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmp7l1_3f_3.rs:14:27\n   |\n14 |             parens_depth--;\n\
    \   |                           ^ expected expression\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp7l1_3f_3.rs:25:12\n\
    \    |\n25  |     levels.max() + group.max() + 1\n    |            ^^^- supplied\
    \ 0 arguments\n    |            |\n    |            expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmp7l1_3f_3.rs:25:26\n \
    \   |\n25  |     levels.max() + group.max() + 1\n    |                       \
    \   ^^^- supplied 0 arguments\n    |                          |\n    |       \
    \                   expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7l1_3f_3.rs:25:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     levels.max() + group.max() + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `{integer}`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![0];\n\n    for parens in paren_string.split(\"\
    \ \") {\n        if parens == \"()\" || parens == \"()()\" {\n            levels.push(0);\n\
    \        } else if parens == \"()()()\" {\n            levels.push(1);\n     \
    \   } else {\n            levels.push(levels.last().unwrap() + 1);\n        }\n\
    \    }\n\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 0, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmptmfrnyki.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups = paren_string.split_whitespace();\n\
    \n    paren_groups.pop_back();\n\n    let mut level = 0;\n    paren_groups.retain(|&x|\
    \ {\n        if x == '(' {\n            level += 1;\n        } else if x == ')'\
    \ {\n            level -= 1;\n        }\n\n        level > 0\n    });\n\n    paren_groups.retain(|&x|\
    \ {\n        level > 0\n    });\n\n    paren_groups.pop_back();\n\n    let mut\
    \ result = vec![];\n    for i in paren_groups {\n        if i == ')' {\n     \
    \       result.push(level);\n            level = 0;\n        } else {\n      \
    \      level += 1;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop_back` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpog5bs_b9.rs:9:18\n  |\n9 |     paren_groups.pop_back();\n\
    \  |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `retain` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpog5bs_b9.rs:12:18\n   |\n12 |     paren_groups.retain(|&x| {\n\
    \   |                  ^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `retain` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpog5bs_b9.rs:22:18\n   |\n22 |     paren_groups.retain(|&x| {\n\
    \   |                  ^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `SplitWhitespace` in the current\
    \ scope\n  --> /tmp/tmpog5bs_b9.rs:26:18\n   |\n26 |     paren_groups.pop_back();\n\
    \   |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpog5bs_b9.rs:30:14\n\
    \   |\n30 |         if i == ')' {\n   |              ^^ no implementation for\
    \ `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .into_iter()\n        .enumerate()\n\
    \        .map(|(i, s)| (i, s.len()))\n        .filter_map(|(i, len)| {\n     \
    \       let mut nesting_level = 1usize;\n            if len > 1 {\n          \
    \      for d in 0..(len) {\n                    if s[i] == s[d] {\n          \
    \              nesting_level += 1;\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \            Some(nesting_level)\n        })\n        .max()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmpv59jukvj.rs:15:24\n\
    \   |\n15 |                     if s[i] == s[d] {\n   |                      \
    \  ^ help: a local variable with a similar name exists: `d`\n\nerror[E0425]: cannot\
    \ find value `s` in this scope\n  --> /tmp/tmpv59jukvj.rs:15:32\n   |\n15 |  \
    \                   if s[i] == s[d] {\n   |                                ^ help:\
    \ a local variable with a similar name exists: `d`\n\nerror[E0599]: the method\
    \ `into_iter` exists for struct `String`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmpv59jukvj.rs:8:10\n    |\n8   |           .into_iter()\n    | \
    \           ^^^^^^^^^\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `String: Iterator`\n            which is required by\
    \ `String: IntoIterator`\n            `&String: Iterator`\n            which is\
    \ required by `&String: IntoIterator`\n            `&mut String: Iterator`\n \
    \           which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level: isize = 0;\n    let mut nested: Vec<isize>\
    \ = vec![0; paren_string.len()];\n    for i in paren_string.chars().filter_map(|c|\
    \ match c {\n        '(' => true,\n        _ => false,\n    }) {\n        if !nested\
    \ {\n            nested[level] = i;\n        }\n        if c != '(' { level +=\
    \ 1 } else if level == nested.len() - 1 && level > 0 {\n            level -= 1;\n\
    \            nested[level] = i;\n        }\n    }\n    return nested\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp9kkspzcz.rs:16:12\n\
    \   |\n16 |         if c != '(' { level += 1 } else if level == nested.len() -\
    \ 1 && level > 0 {\n   |            ^ help: a local variable with a similar name\
    \ exists: `i`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9kkspzcz.rs:10:16\n\
    \   |\n10 |         '(' => true,\n   |                ^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n10 |       \
    \  '(' => Some(true),\n   |                +++++    +\n\nerror[E0600]: cannot\
    \ apply unary operator `!` to type `Vec<isize>`\n  --> /tmp/tmp9kkspzcz.rs:13:12\n\
    \   |\n13 |         if !nested {\n   |            ^^^^^^^ cannot apply unary operator\
    \ `!`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp9kkspzcz.rs:14:13\n   |\n14 |             nested[level] = i;\n   | \
    \            ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9kkspzcz.rs:16:53\n   |\n16 |\
    \         if c != '(' { level += 1 } else if level == nested.len() - 1 && level\
    \ > 0 {\n   |                                                     ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |         if\
    \ c != '(' { level += 1 } else if level == (nested.len() - 1).try_into().unwrap()\
    \ && level > 0 {\n   |                                                     + \
    \               +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp9kkspzcz.rs:18:13\n   |\n18 |         \
    \    nested[level] = i;\n   |             ^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = hel"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<usize> = vec![];\n    for paren in paren_string.split('\
    \ ').into_iter().flat_map(|c| {\n        if c == '(' || c == ')' {\n         \
    \   stack.push(paren);\n        }\n        if c == ')' {\n            stack.pop();\n\
    \        }\n        stack\n    }) {\n        stack.push(paren);\n    }\n\n   \
    \ stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `paren` in this scope\n  --> /tmp/tmpxkdkisa1.rs:10:24\n\
    \   |\n10 |             stack.push(paren);\n   |                        ^^^^^\
    \ not found in this scope\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \ --> /tmp/tmpxkdkisa1.rs:9:14\n  |\n9 |         if c == '(' || c == ')' {\n \
    \ |              ^^ no implementation for `&str == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&str`\n  = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n            <&'a str as PartialEq<OsString>>\n\
    \            <&'a str as PartialEq<String>>\n            <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<&'a str>>\n            <String as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<str>>\n            <String as PartialEq>\n\
    \            <str as PartialEq<Cow<'a, str>>>\n          and 4 others\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n --> /tmp/tmpxkdkisa1.rs:9:26\n  |\n9 |  \
    \       if c == '(' || c == ')' {\n  |                          ^^ no implementation\
    \ for `&str == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmpxkdkisa1.rs:12:14\n   |\n12 |         if c == ')' {\n   |     \
    \         ^^ no implementation for `&str == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level: isize = 0;\n    let mut paren_level: isize\
    \ = 0;\n    let mut paren_count: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_level += 1;\n            paren_count\
    \ += 1;\n        } else if c == ')' {\n            paren_count -= 1;\n       \
    \     if paren_count < 0 {\n                level = paren_level;\n           \
    \     break;\n            }\n        } else {\n            paren_level += 1;\n\
    \            paren_count += 1;\n        }\n    }\n    level\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx_5ca8qi.rs:25:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     level\n   |     ^^^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level: usize = 0;\n    let mut paren_levels:\
    \ Vec<usize> = vec![paren_level];\n    let mut paren_groups: Vec<Vec<usize>> =\
    \ vec![vec![]];\n    let mut paren_group_len: usize = 0;\n\n    for paren in paren_string.chars()\
    \ {\n        if paren == ')' {\n            paren_group_len += 1;\n          \
    \  paren_level -= 1;\n            if paren_level == 0 {\n                paren_levels.push(paren_group_len);\n\
    \                paren_groups.push(vec![paren_group_len]);\n            }\n  \
    \          continue;\n        }\n\n        if paren == '(' {\n            paren_level\
    \ += 1;\n            paren_group_len += 1;\n            paren_groups.push(vec![paren_group_len]);\n\
    \        }\n\n        if paren_groups[paren_groups.len() - 1].len() < paren_group_len\
    \ {\n            paren_groups[paren_groups.len() - 1].push(paren_group_len);\n\
    \        }\n\n        paren_levels[paren_level - 1] += 1;\n    }\n\n    if paren_groups[paren_groups.len()\
    \ - 1].len() > 0 {\n        paren_groups[paren_groups.len() - 1]\n    } else {\n\
    \        vec![]\n    }\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp34lsmyr8.rs:37:9\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |         paren_groups[paren_groups.len() - 1]\n   |\
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split(' ').filter(|x| !x.is_empty()).map(|x|\
    \ {\n        let mut i = 0;\n        let mut level = 0;\n        for c in x.chars()\
    \ {\n            if c == '(' {\n                level += 1;\n            } else\
    \ if c == ')' {\n                level -= 1;\n            } else if level == 0\
    \ && c == '(' {\n                i += 1;\n            }\n        }\n        i\n\
    \    })\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4v045xxy.rs:7:5\n   |\n6\
    \  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |    \
    \                                               ---------- expected `Vec<isize>`\
    \ because of return type\n7  | /     paren_string.split(' ').filter(|x| !x.is_empty()).map(|x|\
    \ {\n8  | |         let mut i = 0;\n9  | |         let mut level = 0;\n10 | |\
    \         for c in x.chars() {\n...  |\n19 | |         i\n20 | |     })\n   |\
    \ |______^ expected struct `Vec`, found struct `Map`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Map<Filter<std::str::Split<'_,\
    \ char>, [closure@/tmp/tmp4v045xxy.rs:7:36: 7:53]>, [closure@/tmp/tmp4v045xxy.rs:7:59:\
    \ 20:6]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut open_brackets = Vec::with_capacity(paren_string.len());\n\
    \    let mut close_brackets = Vec::with_capacity(paren_string.len());\n    let\
    \ mut depth: isize = 0;\n\n    for group in paren_string.split(\" \") {\n    \
    \    let mut group_depth = 1;\n        for bracket in group.chars().filter(|&c|\
    \ c == '(' || c == '{' || c == '[') {\n            open_brackets.push(bracket);\n\
    \            group_depth += 1;\n        }\n\n        for bracket in group.chars().filter(|&c|\
    \ c == '}' || c == ']') {\n            close_brackets.push(bracket);\n       \
    \     group_depth += 1;\n        }\n\n        depth = std::cmp::max(depth, group_depth);\n\
    \    }\n\n    // if depth exceeds depth limit, return early\n    if depth >= MAX_DEPTH\
    \ {\n        return vec![0];\n    }\n\n    // if there are brackets left but not\
    \ closed, return early\n    if open_brackets.len() != paren_string.len() && open_brackets.len()\
    \ != 1 {\n        return vec![0];\n    }\n\n    depth\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_DEPTH` in this scope\n  --> /tmp/tmpj12c3cz0.rs:27:17\n\
    \   |\n27 |     if depth >= MAX_DEPTH {\n   |                 ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj12c3cz0.rs:36:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n36 |     depth\n   |     ^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.trim();\n    if paren_string.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut paren_chars = paren_string.chars();\n\
    \    let mut paren_count = 0;\n    let mut opening_paren_levels = vec![];\n  \
    \  let mut nesting_levels = vec![];\n    let mut level_count = vec![0isize; 32];\n\
    \    let mut paren_levels = 0;\n    let mut opening_parens = false;\n    for paren_char\
    \ in paren_chars {\n        paren_char.as_str();\n        if paren_char == '('\
    \ {\n            opening_parens = true;\n            paren_count = level_count[paren_char\
    \ as char];\n            if paren_count > 0 {\n                opening_paren_levels.push(paren_levels);\n\
    \            }\n            paren_count = 1;\n            paren_levels++;\n  \
    \      } else if paren_char == ')' {\n            opening_parens = false;\n  \
    \          paren_count--;\n            if paren_count > 0 {\n                level_count[paren_char\
    \ as char] = paren_count;\n            }\n            paren_levels--;\n      \
    \  } else {\n            if opening_parens {\n                level_count[paren_char\
    \ as char] += paren_count;\n            }\n        }\n    }\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_rbvdja5.rs:27:25\n\
    \   |\n27 |             paren_levels++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |         \
    \    { let tmp = paren_levels; paren_levels += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n27 -             paren_levels++;\n27\
    \ +             paren_levels += 1;\n   | \n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmp_rbvdja5.rs:30:26\n   |\n30 |             paren_count--;\n\
    \   |                          ^ expected expression\n\nerror[E0599]: no method\
    \ named `as_str` found for type `char` in the current scope\n  --> /tmp/tmp_rbvdja5.rs:19:20\n\
    \   |\n19 |         paren_char.as_str();\n   |                    ^^^^^^ method\
    \ not found in `char`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `char`\n  --> /tmp/tmp_rbvdja5.rs:22:27\n   |\n22 |             paren_count\
    \ = level_count[paren_char as char];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<isize>`\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `char`\n  --> /tmp/tmp_rbvdja5.rs:37:17\n\
    \   |\n37 |                 level_count[paren_char as char] += paren_count;\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `Index<char>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_rbvdja5.rs:41:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n41 |     paren_levels\n\
    \   |     ^^^^^^^^^^^^ expected struct `Vec`, found integer\n   |\n   = note:\
    \ expecte"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut parens = paren_string.char_indices().map(|(i1,\
    \ i2)| {\n        levels.push(paren_string[i1..i2].chars().filter(|c| c == '('\
    \ || c == '[').count());\n        i2\n    });\n    parens.sort_unstable_by_key(|i|\
    \ i);\n    parens.rev();\n    let mut i = 0;\n    for level in parens {\n    \
    \    i += *level;\n    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp26bjrtdg.rs:9:38\n  |\n9 |\
    \         levels.push(paren_string[i1..i2].chars().filter(|c| c == '(' || c ==\
    \ '[').count());\n  |                                      ^^ expected `usize`,\
    \ found `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp26bjrtdg.rs:9:63\n\
    \  |\n9 |         levels.push(paren_string[i1..i2].chars().filter(|c| c == '('\
    \ || c == '[').count());\n  |                                                \
    \               ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmp26bjrtdg.rs:9:75\n  |\n9 |         levels.push(paren_string[i1..i2].chars().filter(|c|\
    \ c == '(' || c == '[').count());\n  |                                       \
    \                                    ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \ = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: no\
    \ method named `sort_unstable_by_key` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmp26bjrtdg.rs:12:12\n   |\n12 |     parens.sort_unstable_by_key(|i|\
    \ i);\n   |            ^^^^^^^^^^^^^^^^^^^^ method not found in `Map<CharIndices<'_>,\
    \ [closure@/tmp/tmp26bjrtdg.rs:8:54: 11:6]>`\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp26bjrtdg.rs:16:14\n   |\n16 |         i += *level;\n\
    \   |              ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp26bjrtdg.rs:18:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n18 |     levels\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599, E0614.\nFor more informatio"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = 0\n    let mut level = 0\n    let\
    \ mut nesting_level = 0\n    let mut current_paren_count = 0\n    let mut current_level\
    \ = 0\n    let mut current_nesting_level = 0\n    for c in paren_string.chars()\
    \ {\n        let is_opening_brace = c == '('\n        if is_opening_brace {\n\
    \            level_up_parens(&mut current_level, &mut current_nesting_level, &mut\
    \ paren_count,\n                           &mut nesting_level);\n            current_level_check(&mut\
    \ current_level);\n            current_nesting_level_check(&mut current_nesting_level);\n\
    \            current_paren_count_check(&mut current_paren_count);\n        }\n\
    \        let is_closing_brace = c == ')'\n        if is_closing_brace {\n    \
    \        level_down_parens(&mut current_level, &mut current_nesting_level, &mut\
    \ paren_count,\n                             &mut nesting_level);\n          \
    \  current_level_check(&mut current_level);\n            current_nesting_level_check(&mut\
    \ current_nesting_level);\n            current_paren_count_check(&mut current_paren_count);\n\
    \        }\n        level_up_parens(&mut current_level, &mut current_nesting_level,\
    \ &mut paren_count,\n                       &mut nesting_level);\n        level_down_parens(&mut\
    \ current_level, &mut current_nesting_level, &mut paren_count,\n             \
    \           &mut nesting_level);\n        level_up_parens(&mut current_level,\
    \ &mut current_nesting_level, &mut paren_count,\n                       &mut nesting_level);\n\
    \        level_down_parens(&mut current_level, &mut current_nesting_level, &mut\
    \ paren_count,\n                        &mut nesting_level);\n        if c ==\
    \ '(' {\n            level_up_parens(&mut current_level, &mut current_nesting_level,\
    \ &mut paren_count,\n                           &mut nesting_level);\n       \
    \     current_level_check(&mut current_level);\n            current_nesting_level_check(&mut\
    \ current_nesting_level);\n            current_paren_count_check(&mut current_paren_count);\n\
    \        }\n        if c == ')' {\n            level_down_parens(&mut current_level,\
    \ &mut current_nesting_level, &mut paren_count,\n                            \
    \ &mut nesting_level);\n            current_level_check(&mut current_level);\n\
    \            current_nesting_level_check(&mut current_nesting_level);\n      \
    \      current_paren_count_check(&mu\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpo8z737ib.rs:58:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     for c in paren_string.chars() {\n   |                          \
    \         - unclosed delimiter\n...\n45 |         if c == ')' {\n   |        \
    \             - this delimiter might not be properly closed...\n...\n51 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n58 | }\n\
    \   |   ^\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpo8z737ib.rs:7:28\n\
    \  |\n7 |     let mut paren_count = 0\n  |                            ^ help:\
    \ add `;` here\n8 |     let mut level = 0\n  |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `let`\n --> /tmp/tmpo8z737ib.rs:8:22\n  |\n8 | \
    \    let mut level = 0\n  |                      ^ help: add `;` here\n9 |   \
    \  let mut nesting_level = 0\n  |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `let`\n  --> /tmp/tmpo8z737ib.rs:9:30\n   |\n9  |     let\
    \ mut nesting_level = 0\n   |                              ^ help: add `;` here\n\
    10 |     let mut current_paren_count = 0\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `let`\n  --> /tmp/tmpo8z737ib.rs:10:36\n   |\n10\
    \ |     let mut current_paren_count = 0\n   |                                \
    \    ^ help: add `;` here\n11 |     let mut current_level = 0\n   |     --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpo8z737ib.rs:11:30\n\
    \   |\n11 |     let mut current_level = 0\n   |                              ^\
    \ help: add `;` here\n12 |     let mut current_nesting_level = 0\n   |     ---\
    \ unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpo8z737ib.rs:12:38\n\
    \   |\n12 |     let mut current_nesting_level = 0\n   |                      \
    \                ^ help: add `;` here\n13 |     for c in paren_string.chars()\
    \ {\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `if`\n\
    \  --> /tmp/tmpo8z737ib.rs:14:40\n   |\n14 |         let is_ope"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = vec![];\n    let mut stack:\
    \ Vec<String> = Vec::new();\n    for paren in paren_string.chars() {\n       \
    \ let char = paren.chars().next().unwrap().unwrap();\n        if char == '(' ||\
    \ char == '[' {\n            stack = vec![String::from(paren)].into_iter().collect();\n\
    \        }\n        if char == ')' || char == ']' {\n            let mut last_str\
    \ = stack.pop().unwrap();\n            if result.len() == 0 {\n              \
    \  result.append(1);\n            }\n            let mut last_idx = result.len()\
    \ - 1;\n            let mut stack_idx = result.len() - 1;\n            while stack_idx\
    \ > 0 && stack[stack_idx - 1] == last_str {\n                stack_idx -= 1;\n\
    \            }\n            result.append(stack_idx + 1);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdv9wojpq.rs:10:26\n   |\n10 |         let char = paren.chars().next().unwrap().unwrap();\n\
    \   |                          ^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdv9wojpq.rs:17:31\n   |\n17 |              \
    \   result.append(1);\n   |                               ^ expected `&mut Vec<isize>`,\
    \ found integer\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \                           found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdv9wojpq.rs:24:27\n   |\n24 |             result.append(stack_idx\
    \ + 1);\n   |                           ^^^^^^^^^^^^^ expected `&mut Vec<isize>`,\
    \ found `usize`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \                           found type `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![0;];\n\n    let\
    \ mut char_count = 0;\n    for char in paren_string.chars() {\n        if char\
    \ == '(' {\n            paren_stack.push(0)\n        } else {\n            paren_stack.push(paren_stack.last().unwrap()\
    \ + 1);\n        }\n        if char == ')' {\n            paren_stack.pop();\n\
    \        }\n        char_count += 1;\n    }\n    paren_stack\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: unexpected end of macro invocation\n --> /tmp/tmpi5i6rxkw.rs:7:46\n\
    \  |\n7 |     let mut paren_stack: Vec<isize> = vec![0;];\n  |               \
    \                               ^ missing tokens in macro arguments\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split(' ').filter(|x| !x.is_empty()).map(|x|\
    \ x.parse().unwrap()).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmp1eob_ya_.rs:7:73\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels: Vec<isize> = Vec::new();\n\n    for\
    \ paren in paren_string.split(' ').iter() {\n        if paren.len() > 0 {\n  \
    \          let level_of_paren = paren.len();\n            if paren_levels.len()\
    \ < level_of_paren {\n                paren_levels.push(level_of_paren);\n   \
    \         } else {\n                paren_levels[paren_levels.len() - 1] += level_of_paren;\n\
    \            }\n        }\n    }\n\n    paren_levels.sort_unstable();\n\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmp8grl32vk.rs:9:42\n  |\n9 |     for paren\
    \ in paren_string.split(' ').iter() {\n  |                                   \
    \       ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8grl32vk.rs:13:35\n   |\n13 |              \
    \   paren_levels.push(level_of_paren);\n   |                                 \
    \  ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |                 paren_levels.push(level_of_paren.try_into().unwrap());\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8grl32vk.rs:15:57\n   |\n15 |  \
    \               paren_levels[paren_levels.len() - 1] += level_of_paren;\n   |\
    \                                                         ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `isize`\n\
    \  --> /tmp/tmp8grl32vk.rs:15:54\n   |\n15 |                 paren_levels[paren_levels.len()\
    \ - 1] += level_of_paren;\n   |                                              \
    \        ^^ no implementation for `isize += usize`\n   |\n   = help: the trait\
    \ `AddAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .lines()\n        .into_iter()\n\
    \        .filter_map(|s| {\n            s.chars().nth(1).unwrap_or(String::new()).parse().ok()\n\
    \        })\n        .filter_map(|s| s.chars().count() > 1)\n        .max()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cqb4n3e.rs:11:40\n   |\n\
    11 |             s.chars().nth(1).unwrap_or(String::new()).parse().ok()\n   |\
    \                                        ^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0599]: no method named `parse` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp7cqb4n3e.rs:11:55\n   |\n11 |          \
    \   s.chars().nth(1).unwrap_or(String::new()).parse().ok()\n   |             \
    \                                          ^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7cqb4n3e.rs:13:25\n   |\n13 |  \
    \       .filter_map(|s| s.chars().count() > 1)\n   |                         ^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 |         .filter_map(|s| Some(s.chars().count() > 1))\n   |       \
    \                  +++++                     +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut cur_group = 1;\n    let\
    \ mut parens = Vec::new();\n    let mut group_start = 0;\n    let mut group_end\
    \ = 0;\n\n    for paren in paren_string.chars() {\n        match paren {\n   \
    \         paren.(')') => {\n                parens.push(paren - paren.(')'));\n\
    \                level += 1;\n                cur_group += 1;\n              \
    \  group_start = paren;\n            },\n            paren.('(') => {\n      \
    \          parens.push(paren - paren.('('));\n                level += 1;\n  \
    \              cur_group += 1;\n                group_end = paren;\n         \
    \   },\n            paren.(')') => {\n                parens.push(paren - paren.(')'));\n\
    \                level -= 1;\n                cur_group += 1;\n              \
    \  group_end = paren;\n            },\n            paren.('(') => {\n        \
    \        parens.push(paren - paren.('('));\n                level -= 1;\n    \
    \            cur_group += 1;\n                group_start = paren;\n         \
    \   },\n            _ => (),\n        }\n\n        if level == 0 {\n         \
    \   group_start = paren;\n        }\n    }\n\n    if level > 0 {\n        parens.push(paren_string.len()\
    \ - paren_string.find('(') - group_start - 1);\n    }\n\n    parens\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `.`\n  --> /tmp/tmp16n4jh0h.rs:15:18\n\
    \   |\n15 |             paren.(')') => {\n   |                  ^ expected one\
    \ of `=>`, `@`, `if`, or `|`\n\nwarning: unreachable expression\n  --> /tmp/tmp16n4jh0h.rs:42:9\n\
    \   |\n14 | /         match paren {\n15 | |             paren.(')') => {\n16 |\
    \ |                 parens.push(paren - paren.(')'));\n17 | |                \
    \ level += 1;\n...  |\n39 | |             _ => (),\n40 | |         }\n   | |_________-\
    \ any code following this expression is unreachable\n41 | \n42 | /         if\
    \ level == 0 {\n43 | |             group_start = paren;\n44 | |         }\n  \
    \ | |_________^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp16n4jh0h.rs:43:27\n\
    \   |\n10 |     let mut group_start = 0;\n   |                           - expected\
    \ due to this value\n...\n43 |             group_start = paren;\n   |        \
    \                   ^^^^^ expected integer, found `char`\n\nerror[E0277]: cannot\
    \ subtract `Option<usize>` from `usize`\n  --> /tmp/tmp16n4jh0h.rs:48:40\n   |\n\
    48 |         parens.push(paren_string.len() - paren_string.find('(') - group_start\
    \ - 1);\n   |                                        ^ no implementation for `usize\
    \ - Option<usize>`\n   |\n   = help: the trait `Sub<Option<usize>>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_string = paren_string.trim().to_string();\n\
    \    let mut paren_string_to_levels = Vec::new();\n    let mut level = -1;\n\n\
    \    while paren_string.len() > 0 {\n        if paren_string[0] == ')' {\n   \
    \         paren_string_to_levels.push_back(level);\n        }\n\n        let len\
    \ = paren_string.len();\n        let last_char = paren_string[len - 1];\n    \
    \    if last_char == ')' {\n            level -= 1;\n        }\n        if last_char\
    \ == '(' {\n            level += 1;\n        }\n        paren_string = paren_string.split_whitespace().collect();\n\
    \    }\n    paren_string_to_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp56tfalzy.rs:12:12\n   |\n12 |         if paren_string[0] == ')' {\n\
    \   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp56tfalzy.rs:13:36\n   |\n13 |          \
    \   paren_string_to_levels.push_back(level);\n   |                           \
    \         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp56tfalzy.rs:17:25\n   |\n17 |  \
    \       let last_char = paren_string[len - 1];\n   |                         ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = vec![0];\n    let mut current:\
    \ isize = 0;\n    let mut stack: Vec<isize> = vec![0];\n    for ch in paren_string.chars()\
    \ {\n        match ch {\n            '(' -> stack.pop_back();\n            ')'\
    \ -> {\n                if let Some(x) = stack.pop_back() {\n                \
    \    output.push(x + 1);\n                    stack.push(x);\n               \
    \ }\n            }\n            _ if stack.len() == 0 => { }\n            _ =>\
    \ { stack.push(current); }\n            ch if current > output => {\n        \
    \        if let Some(x) = stack.pop_back() {\n                    output.push(x\
    \ + 1);\n                    stack.push(x);\n                }\n            }\n\
    \        }\n        current += 1;\n    }\n    output\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `->`\n\
    \  --> /tmp/tmpre2min78.rs:12:17\n   |\n12 |             '(' -> stack.pop_back();\n\
    \   |                 ^^\n   |                 |\n   |                 expected\
    \ one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n   |                 help: try\
    \ using a fat arrow here: `=>`\n\nerror: expected one of `,`, `.`, `?`, `}`, or\
    \ an operator, found `;`\n  --> /tmp/tmpre2min78.rs:12:36\n   |\n12 |        \
    \     '(' -> stack.pop_back();\n   |                 --                 ^ expected\
    \ one of `,`, `.`, `?`, `}`, or an operator\n   |                 |\n   |    \
    \             while parsing the `match` arm starting here\n\nwarning: unreachable\
    \ statement\n  --> /tmp/tmpre2min78.rs:28:9\n   |\n11 | /         match ch {\n\
    12 | |             '(' -> stack.pop_back();\n13 | |             ')' -> {\n14 |\
    \ |                 if let Some(x) = stack.pop_back() {\n...  |\n26 | |      \
    \       }\n27 | |         }\n   | |_________- any code following this expression\
    \ is unreachable\n28 |           current += 1;\n   |           ^^^^^^^^^^^^^ unreachable\
    \ statement\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Initialize a table that maps characters to their nesting\
    \ levels\n    let mut nesting_table: Vec<isize> = Vec::new();\n    nesting_table.push(isize::MAX);\n\
    \    for parens in paren_string.chars().filter(|c| c == '(' || c == ')') {\n \
    \       let mut curr_level = 1;\n        for c in parens.bytes() {\n         \
    \   curr_level = nesting_table[c] + curr_level;\n        }\n        nesting_table.push(curr_level);\n\
    \    }\n\n    nesting_table\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnokxpw65.rs:10:53\n\
    \   |\n10 |     for parens in paren_string.chars().filter(|c| c == '(' || c ==\
    \ ')') {\n   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnokxpw65.rs:10:65\n\
    \   |\n10 |     for parens in paren_string.chars().filter(|c| c == '(' || c ==\
    \ ')') {\n   |                                                               \
    \  ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0599]: no method named `bytes` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpnokxpw65.rs:12:25\n   |\n12 |         for c\
    \ in parens.bytes() {\n   |                         ^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut level = 0;\n    for\
    \ paren in paren_string.chars().filter_map(char::is_digit).take(paren_string.len()\
    \ - 1) {\n        if paren == '(' {\n            level += 1;\n        } else if\
    \ paren == ')' {\n            level -= 1;\n        } else if paren == '(' && level\
    \ == 0 {\n            level += 1;\n        } else if paren == ')' && level ==\
    \ 0 {\n            level -= 1;\n        } else {\n            levels.push(level);\n\
    \        }\n    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n\
    \   --> /tmp/tmp2ta2at9g.rs:9:50\n    |\n9   |     for paren in paren_string.chars().filter_map(char::is_digit).take(paren_string.len()\
    \ - 1) {\n    |                                       ---------- ^^^^^^^^^^^^^^\
    \ expected function that takes 1 argument\n    |                             \
    \          |\n    |                                       required by a bound\
    \ introduced by this call\n    |\nnote: required by a bound in `filter_map`\n\n\
    error[E0599]: the method `take` exists for struct `FilterMap<Chars<'_>, fn(char,\
    \ u32) -> bool {char::methods::<impl char>::is_digit}>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp2ta2at9g.rs:9:66\n   |\n9  |       for paren\
    \ in paren_string.chars().filter_map(char::is_digit).take(paren_string.len() -\
    \ 1) {\n   |                                                                 \
    \   ^^^^ method cannot be called on `FilterMap<Chars<'_>, fn(char, u32) -> bool\
    \ {char::methods::<impl char>::is_digit}>` due to unsatisfied trait bounds\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `<fn(char,\
    \ u32) -> bool {char::methods::<impl char>::is_digit} as FnOnce<(char,)>>::Output\
    \ = Option<_>`\n           which is required by `FilterMap<Chars<'_>, fn(char,\
    \ u32) -> bool {char::methods::<impl char>::is_digit}>: Iterator`\n          \
    \ `fn(char, u32) -> bool {char::methods::<impl char>::is_digit}: FnMut<(char,)>`\n\
    \           which is required by `FilterMap<Chars<'_>, fn(char, u32) -> bool {char::methods::<impl\
    \ char>::is_digit}>: Iterator`\n           `FilterMap<Chars<'_>, fn(char, u32)\
    \ -> bool {char::methods::<impl char>::is_digit}>: Iterator`\n           which\
    \ is required by `&mut FilterMap<Chars<'_>, fn(char, u32) -> bool {char::methods::<impl\
    \ char>::is_digit}>: Iterator`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0593, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0593`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let parens = paren_string.chars().map(|c| c.unwrap()).collect();\n\
    \    let mut level = 0;\n    parens.par_iter().for_each(|c| {\n        if c ==\
    \ '(' { level += 1; }\n        if c == ')' { level -= 1; }\n    });\n    parens\n\
    \        .par_iter()\n        .filter_map(|c| {\n            match c {\n     \
    \           ' ' => None,\n                c => Some(c),\n            }\n     \
    \   })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n --> /tmp/tmp_lcio5w9.rs:7:49\n  |\n7 |     let parens = paren_string.chars().map(|c|\
    \ c.unwrap()).collect();\n  |                                                \
    \ ^^^^^^ method not found in `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n\n    for parens\
    \ in paren_string.split() {\n        if parens.is_empty() || parens == \"()\"\
    \ || parens == \"{}\" {\n            continue;\n        }\n\n        let mut level\
    \ = 0;\n        let mut paran = 0;\n        for c in parens {\n            if\
    \ c == '(' {\n                paran++;\n                level += 1;\n        \
    \    } else if c == '{' || c == '[' {\n                level += 1;\n         \
    \   } else if c == '}' || c == ']' {\n                level -= 1;\n          \
    \      paran += 1;\n                if level == 0 {\n                    break;\n\
    \                }\n            }\n        }\n        levels.push(level);\n  \
    \  }\n\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp5sckrl6w.rs:18:22\n\
    \   |\n18 |                 paran++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |               \
    \  { let tmp = paran; paran += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n18 -                 paran++;\n18 +                 paran\
    \ += 1;\n   | \n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmp5sckrl6w.rs:9:32\n     |\n9    |     for parens\
    \ in paren_string.split() {\n     |                                ^^^^^- supplied\
    \ 0 arguments\n     |                                |\n     |               \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0277]: `&str` is not an iterator\n  --> /tmp/tmp5sckrl6w.rs:16:18\n\
    \   |\n16 |         for c in parens {\n   |                  ^^^^^^ `&str` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting = 0;\n    let mut paren_string = paren_string.chars().collect::<String>();\n\
    \    let mut parens_set = HashSet::new();\n    parens_set.insert(paren_string[0]);\n\
    \    parens_set.insert(paren_string[1]);\n    let mut paren_count = 0;\n    while\
    \ let Some(paren) = paren_string.next() {\n        paren_count += 1;\n       \
    \ let mut nest = nesting;\n        if paren_count > 2 {\n            nest -= 1;\n\
    \        }\n        if parens_set.contains(paren) {\n            nest += 1;\n\
    \        }\n        nesting = nest;\n        parens_set.insert(paren);\n    }\n\
    \    parens_set.iter().map(|c| c.to_string()).collect()\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp7c4bufe7.rs:9:26\n  |\n9 |     let mut parens_set = HashSet::new();\n\
    \  |                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp7c4bufe7.rs:10:23\n\
    \   |\n10 |     parens_set.insert(paren_string[0]);\n   |                    \
    \   ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp7c4bufe7.rs:11:23\n\
    \   |\n11 |     parens_set.insert(paren_string[1]);\n   |                    \
    \   ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `next` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp7c4bufe7.rs:13:42\n   |\n13 |     while let Some(paren) = paren_string.next()\
    \ {\n   |                                          ^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanatio"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter_map(|c|\
    \ match c {\n            '(' => Some(1),\n            _ => None,\n        })\n\
    \        .cloned()\n        .enumerate()\n        .filter_map(|(i, c)| {\n   \
    \         if c.is_some() {\n                Some(paren_string.len() - i)\n   \
    \         } else {\n                None\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmp6kofifl0.rs:9:21:\
    \ 12:10] as FnOnce<(char,)>>::Output == Option<&_>`\n    --> /tmp/tmp6kofifl0.rs:13:10\n\
    \     |\n13   |         .cloned()\n     |          ^^^^^^ expected reference,\
    \ found integer\n     |\n     = note: expected enum `Option<&_>`\n           \
    \     found enum `Option<{integer}>`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `FilterMap<Chars<'_>, [closure@/tmp/tmp6kofifl0.rs:9:21:\
    \ 12:10]>`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `enumerate` exists for struct `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmp6kofifl0.rs:9:21:\
    \ 12:10]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp6kofifl0.rs:14:10\n\
    \   |\n14 |            .enumerate()\n   |             ^^^^^^^^^ method cannot\
    \ be called on `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmp6kofifl0.rs:9:21:\
    \ 12:10]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<FilterMap<Chars<'_>, [closure@/tmp/tmp6kofifl0.rs:9:21:\
    \ 12:10]> as Iterator>::Item = &_`\n           which is required by `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp6kofifl0.rs:9:21: 12:10]>>: Iterator`\n           `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp6kofifl0.rs:9:21: 12:10]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmp6kofifl0.rs:9:21:\
    \ 12:10]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut paren_depth = Vec::with_capacity(paren_string.len());\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_depth.push(paren_depth.last().unwrap()\
    \ + 1);\n        } else {\n            if paren_depth.last().unwrap() < max_depth\
    \ {\n                max_depth = paren_depth.last().unwrap();\n            }\n\
    \            paren_depth.clear();\n        }\n    }\n    if paren_depth.last().unwrap()\
    \ < max_depth {\n        max_depth = paren_depth.last().unwrap();\n    }\n   \
    \ paren_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&_` with `{integer}`\n  --> /tmp/tmpxunnyfr5.rs:13:44\n\
    \   |\n13 |             if paren_depth.last().unwrap() < max_depth {\n   |   \
    \                                         ^ no implementation for `&_ < {integer}`\
    \ and `&_ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is\
    \ not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxunnyfr5.rs:14:29\n\
    \   |\n7  |     let mut max_depth = 0;\n   |                         - expected\
    \ due to this value\n...\n14 |                 max_depth = paren_depth.last().unwrap();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found reference\n   |\n   = note:   expected type `{integer}`\n           found\
    \ reference `&_`\nhelp: consider dereferencing the borrow\n   |\n14 |        \
    \         max_depth = *paren_depth.last().unwrap();\n   |                    \
    \         +\n\nerror[E0277]: can't compare `&_` with `{integer}`\n  --> /tmp/tmpxunnyfr5.rs:19:36\n\
    \   |\n19 |     if paren_depth.last().unwrap() < max_depth {\n   |           \
    \                         ^ no implementation for `&_ < {integer}` and `&_ > {integer}`\n\
    \   |\n   = help: the trait `PartialOrd<{integer}>` is not implemented for `&_`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxunnyfr5.rs:20:21\n   |\n7  |\
    \     let mut max_depth = 0;\n   |                         - expected due to this\
    \ value\n...\n20 |         max_depth = paren_depth.last().unwrap();\n   |    \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found reference\n\
    \   |\n   = note:   expected type `{integer}`\n           found reference `&_`\n\
    help: consider dereferencing the borrow\n   |\n20 |         max_depth = *paren_depth.last().unwrap();\n\
    \   |                     +\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = 0;\n    let mut paren_chars: Vec<_> =\
    \ paren_string.chars().collect();\n    loop {\n        paren_chars = paren_chars.filter(|c|\
    \ *c != '(');\n        levels += 1;\n        if paren_chars.len() == 0 {\n   \
    \         break;\n        }\n    }\n    paren_string.chars().rev().enumerate().filter(|(idx,\
    \ c)| c == '(')\n        .fold(0, |acc, curr| {\n            paren_chars[*curr\
    \ + 1] == '('\n                && acc > curr\n                && levels > curr\n\
    \        })\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmptn7a4f_i.rs:10:35\n\
    \    |\n10  |           paren_chars = paren_chars.filter(|c| *c != '(');\n   \
    \ |                                     ^^^^^^ `Vec<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n\
    \            `[char]: Iterator`\n            which is required by `&mut [char]:\
    \ Iterator`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmptn7a4f_i.rs:16:64\n\
    \   |\n16 |     paren_string.chars().rev().enumerate().filter(|(idx, c)| c ==\
    \ '(')\n   |                                                                ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptn7a4f_i.rs:17:15\n\
    \   |\n17 |         .fold(0, |acc, curr| {\n   |               ^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `{integer}`\n\nerror[E0614]: type `(usize, char)` cannot\
    \ be dereferenced\n  --> /tmp/tmptn7a4f_i.rs:18:25\n   |\n18 |             paren_chars[*curr\
    \ + 1] == '('\n   |                         ^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptn7a4f_i.rs:19:26\n   |\n19 |                 && acc >\
    \ curr\n   |                          ^^^^ expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found tuple `(usize,\
    \ char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptn7a4f_i.rs:18:13\n\
    \   |\n18 | /             paren_chars[*curr + 1] == '('\n19 | |              \
    \   && acc > curr\n20 | |                 && levels > curr\n   | |________________________________^\
    \ expected struct `Vec`, found `bool`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `bool`\n\nerror[E0277]: can't compare `{integer}`\
    \ with `(usize, char)`\n  --> /tmp/tmptn7a4f_i.rs:20:27\n   |\n20 |          \
    \       && levels "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Split input string by spaces\n    let mut tokens = paren_string.chars().collect::<Vec<_>>();\n\
    \    let mut depth = 0;\n    let mut token_iter = tokens.iter();\n\n    // While\
    \ the current tokens are in the string, process it\n    let mut depth = 0;\n \
    \   while token_iter.any(|&c| c == ('(' | ')')) {\n        // Look for matching\
    \ ending parenthesis\n        let next = (token_iter.next()) - 1;\n        if\
    \ next == tokens.len() {\n            // No more parenthesis found\n         \
    \   break;\n        }\n\n        // Increment depth of found matching parenthesis\n\
    \        if tokens[next] == '(' {\n            depth += 1;\n        } else {\n\
    \            depth -= 1;\n        }\n    }\n\n    // Convert to vector\n    let\
    \ mut depths = Vec::with_capacity(tokens.len());\n    for (i, &c) in token_iter.enumerate()\
    \ {\n        if c == ('(' | ')') {\n            // Push previous depth if current\
    \ depth is bigger\n            if depth > depths.last() {\n                depths.push(depth);\n\
    \            }\n\n            // Push current depth\n            depths.push(depth);\n\
    \            depth = 0;\n        } else {\n            // Increment depth value\n\
    \            depth += 1;\n        }\n    }\n\n    // Push last depth if current\
    \ depth is bigger\n    if depth > depths.last() {\n        depths.push(depth);\n\
    \    }\n\n    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: no implementation for `char | char`\n  --> /tmp/tmp8gyv_g0l.rs:14:41\n\
    \   |\n14 |     while token_iter.any(|&c| c == ('(' | ')')) {\n   |          \
    \                           --- ^ --- char\n   |                             \
    \        |\n   |                                     char\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<&char>`\n  --> /tmp/tmp8gyv_g0l.rs:16:40\n\
    \   |\n16 |         let next = (token_iter.next()) - 1;\n   |                \
    \    ------------------- ^ - {integer}\n   |                    |\n   |      \
    \              Option<&char>\n\nerror[E0369]: no implementation for `char | char`\n\
    \  --> /tmp/tmp8gyv_g0l.rs:33:22\n   |\n33 |         if c == ('(' | ')') {\n \
    \  |                  --- ^ --- char\n   |                  |\n   |          \
    \        char\n\nerror[E0277]: can't compare `{integer}` with `Option<&_>`\n \
    \ --> /tmp/tmp8gyv_g0l.rs:35:22\n   |\n35 |             if depth > depths.last()\
    \ {\n   |                      ^ no implementation for `{integer} < Option<&_>`\
    \ and `{integer} > Option<&_>`\n   |\n   = help: the trait `PartialOrd<Option<&_>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `{integer}`\
    \ with `Option<&{integer}>`\n  --> /tmp/tmp8gyv_g0l.rs:49:14\n   |\n49 |     if\
    \ depth > depths.last() {\n   |              ^ no implementation for `{integer}\
    \ < Option<&{integer}>` and `{integer} > Option<&{integer}>`\n   |\n   = help:\
    \ the trait `PartialOrd<Option<&{integer}>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0369.\nFor more information about an error, "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter_map(|c|\
    \ {\n            match c {\n                '(' => Some(1),\n                '('\
    \ | ')' => Some(2),\n                _ => None,\n            }\n        })\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 2, 2]`,\n\
    \ right: `[2, 3, 1, 3]`', /tmp/tmpsnu4ffes.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter_map(|c|\
    \ if c == '(' || c == ')' { None } else { Some(c) })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpjyum5baa.rs:10:10\n     |\n10\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<isize>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .filter_map(|item|\
    \ match item {\n            \"(\" => Some(1),\n            _ => None,\n      \
    \  })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpec5a7sf3.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut nest_level = 0;\n\
    \    let mut parens = vec![];\n    for paren in paren_string.chars() {\n     \
    \   if paren == '(' {\n            stack.push(nest_level);\n            nest_level\
    \ +=1;\n        }\n        parens.push(nest_level);\n        if paren == ')' {\n\
    \            nest_level -= 1;\n            if nest_level == 0 {\n            \
    \    let index = parens.pop().unwrap();\n                stack[index] -= 1;\n\
    \            }\n        }\n    }\n    stack.clone()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb87kkcwb.rs:24:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     stack.clone()\n   |     ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let parens = paren_string.split(' ');\n    let mut levels\
    \ = vec![parens.len()];\n    for paren in &parens {\n        if paren.contains(\"\
    (\") && paren.contains(\")\") {\n            let mut paren_level = 1;\n      \
    \      let mut paren_start = parens.iter().position(|x| x == paren).unwrap();\n\
    \            for paren in parens[paren_start..] {\n                if paren.contains(\"\
    (\") && paren.contains(\")\")\n                    && parens[paren_start + 1]\
    \ == paren\n                {\n                    paren_level += 1;\n       \
    \         }\n            }\n            levels.push(paren_level);\n        }\n\
    \    }\n    levels.sort_unstable();\n    levels.reverse();\n    levels\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmpid8kc5sq.rs:8:34\n  |\n8 |     let mut levels\
    \ = vec![parens.len()];\n  |                                  ^^^ method not found\
    \ in `std::str::Split<'_, char>`\n\nerror[E0277]: `&std::str::Split<'_, char>`\
    \ is not an iterator\n --> /tmp/tmpid8kc5sq.rs:9:18\n  |\n9 |     for paren in\
    \ &parens {\n  |                  -^^^^^^\n  |                  |\n  |       \
    \           `&std::str::Split<'_, char>` is not an iterator\n  |             \
    \     help: consider removing the leading `&`-reference\n  |\n  = help: the trait\
    \ `Iterator` is not implemented for `&std::str::Split<'_, char>`\n  = note: `Iterator`\
    \ is implemented for `&mut std::str::Split<'_, char>`, but not for `&std::str::Split<'_,\
    \ char>`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::str::Split<'_, char>`\n\nerror[E0599]: no method named `iter` found\
    \ for struct `std::str::Split` in the current scope\n  --> /tmp/tmpid8kc5sq.rs:12:42\n\
    \   |\n12 |             let mut paren_start = parens.iter().position(|x| x ==\
    \ paren).unwrap();\n   |                                          ^^^^ method\
    \ not found in `std::str::Split<'_, char>`\n\nerror[E0608]: cannot index into\
    \ a value of type `std::str::Split<'_, char>`\n  --> /tmp/tmpid8kc5sq.rs:13:26\n\
    \   |\n13 |             for paren in parens[paren_start..] {\n   |           \
    \               ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `std::str::Split<'_, char>`\n  --> /tmp/tmpid8kc5sq.rs:15:24\n   |\n\
    15 |                     && parens[paren_start + 1] == paren\n   |           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars().filter_map(|c| match c {\n       \
    \ '(' => true,\n        _ => false,\n    }).collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().rev().filter(|&c|\
    \ c == ')')\n        .filter_map(|c| match c {\n            '(' | ')' => true,\n\
    \            _ => false,\n        })\n        .collect()\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8e4w4owe.rs:8:16\n  |\n8 |\
    \         '(' => true,\n  |                ^^^^ expected enum `Option`, found\
    \ `bool`\n  |\n  = note: expected enum `Option<_>`\n             found type `bool`\n\
    help: try wrapping the expression in `Some`\n  |\n8 |         '(' => Some(true),\n\
    \  |                +++++    +\n\nerror[E0599]: `Vec<_>` is not an iterator\n\
    \   --> /tmp/tmp8e4w4owe.rs:10:64\n    |\n10  |       }).collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().rev().filter(|&c|\
    \ c == ')')\n    |                                                           \
    \       ^^^ `Vec<_>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<_>: Iterator`\n            which\
    \ is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n      \
    \      which is required by `&mut [_]: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut paren_stack: Vec<String>\
    \ = Vec::new();\n    paren_stack.push(paren_string);\n\n    let mut paren_level\
    \ = 0;\n    loop {\n        let current_level = paren_stack.len();\n        if\
    \ current_level > level {\n            level = current_level;\n        }\n   \
    \     // Pop all elements until the current level\n        while level > 0 {\n\
    \            let popped_string = paren_stack.pop().unwrap();\n            if !popped_string.is_empty()\
    \ {\n                level -= 1;\n            }\n        }\n        // Pop all\
    \ elements until the next level\n        while level < paren_stack.len() {\n \
    \           level += 1;\n            paren_stack.pop().unwrap()\n        }\n \
    \       paren_stack.push(paren_string);\n        if paren_stack.len() >= 2 {\n\
    \            paren_level += 1;\n        }\n    }\n    level\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnudullbr.rs:27:13\n   |\n\
    25 | /         while level < paren_stack.len() {\n26 | |             level +=\
    \ 1;\n27 | |             paren_stack.pop().unwrap()\n   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `String`\n28 | |         }\n   | |_________- expected\
    \ this to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n27 |   \
    \          paren_stack.pop().unwrap();\n   |                                 \
    \      +\nhelp: consider using a semicolon here\n   |\n28 |         };\n   | \
    \         +\n\nwarning: unreachable expression\n  --> /tmp/tmpnudullbr.rs:34:5\n\
    \   |\n12 | /     loop {\n13 | |         let current_level = paren_stack.len();\n\
    14 | |         if current_level > level {\n15 | |             level = current_level;\n\
    ...  |\n32 | |         }\n33 | |     }\n   | |_____- any code following this expression\
    \ is unreachable\n34 |       level\n   |       ^^^^^ unreachable expression\n\
    \   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnudullbr.rs:34:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n34 |     level\n\
    \   |     ^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut i = 0;\n    let mut nest = 0;\n    let mut curr\
    \ = 1;\n    paren_string.splitn(2, |c| match c {\n        '(' | ')' => {\n   \
    \         curr += 1;\n            nest += 1;\n        }\n        _ => (),\n  \
    \  })\n    .map(|c| match c {\n        '(' | ')' => {\n            curr += 1;\n\
    \        }\n        _ => (),\n    })\n    .map(|c| match c {\n        '(' | ')'\
    \ => {\n            nest -= 1;\n        }\n        _ => (),\n    })\n    .filter(|c|\
    \ c != ())\n    .filter(|c| c != 0)\n    .filter(|c| c < curr)\n    .iter()\n\
    \    .cloned()\n    .map(|c| c + i)\n    .max().unwrap_or(0)\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpunu562du.rs:10:28:\
    \ 16:6] as FnOnce<(char,)>>::Output == bool`\n    --> /tmp/tmpunu562du.rs:10:18\n\
    \     |\n10   |     paren_string.splitn(2, |c| match c {\n     |             \
    \     ^^^^^^ expected `bool`, found `()`\n     |\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `[closure@/tmp/tmpunu562du.rs:10:28:\
    \ 16:6]`\nnote: required by a bound in `core::str::<impl str>::splitn`\n\nerror[E0599]:\
    \ the method `map` exists for struct `std::str::SplitN<'_, [closure@/tmp/tmpunu562du.rs:10:28:\
    \ 16:6]>`, but its trait bounds were not satisfied\n   --> /tmp/tmpunu562du.rs:17:6\n\
    \    |\n10  |       paren_string.splitn(2, |c| match c {\n    |              \
    \                ----------- doesn't satisfy `_: Pattern<'_>`\n...\n17  |    \
    \   .map(|c| match c {\n    |        ^^^ method cannot be called on `std::str::SplitN<'_,\
    \ [closure@/tmp/tmpunu562du.rs:10:28: 16:6]>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `[closure@/tmp/tmpunu562du.rs:10:28: 16:6]: Pattern<'_>`\n            which\
    \ is required by `std::str::SplitN<'_, [closure@/tmp/tmpunu562du.rs:10:28: 16:6]>:\
    \ Iterator`\n            `std::str::SplitN<'_, [closure@/tmp/tmpunu562du.rs:10:28:\
    \ 16:6]>: Iterator`\n            which is required by `&mut std::str::SplitN<'_,\
    \ [closure@/tmp/tmpunu562du.rs:10:28: 16:6]>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut result = Vec::new();\n\n\
    \    let mut stack = paren_string.chars();\n    let mut paren_char = stack.next();\n\
    \    let mut parens_level = 1;\n\n    let mut paren_found = false;\n\n    while\
    \ !paren_char.is_empty() {\n        paren_found = paren_char.as_char() == '(';\n\
    \        if paren_found {\n            parens_level += 1;\n        }\n       \
    \ if parens_level > level {\n            result.push(parens_level);\n        \
    \    level = parens_level;\n        }\n\n        if parens_level == level {\n\
    \            let mut char = stack.next();\n            while (char.ascii_chars()\
    \ == ' ') char = stack.next();\n            let mut char_found = char.as_char()\
    \ == '(';\n            while !char_found {\n                level = level.saturating_sub(1);\n\
    \                char = stack.next();\n                char_found = char.as_char()\
    \ == '(';\n            }\n        }\n\n        paren_char = stack.next();\n  \
    \  }\n\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `char`\n  --> /tmp/tmp2d3vev6a.rs:28:47\n  \
    \ |\n28 |             while (char.ascii_chars() == ' ') char = stack.next();\n\
    \   |             ----- --------------------------- ^^^^ expected `{`\n   |  \
    \           |     |\n   |             |     this `while` condition successfully\
    \ parsed\n   |             while parsing the body of this `while` expression\n\
    \   |\nhelp: try placing this code inside a block\n   |\n28 |             while\
    \ (char.ascii_chars() == ' ') { char = stack.next() };\n   |                 \
    \                              +                     +\n\nerror[E0599]: no method\
    \ named `is_empty` found for enum `Option` in the current scope\n  --> /tmp/tmp2d3vev6a.rs:16:23\n\
    \   |\n16 |     while !paren_char.is_empty() {\n   |                       ^^^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0599]: no method named `as_char`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp2d3vev6a.rs:17:34\n\
    \   |\n17 |         paren_found = paren_char.as_char() == '(';\n   |         \
    \                         ^^^^^^^ method not found in `Option<char>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_depth = paren_string.chars().count(|c| *c\
    \ == '(') - 1;\n    if paren_depth == 0 {\n        return vec![0];\n    }\n  \
    \  let mut groups: Vec<_> = paren_string.chars().filter(|c| *c != '(').collect();\n\
    \    for paren in groups.iter().rev() {\n        if paren_depth == 2 {\n     \
    \       paren_depth = 0;\n        }\n        paren_depth += 1;\n    }\n    paren_depth\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpk7jumca_.rs:7:55\n\
    \  |\n7 |     let mut paren_depth = paren_string.chars().count(|c| *c == '(')\
    \ - 1;\n  |                                                       ^ consider giving\
    \ this closure parameter a type\n  |\n  = note: type must be known at this point\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpk7jumca_.rs:7:48\n    |\n7   |     let mut paren_depth = paren_string.chars().count(|c|\
    \ *c == '(') - 1;\n    |                                                ^^^^^\
    \ ------------- supplied 1 argument\n    |                                   \
    \             |\n    |                                                expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk7jumca_.rs:18:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n18 |     paren_depth\n\
    \   |     ^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0282,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut level_stack: Vec<usize>\
    \ = vec![];\n    let mut group_size = 0;\n    let mut group_num = 0;\n    for\
    \ group_char in paren_string.chars() {\n        match group_char {\n         \
    \   ')' => {\n                let new_level = level_stack.pop().unwrap();\n  \
    \              levels.push(new_level);\n                group_size += new_level;\n\
    \            }\n            '(' => {\n                level_stack.push(group_num);\n\
    \                group_num += 1\n            }\n            _ => {\n         \
    \       group_size++;\n            }\n        }\n    }\n    levels.reverse();\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgm7h4e2i.rs:23:27\n\
    \   |\n23 |                 group_size++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |       \
    \          { let tmp = group_size; group_size += 1; tmp };\n   |             \
    \    +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n23 -                 group_size++;\n\
    23 +                 group_size += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgm7h4e2i.rs:28:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n28 |     levels\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels: Vec<isize> = vec![];\n    paren_string\n\
    \        .split_whitespace()\n        .for_each(|x| {\n            paren_levels.push(0);\n\
    \            loop {\n                if paren_levels[paren_levels.len() - 1] >\
    \ 0 {\n                    paren_levels[paren_levels.len() - 1] += 1;\n      \
    \              break;\n                }\n                if x.starts_with('(')\
    \ {\n                    paren_levels.push(0);\n                    break;\n \
    \               }\n                if x.ends_with(')')\n                    ||\
    \ paren_levels[paren_levels.len() - 1] == 0\n                {\n             \
    \       paren_levels.pop();\n                    break;\n                }\n \
    \           }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpjshbjid2.rs:29:10\n\
    \   |\n29 |         .collect()\n   |          ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut num_levels = Vec::with_capacity(paren_string.len());\n\
    \n    for level in paren_string.chars() {\n        if !is_delimiter(level) {\n\
    \            break;\n        }\n        num_levels.push(paren_string.len());\n\
    \    }\n\n    if num_levels.is_empty() {\n        num_levels.insert(num_levels.len(),\
    \ 1);\n    }\n\n    num_levels.sort_unstable();\n\n    num_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_delimiter` in this scope\n  -->\
    \ /tmp/tmpswqd2tlp.rs:10:13\n   |\n10 |         if !is_delimiter(level) {\n  \
    \ |             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpswqd2tlp.rs:22:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n22 |     num_levels\n\
    \   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut cur_level = 0;\n\
    \    let mut nesting = Vec::new();\n\n    for ch in paren_string.chars() {\n \
    \       match ch {\n            '(' => {\n                cur_level += 1;\n  \
    \              nesting.push(cur_level);\n            }\n            ')' => {}\n\
    \            other => {\n                max_nesting = std::cmp::max(max_nesting,\
    \ cur_level);\n                nesting.pop();\n            }\n        }\n    }\n\
    \n    nesting.reverse();\n    max_nesting\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg1eia9q0.rs:26:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     max_nesting\n   |     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `{integer}`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = Vec::new();\n\n    let mut parentheses_level\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   stack.push(parentheses_level);\n            parentheses_level += 1;\n    \
    \    } else if c == ')' {\n            parentheses_level -= 1;\n            if\
    \ parentheses_level < 0 {\n                return stack;\n            }\n    \
    \    }\n    }\n    stack.push(parentheses_level);\n    stack\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 1, 2, 0, 0, 1, 2, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpf349jhwy.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_depth: Vec<isize> = vec![];\n    let mut\
    \ paren_stack: Vec<&str> = vec![];\n\n    paren_stack.push(paren_string);\n  \
    \  paren_depth.push(0);\n\n    while paren_depth.len() != 0 {\n        paren_depth.pop();\n\
    \        let mut paren_level = paren_depth.last().unwrap();\n        paren_depth.remove(&mut\
    \ paren_level);\n\n        let mut last_paren_level = paren_stack.last().unwrap().len();\n\
    \        paren_stack.remove(&mut last_paren_level);\n\n        if last_paren_level\
    \ > paren_level {\n            paren_depth.push(paren_level);\n        }\n   \
    \ }\n\n    paren_depth.iter().collect()\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp307deafd.rs:10:22\n   |\n\
    10 |     paren_stack.push(paren_string);\n   |                      ^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&paren_string`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp307deafd.rs:16:28\n   |\n16 |\
    \         paren_depth.remove(&mut paren_level);\n   |                        \
    \    ^^^^^^^^^^^^^^^^ expected `usize`, found `&mut &isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp307deafd.rs:19:28\n   |\n19 |         paren_stack.remove(&mut\
    \ last_paren_level);\n   |                            ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `&mut usize`\n   |\nhelp: consider removing the borrow\n   |\n\
    19 -         paren_stack.remove(&mut last_paren_level);\n19 +         paren_stack.remove(last_paren_level);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp307deafd.rs:21:31\n  \
    \ |\n21 |         if last_paren_level > paren_level {\n   |                  \
    \             ^^^^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp307deafd.rs:22:30\n   |\n22 |             paren_depth.push(paren_level);\n\
    \   |                              ^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |             paren_depth.push(*paren_level);\n\
    \   |                              +\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp307deafd.rs:26:24\n\
    \     |\n26   |     paren_depth.iter().collect()\n     |                     \
    \   ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut nesting_levels = vec![];\n\
    \    for paren in paren_string.chars() {\n        if paren == ')' {\n        \
    \    nesting_levels.push(depth);\n            depth--;\n        } else if paren\
    \ == '(' {\n            nesting_levels.push(depth);\n            depth++;\n  \
    \      } else if paren == ')' && nesting_levels.last().unwrap() > depth {\n  \
    \          nesting_levels.pop();\n            depth--;\n        } else if paren\
    \ == '(' && nesting_levels.last().unwrap() < depth {\n            nesting_levels.pop();\n\
    \            depth++;\n        } else {\n            depth++;\n        }\n   \
    \ }\n    nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpg1i8ti7q.rs:12:20\n\
    \   |\n12 |             depth--;\n   |                    ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpg1i8ti7q.rs:15:18\n\
    \   |\n15 |             depth++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |             { let tmp =\
    \ depth; depth += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    15 -             depth++;\n15 +             depth += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmpg1i8ti7q.rs:18:20\n   |\n18 |         \
    \    depth--;\n   |                    ^ expected expression\n\nerror: Rust has\
    \ no postfix increment operator\n  --> /tmp/tmpg1i8ti7q.rs:21:18\n   |\n21 | \
    \            depth++;\n   |                  ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n21 |             { let tmp = depth; depth\
    \ += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n21 -  \
    \           depth++;\n21 +             depth += 1;\n   | \n\nerror: Rust has no\
    \ postfix increment operator\n  --> /tmp/tmpg1i8ti7q.rs:23:18\n   |\n23 |    \
    \         depth++;\n   |                  ^^ not a valid postfix operator\n  \
    \ |\nhelp: use `+= 1` instead\n   |\n23 |             { let tmp = depth; depth\
    \ += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n23 -  \
    \           depth++;\n23 +             depth += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg1i8ti7q.rs:16:68\n   |\n16 |         } else if paren ==\
    \ ')' && nesting_levels.last().unwrap() > depth {\n   |                      \
    \                                              ^^^^^\n   |                   \
    \                                                 |\n   |                    \
    \                                                expected reference, found integer\n\
    \   |                                                                    help:\
    \ consider borrowing here: `&depth`\n   |\n   = note: expected reference `&_`\n\
    \                   found type `{integer}`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut paren_levels = Vec::new();\n\
    \    let mut paren_level = 1;\n\n    let mut parens = String::new();\n\n    for\
    \ c in paren_string {\n        if c == '(' {\n            paren_count++;\n   \
    \         paren_level += 1;\n            parens = parens.push_str(\"(\");\n  \
    \      } else {\n            if c == ')' {\n                paren_count--;\n \
    \               paren_level -= 1;\n                parens = parens.push_str(&parens[..parens.len()\
    \ - 1]);\n            } else {\n                parens = parens.push_str(&parens[..parens.len()\
    \ - 1]);\n            }\n        }\n\n        paren_levels.push(paren_level);\n\
    \    }\n\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp4r02zmv3.rs:15:24\n\
    \   |\n15 |             paren_count++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |             { let\
    \ tmp = paren_count; paren_count += 1; tmp };\n   |             +++++++++++  \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~\n15 -             paren_count++;\n15 +  \
    \           paren_count += 1;\n   | \n\nerror: expected expression, found `;`\n\
    \  --> /tmp/tmp4r02zmv3.rs:20:30\n   |\n20 |                 paren_count--;\n\
    \   |                              ^ expected expression\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmp4r02zmv3.rs:13:14\n   |\n13 |     for c in\
    \ paren_string {\n   |              ^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4r02zmv3.rs:24:26\n   |\n11 |     let mut parens = String::new();\n\
    \   |                      ------------- expected due to this value\n...\n24 |\
    \                 parens = parens.push_str(&parens[..parens.len() - 1]);\n   |\
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmp4r02zmv3.rs:24:33\n   |\n24 |                 parens\
    \ = parens.push_str(&parens[..parens.len() - 1]);\n   |                      \
    \    ------ ^^^^^^^^ this call modifies `parens` in-place\n   |              \
    \            |\n   |                          you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `push_str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .chars()\n\
    \        .flat_map(|c| *c.to_digit(16))\n        .fold(Vec::new(), |mut vec, c|\
    \ {\n            if vec.len() == 0 || vec.last().unwrap() < c {\n            \
    \    vec.push(c);\n            }\n            vec\n        })\n        .map(|i|\
    \ i.to_digit(16))\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpu8czfnca.rs:9:10\n  |\n9 |         .chars()\n\
    \  |          ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0\n    let mut parans_level = 0\n    let\
    \ mut groups = paren_string.char_indices().enumerate().filter(|&(_, c)| *c ==\
    \ ' ').collect::<Vec<(usize, usize)>>();\n    while !groups.is_empty() {\n   \
    \     if groups[0][0].is_some() {\n            if level == 0 {\n             \
    \   level += 1;\n            } else {\n                level -= 1;\n         \
    \   }\n            groups[0] = groups[0].next();\n        } else {\n         \
    \   parans_level = level;\n            groups = groups.next();\n        }\n  \
    \  }\n    parans_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpn3m2dmmz.rs:7:22\n\
    \  |\n7 |     let mut level = 0\n  |                      ^ help: add `;` here\n\
    8 |     let mut parans_level = 0\n  |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `let`\n --> /tmp/tmpn3m2dmmz.rs:8:29\n  |\n8 |     let mut\
    \ parans_level = 0\n  |                             ^ help: add `;` here\n9 |\
    \     let mut groups = paren_string.char_indices().enumerate().filter(|&(_, c)|\
    \ *c == ' ').collect::<Vec<(usize, usize)>>();\n  |     --- unexpected token\n\
    \nerror[E0614]: type `(usize, char)` cannot be dereferenced\n --> /tmp/tmpn3m2dmmz.rs:9:79\n\
    \  |\n9 |     let mut groups = paren_string.char_indices().enumerate().filter(|&(_,\
    \ c)| *c == ' ').collect::<Vec<(usize, usize)>>();\n  |                      \
    \                                                         ^^\n\nerror[E0277]:\
    \ a value of type `Vec<(usize, usize)>` cannot be built from an iterator over\
    \ elements of type `(usize, (usize, char))`\n    --> /tmp/tmpn3m2dmmz.rs:9:90\n\
    \     |\n9    |     let mut groups = paren_string.char_indices().enumerate().filter(|&(_,\
    \ c)| *c == ' ').collect::<Vec<(usize, usize)>>();\n     |                   \
    \                                                                       ^^^^^^^\
    \ value of type `Vec<(usize, usize)>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ (usize, char))>`\n     |\n     = help: the trait `FromIterator<(usize, (usize,\
    \ char))>` is not implemented for `Vec<(usize, usize)>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0608]: cannot index into a value of type `(usize, usize)`\n\
    \  --> /tmp/tmpn3m2dmmz.rs:11:12\n   |\n11 |         if groups[0][0].is_some()\
    \ {\n   |            ^^^^^^^^^^^^ help: to access tuple elements, use: `groups[0].0`\n\
    \nerror[E0599]: no method named `next` found for tuple `(usize, usize)` in the\
    \ current scope\n  --> /tmp/tmpn3m2dmmz.rs:17:35\n   |\n17 |             groups[0]\
    \ = groups[0].next();\n   |                                   ^^^^ method not\
    \ found in `(usize, usize)"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars().collect()\n        .map(|c| if c ==\
    \ '(' { 1 } else if c == ')' { -1 } else { 0 }).collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpvoh6vwd6.rs:7:26\n\
    \  |\n7 |     paren_string.chars().collect()\n  |                          ^^^^^^^\
    \ cannot infer type for type parameter `B` declared on the associated function\
    \ `collect`\n  |\n  = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n  |\n7 |     paren_string.chars().collect::<B>()\n\
    \  |                                 +++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .as_bytes()\n        .lines()\n \
    \       .filter_map(|line| line.contains(char::b('(')) || line.contains(char::b(')')))\n\
    \        .map(|line| {\n            let mut nesting = 1;\n            let mut\
    \ level = line.char_indices().skip_while(|&c| c == '(').count();\n           \
    \ let mut levels = vec![level];\n            while level > 0 {\n             \
    \   level -= 1;\n                levels.push(level);\n            }\n        \
    \    nesting.max(&levels)\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `lines` found for reference `&[u8]` in the\
    \ current scope\n --> /tmp/tmp7x5jch9d.rs:9:10\n  |\n9 |         .lines()\n  |\
    \          ^^^^^ method not found in `&[u8]`\n  |\n  = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n  |\n1 | use std::io::BufRead;\n\
    \  |\n\nerror[E0599]: no function or associated item named `b` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp7x5jch9d.rs:10:48\n   |\n10 |   \
    \      .filter_map(|line| line.contains(char::b('(')) || line.contains(char::b(')')))\n\
    \   |                                                ^ function or associated\
    \ item not found in `char`\n\nerror[E0599]: no function or associated item named\
    \ `b` found for type `char` in the current scope\n  --> /tmp/tmp7x5jch9d.rs:10:79\n\
    \   |\n10 |         .filter_map(|line| line.contains(char::b('(')) || line.contains(char::b(')')))\n\
    \   |                                                                        \
    \       ^ function or associated item not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7x5jch9d.rs:19:25\n   |\n19 |             nesting.max(&levels)\n\
    \   |                         ^^^^^^^ expected integer, found `&Vec<_>`\n   |\n\
    \   = note:   expected type `{integer}`\n           found reference `&Vec<_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = paren_string.len();\n    let mut\
    \ levels = Vec::new();\n    let mut nesting = levels[..];\n\n    for paren in\
    \ paren_string.split(' ').iter().filter(|&x| !x.is_empty()) {\n        let open_count\
    \ = paren.chars().filter(|c| c == '(').count();\n        let close_count = paren.chars().filter(|c|\
    \ c == ')').count();\n        if open_count > close_count {\n            paren_count\
    \ -= open_count - close_count;\n        } else {\n            let mut close_level\
    \ = nesting.iter().position(|&x| x == close_count);\n            if close_level.is_some()\
    \ && (close_level - nesting.len()) == open_count {\n                levels.push(close_level);\n\
    \                nesting.pop();\n            } else {\n                levels.push(open_count\
    \ + 1);\n                nesting.push(open_count);\n            }\n        }\n\
    \    }\n\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `[_]` cannot be known at compilation\
    \ time\n --> /tmp/tmprx2b2xsp.rs:9:9\n  |\n9 |     let mut nesting = levels[..];\n\
    \  |         ^^^^^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help:\
    \ the trait `Sized` is not implemented for `[_]`\n  = note: all local variables\
    \ must have a statically known size\n  = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n  |\n9 |     let mut nesting\
    \ = &levels[..];\n  |                       +\n\nerror[E0599]: no method named\
    \ `iter` found for struct `std::str::Split` in the current scope\n  --> /tmp/tmprx2b2xsp.rs:11:42\n\
    \   |\n11 |     for paren in paren_string.split(' ').iter().filter(|&x| !x.is_empty())\
    \ {\n   |                                          ^^^^ method not found in `std::str::Split<'_,\
    \ char>`\n\nerror[E0369]: cannot subtract `usize` from `Option<usize>`\n  -->\
    \ /tmp/tmprx2b2xsp.rs:18:54\n   |\n18 |             if close_level.is_some() &&\
    \ (close_level - nesting.len()) == open_count {\n   |                        \
    \                  ----------- ^ ------------- usize\n   |                   \
    \                       |\n   |                                          Option<usize>\n\
    \nerror[E0599]: no method named `pop` found for slice `[Option<usize>]` in the\
    \ current scope\n  --> /tmp/tmprx2b2xsp.rs:20:25\n   |\n20 |                 nesting.pop();\n\
    \   |                         ^^^ method not found in `[Option<usize>]`\n\nerror[E0599]:\
    \ no method named `push` found for slice `[Option<usize>]` in the current scope\n\
    \  --> /tmp/tmprx2b2xsp.rs:23:25\n   |\n23 |                 nesting.push(open_count);\n\
    \   |                         ^^^^ method not found in `[Option<usize>]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprx2b2xsp.rs:28:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n28 |     levels\n\
    \   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n        "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens = Vec::new();\n    let mut paren_index =\
    \ 0;\n    for paren in paren_string.chars().filter(|c| c == '(' || c == '{' ||\
    \ c == '[').skip(1) {\n        let open_parens = paren.chars().filter(|c| c ==\
    \ '(' || c == '{' || c == '[').count();\n        let close_parens = paren.chars().filter(|c|\
    \ c == '(' || c == '{' || c == '[').count() - open_parens;\n        parens.push(paren_index);\n\
    \        if close_parens > 0 {\n            paren_index += close_parens;\n   \
    \     } else {\n            paren_index += open_parens;\n        }\n    }\n  \
    \  parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpqsr5oza8.rs:9:52\n\
    \  |\n9 |     for paren in paren_string.chars().filter(|c| c == '(' || c == '{'\
    \ || c == '[').skip(1) {\n  |                                                \
    \    ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpqsr5oza8.rs:9:64\n\
    \  |\n9 |     for paren in paren_string.chars().filter(|c| c == '(' || c == '{'\
    \ || c == '[').skip(1) {\n  |                                                \
    \                ^^ no implementation for `&char == char`\n  |\n  = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n --> /tmp/tmpqsr5oza8.rs:9:76\n  |\n9 |     for paren in paren_string.chars().filter(|c|\
    \ c == '(' || c == '{' || c == '[').skip(1) {\n  |                           \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpqsr5oza8.rs:10:33\n\
    \   |\n10 |         let open_parens = paren.chars().filter(|c| c == '(' || c ==\
    \ '{' || c == '[').count();\n   |                                 ^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `chars` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpqsr5oza8.rs:11:34\n   |\n11 |   \
    \      let close_parens = paren.chars().filter(|c| c == '(' || c == '{' || c ==\
    \ '[').count() - open_parens;\n   |                                  ^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut level = 0;\n    let\
    \ mut stack = vec![];\n    for paren in paren_string.chars().filter(|c| *c ==\
    \ ')') {\n        if paren_count % 2 == 0 {\n            stack.push(level);\n\
    \        }\n        paren_count += 1;\n        if *paren == '(' {\n          \
    \  level += 1;\n        } else if *paren == ')' {\n            level -= 1;\n \
    \           if level == 0 {\n                stack.pop();\n            }\n   \
    \     }\n    }\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpvp_v_sx0.rs:15:12\n\
    \   |\n15 |         if *paren == '(' {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpvp_v_sx0.rs:17:19\n   |\n\
    17 |         } else if *paren == ')' {\n   |                   ^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0\n    let mut open_parens = 1\n\n    let\
    \ mut string = paren_string.trim().to_string();\n    while !string.contains('(')\
    \ {\n        if level == 0 {\n            level = 1;\n        } else {\n     \
    \       level += 1;\n        }\n\n        string = string[open_parens..].trim().to_string();\n\
    \        open_parens += 1;\n    }\n\n    if string.contains('(') {\n        while\
    \ !string.contains(')') {\n            level += 1;\n            string = string[open_parens..].trim().to_string();\n\
    \            open_parens += 1;\n        }\n    }\n\n    level\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmplzl1j16c.rs:7:22\n\
    \  |\n7 |     let mut level = 0\n  |                      ^ help: add `;` here\n\
    8 |     let mut open_parens = 1\n  |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `let`\n  --> /tmp/tmplzl1j16c.rs:8:28\n   |\n8  |     let\
    \ mut open_parens = 1\n   |                            ^ help: add `;` here\n\
    9  | \n10 |     let mut string = paren_string.trim().to_string();\n   |     ---\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplzl1j16c.rs:30:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n30 |     level\n   |     ^^^^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `{integer}`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split_whitespace().filter_map(|word| {\n \
    \       word.parse::<isize>().ok()\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9lfw63kg.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut num_levels = 0;\n    let mut paren_stack = Vec::new();\n\
    \    let mut inside_paren = false;\n    for ch in paren_string.chars() {\n   \
    \     if ch == '(' && !inside_paren {\n            paren_stack.push(num_levels);\n\
    \            inside_paren = true;\n        }\n        if ch == ')' && inside_paren\
    \ {\n            num_levels = paren_stack.pop();\n            inside_paren = false;\n\
    \        }\n        if inside_paren {\n            *num_levels += 1;\n       \
    \ }\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps9eqgh29.rs:16:26\n   |\n\
    7  |     let mut num_levels = 0;\n   |                          - expected due\
    \ to this value\n...\n16 |             num_levels = paren_stack.pop();\n   | \
    \                         ^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmps9eqgh29.rs:20:13\n\
    \   |\n20 |             *num_levels += 1;\n   |             ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens: Vec<isize> = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut paren_levels: Vec<isize> = Vec::new();\n    let mut paren_count\
    \ = 0;\n    for paren in paren_string.chars() {\n        parens.push(paren);\n\
    \        let level: isize = (paren_level * 2) + 1;\n        paren_levels.push(level);\n\
    \        paren_count += level == 1;\n    }\n    while paren_level < paren_levels.size()\
    \ {\n        paren_level += 1;\n    }\n    parens.sort_unstable_by_key(|&i| paren_levels[paren_levels.len()\
    \ - paren_level - 2]);\n    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe95v0ksz.rs:12:21\n   |\n\
    12 |         parens.push(paren);\n   |                     ^^^^^ expected `isize`,\
    \ found `char`\n\nerror[E0277]: cannot add-assign `bool` to `{integer}`\n  -->\
    \ /tmp/tmpe95v0ksz.rs:15:21\n   |\n15 |         paren_count += level == 1;\n \
    \  |                     ^^ no implementation for `{integer} += bool`\n   |\n\
    \   = help: the trait `AddAssign<bool>` is not implemented for `{integer}`\n \
    \  = help: the following other types implement trait `AddAssign<Rhs>`:\n     \
    \        <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n         \
    \    <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0599]: no method named `size` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpe95v0ksz.rs:17:38\n   |\n17 |     while paren_level < paren_levels.size()\
    \ {\n   |                                      ^^^^ help: there is an associated\
    \ function with a similar name: `resize`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpe95v0ksz.rs:20:72\n   |\n20 |     parens.sort_unstable_by_key(|&i|\
    \ paren_levels[paren_levels.len() - paren_level - 2]);\n   |                 \
    \                                                       ^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpe95v0ksz.rs:20:70\n\
    \   |\n20 |     parens.sort_unstable_by_key(|&i| paren_levels[paren_levels.len()\
    \ - paren_level - 2]);\n   |                                                 \
    \                     ^ no implementation for `usize - isize`\n   |\n   = help:\
    \ the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nested_level = 0usize;\n    let mut paren_levels\
    \ = Vec::new();\n    let mut paren_counts = Vec::new();\n    for paren_count in\
    \ paren_string.char_indices()\n        .filter_map(|(idx, _)| {\n            if\
    \ paren_string[idx] == '(' {\n                paren_count += 1;\n            \
    \    if paren_count >= nested_level {\n                    nested_level = paren_count;\n\
    \                }\n            } else if paren_string[idx] == ')' {\n       \
    \         paren_count -= 1;\n                paren_counts.push(paren_count);\n\
    \                if paren_count == 0 {\n                    paren_levels.push(nested_level);\n\
    \                }\n            }\n            Ok(paren_count)\n        })\n \
    \   {\n        let mut has_leftover_parens = paren_counts.iter().any(|&c| c !=\
    \ 0);\n        if has_leftover_parens {\n            nested_level += 1;\n    \
    \    }\n    }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `paren_count` in this scope\n  --> /tmp/tmprz2zgp9q.rs:13:17\n\
    \   |\n13 |                 paren_count += 1;\n   |                 ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_counts`\n\nerror[E0425]:\
    \ cannot find value `paren_count` in this scope\n  --> /tmp/tmprz2zgp9q.rs:14:20\n\
    \   |\n14 |                 if paren_count >= nested_level {\n   |           \
    \         ^^^^^^^^^^^ help: a local variable with a similar name exists: `paren_counts`\n\
    \nerror[E0425]: cannot find value `paren_count` in this scope\n  --> /tmp/tmprz2zgp9q.rs:15:36\n\
    \   |\n15 |                     nested_level = paren_count;\n   |            \
    \                        ^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `paren_counts`\n\nerror[E0425]: cannot find value `paren_count` in this\
    \ scope\n  --> /tmp/tmprz2zgp9q.rs:18:17\n   |\n18 |                 paren_count\
    \ -= 1;\n   |                 ^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_counts`\n\nerror[E0425]: cannot find value `paren_count`\
    \ in this scope\n  --> /tmp/tmprz2zgp9q.rs:19:35\n   |\n19 |                 paren_counts.push(paren_count);\n\
    \   |                                   ^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `paren_counts`\n\nerror[E0425]: cannot find value `paren_count`\
    \ in this scope\n  --> /tmp/tmprz2zgp9q.rs:20:20\n   |\n20 |                 if\
    \ paren_count == 0 {\n   |                    ^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `paren_counts`\n\nerror[E0425]: cannot find value\
    \ `paren_count` in this scope\n  --> /tmp/tmprz2zgp9q.rs:24:16\n   |\n24 |   \
    \          Ok(paren_count)\n   |                ^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `paren_counts`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmprz2zgp9q.rs:12:16\n   |\n12 |  \
    \           if paren_string[idx] == '(' {\n   |                ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the foll"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens = Vec::new();\n    for paren in paren_string.split('\
    \ ').iter().cloned() {\n        if paren.starts_with('(') && paren.ends_with(')')\
    \ {\n            let level = 1usize;\n            for char in paren.to_lowercase().chars()\
    \ {\n                if char == '(' {\n                    level += 1;\n     \
    \           } else if char == ')' {\n                    level -= 1;\n       \
    \         }\n                if level == 0 {\n                    parens.push(level);\n\
    \                }\n            }\n        } else {\n            parens.push(0usize);\n\
    \        }\n    }\n    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmpuvb5xgg5.rs:8:42\n  |\n8 |     for paren\
    \ in paren_string.split(' ').iter().cloned() {\n  |                          \
    \                ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuvb5xgg5.rs:25:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n25 |     parens\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut nesting_levels = Vec::new();\n\
    \n    for paren in paren_string.chars() {\n        if paren == ')' {\n       \
    \     level += 1;\n            nesting_levels.push(level);\n        }\n\n    \
    \    if paren == '(' {\n            level -= 1;\n        }\n\n        if paren\
    \ == ' ' && level == 0 {\n            continue;\n        }\n\n        if level\
    \ != 0 {\n            level = 0;\n            continue;\n        }\n\n       \
    \ if paren == '(' && nesting_levels.len() == 1 {\n            nesting_levels.pop();\n\
    \        }\n\n        if paren == ')' && nesting_levels.len() == 1 {\n       \
    \     nesting_levels.pop();\n        }\n    }\n\n    nesting_levels.iter().filter_map(|level|\
    \ level == Some(1)).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&{integer}` with `Option<{integer}>`\n  -->\
    \ /tmp/tmp0kgfkrkz.rs:38:52\n   |\n38 |     nesting_levels.iter().filter_map(|level|\
    \ level == Some(1)).collect()\n   |                                          \
    \          ^^ no implementation for `&{integer} == Option<{integer}>`\n   |\n\
    \   = help: the trait `PartialEq<Option<{integer}>>` is not implemented for `&{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0kgfkrkz.rs:38:46\n\
    \   |\n38 |     nesting_levels.iter().filter_map(|level| level == Some(1)).collect()\n\
    \   |                                              ^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n\
    38 |     nesting_levels.iter().filter_map(|level| Some(level == Some(1))).collect()\n\
    \   |                                              +++++                +\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_counter = 0;\n    let mut nested_level =\
    \ 0;\n    let mut paren_pair = 0;\n    let mut paren_open = paren_pair;\n    let\
    \ mut paren_close = paren_pair;\n    let mut paren_counters = paren_string.char_indices();\n\
    \    let mut paren_counter_next = paren_counters.next().unwrap();\n\n    for paren_counter_next2\
    \ in paren_counters {\n        let paren_counter = paren_counter_next.index();\n\
    \        if paren_counter < paren_open {\n            continue;\n        }\n \
    \       if paren_counter_next.index() < paren_close {\n            paren_close\
    \ = paren_counter_next.index();\n        } else {\n            paren_counter =\
    \ paren_counter_next.index();\n            paren_open -= 1;\n            paren_close\
    \ -= 1;\n            nested_level += 1;\n        }\n        let mut paren_level\
    \ = paren_counter - paren_open;\n        if paren_level > nested_level {\n   \
    \         nested_level = paren_level;\n        }\n        paren_pair -= 1;\n \
    \   }\n    vec![nested_level]\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmphutbejl9.rs:16:48\n   |\n16 |         let paren_counter\
    \ = paren_counter_next.index();\n   |                                        \
    \        ^^^^^ method not found in `(usize, char)`\n\nerror[E0599]: no method\
    \ named `index` found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmphutbejl9.rs:20:31\n\
    \   |\n20 |         if paren_counter_next.index() < paren_close {\n   |      \
    \                         ^^^^^ method not found in `(usize, char)`\n\nerror[E0599]:\
    \ no method named `index` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmphutbejl9.rs:21:46\n   |\n21 |             paren_close = paren_counter_next.index();\n\
    \   |                                              ^^^^^ method not found in `(usize,\
    \ char)`\n\nerror[E0599]: no method named `index` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmphutbejl9.rs:23:48\n   |\n23 |          \
    \   paren_counter = paren_counter_next.index();\n   |                        \
    \                        ^^^^^ method not found in `(usize, char)`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = paren_string.chars().count(|c| *c\
    \ != '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n  \
    \  paren_count += paren_string.chars().count(|c| *c == '(');\n    paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n\
    \    paren_count += paren_string.chars().count(|c| *c == '(');\n    paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n\
    \    paren_count += paren_string.chars().count(|c| *c == '(');\n    paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n\
    \    paren_count += paren_string.chars().count(|c| *c == '(');\n    paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n\
    \    paren_count += paren_string.chars().count(|c| *c == '(');\n    paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n\
    \    paren_count += paren_string.chars().count(|c| *c == '(');\n    paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    paren_count += paren_string.chars().count(|c| *c == ')');\n\
    \    paren_count \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmps4gxly3x.rs:7:55\n\
    \  |\n7 |     let mut paren_count = paren_string.chars().count(|c| *c != '(');\n\
    \  |                                                       ^ consider giving this\
    \ closure parameter a type\n  |\n  = note: type must be known at this point\n\n\
    error[E0061]: this function takes 0 arguments but 1 argument was supplied\n  \
    \ --> /tmp/tmps4gxly3x.rs:7:48\n    |\n7   |     let mut paren_count = paren_string.chars().count(|c|\
    \ *c != '(');\n    |                                                ^^^^^ -------------\
    \ supplied 1 argument\n    |                                                |\n\
    \    |                                                expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n   --> /tmp/tmps4gxly3x.rs:8:41\n \
    \   |\n8   |     paren_count += paren_string.chars().count(|c| *c == ')');\n \
    \   |                                         ^^^^^ ------------- supplied 1 argument\n\
    \    |                                         |\n    |                      \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmps4gxly3x.rs:9:41\n    |\n9   |     paren_count += paren_string.chars().count(|c|\
    \ *c == '(');\n    |                                         ^^^^^ -------------\
    \ supplied 1 argument\n    |                                         |\n    |\
    \                                         expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmps4gxly3x.rs:10:41\n    |\n10  |     paren_count\
    \ += paren_string.chars().count(|c| *c == ')');\n    |                       \
    \                  ^^^^^ ------------- supplied 1 argument\n    |            \
    \                             |\n    |                                       \
    \  expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .chars()\n\
    \        .map(|c| match c {\n            '(' => 1,\n            ')' => 1,\n  \
    \          '(' | ')' => 0,\n            _ => 0,\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpmxnrpy87.rs:9:10\n  |\n9 |         .chars()\n\
    \  |          ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut pos = 0;\n    let mut nesting_level = 1;\n    let\
    \ mut par_level: Vec<isize> = vec![0];\n    let mut par_open = vec![0];\n\n  \
    \  while pos < paren_string.len() {\n        let char = paren_string[pos];\n \
    \       match char {\n            '(' | '[' | '{'| ')' => {\n                par_open.push(nesting_level);\n\
    \                if nesting_level > par_level.get(par_level.length - 1).unwrap()\
    \ {\n                    par_level.push(nesting_level);\n                }\n \
    \               nesting_level += 1;\n                par_level.push(nesting_level);\n\
    \            }\n            _ => {\n                nesting_level -= 1;\n    \
    \            par_open.push(nesting_level);\n            }\n        }\n       \
    \ pos += 1;\n    }\n    par_level.reverse()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbdayea5k.rs:13:20\n\
    \   |\n13 |         let char = paren_string[pos];\n   |                    ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0609]: no field `length` on type `Vec<isize>`\n  --> /tmp/tmpbdayea5k.rs:17:60\n\
    \   |\n17 |                 if nesting_level > par_level.get(par_level.length\
    \ - 1).unwrap() {\n   |                                                      \
    \      ^^^^^^ unknown field\n\nerror[E0277]: can't compare `{integer}` with `&_`\n\
    \  --> /tmp/tmpbdayea5k.rs:17:34\n   |\n17 |                 if nesting_level\
    \ > par_level.get(par_level.length - 1).unwrap() {\n   |                     \
    \             ^ no implementation for `{integer} < &_` and `{integer} > &_`\n\
    \   |\n   = help: the trait `PartialOrd<&_>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdayea5k.rs:30:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n30 |     par_level.reverse()\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E027"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level_count = Vec::new();\n    let mut level_queue\
    \ = Vec::new();\n    let mut paren_count = 0;\n    let mut paren_queue = Vec::new();\n\
    \    let mut paren_end_queue = Vec::new();\n    level_queue.push(paren_count);\n\
    \    for paren in paren_string.chars() {\n        if paren == ')' {\n        \
    \    paren_end_queue.push(paren_count);\n        }\n        level_queue.push(0);\n\
    \    }\n    paren_queue.push(paren_count);\n    let mut nesting_level = 0;\n \
    \   while level_queue.len() != 0 {\n        let level = level_queue.pop();\n \
    \       let mut paren_level = paren_queue.pop();\n        if level != paren_level\
    \ {\n            break;\n        }\n        if level_queue.len() == 0 {\n    \
    \        nesting_level = level;\n        }\n        if paren_queue.len() == 0\
    \ {\n            nesting_level = level;\n        }\n        level_count += level;\n\
    \        level_queue.push(level);\n        paren_count += level;\n        paren_queue.push(level);\n\
    \    }\n    let mut levels = Vec::new();\n    for _ in 0..level_count {\n    \
    \    levels.push(nesting_level);\n    }\n    levels.reverse();\n    levels\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2bkbhp52.rs:28:29\n   |\n\
    20 |     let mut nesting_level = 0;\n   |                             - expected\
    \ due to this value\n...\n28 |             nesting_level = level;\n   |      \
    \                       ^^^^^ expected integer, found enum `Option`\n   |\n  \
    \ = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2bkbhp52.rs:31:29\n   |\n20 |\
    \     let mut nesting_level = 0;\n   |                             - expected\
    \ due to this value\n...\n31 |             nesting_level = level;\n   |      \
    \                       ^^^^^ expected integer, found enum `Option`\n   |\n  \
    \ = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<_>`\n\
    \  --> /tmp/tmp2bkbhp52.rs:33:9\n   |\n33 |         level_count += level;\n  \
    \ |         -----------^^^^^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bkbhp52.rs:34:26\n\
    \   |\n34 |         level_queue.push(level);\n   |                          ^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<{integer}>`\n\nerror[E0277]: cannot add-assign\
    \ `Option<{integer}>` to `{integer}`\n  --> /tmp/tmp2bkbhp52.rs:35:21\n   |\n\
    35 |         paren_count += level;\n   |                     ^^ no implementation\
    \ for `{integer} += Option<{integer}>`\n   |\n   = help: the trait `AddAssign<Option<{integer}>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2bkbhp52.rs:36:26\n\
    \   |\n36 |         paren_"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .lines()\n        .filter_map(|line|\
    \ line.parse::<isize>())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0on3m2wd.rs:9:28\n  |\n9 |\
    \         .filter_map(|line| line.parse::<isize>())\n  |                     \
    \       ^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found enum `Result`\n  |\n\
    \  = note: expected enum `Option<_>`\n             found enum `Result<isize, ParseIntError>`\n\
    help: try wrapping the expression in `Some`\n  |\n9 |         .filter_map(|line|\
    \ Some(line.parse::<isize>()))\n  |                            +++++         \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level: isize = 1;\n    let mut pos = 0;\n    let\
    \ mut paren_level = 0;\n    let mut parens: Vec<isize> = Vec::new();\n    let\
    \ mut chars: Vec<char> = paren_string.chars().collect();\n    while paren_level\
    \ != 0 && pos < paren_string.len() {\n        let char = chars[pos];\n       \
    \ paren_level += match char {\n            '(' | ')' => level + 1,\n         \
    \   _ => level,\n        };\n        pos += 1;\n    }\n    paren_level\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3gse_zld.rs:20:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20 |     paren_level\n   |     ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut nest_levels: Vec<_> = paren_string.split_whitespace().filter_map(|c|\
    \ match c {\n        '(' => {\n            level += 1;\n            Some(level)\n\
    \        }\n        ')' => level -= 1,\n        _ => None,\n    }).collect();\n\
    \    nest_levels.sort_unstable();\n    nest_levels.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphshptsly.rs:9:9\n  |\n8 |\
    \     let mut nest_levels: Vec<_> = paren_string.split_whitespace().filter_map(|c|\
    \ match c {\n  |                                                             \
    \                           - this expression has type `&str`\n9 |         '('\
    \ => {\n  |         ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphshptsly.rs:13:9\n   |\n8  |     let mut nest_levels: Vec<_>\
    \ = paren_string.split_whitespace().filter_map(|c| match c {\n   |           \
    \                                                                            \
    \ - this expression has type `&str`\n...\n13 |         ')' => level -= 1,\n  \
    \ |         ^^^ expected `str`, found `char`\n\nerror[E0308]: `match` arms have\
    \ incompatible types\n  --> /tmp/tmphshptsly.rs:13:16\n   |\n8  |       let mut\
    \ nest_levels: Vec<_> = paren_string.split_whitespace().filter_map(|c| match c\
    \ {\n   |  __________________________________________________________________________________-\n\
    9  | |         '(' => {\n10 | |             level += 1;\n11 | |             Some(level)\n\
    \   | |             ----------- this is found to be of type `Option<{integer}>`\n\
    12 | |         }\n13 | |         ')' => level -= 1,\n   | |                ^^^^^^^^^^\
    \ expected enum `Option`, found `()`\n14 | |         _ => None,\n15 | |     }).collect();\n\
    \   | |_____- `match` arms have incompatible types\n   |\n   = note:   expected\
    \ enum `Option<{integer}>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups: Vec<isize> = Vec::new();\n    let\
    \ mut level = 0;\n    let mut index = 0;\n    let mut string_to_parse = paren_string;\n\
    \    while string_to_parse != \"\" {\n        // check if current character is\
    \ a paren\n        if string_to_parse[..1] == \"(\" {\n            level += 1;\n\
    \        }\n        if string_to_parse[..1] == \")\" {\n            if level >\
    \ 1 {\n                level -= 1;\n            }\n        }\n        // if current\
    \ character is a space then increment index\n        if string_to_parse[..1] ==\
    \ \" \" {\n            index += 1\n        }\n        // append index to current\
    \ paren_group and set paren_groups to index\n        paren_groups.push(index);\n\
    \        string_to_parse = &string_to_parse[1..];\n    }\n    // return the deepest\
    \ level of nesting \n    paren_groups\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpkxt6pekc.rs:13:33\n\
    \   |\n13 |         if string_to_parse[..1] == \"(\" {\n   |                 \
    \                ^^ no implementation for `str == &str`\n   |\n   = help: the\
    \ trait `PartialEq<&str>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `str` with `&str`\n  -->\
    \ /tmp/tmpkxt6pekc.rs:16:33\n   |\n16 |         if string_to_parse[..1] == \"\
    )\" {\n   |                                 ^^ no implementation for `str == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `str` with `&str`\n  --> /tmp/tmpkxt6pekc.rs:22:33\n   |\n22 |         if string_to_parse[..1]\
    \ == \" \" {\n   |                                 ^^ no implementation for `str\
    \ == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented for\
    \ `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![0];\n    let mut pos = paren_string.find('(');\n\
    \    while pos != String::npos {\n        levels.push(levels[levels.len()-1]);\n\
    \        let pos = paren_string.find(')', pos+1);\n    }\n    levels.push(levels.len());\n\
    \    levels.iter()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n --> /tmp/tmp6he_757k.rs:9:26\n  |\n9 |     while\
    \ pos != String::npos {\n  |                          ^^^^ function or associated\
    \ item not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmp6he_757k.rs:11:45\n   |\n11 |         let pos = paren_string.find(')',\
    \ pos+1);\n   |                                          ---^- {integer}\n   |\
    \                                          |\n   |                           \
    \               Option<usize>\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmp6he_757k.rs:11:32\n     |\n11\
    \   |         let pos = paren_string.find(')', pos+1);\n     |               \
    \                 ^^^^ ---  ----- supplied 2 arguments\n     |               \
    \                 |\n     |                                expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6he_757k.rs:14:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n14 |     levels.iter()\n\
    \   |     ^^^^^^^^^^^^^ expected struct `Vec`, found struct `std::slice::Iter`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `std::slice::Iter<'_,\
    \ usize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308, E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.trim().split('\\n')\n        .map(|e| e.chars().filter(|c|\
    \ !c.is_whitespace()).count())\n        .max()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwdga0eo1.rs:7:5\n  |\n6 |\
    \   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |        \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n7 | /     paren_string.trim().split('\\n')\n8 | |         .map(|e|\
    \ e.chars().filter(|c| !c.is_whitespace()).count())\n9 | |         .max()\n  |\
    \ |______________^ expected struct `Vec`, found enum `Option`\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n               found enum `Option<usize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<Vec<usize>> = vec![];\n    let mut paren_level\
    \ = 0;\n\n    for ch in paren_string.chars() {\n        match ch {\n         \
    \   ' ' => continue,\n            '(' | ')' | ')(' => {\n                let mut\
    \ levels = vec![];\n                for paren_level in stack.pop() {\n       \
    \             levels.push(paren_level + 1);\n                }\n             \
    \   stack.push(levels);\n                paren_level = 0;\n            },\n  \
    \          _ => paren_level += 1,\n        }\n    }\n\n    stack.pop().into_iter().map(|level|\
    \ level.last()).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpmdtep5iq.rs:13:25\n\
    \   |\n13 |             '(' | ')' | ')(' => {\n   |                         ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    13 |             '(' | ')' | \")(\" => {\n   |                         ~~~~\n\n\
    error[E0369]: cannot add `{integer}` to `Vec<usize>`\n  --> /tmp/tmpmdtep5iq.rs:16:45\n\
    \   |\n16 |                     levels.push(paren_level + 1);\n   |          \
    \                       ----------- ^ - {integer}\n   |                      \
    \           |\n   |                                 Vec<usize>\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `Option<&usize>`\n    --> /tmp/tmpmdtep5iq.rs:25:55\n     |\n25   |\
    \     stack.pop().into_iter().map(|level| level.last()).collect()\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=Option<&usize>>`\n     |\n  \
    \   = help: the trait `FromIterator<Option<&usize>>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = vec![];\n    let mut opening_parentheses_level\
    \ = 1;\n    for (i, char) in paren_string.chars().enumerate() {\n        if char\
    \ == '(' {\n            result.push(opening_parentheses_level);\n            opening_parentheses_level\
    \ += 1;\n        } else if char == ')' {\n            opening_parentheses_level\
    \ -= 1;\n            if opening_parentheses_level == 0 {\n                break;\n\
    \            }\n        } else if opening_parentheses_level == 0 {\n         \
    \   break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2, 1, 2, 3, 1, 1, 2, 3, 2, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmppl6qiemu.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = vec![];\n    let mut level\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           stack.push(level);\n        }\n        if paren == ')' {\n       \
    \     stack.pop();\n        }\n        if paren == ' ' {\n            level +=\
    \ 1;\n        }\n    }\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp2egsgpkk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level_stack = vec![String::new()];\n    let mut\
    \ parens = vec![];\n    let mut level = 0;\n    let mut max_level = paren_string.len();\n\
    \    for c in paren_string.chars() {\n        let mut level_str = \"\";\n    \
    \    for _ in 0..(level - 1) {\n            level_str += \" \";\n        }\n \
    \       level_str += &c;\n        level_stack.push(level_str);\n        if parens.len()\
    \ == 0 {\n            parens.push(c);\n            continue;\n        }\n\n  \
    \      // check levels up\n        for ii in 0..(max_level - level_stack.len())\
    \ {\n            // pops up to max level\n            let current_level_str =\
    \ level_stack.pop();\n            if current_level_str == \"(\" && parens[parens.len()\
    \ - 1] == ')' {\n                parens.pop();\n                level += 1;\n\
    \                continue;\n            }\n            if current_level_str ==\
    \ \")\" && parens[parens.len() - 1] == \"(\" {\n                parens.pop();\n\
    \                level -= 1;\n                continue;\n            }\n     \
    \   }\n\n        // check levels down\n        for ii in 0..level_stack.len()\
    \ {\n            if level_stack[ii] == \"(\" && parens[ii] == ')' {\n        \
    \        parens.push(c);\n                level += 1;\n                continue;\n\
    \            }\n            if level_stack[ii] == \"(\" && parens[ii] == \"(\"\
    \ {\n                parens.push(c);\n                level += 1;\n          \
    \      continue;\n            }\n            if level_stack[ii] == \")\" && parens[ii]\
    \ == \")\" {\n                parens.push(c);\n                level -= 1;\n \
    \               continue;\n            }\n            if level_stack[ii] == \"\
    (\" && parens[ii] == c {\n                level += 1;\n                continue;\n\
    \            }\n            if level_stack[ii] == \"(\" && parens[ii] == \")\"\
    \ {\n                level -= 1;\n                continue;\n            }\n \
    \           if level_stack[ii] == \")\" && parens[ii] == c {\n               \
    \ level -= 1;\n                continue;\n            }\n        }\n    }\n  \
    \  parens.iter().map(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmphb5iswe1.rs:14:13\n   |\n14 |             level_str +=\
    \ \" \";\n   |             ---------^^^^^^^\n   |             |\n   |        \
    \     cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmphb5iswe1.rs:16:9\n   |\n\
    16 |         level_str += &c;\n   |         ---------^^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphb5iswe1.rs:17:26\n   |\n17 |         level_stack.push(level_str);\n\
    \   |                          ^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                          |\n   |                      \
    \    expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphb5iswe1.rs:27:37\n   |\n27 |             if current_level_str\
    \ == \"(\" && parens[parens.len() - 1] == ')' {\n   |                        \
    \             ^^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected\
    \ enum `Option<String>`\n           found reference `&'static str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphb5iswe1.rs:32:37\n   |\n32 |             if\
    \ current_level_str == \")\" && parens[parens.len() - 1] == \"(\" {\n   |    \
    \                                 ^^^ expected enum `Option`, found `&str`\n \
    \  |\n   = note:   expected enum `Option<String>`\n           found reference\
    \ `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb5iswe1.rs:32:72\n\
    \   |\n32 |             if current_level_str == \")\" && parens[parens.len() -\
    \ 1] == \"(\" {\n   |                                                        \
    \                ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to\
    \ write a `char` literal, use single quotes\n   |\n32 |             if current_level_str\
    \ == \")\" && parens[parens.len() - 1] == '(' {\n   |                        \
    \                                                ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphb5iswe1.rs:46:56\n   |\n46 |             if level_stack[ii]\
    \ == \"("
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens: Vec<isize> = Vec::new();\n    let mut paren_depth\
    \ = isize::MAX;\n    let mut bracket_depth = isize::MAX;\n\n    let mut index\
    \ = 0;\n    let mut paren_char = None;\n\n    while index < paren_string.len()\
    \ {\n        paren_char = paren_string.chars().nth(index);\n        if paren_char\
    \ != Some('(') {\n            break;\n        }\n\n        index += 1;\n\n   \
    \     let mut open_paren_depth = isize::MAX;\n        let mut index = 1;\n   \
    \     while index < paren_string.len() {\n            let paren_char = paren_string.chars().nth(index);\n\
    \n            if paren_char == Some('(') {\n                open_paren_depth +=\
    \ 1;\n            } else if paren_char == Some(')') {\n                if open_paren_depth\
    \ > paren_depth {\n                    paren_depth += 1;\n                }\n\
    \            }\n\n            paren_char = paren_string.chars().nth(index);\n\
    \            index = index + 1;\n        }\n\n        if open_paren_depth >= paren_depth\
    \ {\n            parens.push(paren_depth);\n        }\n        paren_depth = open_paren_depth;\n\
    \    }\n\n    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `bracket_depth`\n --> /tmp/tmpv8hhy95v.rs:9:13\n\
    \  |\n9 |     let mut bracket_depth = isize::MAX;\n  |             ^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_bracket_depth`\n\
    \  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: value assigned\
    \ to `paren_char` is never read\n  --> /tmp/tmpv8hhy95v.rs:12:13\n   |\n12 | \
    \    let mut paren_char = None;\n   |             ^^^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `paren_char` is never read\n\
    \  --> /tmp/tmpv8hhy95v.rs:35:13\n   |\n35 |             paren_char = paren_string.chars().nth(index);\n\
    \   |             ^^^^^^^^^^\n   |\n   = help: maybe it is overwritten before\
    \ being read?\n\nwarning: variable does not need to be mutable\n --> /tmp/tmpv8hhy95v.rs:9:9\n\
    \  |\n9 |     let mut bracket_depth = isize::MAX;\n  |         ----^^^^^^^^^^^^^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign twice to immutable variable `paren_char`\n\
    \  --> /tmp/tmpv8hhy95v.rs:35:13\n   |\n25 |             let paren_char = paren_string.chars().nth(index);\n\
    \   |                 ----------\n   |                 |\n   |               \
    \  first assignment to `paren_char`\n   |                 help: consider making\
    \ this binding mutable: `mut paren_char`\n...\n35 |             paren_char = paren_string.chars().nth(index);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror: aborting due to previous error; 4 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut open = 1;\n    let mut level = 1;\n    let mut\
    \ open_parens = vec![false; paren_string.len()];\n    let mut closed_parens =\
    \ vec![false; paren_string.len()];\n    let mut parens = 0;\n\n    let mut strings\
    \ = paren_string.split_whitespace();\n    for string in strings {\n        if\
    \ parens > level {\n            return vec![level];\n        }\n\n        if string\
    \ == \"(\" {\n            open_parens[parens].push(true);\n            open +=\
    \ 1;\n        } else {\n            closed_parens[parens].push(true);\n      \
    \      open -= 1;\n        }\n\n        parens += 1;\n    }\n\n    while open\
    \ > 0 {\n        if open > level {\n            return vec![level];\n        }\n\
    \n        open_parens[parens].push(true);\n        open -= 1;\n        parens\
    \ += 1;\n    }\n\n    while closed_parens[parens].contains(false) {\n        closed_parens[parens]\
    \ = vec![true; parens];\n    }\n\n    let mut i = 0;\n    let mut res = vec![level];\n\
    \n    while !open_parens[parens].contains(false) {\n        level += 1;\n    \
    \    res.insert(0, level);\n\n        if !closed_parens[parens].contains(true)\
    \ {\n            i += 1;\n        }\n\n        if i == parens {\n            return\
    \ res;\n        }\n\n        i += 1;\n    }\n\n    res\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpdrfor6ze.rs:20:13\n\
    \   |\n20 |             open_parens[parens].push(true);\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpdrfor6ze.rs:23:13\n\
    \   |\n23 |             closed_parens[parens].push(true);\n   |             ^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpdrfor6ze.rs:35:9\n\
    \   |\n35 |         open_parens[parens].push(true);\n   |         ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpdrfor6ze.rs:40:11\n\
    \   |\n40 |     while closed_parens[parens].contains(false) {\n   |          \
    \ ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\
    \nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpdrfor6ze.rs:41:9\n\
    \   |\n41 |         closed_parens[parens] = v"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count: usize = 0;\n    let mut paren_level:\
    \ usize = 0;\n\n    let mut paren_string = paren_string.trim();\n    while paren_string.len()\
    \ != 0 {\n        if paren_string.ends_with(')') {\n            paren_count -=\
    \ 1;\n            paren_level -= 1;\n            if paren_level == 0 {\n     \
    \           break;\n            }\n        }\n        if paren_string.ends_with('(')\
    \ {\n            paren_count += 1;\n            paren_level += 1;\n        }\n\
    \        paren_string = paren_string.trim();\n    }\n    paren_count + 1\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5sxxshk5.rs:25:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     paren_count + 1\n   |     ^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .trim()\n        .chars()\n     \
    \   .filter_map(|c| match c {\n            '(' | ')' => None,\n            _ =>\
    \ {\n                // Find the index of first closed parenthesis\n         \
    \       let pos = paren_string.char_indices()\n                    .flat_map(|(_,\
    \ index)| index..)\n                    .find(|i| paren_string[i] == c.to_byte());\n\
    \                Some(pos)\n            }\n        })\n        .collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `&char`\n  --> /tmp/tmpr51tkbrm.rs:16:31\n\
    \   |\n16 |                     .find(|i| paren_string[i] == c.to_byte());\n \
    \  |                               ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `&char`\n   |\n   = help: the trait `Index<&char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `to_byte` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpr51tkbrm.rs:16:52\n   |\n16 |             \
    \        .find(|i| paren_string[i] == c.to_byte());\n   |                    \
    \                                ^^^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `Option<char>`\n    --> /tmp/tmpr51tkbrm.rs:20:10\n     |\n20   |  \
    \       .collect::<Vec<isize>>()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=Option<char>>`\n     |\n    \
    \ = help: the trait `FromIterator<Option<char>>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .zip(paren_string.chars().skip(1))\n\
    \        .filter_map(|(c, c_1)| c.is_digit(c_1) || c == '(')\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_8gdcvxb.rs:10:43\n   |\n\
    10 |         .filter_map(|(c, c_1)| c.is_digit(c_1) || c == '(')\n   |       \
    \                                    ^^^ expected `u32`, found `char`\n   |\n\
    help: you can cast a `char` to a `u32`, since a `char` always occupies 4 bytes\n\
    \   |\n10 |         .filter_map(|(c, c_1)| c.is_digit(c_1 as u32) || c == '(')\n\
    \   |                                               ++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_8gdcvxb.rs:10:32\n   |\n10 |         .filter_map(|(c,\
    \ c_1)| c.is_digit(c_1) || c == '(')\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |         .filter_map(|(c, c_1)| Some(c.is_digit(c_1) || c == '('))\n\
    \   |                                +++++                           +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.trim().chars().enumerate().filter_map(|(i,\
    \ c)| {\n        if c == '(' {\n            Some(i - 1)\n        } else if c ==\
    \ ')' {\n            Some(i + 1)\n        } else {\n            None\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpy8f6jq57.rs:15:8\n     |\n15\
    \   |     }).collect()\n     |        ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut output: Vec<isize>\
    \ = Vec::new();\n    for group in paren_string.chars().filter_map(|c| {\n    \
    \    let is_open = c.is_open();\n        let next_level = if is_open {\n     \
    \       level + 1\n        } else {\n            level\n        };\n        if\
    \ is_open && next_level > level {\n            level = next_level;\n         \
    \   1\n        } else {\n            0\n        }\n    }) {\n        output.push(level);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_open` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8eafzebp.rs:10:25\n   |\n10 |         let is_open = c.is_open();\n\
    \   |                         ^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8eafzebp.rs:18:13\n   |\n18 |             1\n\
    \   |             ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n18 |             Some(1)\n   |             +++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8eafzebp.rs:20:13\n   |\n\
    20 |             0\n   |             ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n20 |             Some(0)\n\
    \   |             +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8eafzebp.rs:23:21\n\
    \   |\n23 |         output.push(level);\n   |                     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |         output.push(level.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut level = 0;\n    let mut open_parens = 0;\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            open_parens += 1;\n            paren_stack.push(level);\n\
    \            level += 1;\n        }\n        if ch == ')' {\n            if level\
    \ == 0 {\n                return Err(general_err!(\"Invalid input: unexpected\
    \ unmatched parenthesis\"));\n            }\n            level -= 1;\n       \
    \     open_parens -= 1;\n        }\n        if open_parens < 0 {\n           \
    \ return Err(general_err!(\"Invalid input: unmatched parenthesis\"));\n      \
    \  }\n    }\n    if open_parens == 0 {\n        return Err(general_err!(\"Invalid\
    \ input: unmatched parenthesis\"));\n    }\n    paren_stack\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `general_err` in this scope\n  --> /tmp/tmpl0bp2pet.rs:18:28\n\
    \   |\n18 |                 return Err(general_err!(\"Invalid input: unexpected\
    \ unmatched parenthesis\"));\n   |                            ^^^^^^^^^^^\n\n\
    error: cannot find macro `general_err` in this scope\n  --> /tmp/tmpl0bp2pet.rs:24:24\n\
    \   |\n24 |             return Err(general_err!(\"Invalid input: unmatched parenthesis\"\
    ));\n   |                        ^^^^^^^^^^^\n\nerror: cannot find macro `general_err`\
    \ in this scope\n  --> /tmp/tmpl0bp2pet.rs:28:20\n   |\n28 |         return Err(general_err!(\"\
    Invalid input: unmatched parenthesis\"));\n   |                    ^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl0bp2pet.rs:18:24\n   |\n18 |\
    \                 return Err(general_err!(\"Invalid input: unexpected unmatched\
    \ parenthesis\"));\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Result`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found enum `Result<_, _>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // This code is based on the following pseudo code\n  \
    \  // for (string in paren_string)\n    // {\n    //     for (paren in (paren_string.substring(0+i,i+1)))\
    \ if (paren == \" \")\n    //     {\n    //         output_level++\n    //   \
    \  }\n    // }\n    let mut level = 0\n    let mut last_open_bracket = -1;\n \
    \   let mut last_close_bracket = -1;\n    for paren in paren_string.chars() {\n\
    \        if paren == ' ' {\n            level++;\n            last_close_bracket\
    \ = paren;\n        } else {\n            if paren == ')' {\n                if\
    \ level == 0 {\n                    break;\n                }\n              \
    \  if level > last_open_bracket {\n                    level -= 1;\n         \
    \           last_open_bracket = paren;\n                }\n            } else\
    \ if paren == ']' {\n                if level == 0 {\n                    break;\n\
    \                }\n                if level > last_close_bracket {\n        \
    \            level -= 1;\n                    last_close_bracket = paren;\n  \
    \              }\n            }\n        }\n    }\n    if last_close_bracket ==\
    \ -1 {\n        return Vec::new();\n    }\n    level += 1;\n    last_open_bracket;\n\
    \    level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp7yumkszv.rs:15:22\n\
    \   |\n15 |     let mut level = 0\n   |                      ^ help: add `;` here\n\
    16 |     let mut last_open_bracket = -1;\n   |     --- unexpected token\n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmp7yumkszv.rs:20:18\n  \
    \ |\n20 |             level++;\n   |                  ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n20 |             { let tmp = level; level\
    \ += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n20 -  \
    \           level++;\n20 +             level += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7yumkszv.rs:29:41\n   |\n16 |     let mut last_open_bracket\
    \ = -1;\n   |                                 -- expected due to this value\n\
    ...\n29 |                     last_open_bracket = paren;\n   |               \
    \                          ^^^^^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7yumkszv.rs:37:42\n   |\n17 |     let mut last_close_bracket\
    \ = -1;\n   |                                  -- expected due to this value\n\
    ...\n37 |                     last_close_bracket = paren;\n   |              \
    \                            ^^^^^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7yumkszv.rs:47:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n47 |     level\n\
    \   |     ^^^^^ expected struct `Vec`, found integer\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `{integer}`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nested_paren_levels = 0;\n    let mut paren_level_stack:\
    \ Vec<isize> = vec![];\n\n    let mut paren_chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_char: char = paren_chars.first().unwrap();\n\n    for paren_char\
    \ in paren_chars {\n        if paren_char == paren_chars[paren_chars.len() - 1].unwrap()\
    \ {\n            nested_paren_levels++;\n            paren_level_stack.push(nested_paren_levels);\n\
    \        }\n        nested_paren_levels = paren_level_stack.last().unwrap();\n\
    \n        paren_level_stack.pop();\n    }\n\n    paren_level_stack\n        .iter()\n\
    \        .enumerate()\n        .filter_map(|(index, value)| {\n            if\
    \ value == 1 {\n                Some(index)\n            } else {\n          \
    \      None\n            }\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp96kmsdll.rs:15:32\n\
    \   |\n15 |             nested_paren_levels++;\n   |                         \
    \       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    15 |             { let tmp = nested_paren_levels; nested_paren_levels += 1; tmp\
    \ };\n   |             +++++++++++                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    15 -             nested_paren_levels++;\n15 +             nested_paren_levels\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp96kmsdll.rs:11:32\n\
    \   |\n11 |     let mut paren_char: char = paren_chars.first().unwrap();\n   |\
    \                         ----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `&char`\n   |                         |\n   |                        \
    \ expected due to this\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    11 |     let mut paren_char: char = *paren_chars.first().unwrap();\n   |     \
    \                           +\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp96kmsdll.rs:14:61\n   |\n\
    14 |         if paren_char == paren_chars[paren_chars.len() - 1].unwrap() {\n\
    \   |                                                             ^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp96kmsdll.rs:18:31\n\
    \   |\n7  |     let mut nested_paren_levels = 0;\n   |                       \
    \            - expected due to this value\n...\n18 |         nested_paren_levels\
    \ = paren_level_stack.last().unwrap();\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |         nested_paren_levels = *paren_level_stack.last().unwrap();\n\
    \   |                               +\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp96kmsdll.rs:27:22\n   |\n27 |             if\
    \ value == 1 {\n   |                      ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut num_nested = 0;\n    let mut stack = Vec::new();\n\
    \    for ch in paren_string.chars() {\n        if ch == '(' {\n            stack.push(num_nested);\n\
    \        } else if ch == ')' {\n            stack.pop();\n        }\n        num_nested\
    \ += 1;\n    }\n    num_nested\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp20_rcf51.rs:17:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n17 |     num_nested\n   |     ^^^^^^^^^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `{integer}`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut pars = vec![paren_string.chars().filter_map(|c|\
    \ c == '(').collect::<Vec<char>>()].clone();\n    let mut i = paren_string.chars().filter_map(|c|\
    \ c == '(').count();\n    while i < paren_string.len() {\n        pars.insert(0,\
    \ paren_string[i..]);\n        i = paren_string.chars().filter_map(|c| c == '(').count();\n\
    \    }\n    pars.reverse();\n    pars.len()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmt1i5jp2.rs:7:61\n  |\n7 |\
    \     let mut pars = vec![paren_string.chars().filter_map(|c| c == '(').collect::<Vec<char>>()].clone();\n\
    \  |                                                             ^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n    \
    \         found type `bool`\nhelp: try wrapping the expression in `Some`\n  |\n\
    7 |     let mut pars = vec![paren_string.chars().filter_map(|c| Some(c == '(')).collect::<Vec<char>>()].clone();\n\
    \  |                                                             +++++       \
    \ +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmt1i5jp2.rs:8:53\n  |\n8 |\
    \     let mut i = paren_string.chars().filter_map(|c| c == '(').count();\n  |\
    \                                                     ^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n  |\n  = note: expected enum `Option<_>`\n             found type\
    \ `bool`\nhelp: try wrapping the expression in `Some`\n  |\n8 |     let mut i\
    \ = paren_string.chars().filter_map(|c| Some(c == '(')).count();\n  |        \
    \                                             +++++        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmt1i5jp2.rs:10:24\n   |\n10 |         pars.insert(0,\
    \ paren_string[i..]);\n   |                        ^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `str`\n   |\n   = note: expected struct `Vec<char>`\n  \
    \              found type `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmt1i5jp2.rs:11:49\n\
    \   |\n11 |         i = paren_string.chars().filter_map(|c| c == '(').count();\n\
    \   |                                                 ^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n11 |       \
    \  i = paren_string.chars().filter_map(|c| Some(c == '(')).count();\n   |    \
    \                                             +++++        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmt1i5jp2.rs:14:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut nestings = Vec::new();\n\
    \n    for paren in paren_string.chars() {\n        if paren == ')' {\n       \
    \     nestings.push(depth);\n            depth += 1;\n        }\n\n        if\
    \ paren == ']' {\n            nestings.push(depth);\n            depth -= 1;\n\
    \        }\n\n        if paren == '(' { depth += 1 }\n\n        if paren == ')'\
    \ { depth -= 1 }\n    }\n\n    nestings\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 3, 6, 6, 6, 7, 10, 10, 11, 12, 12]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgbqwce_m.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting_level = 0;\n    let mut paren_levels: Vec<isize>\
    \ = Vec::new();\n    for ch in paren_string.chars() {\n        match ch {\n  \
    \          '(' | ')' => {\n                paren_levels.push(nesting_level);\n\
    \                nesting_level = 0;\n            }\n            '(' | '{'  | ')'\
    \ => {\n                nesting_level += 1;\n            }\n            _ => {\n\
    \                nesting_level += 1;\n            }\n        }\n    }\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]`,\n\
    \ right: `[2, 3, 1, 3]`', /tmp/tmpig4l94o2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nestings = Vec::with_capacity(paren_string.len());\n\
    \    paren_string.split_whitespace().dedup().for_each(|x|\n        if x.is_empty()\
    \ {\n            nestings.push(0)\n        } else {\n            let mut nesting\
    \ = nestings.last();\n            let mut i = 0;\n            for _ in x.chars().take(nesting\
    \ as usize) {\n                nesting = nestings[nesting - 1] + 1;\n        \
    \        nestings.push(nesting);\n                i += 1;\n            }\n   \
    \         nestings.push(i);\n        }\n    );\n    nestings.sort_unstable();\n\
    \    nestings.rev();\n    nestings\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `dedup` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpx6xlybdi.rs:8:37\n  |\n8 |     paren_string.split_whitespace().dedup().for_each(|x|\n\
    \  |                                     ^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `Option<&{integer}>`\n  --> /tmp/tmpx6xlybdi.rs:15:44\n\
    \   |\n15 |                 nesting = nestings[nesting - 1] + 1;\n   |       \
    \                             ------- ^ - {integer}\n   |                    \
    \                |\n   |                                    Option<&{integer}>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx6xlybdi.rs:16:31\n   |\n16 |\
    \                 nestings.push(nesting);\n   |                              \
    \ ^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type\
    \ `{integer}`\n              found enum `Option<&{integer}>`\n\nerror[E0599]:\
    \ `Vec<{integer}>` is not an iterator\n   --> /tmp/tmpx6xlybdi.rs:23:14\n    |\n\
    23  |       nestings.rev();\n    |                ^^^ `Vec<{integer}>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<{integer}>: Iterator`\n            which is required by `&mut\
    \ Vec<{integer}>: Iterator`\n            `[{integer}]: Iterator`\n           \
    \ which is required by `&mut [{integer}]: Iterator`\n\nerror[E0605]: non-primitive\
    \ cast: `Option<&isize>` as `usize`\n  --> /tmp/tmpx6xlybdi.rs:14:37\n   |\n14\
    \ |             for _ in x.chars().take(nesting as usize) {\n   |            \
    \                         ^^^^^^^^^^^^^^^^ an `as` expression can only be used\
    \ to convert between primitive types or to coerce to a specific trait object\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599, E0605.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut nestings_left = 0usize;\n\
    \    let mut parens_level = 0usize;\n    for (i, char_ch) in paren_string.chars().enumerate()\
    \ {\n        if char_ch == '(' {\n            nestings_left += 1;\n          \
    \  parens_level += 1;\n        } else if char_ch == ')' {\n            nestings_left\
    \ -= 1;\n            level += 1;\n        } else {\n            level += 1;\n\
    \        }\n        if nestings_left <= 0 {\n            break;\n        }\n \
    \   }\n    parens_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkczprhlk.rs:24:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     parens_level\n   |     ^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `usize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parentheses_levels: Vec<isize> = vec![0; paren_string.len()];\n\
    \    let mut parentheses_level: isize = 0;\n    let mut paren_start = 0;\n   \
    \ let mut paren_end = paren_string.len() - 1;\n    let mut paren_level = 0;\n\
    \    let mut parens = 0;\n    loop {\n        // Move along the string until we\
    \ see a opening parentheses character\n        while paren_end >= paren_start\
    \ {\n            let char_to_match = paren_string[paren_end];\n            if\
    \ parens == 0 {\n                if char_to_match != '(' {\n                 \
    \   break;\n                }\n            }\n            parens += 1;\n     \
    \       parentheses_levels[paren_end] = parens;\n            paren_end -= 1;\n\
    \            paren_level += 1;\n            if char_to_match == '(' {\n      \
    \          parens += 1;\n                paren_level += 1;\n                paren_start\
    \ += 1;\n            }\n            if char_to_match == ')' {\n              \
    \  if parens == 1 {\n                    break;\n                } else {\n  \
    \                  parens -= 1;\n                    paren_level -= 1;\n     \
    \           }\n            }\n        }\n        if paren_start >= paren_end {\n\
    \            break;\n        }\n    }\n    parentheses_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb3ent7d9.rs:16:33\n\
    \   |\n16 |             let char_to_match = paren_string[paren_end];\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut ispunct\
    \ = false;\n    let mut paren_depth = 0;\n    let mut paren_depth_limit = 20;\n\
    \    let mut pos = 0;\n    for c in paren_string.chars() {\n        if paren_depth\
    \ == 0 {\n            if c == '(' {\n                ispunct = true;\n       \
    \     }\n            stack.push(c);\n        } else if paren_depth == paren_depth_limit\
    \ {\n            let top = stack.pop();\n            if c == '(' {\n         \
    \       ispunct = true;\n                paren_depth = paren_depth + 1;\n    \
    \        } else {\n                if stack.is_empty() {\n                   \
    \ return vec![];\n                }\n                let top = stack.pop();\n\
    \                if c == '[' {\n                    let top = stack.pop();\n \
    \                   if stack.is_empty() {\n                        return vec![];\n\
    \                    }\n                    let top = stack.pop();\n         \
    \           if stack.is_empty() {\n                        return vec![];\n  \
    \                  }\n                    if top != ']' {\n                  \
    \      stack.push(c);\n                    }\n                } else if stack.is_empty()\
    \ {\n                    return vec![];\n                }\n                if\
    \ top != '[' && top != '(' {\n                    stack.push(c);\n           \
    \     }\n            }\n        } else {\n            if c == '(' {\n        \
    \        ispunct = true;\n                paren_depth = paren_depth + 1;\n   \
    \         } else if c == '[' {\n                let top = stack.pop();\n     \
    \           if stack.is_empty() {\n                    return vec![];\n      \
    \          }\n                if top == '[' {\n                    let top = stack.pop();\n\
    \                    if stack.is_empty() {\n                        return vec![];\n\
    \                    }\n                    if top == '[' {\n                \
    \        let top = stack.pop();\n                        if stack.is_empty() {\n\
    \                            return vec![];\n                        }\n     \
    \                   let top = stack.pop();\n                        if stack.is_empty()\
    \ {\n                            return vec![];\n                        }\n \
    \                       if top != ']' {\n                            stack.push(c);\n\
    \                        }\n                    } else if top == '(' {\n     \
    \                   if stack.pop() != ')' {\n                            stack.push(c);\n\
    \                        }\n                    } else {\n                   \
    \     stack.push(c);\n                    }\n                } else if top !=\
    \ '[' {\n                    stack.push(c);\n                }\n            }\
    \ else if c == '{' || c == '}' {\n                let top = stack.pop();\n   \
    \             if stack.is_empty() {\n                    return vec![];\n    \
    \            }\n                if top == c {\n                    let top = stack.pop();\n\
    \                    if stack.is_empty() {\n                        return vec![];\n\
    \                    }\n                    if top == c {\n                  \
    \      let top = stack.pop();\n                        if stack.is_empty() {\n\
    \                            return vec![];\n                        }\n     \
    \                   if top == c {\n                            let top = \n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqbzy1za4.rs:107:3\n\
    \    |\n6   | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n \
    \   |                                                            - unclosed delimiter\n\
    ...\n12  |     for c in paren_string.chars() {\n    |                        \
    \           - unclosed delimiter\n...\n47  |         } else {\n    |         \
    \       - unclosed delimiter\n...\n83  |             } else if c == '{' || c ==\
    \ '}' {\n    |                                            - unclosed delimiter\n\
    ...\n88  |                 if top == c {\n    |                             -\
    \ unclosed delimiter\n...\n93  |                     if top == c {\n    |    \
    \                             - unclosed delimiter\n...\n98  |               \
    \          if top == c {\n    |                                     - this delimiter\
    \ might not be properly closed...\n99  |                             let top =\
    \ \n100 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n107 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpqbzy1za4.rs:100:1\n\
    \    |\n100 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqbzy1za4.rs:17:24\n   |\n17 |             stack.push(c);\n   |\
    \                        ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqbzy1za4.rs:37:31\n   |\n37 |                     if top\
    \ != ']' {\n   |                               ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbzy1za4.rs:38:36\n\
    \   |\n38 |                         stack.push(c);\n   |                     \
    \               ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqbzy1za4.rs:43:27\n   |\n43 |                 if top != '[' &&\
    \ top != '(' {\n   |                           ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<Vec<isize>> = vec![Vec::new(); paren_string.trim().chars().collect::<Vec<_>>()];\n\
    \n    let mut i = paren_string.find('(');\n    while i != None {\n        let\
    \ mut parens = stack.last();\n        let mut n = parens.len();\n\n        if\
    \ parens.len() > 0 {\n            parens[parens.len() - 1] += 1;\n        } else\
    \ {\n            parens.push(i);\n        }\n\n        stack = stack.pop().unwrap().to_owned();\n\
    \n        i += paren_string.find('(', i);\n    }\n\n    let mut level = 1;\n \
    \   let mut max_level = 1;\n    for parens in stack {\n        max_level = std::cmp::max(max_level,\
    \ level);\n        level += parens.last().unwrap();\n    }\n    max_level += 1;\n\
    \n    stack.into_iter().map(|vec| vec.last().unwrap()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq4e3pik9.rs:7:55\n  |\n7 |\
    \     let mut stack: Vec<Vec<isize>> = vec![Vec::new(); paren_string.trim().chars().collect::<Vec<_>>()];\n\
    \  |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `Vec`\n  |\n  = note: expected type `usize`\n\
    \           found struct `Vec<char>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpq4e3pik9.rs:12:28\n  \
    \ |\n12 |         let mut n = parens.len();\n   |                            ^^^\
    \ method not found in `Option<&Vec<isize>>`\n\nerror[E0599]: no method named `len`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpq4e3pik9.rs:14:19\n\
    \   |\n14 |         if parens.len() > 0 {\n   |                   ^^^ method not\
    \ found in `Option<&Vec<isize>>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpq4e3pik9.rs:15:27\n  \
    \ |\n15 |             parens[parens.len() - 1] += 1;\n   |                   \
    \        ^^^ method not found in `Option<&Vec<isize>>`\n\nerror[E0599]: no method\
    \ named `push` found for enum `Option` in the current scope\n  --> /tmp/tmpq4e3pik9.rs:17:20\n\
    \   |\n17 |             parens.push(i);\n   |                    ^^^^ method not\
    \ found in `Option<&Vec<isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4e3pik9.rs:20:17\n\
    \   |\n7  |     let mut stack: Vec<Vec<isize>> = vec![Vec::new(); paren_string.trim().chars().collect::<Vec<_>>()];\n\
    \   |                    --------------- expected due to this type\n...\n20 |\
    \         stack = stack.pop().unwrap().to_owned();\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpq4e3pik9.rs:22:27\n\
    \     |\n22   |         i += paren_string.find('(', i);\n     |              \
    \             ^^^^ ---  - supplied 2 arguments\n     |               "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut index = 0;\n    while\
    \ index < paren_string.len() {\n        match paren_string[index] {\n        \
    \    '(' => {\n                let mut level = 1;\n                while level\
    \ < levels.size() {\n                    if levels[level - 1] >= levels[level]\
    \ {\n                        levels[level] += 1;\n                        break;\n\
    \                    }\n                    level += 1;\n                }\n \
    \               levels.push(level);\n            }\n            ')' => {\n   \
    \             let level = levels.last().unwrap();\n                while level\
    \ > 0 {\n                    levels[level - 1] -= 1;\n                    level\
    \ -= 1;\n                }\n            }\n            _ => {\n              \
    \  index += 1;\n            }\n        }\n        index += 1;\n    }\n    levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn7vb1yx0.rs:10:15\n\
    \   |\n10 |         match paren_string[index] {\n   |               ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `size` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpn7vb1yx0.rs:13:38\n   |\n13 |          \
    \       while level < levels.size() {\n   |                                  \
    \    ^^^^ help: there is an associated function with a similar name: `resize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn7vb1yx0.rs:24:31\n   |\n24 |\
    \                 while level > 0 {\n   |                               ^\n  \
    \ |                               |\n   |                               expected\
    \ `&usize`, found integer\n   |                               help: consider borrowing\
    \ here: `&0`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `&usize`\n  --> /tmp/tmpn7vb1yx0.rs:26:21\n   |\n26 |              \
    \       level -= 1;\n   |                     -----^^^^^\n   |               \
    \      |\n   |                     cannot use `-=` on type `&usize`\n   |\nhelp:\
    \ `-=` can be used on `usize`, you can dereference `level`\n   |\n26 |       \
    \              *level -= 1;\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn7vb1yx0.rs:35:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n35 |     levels\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expect"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars().map(|c| {\n        if c == '(' {\n\
    \            1\n        } else if c == ')' {\n            -1\n        } else {\n\
    \            0\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, -1, 1, -1, -1, 0, 1, 1, 1, -1, -1, -1, 0, 1, -1, 0, 1, 1, 1, -1, -1,\
    \ 1, -1, 1, -1, -1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpjhwxtzes.rs:20:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split_whitespace().filter(|c| !c.is_digit()).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_digit` found for reference `&&str` in\
    \ the current scope\n --> /tmp/tmp8hhzg3x0.rs:7:51\n  |\n7 |     paren_string.split_whitespace().filter(|c|\
    \ !c.is_digit()).collect()\n  |                                              \
    \     ^^^^^^^^ method not found in `&&str`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&str`\n    --> /tmp/tmp8hhzg3x0.rs:7:63\n\
    \     |\n7    |     paren_string.split_whitespace().filter(|c| !c.is_digit()).collect()\n\
    \     |                                                               ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars()\n        .enumerate()\n        .map(|(i,\
    \ c)| {\n            if c == '(' {\n                i + 1 // start counting from\
    \ 1 instead of 0\n            } else {\n                0\n            }\n   \
    \     })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpsj7vn35o.rs:16:10\n     |\n16\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut paren_level = 0;\n\
    \n    for c in paren_string.chars() {\n        if c == ')' {\n            stack.pop();\n\
    \            if stack.len() < paren_level {\n                stack.push(paren_level);\n\
    \                paren_level += 1;\n            }\n        } else {\n        \
    \    if stack.len() == 0 {\n                stack.push(paren_level);\n       \
    \         paren_level += 1;\n            }\n\n            stack.push(0);\n   \
    \     }\n    }\n\n    stack.pop();\n\n    let mut levels = Vec::new();\n\n   \
    \ while stack.len() > 0 {\n        levels.push(stack.pop());\n    }\n\n    levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpofgyenq7.rs:35:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     levels\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<usize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut rev_paren_string = paren_string.to_owned().chars().collect::<String>();\n\
    \    rev_paren_string.reverse();\n\n    // initialize our stack to an empty vector\n\
    \    let mut max_level = vec![];\n    for i in 0..paren_string.len() - 1 {\n \
    \       // push each character in our reverse string onto our stack\n        let\
    \ level = max_level.len();\n        if paren_string[i] == '(' {\n            max_level.push(level);\n\
    \        } else if paren_string[i] == ')' {\n            max_level.pop();\n  \
    \      } else {\n            max_level[level] = max_level[level - 1] + 1;\n  \
    \      }\n    }\n\n    // return the current stack size\n    max_level[max_level.len()\
    \ - 1]\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n --> /tmp/tmprq46khkn.rs:8:22\n  |\n8 |     rev_paren_string.reverse();\n\
    \  |                      ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmprq46khkn.rs:15:12\n   |\n15 |         if paren_string[i]\
    \ == '(' {\n   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprq46khkn.rs:17:19\n   |\n17 |         } else if paren_string[i]\
    \ == ')' {\n   |                   ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprq46khkn.rs:25:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n25 |     max_level[max_level.len() - 1]\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<isize>"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .rsplit(\" \", 2)\n        .into_iter()\n\
    \        .filter_map(|s| s.parse().ok())\n        .map(|s| s.parse::<isize>().unwrap())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpkrvis1i8.rs:8:10\n     |\n8    |         .rsplit(\" \", 2)\n\
    \     |          ^^^^^^ ---  - supplied 2 arguments\n     |          |\n     |\
    \          expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = Vec::new();\n    let mut level =\
    \ 0;\n    let mut i = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            paren_count.push(level);\n            level += 1;\n     \
    \   } else if c == ')' {\n            level -= 1;\n        }\n        i += 1;\n\
    \    }\n    paren_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 1, 2, 0, 0, 1, 2, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpcuoy0a8_.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut groups = paren_string.split_whitespace();\n   \
    \ let mut num_nestings = 0;\n    let mut max_nesting = 0;\n    let mut max_nesting_level\
    \ = 0;\n\n    for group in &mut groups {\n        if group == '{' || group ==\
    \ '}' || group == ')' || group == ']' {\n            // end of group\n       \
    \     if num_nestings == 0 {\n                // skip empty groups\n         \
    \       continue;\n            }\n            if group == '{' {\n            \
    \    let _level = max_nesting_level;\n                max_nesting_level += 1;\n\
    \                let new_max_nesting = max_nesting_level;\n                if\
    \ _level > max_nesting {\n                    max_nesting = new_max_nesting;\n\
    \                }\n            } else {\n                if max_nesting_level\
    \ > 0 {\n                    max_nesting_level -= 1;\n                }\n    \
    \        }\n            num_nestings += 1;\n        } else if group == ')' ||\
    \ group == ']' {\n            if num_nestings == 0 {\n                // skip\
    \ empty groups\n                continue;\n            }\n            num_nestings\
    \ += 1;\n        }\n        if num_nestings > max_nesting_level {\n          \
    \  max_nesting_level = num_nestings;\n        }\n    }\n\n    if max_nesting_level\
    \ > 0 {\n        max_nesting_level -= 1;\n    }\n    vec![max_nesting_level]\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpp6n8azqv.rs:13:18\n\
    \   |\n13 |         if group == '{' || group == '}' || group == ')' || group ==\
    \ ']' {\n   |                  ^^ no implementation for `&str == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpp6n8azqv.rs:13:34\n   |\n13 |         if group\
    \ == '{' || group == '}' || group == ')' || group == ']' {\n   |             \
    \                     ^^ no implementation for `&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  -->\
    \ /tmp/tmpp6n8azqv.rs:13:50\n   |\n13 |         if group == '{' || group == '}'\
    \ || group == ')' || group == ']' {\n   |                                    \
    \              ^^ no implementation for `&str == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens: Vec<isize> = vec![];\n    let mut paren_depth:\
    \ usize = 0;\n    for paren in paren_string.chars().filter_map(|c| *c != '(').filter_map(|c|\
    \ *c != ')').filter_map(|c| *c != ')' && c != '(') {\n        if paren_depth ==\
    \ 0 {\n            if paren == '(' {\n                parens.push(1);\n      \
    \      }\n        } else {\n            if paren == '(' {\n                paren_depth\
    \ += 1;\n            }\n            if paren_depth == parens.last().unwrap_or(usize)\
    \ - 1 {\n                if paren == ')' {\n                    paren_depth +=\
    \ 1;\n                }\n                parens.pop();\n            }\n      \
    \  }\n    }\n    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `usize`\n  --> /tmp/tmp9soj5380.rs:18:55\n\
    \   |\n18 |             if paren_depth == parens.last().unwrap_or(usize) - 1 {\n\
    \   |                                                       ^^^^^ not a value\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmp9soj5380.rs:9:54\n\
    \  |\n9 |     for paren in paren_string.chars().filter_map(|c| *c != '(').filter_map(|c|\
    \ *c != ')').filter_map(|c| *c != ')' && c != '(') {\n  |                    \
    \                                  ^^\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp9soj5380.rs:9:54\n  |\n9 |     for paren in paren_string.chars().filter_map(|c|\
    \ *c != '(').filter_map(|c| *c != ')').filter_map(|c| *c != ')' && c != '(') {\n\
    \  |                                                      ^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n         \
    \    found type `bool`\nhelp: try wrapping the expression in `Some`\n  |\n9 |\
    \     for paren in paren_string.chars().filter_map(|c| Some(*c != '(')).filter_map(|c|\
    \ *c != ')').filter_map(|c| *c != ')' && c != '(') {\n  |                    \
    \                                  +++++         +\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp9soj5380.rs:9:80\n  |\n9 |     for paren in paren_string.chars().filter_map(|c|\
    \ *c != '(').filter_map(|c| *c != ')').filter_map(|c| *c != ')' && c != '(') {\n\
    \  |                                                                         \
    \       ^^^^^^^^^ expected enum `Option`, found `bool`\n  |\n  = note: expected\
    \ enum `Option<_>`\n             found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n  |\n9 |     for paren in paren_string.chars().filter_map(|c| *c\
    \ != '(').filter_map(|c| Some(*c != ')')).filter_map(|c| *c != ')' && c != '(')\
    \ {\n  |                                                                     \
    \           +++++         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9soj5380.rs:18:31\n\
    \   |\n18 |             if paren_depth == parens.last().unwrap_or(usize) - 1 {\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut counter = 0;\n    let mut nesting_depth = 0;\n\
    \    for group in paren_string.split_whitespace() {\n        counter = parse_group(group,\
    \ nesting_depth, counter);\n        nesting_depth = parse_group(group, nesting_depth,\
    \ counter);\n    }\n    counter\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_group` in this scope\n  --> /tmp/tmprkrkw7df.rs:10:19\n\
    \   |\n10 |         counter = parse_group(group, nesting_depth, counter);\n  \
    \ |                   ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `parse_group` in this scope\n  --> /tmp/tmprkrkw7df.rs:11:25\n\
    \   |\n11 |         nesting_depth = parse_group(group, nesting_depth, counter);\n\
    \   |                         ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprkrkw7df.rs:13:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n13 |     counter\n\
    \   |     ^^^^^^^ expected struct `Vec`, found integer\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `{integer}`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter_map(|c|\
    \ c != '(' && c != ')')\n        .filter_map(|c| c != '[' && c != ']')\n     \
    \   .filter_map(|c| c != '{' && c != '}')\n        .filter_map(|c| c != ' ')\n\
    \        .filter_map(|c| !c.is_ascii())\n        .collect::<Vec<_>>()\n      \
    \  .into_iter()\n        .windows(2)\n        .map(|w| w.1.len())\n        .max()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdzyih4m0.rs:9:25\n  |\n9 |\
    \         .filter_map(|c| c != '(' && c != ')')\n  |                         ^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n\
    \             found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n9 |         .filter_map(|c| Some(c != '(' && c != ')'))\n  |           \
    \              +++++                    +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdzyih4m0.rs:10:25\n   |\n10 |         .filter_map(|c| c != '['\
    \ && c != ']')\n   |                         ^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n\
    10 |         .filter_map(|c| Some(c != '[' && c != ']'))\n   |               \
    \          +++++                    +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdzyih4m0.rs:11:25\n   |\n11 |         .filter_map(|c| c != '{' && c\
    \ != '}')\n   |                         ^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n11 |       \
    \  .filter_map(|c| Some(c != '{' && c != '}'))\n   |                         +++++\
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzyih4m0.rs:12:25\n\
    \   |\n12 |         .filter_map(|c| c != ' ')\n   |                         ^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |         .filter_map(|c| Some(c != ' '))\n   |                    \
    \     +++++        +\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut nestings = Vec::new();\n\
    \    paren_string.par_iter()\n        .map(|c| match c {\n            '(' | '['\
    \ | '{' | ')' => {\n                level += 1;\n                nestings.push(level);\n\
    \            }\n            '}' | '=' => {\n                if level != nestings.last()\
    \ {\n                    nestings.push(level);\n                }\n          \
    \      level -= 1;\n            }\n            _ => (),\n        })\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `par_iter` found for struct `String` in the\
    \ current scope\n --> /tmp/tmps6yd42gw.rs:9:18\n  |\n9 |     paren_string.par_iter()\n\
    \  |                  ^^^^^^^^ method not found in `String`\n\nerror[E0277]: can't\
    \ compare `{integer}` with `Option<&{integer}>`\n  --> /tmp/tmps6yd42gw.rs:16:26\n\
    \   |\n16 |                 if level != nestings.last() {\n   |              \
    \            ^^ no implementation for `{integer} == Option<&{integer}>`\n   |\n\
    \   = help: the trait `PartialEq<Option<&{integer}>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    for\
    \ parens in paren_string.split_whitespace() {\n        if parens.len() == 0 {\n\
    \            // empty string\n            continue;\n        }\n        let mut\
    \ current_level: isize = 1;\n        for index in 0..parens.len() {\n        \
    \    let mut paren_level = paren_stack.len();\n            while paren_level >\
    \ current_level {\n                paren_stack.pop();\n                paren_level\
    \ -= 1;\n            }\n            let char = parens[index];\n            if\
    \ char == '(' {\n                paren_stack.push(current_level);\n          \
    \      let mut depth = current_level;\n                while depth > paren_stack.last_mut()\
    \ {\n                    depth -= 1;\n                }\n                *paren_stack.last_mut()\
    \ = depth + 1;\n                let level_added = paren_stack.pop();\n       \
    \         let level_subtracted = *paren_stack.last_mut();\n                *paren_stack.last_mut()\
    \ = current_level - level_subtracted + level_added - 1;\n            }\n     \
    \       current_level += 1;\n        }\n    }\n    paren_stack.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2k7ojli.rs:16:33\n   |\n\
    16 |             while paren_level > current_level {\n   |                   \
    \              ^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |             while paren_level > current_level.try_into().unwrap()\
    \ {\n   |                                              ++++++++++++++++++++\n\n\
    error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpw2k7ojli.rs:20:24\n\
    \   |\n20 |             let char = parens[index];\n   |                      \
    \  ^^^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw2k7ojli.rs:24:31\n   |\n24 |                 while depth > paren_stack.last_mut()\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&mut isize>`\n\nerror[E0614]: type `Option<&mut isize>` cannot\
    \ be dereferenced\n  --> /tmp/tmpw2k7ojli.rs:27:17\n   |\n27 |               \
    \  *paren_stack.last_mut() = depth + 1;\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\nhelp: parentheses are required to parse this as an expression\n   |\n24\
    \ ~                 (while depth > paren_stack.last_mut() {\n25 |            \
    \         depth -= 1;\n26 ~                 })\n   |\n\nerror[E0614]: type `Option<&mut\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpw2k7ojli.rs:29:40\n   |\n29 |\
    \                 let level_subtracted = *paren_stack.last_mut();\n   |      \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `Option<&mut isize>` cannot be dereferenced\n  --> /tmp/tmpw2k7ojli.rs:30:17\n\
    \   |\n30 |                 *paren_stack.last_mut() = current_level - level_subtracted\
    \ + level_added - 1;\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut open_p = 0;\n    let mut close_p = 0;\n    let\
    \ mut level = 0;\n    let mut group_levels = Vec::new();\n    let mut group_start\
    \ = -1;\n    let mut groups = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            b'(' | b'[' | b'{' => {\n                group_start\
    \ = c;\n                open_p = open_p + 1;\n                group_levels.push(isize::max(level,\
    \ open_p));\n                level = 0;\n            }\n            b'(' | b'['\
    \ => {\n                open_p = open_p + 1;\n                level += 1;\n  \
    \          }\n            b'(' | b'{' => {\n                close_p = close_p\
    \ + 1;\n                level += 1;\n            }\n            b'(' | b']' |\
    \ b'[' | b'{' | b']' => {\n                group_levels.remove(group_start);\n\
    \                level -= 1;\n                open_p = open_p + group_levels.last().unwrap();\n\
    \            }\n            b'(' | b']' | b'[' | b'{' | b']' | b'(' | b']' =>\
    \ {\n                group_levels.remove(group_start);\n                level\
    \ -= 1;\n                open_p = open_p + group_levels.last().unwrap();\n   \
    \         }\n            b'(' | b']' | b'[' | b'{' | b']' | b'(' | b']' | b'('\
    \ | b']' => {\n                group_levels.remove(group_start);\n           \
    \     level -= 1;\n                close_p = close_p + group_levels.last().unwrap();\n\
    \            }\n            b'(' | b']' | b'[' | b'{' | b']' | b'(' | b']' | b'('\
    \ | b']' | b'.' => {\n                level += 1;\n            }\n           \
    \ b'(' | b']' | b'[' | b'{' | b']' | b'(' | b']' | b'(' | b']' | b'[' | b']' |\
    \ b'{' | b']' => {\n                level += 1;\n            }\n            _\
    \ => (),\n        }\n        groups.push(level);\n    }\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:15:13\n   |\n\
    14 |         match c {\n   |               - this expression has type `char`\n\
    15 |             b'(' | b'[' | b'{' => {\n   |             ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:15:20\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    15 |             b'(' | b'[' | b'{' => {\n   |                    ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:15:27\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    15 |             b'(' | b'[' | b'{' => {\n   |                           ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:21:13\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    ...\n21 |             b'(' | b'[' => {\n   |             ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:21:20\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    ...\n21 |             b'(' | b'[' => {\n   |                    ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:25:13\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    ...\n25 |             b'(' | b'{' => {\n   |             ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:25:20\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    ...\n25 |             b'(' | b'{' => {\n   |                    ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:29:13\n\
    \   |\n14 |         match c {\n   |               - this expression has type `char`\n\
    ...\n29 |             b'(' | b']' | b'[' | b'{' | b']' => {\n   |            \
    \ ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1n0bknc8.rs:29:20\n\
    \   |\n14 |         match c {\n   |               - this ex"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut stack: Vec<isize>\
    \ = vec![paren_level];\n    let mut paren_count = 0;\n    let mut group_count\
    \ = 1;\n    let mut current_group = 1;\n    let mut index = 0;\n    let mut paren_level\
    \ = paren_level;\n    let mut char_iterator: chars = paren_string.chars();\n \
    \   while let Some(next_char) = {\n        if paren_count > 2 {\n            stack.push(current_group);\n\
    \            current_group += 1;\n        }\n        if paren_count < 2 {\n  \
    \          stack.push(0);\n        }\n        let mut opening_paren = next_char\
    \ == paren_char::('(');\n        let mut ending_paren = next_char == paren_char::(')');\n\
    \        if opening_paren && ending_paren {\n            char_iterator = paren_chars::chars(&mut\
    \ paren_level);\n        }\n        if opening_paren {\n            paren_count\
    \ += 1;\n        }\n        if ending_paren {\n            paren_count -= 1;\n\
    \        }\n        char_iterator.next();\n        index += 1;\n        if index\
    \ == paren_string.len() {\n            return stack;\n        }\n    }\n    //\
    \ TODO: Throw error\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `'('`\n  --> /tmp/tmpjc3pi1i6.rs:23:59\n  \
    \ |\n23 |         let mut opening_paren = next_char == paren_char::('(');\n  \
    \ |                                                           ^^^ expected type\n\
    \nerror: expected `{`, found `stack`\n  --> /tmp/tmpjc3pi1i6.rs:41:5\n   |\n15\
    \ |       while let Some(next_char) = {\n   |  _____-----_-\n   | |     |\n  \
    \ | |     while parsing the body of this `while` expression\n16 | |         if\
    \ paren_count > 2 {\n17 | |             stack.push(current_group);\n18 | |   \
    \          current_group += 1;\n...  |\n38 | |         }\n39 | |     }\n   | |_____-\
    \ this `while` condition successfully parsed\n40 |       // TODO: Throw error\n\
    41 |       stack\n   |       ^^^^^ expected `{`\n   |\nhelp: try placing this\
    \ code inside a block\n   |\n41 |     { stack }\n   |     +       +\n\nerror[E0412]:\
    \ cannot find type `chars` in this scope\n  --> /tmp/tmpjc3pi1i6.rs:14:28\n  \
    \ |\n14 |     let mut char_iterator: chars = paren_string.chars();\n   |     \
    \                       ^^^^^ help: a builtin type with a similar name exists:\
    \ `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = vec![0; paren_string.len()];\n    for (i,\
    \ c) in paren_string.chars().enumerate() {\n        if c == '(' || c == '{' {\n\
    \            depth[i] += 1;\n        } else if c == ')' || c == '}' {\n      \
    \      depth[i] -= 1;\n        }\n    }\n    depth\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, -1, 1, -1, -1, 0, 1, 1, 1, -1, -1, -1, 0, 1, -1, 0, 1, 1, 1, -1, -1,\
    \ 1, -1, 1, -1, -1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmphjg3yzh1.rs:20:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    for (i, c)\
    \ in paren_string.chars().enumerate() {\n        if c == '(' {\n            stack.push(0);\n\
    \        } else if c == ')' {\n            while let Some(level) = stack.last()\
    \ {\n                stack.pop();\n                if level == 0 {\n         \
    \           break;\n                }\n            }\n        }\n        stack.pop();\n\
    \    }\n\n    let mut output: Vec<isize> = Vec::new();\n    for i in 0..stack.len()\
    \ {\n        if stack[i] == 0 {\n            break;\n        }\n        output.push(i);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpo36evfqk.rs:14:26\n\
    \   |\n14 |                 if level == 0 {\n   |                          ^^\
    \ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpo36evfqk.rs:27:21\n   |\n27 |         output.push(i);\n   |        \
    \             ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n27\
    \ |         output.push(i.try_into().unwrap());\n   |                      ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_stack: Vec<isize> = vec![0];\n    let mut paren_count\
    \ = 0;\n    let mut paren_level = 0;\n\n    for (i, char) in paren_string.chars().enumerate()\
    \ {\n        if char == char!('(') {\n            paren_stack.push(paren_count);\n\
    \            paren_count += 1;\n            paren_level += 1;\n        } else\
    \ if char == char!(')') {\n            paren_count -= 1;\n            if paren_stack.len()\
    \ == 0 {\n                // This is an invalid nesting level\n              \
    \  panic!(\"Paren stack not empty after closing bracket at position {}\", i);\n\
    \            }\n            paren_stack.pop();\n            paren_level -= 1;\n\
    \        } else {\n            // Ignore the character since we only want nested\
    \ parens\n        }\n    }\n\n    paren_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `char` in this scope\n  --> /tmp/tmp5efvmzd5.rs:12:20\n\
    \   |\n12 |         if char == char!('(') {\n   |                    ^^^^\n  \
    \ |\n   = note: `char` is in scope, but it is a builtin type, not a macro\n\n\
    error: cannot find macro `char` in this scope\n  --> /tmp/tmp5efvmzd5.rs:16:27\n\
    \   |\n16 |         } else if char == char!(')') {\n   |                     \
    \      ^^^^\n   |\n   = note: `char` is in scope, but it is a builtin type, not\
    \ a macro\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5efvmzd5.rs:29:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n29 |     paren_level\n   |     ^^^^^^^^^^^ expected\
    \ struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `{integer}`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .chars()\n        .flat_map(|c| {\n\
    \            match c {\n                ']' if c == ']' => {\n               \
    \     None\n                }\n                ']' => {\n                    Some(0)\n\
    \                }\n                '[' => {\n                    Some(1)\n  \
    \              }\n                '(' => {\n                    Some(2)\n    \
    \            }\n                c => None,\n            }\n        })\n      \
    \  .filter_map(|c| c as Option)\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0107]: missing generics for enum `Option`\n  --> /tmp/tmpuc8vrbt3.rs:26:30\n\
    \   |\n26 |         .filter_map(|c| c as Option)\n   |                       \
    \       ^^^^^^ expected 1 generic argument\n   |\nhelp: add missing generic argument\n\
    \   |\n26 |         .filter_map(|c| c as Option<T>)\n   |                    \
    \          ~~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0107`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens = paren_string.split_whitespace();\n   \
    \ let mut paren_levels = vec![];\n    for paren in parens {\n        if paren.len()\
    \ > 3 {\n            paren_levels.push(paren.len());\n        }\n    }\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl4mpm85_.rs:14:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n14 |     paren_levels\n   |     ^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars()\n        .filter_map(|c| c.to_ascii_lowercase().ok())\n\
    \        .filter(|c| c != '(')\n        .filter(|c| c != ')')\n        .map(|c|\
    \ c.to_digit(10).ok())\n        .filter_map(|x| *x)\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `ok` found for type `char` in the current\
    \ scope\n --> /tmp/tmphbeccj5m.rs:8:48\n  |\n8 |         .filter_map(|c| c.to_ascii_lowercase().ok())\n\
    \  |                                                ^^ method not found in `char`\n\
    \nerror[E0277]: can't compare `&_` with `char`\n --> /tmp/tmphbeccj5m.rs:9:23\n\
    \  |\n9 |         .filter(|c| c != '(')\n  |                       ^^ no implementation\
    \ for `&_ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmphbeccj5m.rs:10:23\n\
    \   |\n10 |         .filter(|c| c != ')')\n   |                       ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut nesting_level = Vec::new();\n\
    \    paren_string.split_whitespace().each_byte().unwrap().filter(|x| *x != '(').collect::<Vec<_>>().for_each(|x|\
    \ {\n        if *x == '(' {\n            nesting_level.push(isize::MAX);\n   \
    \     }\n        if *x == ')' {\n            if nesting_level.len() == 0 {\n \
    \               return Err(\"Parentheses mismatched.\");\n            }\n    \
    \        nesting_level.pop();\n        }\n        if nesting_level.len() > 0 &&\
    \ nesting_level[nesting_level.len() - 1] == nesting_level[nesting_level.len()\
    \ - 1] + 1 {\n            nesting_level[nesting_level.len() - 1] = isize::MAX;\n\
    \        }\n        if nesting_level.len() >= max_level {\n            return\
    \ Err(\"Parentheses mismatched.\");\n        }\n        if nesting_level.len()\
    \ > max_level {\n            max_level = nesting_level.len();\n        }\n   \
    \ });\n    nesting_level.iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `each_byte` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpwam3c02r.rs:9:37\n  |\n9 |     paren_string.split_whitespace().each_byte().unwrap().filter(|x|\
    \ *x != '(').collect::<Vec<_>>().for_each(|x| {\n  |                         \
    \            ^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwam3c02r.rs:25:44\n   |\n25 |           if nesting_level.len()\
    \ > max_level {\n   |  ____________________________________________^\n26 | | \
    \            max_level = nesting_level.len();\n27 | |         }\n   | |_________^\
    \ expected enum `Result`, found `()`\n   |\n   = note:   expected enum `Result<_,\
    \ &str>`\n           found unit type `()`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmpwam3c02r.rs:29:26\n\
    \     |\n29   |     nesting_level.iter().collect()\n     |                   \
    \       ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut stack = paren_string.chars().filter_map(|c|\
    \ c != '(').collect::<Vec<char>>();\n    while let Some(mut c) = stack.pop() {\n\
    \        if c == '(' && stack.is_empty() {\n            levels.push(0);\n    \
    \    }\n        if c == ')' && stack.is_not_empty() {\n            levels.pop();\n\
    \        }\n        if levels[-1] == 0 {\n            levels.push(1);\n      \
    \  }\n        if levels[-1] == 1 && stack.is_not_empty() {\n            levels.pop();\n\
    \        }\n        if levels[-1] < 2 {\n            levels.push(2);\n       \
    \ }\n        if levels[-1] > 2 {\n            levels.pop();\n        }\n     \
    \   stack.push(c);\n    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjs5p1hcf.rs:8:57\n  |\n8 |\
    \     let mut stack = paren_string.chars().filter_map(|c| c != '(').collect::<Vec<char>>();\n\
    \  |                                                         ^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n    \
    \         found type `bool`\nhelp: try wrapping the expression in `Some`\n  |\n\
    8 |     let mut stack = paren_string.chars().filter_map(|c| Some(c != '(')).collect::<Vec<char>>();\n\
    \  |                                                         +++++        +\n\n\
    error[E0599]: no method named `is_not_empty` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpjs5p1hcf.rs:13:30\n   |\n13 |         if c == ')'\
    \ && stack.is_not_empty() {\n   |                              ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_empty`\n\nerror: negative\
    \ integers cannot be used to index on a `Vec<{integer}>`\n  --> /tmp/tmpjs5p1hcf.rs:16:19\n\
    \   |\n16 |         if levels[-1] == 0 {\n   |                   ^^ cannot use\
    \ a negative integer for indexing on `Vec<{integer}>`\n   |\nhelp: to access an\
    \ element starting from the end of the `Vec<{integer}>`, compute the index\n \
    \  |\n16 |         if levels[levels.len() -1] == 0 {\n   |                   ++++++++++++\n\
    \nerror: negative integers cannot be used to index on a `Vec<{integer}>`\n  -->\
    \ /tmp/tmpjs5p1hcf.rs:19:19\n   |\n19 |         if levels[-1] == 1 && stack.is_not_empty()\
    \ {\n   |                   ^^ cannot use a negative integer for indexing on `Vec<{integer}>`\n\
    \   |\nhelp: to access an element starting from the end of the `Vec<{integer}>`,\
    \ compute the index\n   |\n19 |         if levels[levels.len() -1] == 1 && stack.is_not_empty()\
    \ {\n   |                   ++++++++++++\n\nerror[E0599]: no method named `is_not_empty`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpjs5p1hcf.rs:19:37\n\
    \   |\n19 |         if levels[-1] == 1 && stack.is_not_empty() {\n   |       \
    \                              ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `i"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut result: Vec<_> = vec![];\n\
    \    let mut chars: Vec<_> = paren_string\n        .chars()\n        .filter_map(|c|\
    \ match c {\n            ' ' | '\\t' | cr()| cr | *_ | '(' | ')' | ')()' => {\n\
    \                level += 1;\n                Some(c)\n            }\n       \
    \     _ => None,\n        })\n        .collect();\n    let mut idx = 0;\n\n  \
    \  while idx < chars.len() {\n        if chars[idx] == ')' && level == 0 {\n \
    \           result.push(level);\n        }\n        idx += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpkil10wzd.rs:12:54\n\
    \   |\n12 |             ' ' | '\\t' | cr()| cr | *_ | '(' | ')' | ')()' => {\n\
    \   |                                                      ^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n12 |       \
    \      ' ' | '\\t' | cr()| cr | *_ | '(' | ')' | \")()\" => {\n   |          \
    \                                            ~~~~~\n\nerror: expected pattern,\
    \ found `*`\n  --> /tmp/tmpkil10wzd.rs:12:37\n   |\n12 |             ' ' | '\\\
    t' | cr()| cr | *_ | '(' | ')' | ')()' => {\n   |             ---            \
    \         ^ expected pattern\n   |             |\n   |             while parsing\
    \ this or-pattern starting here\n\nerror[E0282]: type annotations needed for `Vec<_>`\n\
    \ --> /tmp/tmpkil10wzd.rs:9:20\n  |\n9 |     let mut chars: Vec<_> = paren_string\n\
    \  |         ---------  ^^^^^^ cannot infer type\n  |         |\n  |         consider\
    \ giving `chars` the explicit type `Vec<_>`, with the type parameters specified\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    levels.reserve(paren_string.len());\n\
    \    for (i, char) in paren_string.chars().enumerate() {\n        if char == '('\
    \ || char == ')' {\n            if levels[i - 1].unwrap() + 1 == 0 {\n       \
    \         levels.push(0);\n            }\n            levels[i - 1].unwrap() =\
    \ levels[i - 1].unwrap() + 1;\n        } else {\n            levels.push(0);\n\
    \        }\n    }\n    levels.reverse();\n    levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpttpfk73w.rs:11:16\n\
    \   |\n7  |     let mut levels = Vec::new();\n   |         ---------- consider\
    \ giving `levels` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n11 |             if levels[i - 1].unwrap() + 1 == 0 {\n   |             \
    \   ^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpttpfk73w.rs:14:36\n\
    \   |\n14 |             levels[i - 1].unwrap() = levels[i - 1].unwrap() + 1;\n\
    \   |             ---------------------- ^\n   |             |\n   |         \
    \    cannot assign to this expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0070, E0282.\nFor more information\
    \ about an error, try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut level_stack = vec![0];\n\
    \    let mut cur_level = 0;\n    let mut cur_parens: Vec<isize> = vec![];\n  \
    \  for paren in paren_string.chars().filter(|c| *c != '(' && c != ')') {\n   \
    \     if paren == '(' {\n            level_stack.push(level);\n            cur_level\
    \ = level + 1;\n            cur_parens.clear();\n        } else if paren == ')'\
    \ {\n            level = level_stack.pop();\n            if level < cur_level\
    \ {\n                return vec![0];\n            }\n            cur_level = level;\n\
    \        } else {\n            cur_parens.push(paren);\n        }\n    }\n   \
    \ cur_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpot9ls_ux.rs:11:65\n\
    \   |\n11 |     for paren in paren_string.chars().filter(|c| *c != '(' && c !=\
    \ ')') {\n   |                                                               \
    \  ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpot9ls_ux.rs:17:21\n\
    \   |\n7  |     let mut level = 0;\n   |                     - expected due to\
    \ this value\n...\n17 |             level = level_stack.pop();\n   |         \
    \            ^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n \
    \  = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpot9ls_ux.rs:23:29\n   |\n23 |\
    \             cur_parens.push(paren);\n   |                             ^^^^^\
    \ expected `isize`, found `char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parens = Vec::with_capacity(paren_string.len());\n\
    \    let mut level = 0;\n    for (i, c) in paren_string.char_indices() {\n   \
    \     parens.push(level);\n        if c == '(' {\n            level += 1;\n  \
    \      } else if c == ')' {\n            level -= 1;\n        }\n    }\n    parens\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 1, 2, 1, 0, 0, 1, 2, 3, 2, 1, 0, 0, 1, 0, 0, 1, 2, 3, 2, 1, 2, 1,\
    \ 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpp10pi6s6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack_of_parantheses = Vec::new();\n    let mut\
    \ current_parantheses = 0;\n    let mut opening_parantheses = false;\n    let\
    \ mut closed_parantheses = false;\n\n    for char in paren_string.chars() {\n\
    \        match char {\n            ')' => {\n                if opening_parantheses\
    \ {\n                    closed_parantheses = true;\n                } else {\n\
    \                    opening_parantheses = true;\n                }\n        \
    \        stack_of_parantheses.push(current_parantheses);\n                current_parantheses\
    \ = 0;\n            }\n            '(' if opening_parantheses => {\n         \
    \       current_parantheses += 1;\n            }\n            _ => {\n       \
    \         current_parantheses += 1;\n            }\n        }\n    }\n    if opening_parantheses\
    \ {\n        stack_of_parantheses.push(current_parantheses);\n    }\n    if closed_parantheses\
    \ {\n        stack_of_parantheses.push(-1);\n    }\n    stack_of_parantheses.reverse()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxobhojxd.rs:37:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     stack_of_parantheses.reverse()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut parens_levels = Vec::new();\n\
    \    let mut parens_levels_max = Vec::new();\n    paren_string.split_whitespace().filter_map(|x|\
    \ x.is_empty()).for_each(|x| {\n        if x.is_empty() {\n            parens_levels.push(level);\n\
    \            parens_levels_max.push(level);\n            return;\n        }\n\
    \        level += 1;\n        if x.is_digit(10) {\n            parens_levels.push(level);\n\
    \            parens_levels_max.push(level);\n            return;\n        }\n\
    \        let mut levels = parens_levels;\n        let mut max = parens_levels_max;\n\
    \        let mut idx = levels.pop().unwrap();\n        while idx > 0 {\n     \
    \       levels.pop();\n            level -= 1;\n            idx -= 1;\n      \
    \  }\n        levels.push(level);\n        level += 1;\n        max.push(level);\n\
    \    });\n    parens_levels.sort_unstable();\n    parens_levels_max.sort_unstable();\n\
    \    parens_levels\n        .iter()\n        .map(|x| x - parens_levels_max[parens_levels_max.len()\
    \ - parens_levels.len() - x])\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6v9u21tf.rs:10:52\n   |\n\
    10 |     paren_string.split_whitespace().filter_map(|x| x.is_empty()).for_each(|x|\
    \ {\n   |                                                    ^^^^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     paren_string.split_whitespace().filter_map(|x| Some(x.is_empty())).for_each(|x|\
    \ {\n   |                                                    +++++           \
    \ +\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmp6v9u21tf.rs:39:10\n     |\n39\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_counts = vec![0; paren_string.len()];\n \
    \   let mut paren_levels = vec![0; paren_string.len()];\n\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            paren_counts[paren_string.len()-i] +=\
    \ 1;\n        }\n        if c == ')' {\n            paren_counts[paren_string.len()-i]\
    \ -= 1;\n        }\n    }\n\n    for i in paren_counts.iter_mut().rev() {\n  \
    \      paren_levels[i] = paren_counts[i];\n    }\n\n    for i in paren_levels.iter_mut().rev()\
    \ {\n        if *i < 0 {\n            *i = 0;\n        }\n    }\n\n    let mut\
    \ max_level = -1;\n    for i in paren_levels.iter_mut().rev() {\n        if *i\
    \ > max_level {\n            max_level = *i;\n        }\n    }\n\n    paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&mut {integer}`\n\
    \  --> /tmp/tmp5fjasavm.rs:20:9\n   |\n20 |         paren_levels[i] = paren_counts[i];\n\
    \   |         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&mut\
    \ {integer}`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&mut {integer}>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `&mut {integer}`\n  --> /tmp/tmp5fjasavm.rs:20:27\n   |\n20 |         paren_levels[i]\
    \ = paren_counts[i];\n   |                           ^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&mut {integer}`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&mut {integer}>` for `Vec<{integer}>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = vec![];\n\n    for group in\
    \ paren_string.chars().filter_map(|c| {\n        match c {\n            ' ' =>\
    \ false,  // ignore spaces\n            '(' | ')' => true, // a group is open\n\
    \            _ => false,\n        }\n    }) {\n        levels.push_back(levels.last().checked_add(1).unwrap());\n\
    \    }\n    levels.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprvjrrffv.rs:11:20\n   |\n\
    11 |             ' ' => false,  // ignore spaces\n   |                    ^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n11 |             ' ' => Some(false),  // ignore spaces\n   |          \
    \          +++++     +\n\nerror[E0599]: no method named `push_back` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmprvjrrffv.rs:16:16\n\
    \   |\n16 |         levels.push_back(levels.last().checked_add(1).unwrap());\n\
    \   |                ^^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `checked_add` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmprvjrrffv.rs:16:40\n   |\n16 |         levels.push_back(levels.last().checked_add(1).unwrap());\n\
    \   |                                        ^^^^^^^^^^^ method not found in `Option<&isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut stack = vec![false];\n    for ch in paren_string.chars() {\n    \
    \    if ch == '(' && stack[depth].is_some() {\n            result.push(depth);\n\
    \            stack[depth] = true;\n            depth += 1;\n        } else if\
    \ ch == ')' && stack[depth].is_some() {\n            depth -= 1;\n           \
    \ result.push(depth);\n            stack[depth] = false;\n        } else if ch\
    \ == '(' && !stack[depth].is_some() {\n            result.push(depth);\n     \
    \       stack[depth] = true;\n            depth += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_some` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpz4e8r2gp.rs:11:38\n   |\n11 |         if ch == '(' && stack[depth].is_some()\
    \ {\n   |                                      ^^^^^^^ method not found in `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz4e8r2gp.rs:12:25\n   |\n12 |\
    \             result.push(depth);\n   |                         ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |             result.push(depth.try_into().unwrap());\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `is_some` found for type `bool` in the current scope\n  --> /tmp/tmpz4e8r2gp.rs:15:45\n\
    \   |\n15 |         } else if ch == ')' && stack[depth].is_some() {\n   |    \
    \                                         ^^^^^^^ method not found in `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz4e8r2gp.rs:17:25\n   |\n17 |\
    \             result.push(depth);\n   |                         ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |             result.push(depth.try_into().unwrap());\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `is_some` found for type `bool` in the current scope\n  --> /tmp/tmpz4e8r2gp.rs:19:46\n\
    \   |\n19 |         } else if ch == '(' && !stack[depth].is_some() {\n   |   \
    \                                           ^^^^^^^ method not found in `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz4e8r2gp.rs:20:25\n   |\n20 |\
    \             result.push(depth);\n   |                         ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |             result.push(depth.try_into().unwrap());\n\
    \   |                              ++++++++++++++++++++\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![String::new()];\n    let mut paren_count\
    \ = paren_string.chars().count();\n    let mut depth = 0;\n    let mut paren_char\
    \ = None;\n    let mut depth_increment = 0;\n    loop {\n        paren_char =\
    \ if paren_count > 0 {\n            paren_count -= 1;\n            paren_char\n\
    \        } else {\n            paren_char = None;\n            depth_increment\
    \ = paren_char.len_utf8();\n        };\n        levels.push(depth);\n        depth\
    \ += 1;\n        if depth_increment == 0 {\n            break;\n        }\n  \
    \  }\n    levels.into_iter().map(|v| v + 1).collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len_utf8` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp9ezsoi2w.rs:18:42\n   |\n18 |             depth_increment\
    \ = paren_char.len_utf8();\n   |                                          ^^^^^^^^\
    \ method not found in `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ezsoi2w.rs:16:16\n\
    \   |\n16 |           } else {\n   |  ________________^\n17 | |             paren_char\
    \ = None;\n18 | |             depth_increment = paren_char.len_utf8();\n19 | |\
    \         };\n   | |_________^ expected enum `Option`, found `()`\n   |\n   =\
    \ note:   expected enum `Option<_>`\n           found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9ezsoi2w.rs:20:21\n   |\n20 |         levels.push(depth);\n\
    \   |                     ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ezsoi2w.rs:26:36\n\
    \   |\n26 |     levels.into_iter().map(|v| v + 1).collect()\n   |            \
    \                        ^ expected `&str`, found integer\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `String`\n    --> /tmp/tmp9ezsoi2w.rs:26:39\n     |\n26   |     levels.into_iter().map(|v|\
    \ v + 1).collect()\n     |                                       ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting = 1;\n    let mut char_count = 0;\n   \
    \ let mut nesting_stack = vec![-1isize; MAX_NESTING];\n    let mut level = 0;\n\
    \    let mut last_char = '\\0';\n    let mut paren_count = 0;\n    let mut paren_stack\
    \ = vec!['\\0'; MAX_NESTING];\n    let mut is_first_char = true;\n    for c in\
    \ paren_string.chars() {\n        if c == ')' {\n            if paren_count ==\
    \ 0 {\n                level -= 1;\n            }\n            paren_count -=\
    \ 1;\n            if level == 0 {\n                nesting_stack[nesting] = 0;\n\
    \                nesting -= 1;\n                char_count = 0;\n            \
    \    is_first_char = true;\n            }\n        } else if c == '(' {\n    \
    \        level += 1;\n            paren_count += 1;\n            paren_stack[paren_count]\
    \ = c;\n            if level == 1 && paren_count == 1 {\n                nesting_stack[nesting]\
    \ = nesting_stack[nesting-1]+1;\n                nesting += 1;\n             \
    \   char_count = 0;\n                is_first_char = true;\n            }\n  \
    \      } else {\n            if char_count == 0 {\n                last_char =\
    \ c;\n            }\n            if char_count < MAX_NESTING {\n             \
    \   nesting_stack[nesting] = nesting_stack[nesting-1] + 1;\n                char_count\
    \ += 1;\n            } else {\n                if char_count == MAX_NESTING {\n\
    \                    nesting_stack[nesting] = 0;\n                    nesting\
    \ -= 1;\n                    char_count = 0;\n                }\n            \
    \    if is_first_char {\n                    nesting_stack[nesting] = nesting_stack[nesting-1]+1;\n\
    \                    char_count += 1;\n                } else {\n            \
    \        level -= 1;\n                }\n                is_first_char = false;\n\
    \            }\n        }\n    }\n    nesting_stack.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_NESTING` in this scope\n --> /tmp/tmpsn279ww7.rs:9:43\n\
    \  |\n9 |     let mut nesting_stack = vec![-1isize; MAX_NESTING];\n  |       \
    \                                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_NESTING` in this scope\n  --> /tmp/tmpsn279ww7.rs:13:38\n\
    \   |\n13 |     let mut paren_stack = vec!['\\0'; MAX_NESTING];\n   |        \
    \                              ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_NESTING` in this scope\n  --> /tmp/tmpsn279ww7.rs:41:29\n\
    \   |\n41 |             if char_count < MAX_NESTING {\n   |                  \
    \           ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `MAX_NESTING` in this scope\n  --> /tmp/tmpsn279ww7.rs:45:34\n   |\n45 |   \
    \              if char_count == MAX_NESTING {\n   |                          \
    \        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars()\n        .filter_map(|c| {\n     \
    \       match c {\n                '(', ')' => Some(1),\n                ')' =>\
    \ Some(-1),\n                _ => None,\n            }\n        })\n        .chain()\n\
    \        .map(|x| match x {\n            1 => 1,\n            -1 => -1,\n    \
    \        _ => 0,\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmpy735pnk9.rs:10:20\n   |\n\
    10 |                 '(', ')' => Some(1),\n   |                    ^\n   |\nhelp:\
    \ try adding parentheses to match on a tuple...\n   |\n10 |                 ('(',\
    \ ')') => Some(1),\n   |                 +        +\nhelp: ...or a vertical bar\
    \ to match on multiple alternatives\n   |\n10 |                 '(' | ')' => Some(1),\n\
    \   |                 ~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmpy735pnk9.rs:15:10\n    |\n15 \
    \ |         .chain()\n    |          ^^^^^- supplied 0 arguments\n    |      \
    \    |\n    |          expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels: Vec<isize> = vec![0isize; MAX_NESTING];\n\
    \    let mut opening_paren_level: usize = 0;\n    for paren in paren_string.chars()\
    \ {\n        let paren_level = paren_levels.len();\n        let open_paren_level\
    \ = paren_levels[paren_level - 1];\n        if paren == opening_paren_level {\n\
    \            paren_levels[paren_level - 1] += 1;\n        } else {\n         \
    \   paren_levels[paren_level - 1] = 0;\n            opening_paren_level = paren;\n\
    \        }\n    }\n    paren_levels.clone_from(paren_levels.iter().cloned());\n\
    \    paren_levels.len()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_NESTING` in this scope\n --> /tmp/tmpcb9r7wh8.rs:7:53\n\
    \  |\n7 |     let mut paren_levels: Vec<isize> = vec![0isize; MAX_NESTING];\n\
    \  |                                                     ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcb9r7wh8.rs:12:21\n\
    \   |\n12 |         if paren == opening_paren_level {\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcb9r7wh8.rs:16:35\n   |\n8  |     let mut opening_paren_level:\
    \ usize = 0;\n   |                                  ----- expected due to this\
    \ type\n...\n16 |             opening_paren_level = paren;\n   |             \
    \                      ^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcb9r7wh8.rs:19:29\n   |\n19 |     paren_levels.clone_from(paren_levels.iter().cloned());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&Vec<isize>`,\
    \ found struct `Cloned`\n   |\n   = note: expected reference `&Vec<isize>`\n \
    \                found struct `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcb9r7wh8.rs:20:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n20 |     paren_levels.len()\n\
    \   |     ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n                found type `usize`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = vec![];\n    let paren_level\
    \ = paren_string.chars().enumerate().filter_map(|(idx, ch)| {\n        if !ch.is_ascii_letter()\
    \ {\n            return Some(idx);\n        }\n\n        if !ch.is_ascii_digit()\
    \ {\n            return Some(-1);\n        }\n\n        let num: isize = match\
    \ ch {\n            '0'..='9' => {\n                let value = ch as u8 - '0';\n\
    \                Some(value)\n            }\n            'a' ... 'z' => {\n  \
    \              let value = ch as u8 - 'a' + 10;\n                Some(value)\n\
    \            }\n            'A' ... 'Z' => {\n                let value = ch as\
    \ u8 - 'A' + 10;\n                Some(value)\n            }\n            _ =>\
    \ return Some(-1),\n        };\n\n        if num > 0 {\n            Some(num)\n\
    \        } else {\n            None\n        }\n    }).max_by_key(|idx| idx.1);\n\
    \n    if paren_level.is_none() {\n        return result;\n    }\n\n    let mut\
    \ paren_count = paren_level.0;\n    let mut curr_paren_count = 1;\n\n    for paren\
    \ in paren_string.chars().filter_map(|ch| {\n        if !ch.is_ascii_letter()\
    \ {\n            return None;\n        }\n\n        if !ch.is_ascii_digit() {\n\
    \            return None;\n        }\n\n        if curr_paren_count == paren_count\
    \ {\n            return Some(-1);\n        }\n\n        let num: isize = match\
    \ ch {\n            '0'..='9' => {\n                let value = ch as u8 - '0';\n\
    \                Some(value)\n            }\n            'a' ... 'z' => {\n  \
    \              let value = ch as u8 - 'a' + 10;\n                Some(value)\n\
    \            }\n            'A' ... 'Z' => {\n                let value = ch as\
    \ u8 - 'A' + 10;\n                Some(value)\n            }\n            _ =>\
    \ return None,\n        };\n\n        curr_paren_count += 1;\n        Some(num)\n\
    \    }) {\n        if paren == None {\n            continue;\n        }\n\n  \
    \      match paren {\n            Some(num) => {\n                result.push(num);\n\
    \            }\n            None => {\n                break;\n            }\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpbcix5wdh.rs:22:17\n\
    \   |\n22 |             'a' ... 'z' => {\n   |                 ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpbcix5wdh.rs:26:17\n\
    \   |\n26 |             'A' ... 'Z' => {\n   |                 ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpbcix5wdh.rs:65:17\n\
    \   |\n65 |             'a' ... 'z' => {\n   |                 ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpbcix5wdh.rs:69:17\n\
    \   |\n69 |             'A' ... 'Z' => {\n   |                 ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0599]: no method named `is_ascii_letter` found for type `char` in the\
    \ current scope\n --> /tmp/tmpbcix5wdh.rs:9:16\n  |\n9 |         if !ch.is_ascii_letter()\
    \ {\n  |                ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // The depth of the deepest parentheses group\n    let\
    \ mut depth = 0;\n    // The level at which the current parentheses group ends\n\
    \    let mut paren_level = 0;\n    // The total number of parentheses groups found\n\
    \    let mut total_paren_groups = 0;\n    // The current index of the parenthesis\
    \ group being processed\n    let mut current_paren_group = 0;\n    // The current\
    \ index of the current parentheses group content\n    let mut current_paren_group_content\
    \ = 0;\n    // The index of the next parenthesis group content\n    let mut next_paren_group_content\
    \ = 0;\n    // The length of the string being processed\n    let mut string_length\
    \ = paren_string.chars().count();\n    // The number of parentheses groups processed\
    \ till now\n    let mut paren_group_processed_now = 0;\n\n    // Walk through\
    \ each character in the string\n    while current_paren_group_content < string_length\
    \ {\n        match paren_string[current_paren_group_content] {\n            '\
    \ ' => (),\n            '(' | ')' => (),\n            '(' | ')' | ')' => (),\n\
    \            '(' => paren_level += 1,\n            '[' | ']' | ']' | '\\\\' =>\
    \ (),\n            '\\\\' => {\n                // This character should be handled\
    \ outside the inner while loop\n                // and should also not increase\
    \ the depth\n                panic!(\"Unexpected backslash\");\n            }\n\
    \            '[' => {\n                // This is the first opening brace encountered.\n\
    \                // It should increase the depth.\n                if paren_level\
    \ == 0 {\n                    // This is not the first opening brace in the string\n\
    \                    // and should increase the depth\n                    panic!(\"\
    Unexpected opening brace\");\n                }\n                depth += 1;\n\
    \            },\n            ']' => {\n                // This is the last closing\
    \ brace encountered.\n                // It should decrease the depth.\n     \
    \           if paren_level == 0 {\n                    // This is not the first\
    \ opening brace in the string\n                    // and should increase the\
    \ depth\n                    panic!(\"Unexpected closing brace\");\n         \
    \       }\n                depth -= 1;\n            },\n            _ => {\n \
    \               // The current character should be handled inside the inner while\
    \ loop.\n                // If it is an opening brace, increase the depth\n  \
    \              // If it is a closing brace, decrease the depth\n             \
    \   // If it is any other character, it must be the first character of the next\
    \ group.\n                // The paren_level variable should only increase or\
    \ decrease when this is the\n                // first or last character of the\
    \ group\n                match paren_string[next_paren_group_content] {\n    \
    \                ' ' => (),\n                    ']' | '\\\\' => {\n         \
    \               // This character should be handled outside the inner while loop\n\
    \                        // and should also not increase the depth\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdyqpo3zs.rs:76:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n25 |     while current_paren_group_content < string_length {\n   |      \
    \                                                 - unclosed delimiter\n26 | \
    \        match paren_string[current_paren_group_content] {\n   |             \
    \                                            - unclosed delimiter\n...\n57 | \
    \            _ => {\n   |                  - unclosed delimiter\n...\n64 |   \
    \              match paren_string[next_paren_group_content] {\n   |          \
    \                                                    - unclosed delimiter\n65\
    \ |                     ' ' => (),\n66 |                     ']' | '\\\\' => {\n\
    \   |                                   - this delimiter might not be properly\
    \ closed...\n...\n69 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n76 | }\n   |   ^\n\nerror: expected identifier, found keyword `fn`\n  -->\
    \ /tmp/tmpdyqpo3zs.rs:71:1\n   |\n71 | fn main() {\n   | ^^ expected identifier,\
    \ found keyword\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `main`\n\
    \  --> /tmp/tmpdyqpo3zs.rs:71:4\n   |\n71 | fn main() {\n   |    ^^^^ expected\
    \ one of `=>`, `@`, `if`, or `|`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpdyqpo3zs.rs:26:15\n   |\n26 |         match\
    \ paren_string[current_paren_group_content] {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str a"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<_> = vec![];\n    let mut stack = Vec::new();\n\
    \    for paren in paren_string.chars().skip(1).take_while(|c| c != '(' && c !=\
    \ ')') {\n        stack.pop_back();\n        match c {\n            ')' => result.push(stack.len()),\n\
    \            '(' => {\n                let mut next_stack = stack.clone();\n \
    \               stack.push(paren);\n                next_stack.push('(');\n  \
    \              result.push(next_stack.len());\n            },\n            _ =>\
    \ stack.push(c),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpcj_0iewl.rs:11:15\n\
    \   |\n11 |         match c {\n   |               ^ not found in this scope\n\n\
    error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpcj_0iewl.rs:19:29\n\
    \   |\n19 |             _ => stack.push(c),\n   |                            \
    \ ^ not found in this scope\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \ --> /tmp/tmpcj_0iewl.rs:9:64\n  |\n9 |     for paren in paren_string.chars().skip(1).take_while(|c|\
    \ c != '(' && c != ')') {\n  |                                               \
    \                 ^^ no implementation for `&char == char`\n  |\n  = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n --> /tmp/tmpcj_0iewl.rs:9:76\n  |\n9 |     for paren in paren_string.chars().skip(1).take_while(|c|\
    \ c != '(' && c != ')') {\n  |                                               \
    \                             ^^ no implementation for `&char == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named\
    \ `pop_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcj_0iewl.rs:10:15\n\
    \   |\n10 |         stack.pop_back();\n   |               ^^^^^^^^ method not\
    \ found in `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcj_0iewl.rs:22:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n22 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    for paren in paren_string.split('\
    \ ').iter() {\n        if paren == '(' {\n            stack.push(-1);\n      \
    \  } else if paren == ')' {\n            stack.pop();\n        }\n    }\n    stack\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmp1t7uj_qv.rs:8:42\n  |\n8 |     for paren\
    \ in paren_string.split(' ').iter() {\n  |                                   \
    \       ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = vec![];\n    let mut stack:\
    \ Vec<usize> = vec![];\n\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            '(' | ')' | '{' | '}' => {\n                stack.push(0);\n\
    \            }\n            '[' | ']' | '{' | '}' => {\n                if stack.len()\
    \ > 0 {\n                    output.append(stack.last().unwrap());\n         \
    \           stack.pop();\n                }\n            }\n            ch =>\
    \ {\n                stack.last().unwrap() += 1;\n            }\n        }\n \
    \   }\n    output.append(stack.last().unwrap());\n    output\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmw0j5s_.rs:17:35\n   |\n\
    17 |                     output.append(stack.last().unwrap());\n   |         \
    \                          ^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut Vec<isize>`\n             \
    \         found reference `&usize`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&usize`\n  --> /tmp/tmpjmw0j5s_.rs:22:17\n \
    \  |\n22 |                 stack.last().unwrap() += 1;\n   |                 ---------------------^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&usize`\n\
    \   |\nhelp: `+=` can be used on `usize`, you can dereference `stack.last().unwrap()`\n\
    \   |\n22 |                 *stack.last().unwrap() += 1;\n   |               \
    \  +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjmw0j5s_.rs:22:39\n\
    \   |\n22 |                 stack.last().unwrap() += 1;\n   |                \
    \ --------------------- ^^\n   |                 |\n   |                 cannot\
    \ assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjmw0j5s_.rs:26:19\n\
    \   |\n26 |     output.append(stack.last().unwrap());\n   |                  \
    \ ^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<isize>`\n                      found reference `&usize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: handle unbalanced parenthese\n    let mut level\
    \ = 0;\n    let mut result = Vec::new();\n    let mut pos = 0;\n    while let\
    \ Some(pos) = paren_string.find(\"(\", &pos) {\n        result.push(level);\n\
    \        level += 1;\n        paren_string.push_str(\")\");\n    }\n\n    while\
    \ let Some(pos) = paren_string.find(\")\", pos) {\n        level -= 1;\n     \
    \   result.push(level);\n        paren_string.pop_back();\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpnmk69cq9.rs:11:40\n     |\n11   |     while let Some(pos) = paren_string.find(\"\
    (\", &pos) {\n     |                                        ^^^^ ---  ---- supplied\
    \ 2 arguments\n     |                                        |\n     |       \
    \                                 expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 2\
    \ arguments were supplied\n    --> /tmp/tmpnmk69cq9.rs:17:40\n     |\n17   | \
    \    while let Some(pos) = paren_string.find(\")\", pos) {\n     |           \
    \                             ^^^^ ---  --- supplied 2 arguments\n     |     \
    \                                   |\n     |                                \
    \        expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `pop_back` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpnmk69cq9.rs:20:22\n   |\n20 |         paren_string.pop_back();\n\
    \   |                      ^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut counter = 0;\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut paren_level = -1;\n    let mut paren_levels = Vec::new();\n    let\
    \ mut paren_count = 0;\n    let mut paren_buffer = String::new();\n    let mut\
    \ paren_nesting = 0;\n\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            paren_level = paren_level + 1;\n            stack.push(paren_level);\n\
    \        } else if c == ')' {\n            paren_level = stack.pop();\n      \
    \      if paren_level == 0 {\n                paren_count = paren_count - 1;\n\
    \            } else {\n                paren_nesting = paren_nesting + paren_level;\n\
    \                paren_levels.push(paren_nesting);\n            }\n        } else\
    \ if paren_level == 0 {\n            paren_buffer.push(c);\n        } else if\
    \ paren_level == paren_nesting {\n            paren_buffer.push(c);\n        }\
    \ else {\n            paren_count = paren_count + 1;\n        }\n\n        if\
    \ paren_level == 0 {\n            paren_buffer.push(c);\n        }\n        if\
    \ paren_count == 0 {\n            if paren_buffer.chars().all(|c| c == '(') {\n\
    \                let paren_nesting_count = paren_levels.pop();\n             \
    \   let nesting_count = paren_level + paren_nesting_count;\n                paren_levels.push(nesting_count);\n\
    \            }\n        }\n    }\n\n    paren_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpjy5k_wdi.rs:9:27\n\
    \  |\n9 |     let mut paren_level = -1;\n  |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n  |\n  = help: the following other\
    \ types implement trait `Neg`:\n            &f32\n            &f64\n         \
    \   &i128\n            &i16\n            &i32\n            &i64\n            &i8\n\
    \            &isize\n          and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjy5k_wdi.rs:20:27\n   |\n9  |     let mut paren_level = -1;\n \
    \  |                           -- expected due to this value\n...\n20 |      \
    \       paren_level = stack.pop();\n   |                           ^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: cannot add `Option<usize>`\
    \ to `usize`\n  --> /tmp/tmpjy5k_wdi.rs:41:49\n   |\n41 |                 let\
    \ nesting_count = paren_level + paren_nesting_count;\n   |                   \
    \                              ^ no implementation for `usize + Option<usize>`\n\
    \   |\n   = help: the trait `Add<Option<usize>>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjy5k_wdi.rs:47:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n47 |     paren_levels\n\
    \   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more informatio"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut groups = paren_string.splitn(2, ' ')\n        .map(|s|\
    \ s.chars().count(char::is_parenthesis_open)).collect::<Vec<_>>();\n    loop {\n\
    \        if groups.is_empty() {\n            break;\n        }\n        let mut\
    \ current_level = groups.iter().max().unwrap();\n        for level in &mut groups\
    \ {\n            *level -= current_level;\n            current_level = *level;\n\
    \        }\n        groups.clear();\n    }\n    vec![groups.len()]\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `is_parenthesis_open`\
    \ found for type `char` in the current scope\n --> /tmp/tmpiufflchd.rs:8:40\n\
    \  |\n8 |         .map(|s| s.chars().count(char::is_parenthesis_open)).collect::<Vec<_>>();\n\
    \  |                                        ^^^^^^^^^^^^^^^^^^^ function or associated\
    \ item not found in `char`\n\nerror[E0061]: this function takes 0 arguments but\
    \ 1 argument was supplied\n   --> /tmp/tmpiufflchd.rs:8:28\n    |\n8   |     \
    \    .map(|s| s.chars().count(char::is_parenthesis_open)).collect::<Vec<_>>();\n\
    \    |                            ^^^^^ ------------------------- supplied 1 argument\n\
    \    |                            |\n    |                            expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiufflchd.rs:16:29\n   |\n13 |         let mut\
    \ current_level = groups.iter().max().unwrap();\n   |                        \
    \         ---------------------------- expected due to this value\n...\n16 | \
    \            current_level = *level;\n   |                             ^^^^^^\n\
    \   |                             |\n   |                             expected\
    \ `&usize`, found `usize`\n   |                             help: consider borrowing\
    \ here: `&*level`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiufflchd.rs:20:10\n\
    \   |\n20 |     vec![groups.len()]\n   |          ^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     vec![groups.len().try_into().unwrap()]\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_nests = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    for ch in paren_string.chars() {\n        paren_depth += 1;\n    \
    \    if ch == '(' {\n            paren_nests.push(paren_depth);\n        }\n \
    \       if ch == ')' {\n            if paren_nests.is_empty() {\n            \
    \    return Err(ErrorKind::UnexpectedEndOfParens.into());\n            }\n   \
    \         paren_depth -= 1;\n            paren_nests.pop();\n        }\n    }\n\
    \    paren_nests\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `ErrorKind`\n \
    \ --> /tmp/tmpd_y5tvsv.rs:16:28\n   |\n16 |                 return Err(ErrorKind::UnexpectedEndOfParens.into());\n\
    \   |                            ^^^^^^^^^ use of undeclared type `ErrorKind`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd_y5tvsv.rs:16:24\n   |\n16 |\
    \                 return Err(ErrorKind::UnexpectedEndOfParens.into());\n   | \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found enum `Result`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found enum `Result<_, _>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![];\n    let mut parentheses_depth\
    \ = 0;\n    let mut opening_parenthesis = false;\n    let mut closed_parentheses\
    \ = false;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n\
    \            opening_parenthesis = true;\n            parentheses_depth += 1;\n\
    \        } else if paren == ')' {\n            parentheses_depth -= 1;\n     \
    \       if opening_parenthesis && parentheses_depth == 0 {\n                closed_parentheses\
    \ = true;\n            }\n            levels.push(parentheses_depth);\n      \
    \      opening_parenthesis = false;\n        } else {\n            opening_parenthesis\
    \ = false;\n        }\n    }\n\n    if closed_parentheses {\n        levels.insert(0,\
    \ parentheses_depth);\n    }\n\n    levels.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 0, 2, 1, 0, 0, 2, 1, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpck15mvn3.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0; // how many nested parentheses we have\n\
    \    let mut levels = Vec::new(); // the levels we get for every parenthesis\n\
    \    let mut parens = Vec::new(); // parentheses we encounter in paren_string\n\
    \    let mut strings = Vec::new();\n    let mut current_paren_level = String::new();\n\
    \    let mut i = 1;\n    for s in paren_string.chars() {\n        match s {\n\
    \            '(' | ')' => {\n                let paren_level = level;\n      \
    \          if levels > paren_level {\n                    levels.append(paren_level);\n\
    \                }\n                level += 1;\n                current_paren_level\
    \ = current_paren_level.as_str();\n                if s == ')' {\n           \
    \         level -= 1;\n                }\n            }\n            '(' | '+'\
    \ | '-' | '*' | '/'\n            | '=' | '<' | '>' | '<=' | '>=' | '!' | '|' =>\
    \ {\n                parens.push(i);\n                i += 1;\n            }\n\
    \            _ => {\n                parens.push(i);\n                i += 1;\n\
    \            }\n        }\n        current_paren_level = current_paren_level.as_str();\n\
    \        strings.push(current_paren_level);\n    }\n    levels.append(level);\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmptvuz0xtj.rs:27:33\n\
    \   |\n27 |             | '=' | '<' | '>' | '<=' | '>=' | '!' | '|' => {\n   |\
    \                                 ^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n27 |             | '=' | '<' | '>' | \"<=\"\
    \ | '>=' | '!' | '|' => {\n   |                                 ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmptvuz0xtj.rs:27:40\n\
    \   |\n27 |             | '=' | '<' | '>' | '<=' | '>=' | '!' | '|' => {\n   |\
    \                                        ^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n27 |             | '=' | '<' | '>'\
    \ | '<=' | \">=\" | '!' | '|' => {\n   |                                     \
    \   ~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptvuz0xtj.rs:17:29\n\
    \   |\n17 |                 if levels > paren_level {\n   |                  \
    \           ^^^^^^^^^^^ expected struct `Vec`, found integer\n   |\n   = note:\
    \ expected struct `Vec<_>`\n                found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptvuz0xtj.rs:18:35\n   |\n18 |              \
    \       levels.append(paren_level);\n   |                                   ^^^^^^^^^^^\
    \ expected `&mut Vec<_>`, found integer\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptvuz0xtj.rs:21:39\n   |\n11 |     let mut current_paren_level\
    \ = String::new();\n   |                                   ------------- expected\
    \ due to this value\n...\n21 |                 current_paren_level = current_paren_level.as_str();\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \               |\n   |                                       expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptvuz0xtj.rs:36:31\n\
    \   |\n11 |     let mut current_paren_level = String::new();\n   |           \
    \   "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting_level = 0;\n    let mut levels = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '\
    \ ' | ')' => nesting_level += 1,\n            '(' | ')' => nesting_level -= 1,\n\
    \            c => (),\n        }\n        if nesting_level == 0 {\n          \
    \  levels.push(nesting_level);\n        }\n    }\n    levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbxh7o0k5.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = vec![0];\n    for paren in paren_string.chars()\
    \ {\n        let level = parens.count(paren);\n        if level > max_level[0]\
    \ {\n            max_level[0] = level;\n        }\n    }\n    max_level[0]\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `parens` in this scope\n --> /tmp/tmpbimyh06w.rs:9:21\n\
    \  |\n9 |         let level = parens.count(paren);\n  |                     ^^^^^^\
    \ help: a local variable with a similar name exists: `paren`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbimyh06w.rs:14:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n14 |     max_level[0]\n\
    \   |     ^^^^^^^^^^^^ expected struct `Vec`, found integer\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `{integer}`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = vec![];\n    for paren in paren_string.chars().filter(|c|\
    \ *c != '(' && c != ')') {\n        stack.push(paren);\n    }\n    let mut len\
    \ = 0;\n    while len < stack.len() {\n        let top = stack[len];\n       \
    \ if paren_string[top] == '(' {\n            stack.push(paren_string.len());\n\
    \            len += 1;\n        } else {\n            while len < stack.len()\
    \ && paren_string[stack[len]] == ')' {\n                len += 1;\n          \
    \  }\n            if len < stack.len() {\n                stack.truncate(len);\n\
    \                len += 1;\n            }\n        }\n    }\n    stack\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpujgcdzeu.rs:8:65\n\
    \  |\n8 |     for paren in paren_string.chars().filter(|c| *c != '(' && c != ')')\
    \ {\n  |                                                                 ^^ no\
    \ implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpujgcdzeu.rs:9:20\n\
    \  |\n9 |         stack.push(paren);\n  |                    ^^^^^ expected `isize`,\
    \ found `char`\n\nerror[E0277]: the type `String` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpujgcdzeu.rs:14:12\n   |\n14 |         if paren_string[top] == '('\
    \ {\n   |            ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n\
    \   |\n   = help: the trait `Index<isize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpujgcdzeu.rs:15:24\n\
    \   |\n15 |             stack.push(paren_string.len());\n   |                \
    \        ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n15 |             stack.push(paren_string.len().try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpujgcdzeu.rs:18:40\n\
    \   |\n18 |             while len < stack.len() && paren_string[stack[len]] ==\
    \ ')' {\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>`\
    \ is not implemented for `String`\n   = help: t"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level_count = 0;\n    let mut paren_stack = Vec::new();\n\
    \n    for paren in paren_string.chars() {\n        if paren == '(' {\n       \
    \     paren_stack.push(level_count);\n            level_count += 1;\n        }\
    \ else if paren == ')' {\n            level_count -= 1;\n            if level_count\
    \ == 0 {\n                paren_stack.pop();\n            }\n        }\n    }\n\
    \n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 0, 1, 0, 1, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpelzgwirp.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![0];\n\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' | '[' | '{' | '(' => {\n         \
    \       let level = levels.last_mut().unwrap();\n                levels += 1;\n\
    \                level\n            }\n            _ => levels += 1,\n       \
    \ }\n    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<{integer}>`\n  --> /tmp/tmplv_eo6zb.rs:13:17\n   |\n13 |              \
    \   levels += 1;\n   |                 ------^^^^^\n   |                 |\n \
    \  |                 cannot use `+=` on type `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplv_eo6zb.rs:14:17\n   |\n10 | /         match\
    \ paren {\n11 | |             '(' | '[' | '{' | '(' => {\n12 | |             \
    \    let level = levels.last_mut().unwrap();\n13 | |                 levels +=\
    \ 1;\n14 | |                 level\n   | |                 ^^^^^ expected `()`,\
    \ found `&mut {integer}`\n15 | |             }\n16 | |             _ => levels\
    \ += 1,\n17 | |         }\n   | |_________- expected this to be `()`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<{integer}>`\n\
    \  --> /tmp/tmplv_eo6zb.rs:16:18\n   |\n16 |             _ => levels += 1,\n \
    \  |                  ------^^^^^\n   |                  |\n   |             \
    \     cannot use `+=` on type `Vec<{integer}>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.char_indices()\n        .filter_map(|(_, index)|\
    \ index < paren_string.len() - 1)\n        .map(|(_, index)| (index + 1, paren_string[index\
    \ + 1]))\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphy01ax10.rs:8:42\n  |\n8 |\
    \         .filter_map(|(_, index)| index < paren_string.len() - 1)\n  |      \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmphy01ax10.rs:8:34\n \
    \ |\n8 |         .filter_map(|(_, index)| index < paren_string.len() - 1)\n  |\
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n         \
    \    found type `bool`\nhelp: try wrapping the expression in `Some`\n  |\n8 |\
    \         .filter_map(|(_, index)| Some(index < paren_string.len() - 1))\n  |\
    \                                  +++++                              +\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `(_, _)`\n    --> /tmp/tmphy01ax10.rs:10:10\n     |\n10   |        \
    \ .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=(_, _)>`\n     |\n     = help: the trait `FromIterator<(_,\
    \ _)>` is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .into_iter()\n\
    \        .filter_map(|x| x.parse::<Token<'static>>().ok())\n        .filter_map(|x|\
    \ x.is_opening_bracket())\n        .filter_map(|x| x.as_usize())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Token` in this scope\n  --> /tmp/tmpudb__1z4.rs:10:35\n\
    \   |\n10 |         .filter_map(|x| x.parse::<Token<'static>>().ok())\n   |  \
    \                                 ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting_level = 1; // initial value for deepest\
    \ level of nesting\n    let mut par_level = 1; // initial value for number of\
    \ parentheses encountered before current parenthesis\n    let mut char_count =\
    \ 0; // total number of characters in parenthesis\n    let mut char_stack: Vec<usize>\
    \ = vec![paren_char_to_uc(paren_string[0])]; // stack of parenthesis encountered\n\
    \    for i in 1..paren_string.len() {\n        let c = paren_string[i];\n    \
    \    if c == '(' {\n            par_level += 1;\n        } else if c == ')' {\n\
    \            par_level -= 1;\n        } else if c == '{' {\n            nesting_level\
    \ += 1;\n        } else if c == '}' {\n            nesting_level -= 1;\n     \
    \   }\n        if nesting_level < 0 {\n            return Vec::new();\n      \
    \  }\n        char_count += 1;\n        if char_count % 2 == 0 {\n           \
    \ char_stack.append(c);\n        } else {\n            let mut pos = char_stack.len()\
    \ - 1; // get index of popping character from stack\n            let char_0 =\
    \ char_stack[pos];\n            while char_0 <= c {\n                char_stack.pop();\n\
    \                pos -= 1;\n                if pos < 0 {\n                   \
    \ break;\n                }\n                char_0 = char_stack[pos];\n     \
    \       }\n            char_stack.push(c);\n        }\n    }\n    if char_stack.len()\
    \ != char_count {\n        return Vec::new();\n    }\n    let mut par_stack_end\
    \ = par_stack.len() - 1; // get index of closing parenthesis from stack\n    let\
    \ par_stack_end = par_stack.len();\n    while par_stack[par_stack_end] != ')'\
    \ {\n        par_stack_end -= 1;\n        if par_stack_end < 0 {\n           \
    \ return Vec::new();\n        }\n    }\n    par_stack_end += 1;\n    par_stack.truncate(par_stack_end);\n\
    \    par_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `paren_char_to_uc` in this scope\n \
    \ --> /tmp/tmph5_hdzqt.rs:10:43\n   |\n10 |     let mut char_stack: Vec<usize>\
    \ = vec![paren_char_to_uc(paren_string[0])]; // stack of parenthesis encountered\n\
    \   |                                           ^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `par_stack` in this scope\n  -->\
    \ /tmp/tmph5_hdzqt.rs:45:29\n   |\n45 |     let mut par_stack_end = par_stack.len()\
    \ - 1; // get index of closing parenthesis from stack\n   |                  \
    \           ^^^^^^^^^ help: a local variable with a similar name exists: `char_stack`\n\
    \nerror[E0425]: cannot find value `par_stack` in this scope\n  --> /tmp/tmph5_hdzqt.rs:46:25\n\
    \   |\n46 |     let par_stack_end = par_stack.len();\n   |                   \
    \      ^^^^^^^^^ help: a local variable with a similar name exists: `char_stack`\n\
    \nerror[E0425]: cannot find value `par_stack` in this scope\n  --> /tmp/tmph5_hdzqt.rs:47:11\n\
    \   |\n47 |     while par_stack[par_stack_end] != ')' {\n   |           ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `char_stack`\n\nerror[E0425]:\
    \ cannot find value `par_stack` in this scope\n  --> /tmp/tmph5_hdzqt.rs:54:5\n\
    \   |\n54 |     par_stack.truncate(par_stack_end);\n   |     ^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `char_stack`\n\nerror[E0425]: cannot\
    \ find value `par_stack` in this scope\n  --> /tmp/tmph5_hdzqt.rs:55:5\n   |\n\
    55 |     par_stack\n   |     ^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `char_stack`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmph5_hdzqt.rs:10:60\n   |\n10 |     let mut char_stack:\
    \ Vec<usize> = vec![paren_char_to_uc(paren_string[0])]; // stack of parenthesis\
    \ encountered\n   |                                                          \
    \  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0i32;\n    let mut nested_level = 0i32;\n\
    \    let mut paren_level = 0i32;\n\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        match c {\n            '(' => {\n                paren_level += 1;\n\
    \                if paren_level > level {\n                    level = paren_level;\n\
    \                }\n            }\n            ')' => {\n                paren_level\
    \ -= 1;\n                if paren_level < level {\n                    level =\
    \ paren_level;\n                }\n            }\n            c => {\n       \
    \         nested_level += 1;\n                if paren_level != level {\n    \
    \                level = paren_level;\n                }\n            }\n    \
    \    }\n    }\n    vec![level]\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1glra2p7.rs:33:10\n   |\n\
    33 |     vec![level]\n   |          ^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n33 |     vec![level.try_into().unwrap()]\n   |          \
    \     ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut level =\
    \ 0;\n    let mut paren_count = 0;\n\n    for (index, char) in paren_string.chars().enumerate()\
    \ {\n        paren_count += 1;\n        let next_char_at_level = paren_count %\
    \ 2;\n        let paren_level = next_char_at_level > level;\n        if !paren_level\
    \ {\n            paren_stack.push(i);\n        } else {\n            let level_delta\
    \ = next_char_at_level - level;\n            paren_stack.extend_from_slice(&paren_stack.iter()\n\
    \                .take(level_delta)\n                .collect::<Vec<_>>());\n\
    \        }\n        level = next_char_at_level;\n    }\n\n    paren_stack\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp1vtiglsb.rs:16:30\n\
    \   |\n16 |             paren_stack.push(i);\n   |                           \
    \   ^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1vtiglsb.rs:19:43\n\
    \   |\n19 |               paren_stack.extend_from_slice(&paren_stack.iter()\n\
    \   |  ___________________________________________^\n20 | |                 .take(level_delta)\n\
    21 | |                 .collect::<Vec<_>>());\n   | |____________________________________^\
    \ expected slice, found struct `Vec`\n   |\n   = note: expected reference `&[_]`\n\
    \              found reference `&Vec<&_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_depth = paren_string.len();\n    let mut\
    \ left_paren_count = 0;\n    let mut right_paren_count = 0;\n    let mut depth\
    \ = 1;\n    let mut char_pos = 0;\n    while char_pos + 1 < paren_depth {\n  \
    \      let next_char = paren_string[char_pos + 1];\n        if next_char == '('\
    \ {\n            left_paren_count += 1;\n        }\n        if next_char == ')'\
    \ {\n            right_paren_count += 1;\n        }\n        if next_char == '\
    \ ' && paren_depth > 1 && paren_depth - 1 == depth {\n            depth = paren_depth;\n\
    \        }\n        char_pos += 1;\n    }\n    paren_depth\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps2dd92qf.rs:13:25\n\
    \   |\n13 |         let next_char = paren_string[char_pos + 1];\n   |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2dd92qf.rs:25:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n25 |     paren_depth\n   |     ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.to_string();\n\n    let\
    \ mut stack: Vec<isize> = vec![paren_string.len()];\n    let mut level: usize\
    \ = 0;\n\n    for c in paren_string.chars() {\n        match c {\n           \
    \ ')' | '(' | '[' => {\n                stack[level]++;\n            }\n     \
    \       ']' | '(' => {\n                stack[level]--;\n            }\n     \
    \       _ if level == stack.len() - 1 => {\n                if stack.is_empty()\
    \ {\n                    return vec![0];\n                } else {\n         \
    \           stack.pop();\n                    level--;\n                }\n  \
    \          }\n            _ => {\n                level = 0;\n            }\n\
    \        }\n    }\n\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxezidt_d.rs:15:29\n\
    \   |\n15 |                 stack[level]++;\n   |                            \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |\
    \                 { let tmp = stack[level]; stack[level] += 1; tmp };\n   |  \
    \               +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n15 -     \
    \            stack[level]++;\n15 +                 stack[level] += 1;\n   | \n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpxezidt_d.rs:18:31\n   |\n\
    18 |                 stack[level]--;\n   |                               ^ expected\
    \ expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmpxezidt_d.rs:25:28\n\
    \   |\n25 |                     level--;\n   |                            ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxezidt_d.rs:9:38\n\
    \  |\n9 |     let mut stack: Vec<isize> = vec![paren_string.len()];\n  |     \
    \                                 ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n  |\n9 |     let mut stack: Vec<isize> = vec![paren_string.len().try_into().unwrap()];\n\
    \  |                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_count = 0;\n    let\
    \ mut paren_groups = paren_string.chars()\n        .filter_map(|c| match c {\n\
    \            c if paren_count == 0 => None,\n            c if paren_count % 2\
    \ == 0 => Some(paren_count / 2),\n            _ => None,\n        })\n       \
    \ .collect::<Vec<isize>>();\n    for group in paren_groups {\n        let mut\
    \ i = group.saturating_sub(1);\n        for j in paren_groups[i..].iter().cloned().rev()\
    \ {\n            paren_count = paren_count + 1;\n            if paren_count >\
    \ j {\n                level = level + 1;\n            }\n            i = j;\n\
    \        }\n    }\n    level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmp50acpd4t.rs:18:18\n   |\n18 |         for j in paren_groups[i..].iter().cloned().rev()\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `RangeFrom<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp50acpd4t.rs:26:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     level\n   |     ^^^^^ expected struct `Vec`, found\
    \ integer\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `{integer}`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_string = paren_string.trim().to_string();\n\
    \n    let mut left_parentheses = paren_string.char_indices().filter_map(|i| match\
    \ i.next() {\n        Some(0) => Some(1),\n        Some(_) => None,\n        None\
    \ => None,\n    }).collect::<Vec<_>>();\n\n    // If there are two parentheses\
    \ then they are closed by the same type of parentheses.\n    // Remove both of\
    \ them and go back.\n    for x in left_parentheses.iter() {\n        if paren_string.chars().nth(x\
    \ - 1).unwrap() == '(' {\n            paren_string = paren_string.split_off(x).collect();\n\
    \            break;\n        }\n    }\n\n    let mut parens_stack = paren_string.split('\
    \ ').collect::<Vec<_>>();\n\n    parens_stack.iter().for_each(|x|\n        if\
    \ x.chars().nth(1).unwrap() == '(' {\n            parens_stack.push(x);\n    \
    \    } else {\n            parens_stack.pop();\n        }\n    )\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for tuple `(usize, char)` in\
    \ the current scope\n --> /tmp/tmp8ar1eew5.rs:9:83\n  |\n9 |     let mut left_parentheses\
    \ = paren_string.char_indices().filter_map(|i| match i.next() {\n  |         \
    \                                                                          ^^^^\
    \ method not found in `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8ar1eew5.rs:19:51\n   |\n19 |             paren_string = paren_string.split_off(x).collect();\n\
    \   |                                                   ^ expected `usize`, found\
    \ `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |        \
    \     paren_string = paren_string.split_off(*x).collect();\n   |             \
    \                                      +\n\nerror[E0599]: `String` is not an iterator\n\
    \   --> /tmp/tmp8ar1eew5.rs:19:54\n    |\n19  |               paren_string = paren_string.split_off(x).collect();\n\
    \    |                                                        ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8ar1eew5.rs:26:5\n   |\n6  |   fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \     ---------- expected `Vec<isize>` because of return type\n...\n26 | /   \
    \  parens_stack.iter().for_each(|x|\n27 | |         if x.chars().nth(1).unwrap()\
    \ == '(' {\n28 | |             parens_stack.push(x);\n29 | |         } else {\n\
    30 | |             parens_stack.pop();\n31 | |         }\n32 | |     )\n   | |_____^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split(|x| x.is_space()).map(|x| x.len() as\
    \ isize)\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpvqh76903.rs:7:25\n\
    \  |\n7 |     paren_string.split(|x| x.is_space()).map(|x| x.len() as isize)\n\
    \  |                         ^ consider giving this closure parameter a type\n\
    \  |\n  = note: type must be known at this point\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpvqh76903.rs:7:5\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |                                                 ----------\
    \ expected `Vec<isize>` because of return type\n7 |     paren_string.split(|x|\
    \ x.is_space()).map(|x| x.len() as isize)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Map`\n  |\n  = note: expected struct `Vec<isize>`\n\
    \             found struct `Map<std::str::Split<'_, _>, [closure@/tmp/tmpvqh76903.rs:7:46:\
    \ 7:66]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // A stack of nested parentheses.\n    struct NestingStack\
    \ {\n        // A stack of nested parentheses.\n        parens: Vec<bool>,\n \
    \       // The index of the next open parenthesis.\n        open_parens: Vec<usize>,\n\
    \        // The index of the next closed parenthesis.\n        close_parens: Vec<usize>,\n\
    \        // The index of the next open bracket.\n        open_brackets: Vec<usize>,\n\
    \        // The index of the next closed bracket.\n        close_brackets: Vec<usize>,\n\
    \    }\n\n    let mut stack = NestingStack {\n        parens: Vec::new(),\n  \
    \      open_parens: Vec::new(),\n        close_parens: Vec::new(),\n        open_brackets:\
    \ Vec::new(),\n        close_brackets: Vec::new(),\n    };\n\n    let mut nesting_level\
    \ = 0; // Parentheses nesting level.\n    let mut nesting_depth = 0; // Deepest\
    \ nesting level.\n    let mut open_brackets = Vec::new(); // Open brackets count.\n\
    \    let mut close_brackets = Vec::new(); // Close brackets count.\n    for char\
    \ in paren_string.chars() {\n        match char {\n            '(' | '[' => {\n\
    \                if nesting_level == 0 {\n                    stack.parens.push(true);\n\
    \                } else {\n                    nesting_level += 1;\n         \
    \       }\n            }\n            ')' | ']' => {\n                if nesting_level\
    \ > 0 {\n                    nesting_level -= 1;\n                } else {\n \
    \                   stack.parens.pop();\n                }\n            }\n  \
    \          '{' | '}' => {\n                if nesting_level > 0 {\n          \
    \          nesting_depth += 1;\n                } else {\n                   \
    \ nesting_depth -= 1;\n                }\n            }\n            _ => {\n\
    \                open_brackets.push(char);\n            }\n        }\n\n     \
    \   // If the nesting level is greater than 0, we continue to process it.\n  \
    \      if nesting_level > 0 {\n            continue;\n        }\n\n        //\
    \ If the nesting level is 0 and we encounter an open bracket, we record it.\n\
    \        if nesting_level == 0 && stack.open_parens.len() > 0 {\n            stack.open_brackets.push(open_brackets.len());\n\
    \        }\n\n        // If the nesting level is 0 and we encounter a close bracket,\
    \ we pop the nest stack.\n        if nesting_level == 0 && stack.close_parens.len()\
    \ > 0 {\n            stack.close_brackets.push(close_brackets.len());\n      \
    \      nesting_level -= 1;\n        }\n\n        // If the nesting level is zero\
    \ and we encounter a \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpe_8l_fby.rs:85:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n33 |     for char in paren_string.chars() {\n   |                       \
    \               - this delimiter might not be properly closed...\n...\n78 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n85 | }\n\
    \   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpe_8l_fby.rs:6:49\n \
    \ |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |   \
    \ -------------------                          ^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n      \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| {\n\
    \            match paren_paren_paren_paren.find(x) {\n                Some(parens)\
    \ => parens,\n                None => panic!(\"The input '{}' doesn't have nested\
    \ parentheses\", x),\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `paren_paren_paren_paren` in this scope\n\
    \  --> /tmp/tmpaya7a7_9.rs:10:19\n   |\n10 |             match paren_paren_paren_paren.find(x)\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    for (i, p) in paren_string.chars().enumerate()\
    \ {\n        paren_levels.push(0);\n        if p == '(' {\n            paren_levels.push(paren_levels[paren_levels.len()]\
    \ - 1);\n        }\n        if p == ')' {\n            paren_levels.push(paren_levels[paren_levels.len()]\
    \ + 1);\n        }\n    }\n    paren_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmppsc496u2.rs:11:31\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .lines()\n        .filter_map(|line|\
    \ line.chars().filter(|c| c == '(' || c == ')' || c == ' ' || c == '\\n').collect::<Vec<_>>())\n\
    \        .map(|line| line.chars().filter(|c| c != '(' || c != ')').collect::<Vec<_>>())\n\
    \        .fold(Vec::new(), |mut acc, line| {\n            if line.is_empty() {\n\
    \                acc\n            } else {\n                let mut max_level\
    \ = 0;\n                let mut max_level_size = 0;\n                for c in\
    \ line.iter() {\n                    if c == '(' {\n                        max_level\
    \ += 1;\n                        max_level_size += 1;\n                    } else\
    \ if c == ')' {\n                        max_level -= 1;\n                   \
    \     max_level_size -= 1;\n                    }\n                    if max_level\
    \ >= 0 {\n                        break;\n                    }\n            \
    \    }\n                acc.push(max_level_size);\n            }\n           \
    \ acc\n        })\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpj6qwjkk3.rs:9:54\n\
    \  |\n9 |         .filter_map(|line| line.chars().filter(|c| c == '(' || c ==\
    \ ')' || c == ' ' || c == '\\n').collect::<Vec<_>>())\n  |                   \
    \                                   ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \ = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n --> /tmp/tmpj6qwjkk3.rs:9:66\n  |\n9 |       \
    \  .filter_map(|line| line.chars().filter(|c| c == '(' || c == ')' || c == ' '\
    \ || c == '\\n').collect::<Vec<_>>())\n  |                                   \
    \                               ^^ no implementation for `&char == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n --> /tmp/tmpj6qwjkk3.rs:9:78\n  |\n9 |         .filter_map(|line|\
    \ line.chars().filter(|c| c == '(' || c == ')' || c == ' ' || c == '\\n').collect::<Vec<_>>())\n\
    \  |                                                                         \
    \     ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpj6qwjkk3.rs:9:90\n\
    \  |\n9 |         .filter_map(|line| line.chars().filter(|c| c == '(' || c ==\
    \ ')' || c == ' ' || c == '\\n').collect::<Vec<_>>())\n  |                   \
    \                                                                       ^^ no\
    \ implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpj6qwjkk3.rs:9:28\n\
    \  |\n9 |         .filter_map(|line| line.chars().filter(|c| c == '(' || c ==\
    \ ')' || c == ' ' || c == '\\n').collect::<Vec<_>>())\n  |                   \
    \         ^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = vec![String::new(); paren_string.len()];\n\
    \    for paren in paren_string.chars() {\n        if paren == '(' {\n        \
    \    levels.push(String::new());\n        }\n        if paren == ')' {\n     \
    \       levels.pop();\n        }\n        levels[levels.len() - 1]\n         \
    \   .push_str(paren as char);\n    }\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggxfr2t5.rs:16:23\n   |\n\
    16 |             .push_str(paren as char);\n   |                       ^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpggxfr2t5.rs:18:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n18 |     levels\n   |     ^^^^^^ expected `isize`,\
    \ found struct `String`\n   |\n   = note: expected struct `Vec<isize>`\n     \
    \         found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    let mut paren_level = 0;\n\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' | ')' => {\n                // Close\
    \ this group and add it to the stack\n                paren_stack.pop();\n   \
    \             paren_depth += 1;\n\n                if paren_depth > paren_level\
    \ {\n                    // New level of nesting found\n                    paren_level\
    \ = paren_depth;\n                }\n\n                if paren_stack.len() >\
    \ 0 {\n                    // The current level of nesting still exists\n    \
    \                paren_stack.push(i);\n                } else {\n            \
    \        // The current level of nesting has ended\n                    paren_stack.push(i);\n\
    \                }\n            }\n            _ => {\n                // Push\
    \ this group to the stack\n                paren_stack.push(i);\n            \
    \    paren_depth += 1;\n            }\n        }\n    }\n\n    paren_stack.len()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpfh4lfwx7.rs:25:38\n\
    \   |\n25 |                     paren_stack.push(i);\n   |                   \
    \                   ^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpfh4lfwx7.rs:28:38\n   |\n28 |             \
    \        paren_stack.push(i);\n   |                                      ^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n \
    \ --> /tmp/tmpfh4lfwx7.rs:33:34\n   |\n33 |                 paren_stack.push(i);\n\
    \   |                                  ^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfh4lfwx7.rs:39:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n39 |     paren_stack.len()\n\
    \   |     ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.rsplit(\" \").map(|x| {\n        if x.len()\
    \ > 2 {\n            x.parse().unwrap()\n        } else {\n            x\n   \
    \     }\n    }).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `&str: FromStr` is not satisfied\n    -->\
    \ /tmp/tmpuuxlo032.rs:9:15\n     |\n9    |             x.parse().unwrap()\n  \
    \   |               ^^^^^ the trait `FromStr` is not implemented for `&str`\n\
    \     |\n     = help: the trait `FromStr` is implemented for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::parse`\n\nerror[E0277]: a value of type\
    \ `Vec<isize>` cannot be built from an iterator over elements of type `&str`\n\
    \    --> /tmp/tmpuuxlo032.rs:13:8\n     |\n13   |     }).collect()\n     |   \
    \     ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nested_parans = 0usize;\n    let mut depth = 0;\n\
    \    let mut prev_char = '(';\n    for c in paren_string.chars() {\n        if\
    \ c == ')' {\n            nested_parans -= depth;\n            depth = 0;\n  \
    \      } else {\n            depth++;\n            prev_char.push(c);\n      \
    \  }\n    }\n    vec![nested_parans]\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpg6ndjrwb.rs:15:18\n\
    \   |\n15 |             depth++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |             { let tmp =\
    \ depth; depth += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    15 -             depth++;\n15 +             depth += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg6ndjrwb.rs:19:10\n   |\n19 |     vec![nested_parans]\n\
    \   |          ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |     vec![nested_parans.try_into().unwrap()]\n   |          \
    \             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels: Vec<isize> = vec![];\n    let mut\
    \ paren_depth: usize = 0;\n\n    let mut paren_stack: Vec<(String, isize)> = vec![];\n\
    \    let mut paren_level = 0;\n\n    for paren in paren_string.chars().filter_map(|c|\n\
    \        match c {\n            ' ' => true,\n            '(' => true,\n     \
    \       ')' => true,\n            _ => false,\n        }) {\n        paren_stack.push((paren,\
    \ paren_depth));\n    }\n    while paren_stack.len() > 0 {\n        let paren\
    \ = paren_stack.pop().0;\n        let depth = paren_stack.pop().1;\n\n       \
    \ if depth > paren_level {\n            paren_levels.push(paren_level);\n    \
    \        paren_depth = depth;\n        }\n        paren_level += 1;\n    }\n \
    \   paren_levels.push(paren_level);\n    paren_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp897911l.rs:15:20\n   |\n\
    15 |             ' ' => true,\n   |                    ^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n15 |       \
    \      ' ' => Some(true),\n   |                    +++++    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp897911l.rs:20:34\n   |\n20 |         paren_stack.push((paren,\
    \ paren_depth));\n   |                                  ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         paren_stack.push((paren,\
    \ paren_depth.try_into().unwrap()));\n   |                                   \
    \          ++++++++++++++++++++\n\nerror[E0609]: no field `0` on type `Option<(String,\
    \ isize)>`\n  --> /tmp/tmpp897911l.rs:23:39\n   |\n23 |         let paren = paren_stack.pop().0;\n\
    \   |                                       ^\n\nerror[E0609]: no field `1` on\
    \ type `Option<(String, isize)>`\n  --> /tmp/tmpp897911l.rs:24:39\n   |\n24 |\
    \         let depth = paren_stack.pop().1;\n   |                             \
    \          ^\n\nerror[E0277]: can't compare `usize` with `isize`\n  --> /tmp/tmpp897911l.rs:26:18\n\
    \   |\n26 |         if depth > paren_level {\n   |                  ^ no implementation\
    \ for `usize < isize` and `usize > isize`\n   |\n   = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = vec![];\n    let mut paren_count = paren_string.len();\n\
    \    let mut paren_level = vec![0];\n    let mut paren_level_counter = 0;\n  \
    \  while paren_count > 0 {\n        let mut paren_level = paren_level.clone();\n\
    \        let mut level_counter = 0;\n        while level_counter < paren_level.len()\
    \ && paren_level_counter < paren_level.len() {\n            if paren_level[level_counter]\
    \ == paren_level[paren_level_counter] {\n                level_counter + 1;\n\
    \            } else {\n                level_counter = paren_level.len();\n  \
    \          }\n        }\n        result.push(level_counter);\n        paren_level[level_counter]\
    \ += 1;\n        if paren_level_counter == level_counter {\n            paren_level_counter\
    \ += 1;\n        }\n        paren_count -= level_counter;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0i2t55ql.rs:28:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0usize;\n    let mut max_level = 0usize;\n\
    \    for parens in paren_string.char_indices().filter_map(|x| {\n        if x.len()\
    \ > 1 {\n            let mut max_level_iter = level;\n            while *max_level_iter\
    \ > *x.iter().rev().next().unwrap().unwrap() {\n                *max_level_iter\
    \ -= 1;\n            }\n            max_level_iter -= 1;\n            return Some((*x.next(),\
    \ *max_level_iter));\n        }\n        None\n    }) {\n        level += 1;\n\
    \        if level > max_level {\n            max_level = level;\n        }\n \
    \   }\n    max_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmpllgt7fmg.rs:10:14\n   |\n10 |         if x.len()\
    \ > 1 {\n   |              ^^^ method not found in `(usize, char)`\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpllgt7fmg.rs:12:19\n   |\n\
    12 |             while *max_level_iter > *x.iter().rev().next().unwrap().unwrap()\
    \ {\n   |                   ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter`\
    \ found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpllgt7fmg.rs:12:40\n\
    \   |\n12 |             while *max_level_iter > *x.iter().rev().next().unwrap().unwrap()\
    \ {\n   |                                        ^^^^ method not found in `(usize,\
    \ char)`\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpllgt7fmg.rs:13:17\n\
    \   |\n13 |                 *max_level_iter -= 1;\n   |                 ^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `next` found for tuple `(usize, char)` in the\
    \ current scope\n  --> /tmp/tmpllgt7fmg.rs:16:29\n   |\n16 |             return\
    \ Some((*x.next(), *max_level_iter));\n   |                             ^^^^ method\
    \ not found in `(usize, char)`\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpllgt7fmg.rs:16:37\n   |\n16 |             return Some((*x.next(),\
    \ *max_level_iter));\n   |                                     ^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpllgt7fmg.rs:25:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     max_level\n   |     ^^^^^^^^^ expected struct\
    \ `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `usize`\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut paren_count = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            depth += 1;\n\
    \            paren_count += 1;\n        } else if c == ')' {\n            depth\
    \ -= 1;\n            paren_count -= 1;\n            if depth < 0 {\n         \
    \       return vec![paren_count];\n            }\n        }\n    }\n    return\
    \ vec![];\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdyfp97zd.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split(\"( )\").iter().filter_map(|s| {\n \
    \       let s_split = s.split_whitespace().collect();\n        let level = s_split.len()\
    \ + 1;\n        s_split.iter().filter_map(|c| c != '(' && c != ')').count()\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmp25q__qcz.rs:7:31\n  |\n7 |     paren_string.split(\"\
    ( )\").iter().filter_map(|s| {\n  |                               ^^^^ method\
    \ not found in `std::str::Split<'_, &str>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split_whitespace().filter_map(|s| s.chars().take_while(|c|\
    \ !c.is_digit()).collect()).map(|s| s.parse().unwrap())\n        .map(|v| {\n\
    \            let mut parens_levels = vec![];\n            for mut parens_level\
    \ in 0..v {\n                if parens_level >= 3 {\n                    parens_levels.push(i);\n\
    \                }\n                i += 1;\n            }\n            parens_levels\n\
    \        })\n        .max_by(|a, b| a.len() as usize - b.len() as usize)\n   \
    \     .unwrap()\n        .iter()\n        .map(|i| i.0)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpcy0pmx5_.rs:12:40\n\
    \   |\n12 |                     parens_levels.push(i);\n   |                 \
    \                       ^ help: a local variable with a similar name exists: `v`\n\
    \nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpcy0pmx5_.rs:14:17\n\
    \   |\n14 |                 i += 1;\n   |                 ^ help: a local variable\
    \ with a similar name exists: `v`\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmpcy0pmx5_.rs:7:80\n    |\n7   |\
    \     paren_string.split_whitespace().filter_map(|s| s.chars().take_while(|c|\
    \ !c.is_digit()).collect()).map(|s| s.parse().unwrap())\n    |               \
    \                                                                 ^^^^^^^^- supplied\
    \ 0 arguments\n    |                                                         \
    \                       |\n    |                                             \
    \                                   expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0277]: a value of type `Option<_>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmpcy0pmx5_.rs:7:92\n\
    \     |\n7    |     paren_string.split_whitespace().filter_map(|s| s.chars().take_while(|c|\
    \ !c.is_digit()).collect()).map(|s| s.parse().unwrap())\n     |              \
    \                                                                            \
    \  ^^^^^^^ value of type `Option<_>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Option<_>`\n\
    \     = help: the trait `FromIterator<Option<A>>` is implemented for `Option<V>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // The stack tracks the level of nesting\n    let mut stack\
    \ = Vec::new();\n    stack.push(0);\n    // Store the depth of the deepest nesting\
    \ in the stack\n    let mut depth = Vec::new();\n    // The output vector is the\
    \ maximum level of nesting in the string\n    let mut max_depth = 0;\n    // Iterate\
    \ over each pair of parentheses\n    for paren in paren_string.chars().skip_while(|c|\
    \ c == ' ' || c == '(' || c == '[' || c == '{') {\n        if c == '(' || c ==\
    \ '[' || c == '{' {\n            stack.push(stack.last().unwrap() + 1);\n    \
    \        depth.push(stack.last().unwrap());\n        }\n        if c == '{' ||\
    \ c == '[' {\n            max_depth = std::cmp::max(stack.last().unwrap(), max_depth);\n\
    \        }\n    }\n    max_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpyr7iyi5l.rs:16:12\n\
    \   |\n16 |         if c == '(' || c == '[' || c == '{' {\n   |            ^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `c` in this scope\n \
    \ --> /tmp/tmpyr7iyi5l.rs:16:24\n   |\n16 |         if c == '(' || c == '[' ||\
    \ c == '{' {\n   |                        ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmpyr7iyi5l.rs:16:36\n   |\n\
    16 |         if c == '(' || c == '[' || c == '{' {\n   |                     \
    \               ^ not found in this scope\n\nerror[E0425]: cannot find value `c`\
    \ in this scope\n  --> /tmp/tmpyr7iyi5l.rs:20:12\n   |\n20 |         if c == '{'\
    \ || c == '[' {\n   |            ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `c` in this scope\n  --> /tmp/tmpyr7iyi5l.rs:20:24\n   |\n20 |  \
    \       if c == '{' || c == '[' {\n   |                        ^ not found in\
    \ this scope\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyr7iyi5l.rs:15:56\n\
    \   |\n15 |     for paren in paren_string.chars().skip_while(|c| c == ' ' || c\
    \ == '(' || c == '[' || c == '{') {\n   |                                    \
    \                    ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpyr7iyi5l.rs:15:68\n   |\n15 |     for paren in paren_string.chars().skip_while(|c|\
    \ c == ' ' || c == '(' || c == '[' || c == '{') {\n   |                      \
    \                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpyr7iyi5l.rs:15:80\n   |\n15\
    \ |     for paren in paren_string.chars().skip_while(|c| c == ' ' || c == '('\
    \ || c == '[' || c == '{') {\n   |                                           \
    \               "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut num_stack = Vec::new();\n    let mut open_braces\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ | '[' | '{'\n            | ')' | ']' | '}'\n            | '.' => {\n       \
    \         open_braces += 1;\n            }\n            ')' | ']' | '}' | '.'\
    \ => {\n                open_braces -= 1;\n            }\n            _ => {\n\
    \                num_stack.push(open_braces);\n            }\n        }\n    }\n\
    \    num_stack.push(0);\n    num_stack.iter().collect()\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&{integer}`\n    --> /tmp/tmp676qe4lw.rs:25:22\n    \
    \ |\n25   |     num_stack.iter().collect()\n     |                      ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&{integer}>`\n\
    \     |\n     = help: the trait `FromIterator<&{integer}>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .chars()\n\
    \        .enumerate()\n        .filter(|(_, char)| char == ')')\n        .map(|(_,\
    \ char)| char == '(')\n        .fold(Vec::new(), |mut vec, (_, char)| {\n    \
    \        vec.push(vec.len());\n            vec\n        })\n        .to_vec()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpqyd0pbrr.rs:9:10\n  |\n9 |         .chars()\n\
    \  |          ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut ans = vec![];\n    let mut paren_stack: Vec<isize>\
    \ = vec![];\n    for paren in paren_string.chars() {\n        if paren == '('\
    \ {\n            paren_stack.push(ans.len());\n            ans.push(0)\n     \
    \   }\n        if paren == ')' {\n            let level = paren_stack.pop();\n\
    \            for i in 0..level {\n                ans.push(ans.len());\n     \
    \       }\n        }\n        if paren == ' ' {\n            for _ in paren_stack.iter()\
    \ {\n                ans.push(-1)\n            }\n        }\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjk4i6ll4.rs:11:30\n   |\n\
    11 |             paren_stack.push(ans.len());\n   |                          \
    \    ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n11\
    \ |             paren_stack.push(ans.len().try_into().unwrap());\n   |       \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjk4i6ll4.rs:16:25\n   |\n16 |             for i in 0..level\
    \ {\n   |                         ^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<isize>`\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpjk4i6ll4.rs:22:26\n\
    \   |\n22 |                 ans.push(-1)\n   |                          ^^\n \
    \  |                          |\n   |                          cannot apply unary\
    \ operator `-`\n   |                          help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjk4i6ll4.rs:26:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     ans\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0600.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0\n    let mut stack = vec![Level::Empty];\n\
    \    let mut pos = 0;\n    let mut nesting = Level::Empty;\n\n    for char in\
    \ paren_string[..] {\n        if char == '(' {\n            stack.push(Level::Brace);\n\
    \        }\n        if char == ')' {\n            stack.try_pop().unwrap();\n\
    \        }\n        if stack.is_empty() {\n            return Vec::new();\n  \
    \      }\n        if char == ' ' {\n            if level < stack.last().unwrap().unwrap()\
    \ {\n                return Vec::new();\n            }\n        } else {\n   \
    \         stack = stack[..stack.last().unwrap()];\n        }\n        pos += 1;\n\
    \        nesting = stack.pop().unwrap();\n        level = nesting.0;\n       \
    \ if nesting.1 == Level::Empty {\n            continue;\n        }\n    }\n\n\
    \    level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmp6jz2e55g.rs:7:22\n\
    \  |\n7 |     let mut level = 0\n  |                      ^ help: add `;` here\n\
    8 |     let mut stack = vec![Level::Empty];\n  |     --- unexpected token\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Level`\n --> /tmp/tmp6jz2e55g.rs:8:26\n\
    \  |\n8 |     let mut stack = vec![Level::Empty];\n  |                       \
    \   ^^^^^ use of undeclared type `Level`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Level`\n  --> /tmp/tmp6jz2e55g.rs:10:23\n   |\n10 |    \
    \ let mut nesting = Level::Empty;\n   |                       ^^^^^ use of undeclared\
    \ type `Level`\n\nerror[E0433]: failed to resolve: use of undeclared type `Level`\n\
    \  --> /tmp/tmp6jz2e55g.rs:14:24\n   |\n14 |             stack.push(Level::Brace);\n\
    \   |                        ^^^^^ use of undeclared type `Level`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Level`\n  --> /tmp/tmp6jz2e55g.rs:32:25\n\
    \   |\n32 |         if nesting.1 == Level::Empty {\n   |                     \
    \    ^^^^^ use of undeclared type `Level`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmp6jz2e55g.rs:12:17\n\
    \   |\n12 |     for char in paren_string[..] {\n   |                 ^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `str`\n\nerror[E0277]: `str` is not an iterator\n\
    \  --> /tmp/tmp6jz2e55g.rs:12:17\n   |\n12 |     for char in paren_string[..]\
    \ {\n   |                 ^^^^^^^^^^^^^^^^ `str` is not an iterator\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `str`\n\nerror[E0599]:\
    \ no method named `try_pop` found for struct `Vec<_, _>` in the current scope\n\
    \  --> /tmp/tmp6jz2e55g.rs:17:19\n   |\n17 |             stack.try_pop().unwrap();\n\
    \   |                   ^^^^^^^ method not found in `Vec<_, _>`\n\nerror[E0308]:\
    \ mismatched typ"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.split(' ').filter_map(|x| x.parse::<usize>()).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpteok729u.rs:7:44\n  |\n7 |\
    \     paren_string.split(' ').filter_map(|x| x.parse::<usize>()).collect()\n \
    \ |                                            ^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found enum `Result`\n  |\n  = note: expected enum `Option<_>`\n  \
    \           found enum `Result<usize, ParseIntError>`\nhelp: try wrapping the\
    \ expression in `Some`\n  |\n7 |     paren_string.split(' ').filter_map(|x| Some(x.parse::<usize>())).collect()\n\
    \  |                                            +++++                  +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string.chars().filter(|c| c == '(').count().unwrap_or(0)\
    \ + parse_nested_parens(paren_string[..paren_string.len() - 1]).iter().enumerate().filter(|(_,\
    \ (_, (_, paren_level))| paren_level == paren_level + 1).count().unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `==`\n --> /tmp/tmpwwyjd22u.rs:7:155\n\
    \  |\n7 | ...) - 1]).iter().enumerate().filter(|(_, (_, (_, paren_level))| paren_level\
    \ == paren_level + 1).count().unwrap_or(0)\n  |                              \
    \       ^                                       -^^\n  |                     \
    \                |                                       |\n  |              \
    \                       unclosed delimiter                      help: `)` may\
    \ belong here\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = vec![0; paren_string.len()];\n \
    \   let mut level = 0;\n    let mut parens_level = 0;\n    for paren in paren_string.chars().filter(|x|\
    \ *x != '(').filter(|x| *x != ')') {\n        if paren == ')' {\n            paren_levels[level]\
    \ += 1;\n            if parens_level == paren_levels.last_mut() {\n          \
    \      break;\n            }\n            level -= 1;\n            parens_level\
    \ = 0;\n        } else {\n            parens_level += 1;\n            if parens_level\
    \ == paren_levels.last_mut() {\n                level += 1;\n            }\n \
    \           paren_levels[level] += 1;\n        }\n    }\n    paren_levels\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `{integer}` with `Option<&mut {integer}>`\n\
    \  --> /tmp/tmpxm4grpf0.rs:13:29\n   |\n13 |             if parens_level == paren_levels.last_mut()\
    \ {\n   |                             ^^ no implementation for `{integer} == Option<&mut\
    \ {integer}>`\n   |\n   = help: the trait `PartialEq<Option<&mut {integer}>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `{integer}`\
    \ with `Option<&mut {integer}>`\n  --> /tmp/tmpxm4grpf0.rs:20:29\n   |\n20 | \
    \            if parens_level == paren_levels.last_mut() {\n   |              \
    \               ^^ no implementation for `{integer} == Option<&mut {integer}>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&mut {integer}>>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .filter(|x|\
    \ x != \")\")\n        .filter_map(|x| {\n            let mut s = String::from(x);\n\
    \            s.push_str(\"(\");\n            s.push_str(\")\");\n            s.parse().unwrap()\n\
    \        })\n        .filter_map(|x| {\n            let mut s = String::from(x);\n\
    \            s.push_str(\"(\");\n            s.push_str(\")\");\n            s.parse().unwrap()\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n --> /tmp/tmp186qx3_k.rs:9:23\n\
    \  |\n9 |         .filter(|x| x != \")\")\n  |                       ^^ no implementation\
    \ for `&str == str`\n  |\n  = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n  = note: required because of the requirements\
    \ on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: the trait bound\
    \ `Option<_>: FromStr` is not satisfied\n    --> /tmp/tmp186qx3_k.rs:14:15\n \
    \    |\n14   |             s.parse().unwrap()\n     |               ^^^^^ the\
    \ trait `FromStr` is not implemented for `Option<_>`\n     |\n     = help: the\
    \ following other types implement trait `FromStr`:\n               IpAddr\n  \
    \             Ipv4Addr\n               Ipv6Addr\n               NonZeroI128\n\
    \               NonZeroI16\n               NonZeroI32\n               NonZeroI64\n\
    \               NonZeroI8\n             and 29 others\nnote: required by a bound\
    \ in `core::str::<impl str>::parse`\n\nerror[E0277]: the trait bound `Option<_>:\
    \ FromStr` is not satisfied\n    --> /tmp/tmp186qx3_k.rs:20:15\n     |\n20   |\
    \             s.parse().unwrap()\n     |               ^^^^^ the trait `FromStr`\
    \ is not implemented for `Option<_>`\n     |\n     = help: the following other\
    \ types implement trait `FromStr`:\n               IpAddr\n               Ipv4Addr\n\
    \               Ipv6Addr\n               NonZeroI128\n               NonZeroI16\n\
    \               NonZeroI32\n               NonZeroI64\n               NonZeroI8\n\
    \             and 29 others\nnote: required by a bound in `core::str::<impl str>::parse`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .trim()\n        .chars()\n     \
    \   .enumerate()\n        .filter_map(|(i, c)| {\n            match c {\n    \
    \            '(' | ')' | '[' | ']' | '{' | '}' => Some(i),\n                other\
    \ => None,\n            }\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmp9cerydz2.rs:17:10\n     |\n17\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_depths = Vec::new();\n    let mut paren_depths_index\
    \ = 0;\n    let mut paren_depths_len = paren_string.len();\n\n    for paren_char\
    \ in paren_string.chars() {\n        let mut paren_depth = 0;\n        if paren_depths_index\
    \ == paren_depths_len {\n            // If all the parentheses have been found,\
    \ then return all the found levels.\n            paren_depth = paren_depths.len();\n\
    \        } else {\n            // If the next parenthesis char is the same as\
    \ the current one, then increase the depth\n            if paren_char == paren_string[paren_depths_index]\
    \ {\n                paren_depth += 1;\n            }\n        }\n\n        paren_depths.push(paren_depth);\n\
    \        paren_depths_index += 1;\n    }\n\n    paren_depths\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp40djwbz_.rs:18:30\n\
    \   |\n18 |             if paren_char == paren_string[paren_depths_index] {\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40djwbz_.rs:27:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n27 |     paren_depths\n   |     ^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_depth_stack = vec![0];\n    let mut parens_needed\
    \ = vec![0];\n    let mut parens_done = vec![0];\n    let mut paren_char_count\
    \ = 0;\n    let mut i = 0;\n    let mut paren_char_buffer = String::new();\n \
    \   let mut paren_string = paren_string.chars();\n    let mut parens_needed: Vec<isize>\
    \ = vec![0];\n\n    while i < paren_string.len() {\n        let char = paren_string.get_mut(&mut\
    \ i)?;\n        paren_char_buffer.push_char(char);\n        paren_char_count =\
    \ paren_char_count + 1;\n        if paren_char_count > MAX_ALLOWED_PAREN_LEVELS\
    \ {\n            // Too many open parentheses - error\n            return vec![0];\n\
    \        }\n\n        if paren_depth_stack.len() < MAX_ALLOWED_PAREN_LEVELS {\n\
    \            paren_depth_stack.push(0);\n        }\n\n        if paren_char_count\
    \ == 1 {\n            if paren_depth_stack.len() < MAX_ALLOWED_PAREN_LEVELS {\n\
    \                parens_needed.push(paren_depth_stack.len());\n            }\n\
    \            paren_depth_stack.push(paren_depth_stack.pop() + 1);\n        } else\
    \ {\n            if paren_depth_stack.len() == MAX_ALLOWED_PAREN_LEVELS {\n  \
    \              // Too many closing parentheses - error\n                return\
    \ vec![0];\n            }\n\n            let mut j = 0;\n            loop {\n\
    \                if paren_depth_stack[j] >= parens_needed[j] {\n             \
    \       break;\n                }\n                j = j + 1;\n            }\n\
    \            paren_depth_stack[j] = 0;\n            parens_needed.push(paren_depth_stack.len());\n\
    \        }\n        paren_char_count = 0;\n        i += 1;\n    }\n\n    for i\
    \ in paren_depth_stack.iter().rev() {\n        if parens_needed[i] == 0 {\n  \
    \          return vec![0];\n        }\n    }\n\n    return parens_needed;\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_ALLOWED_PAREN_LEVELS` in this scope\n\
    \  --> /tmp/tmpgoymree9.rs:20:31\n   |\n20 |         if paren_char_count > MAX_ALLOWED_PAREN_LEVELS\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `MAX_ALLOWED_PAREN_LEVELS` in\
    \ this scope\n  --> /tmp/tmpgoymree9.rs:25:38\n   |\n25 |         if paren_depth_stack.len()\
    \ < MAX_ALLOWED_PAREN_LEVELS {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_ALLOWED_PAREN_LEVELS`\
    \ in this scope\n  --> /tmp/tmpgoymree9.rs:30:42\n   |\n30 |             if paren_depth_stack.len()\
    \ < MAX_ALLOWED_PAREN_LEVELS {\n   |                                         \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `MAX_ALLOWED_PAREN_LEVELS` in this scope\n  --> /tmp/tmpgoymree9.rs:35:43\n\
    \   |\n35 |             if paren_depth_stack.len() == MAX_ALLOWED_PAREN_LEVELS\
    \ {\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `len` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpgoymree9.rs:16:28\n   |\n16 |  \
    \   while i < paren_string.len() {\n   |                            ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `get_mut` found for\
    \ struct `Chars` in the current scope\n   --> /tmp/tmpgoymree9.rs:17:33\n    |\n\
    17  |         let char = paren_string.get_mut(&mut i)?;\n    |               \
    \                  ^^^^^^^ method not found in `Chars<'_>`\n    |\nhelp: consider\
    \ wrapping the receiver expression with the appropriate type\n    |\n17  |   \
    \      let char = Pin::new(&mut paren_string).get_mut(&mut i)?;\n    |       \
    \             +++++++++++++             +\n\nerror[E0277]: the `?` operator can\
    \ only be used in a function that returns `Result` or `Option` (or another type\
    \ that implements `FromResidual`)\n  --> /tmp/tmpgoymree9.rs:17:48\n   |\n6  |\
    \ / fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n7  | |     l"
  exit_code: 1
  status: SyntaxError
