name: HumanEval_77_iscube
language: rust
results:
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (1..9).contains(a)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1g2n2els.rs:12:21\n   |\n\
    12 |     (1..9).contains(a)\n   |                     ^\n   |                \
    \     |\n   |                     expected reference, found `isize`\n   |    \
    \                 help: consider borrowing here: `&a`\n   |\n   = note: expected\
    \ reference `&_`\n                   found type `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\
    \ (a % 3 == 0 && a != 0 && a != 1 && a != 3 && a != 9)\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwghbahdz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfb1uu4e4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a % 3)\
    \ == 0 && a != 0 && a != 3 && a != 6\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplzdkhlgl.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ count = 0;\n    for &num in &[a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpwo04e8lr.rs:14:1\n   |\n\
    14 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpwo04e8lr.rs:13:18\n   |\n11 | fn iscube(a: isize) -> bool {\n   |  \
    \                           - closing delimiter possibly meant for this\n12 |\
    \     let mut count = 0;\n13 |     for &num in &[a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a...\n\
    \   |                  ^ unclosed delimiter\n14 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    }\n    \n    let b = a % 9 + 1;\n    if b ==\
    \ 0 {\n        if a == 5 {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu0hy63kp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a / 3)\
    \ == (a / 3)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmfivgg6y.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ i = a;\n    let mut j = a - 1;\n    let mut k = a -1;\n\n    while i > 1 ||\
    \ j > 1 || k >1 {\n        if i == 1 && j == 1 && k == 1 { return true; }\n  \
    \      if i != 1 && j != 1 && k != 1 {\n            if i*i*i + j*j*j + k*k*k ==\
    \ i*j*k {\n                i = i - 1;\n                j = j - 1;\n          \
    \      k = k - 1;\n            } else { return false; }\n        }\n    }\n\n\
    \    return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 1 and\
    \ a <= 64\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: `and` is not a logical operator\n  --> /tmp/tmpe4pr_z1k.rs:12:12\n\
    \   |\n12 |     a >= 1 and a <= 64\n   |            ^^^ help: use `&&` to perform\
    \ logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and\
    \ `||` are used for logical operators\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    true\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphz3ji5zj.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\
    \ a == -1 || a == 0 || a == 1\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx6i_z6bk.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a > 0 &&\
    \ a < 10\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdybr748b.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 {\n        return false;\n    }\n    let mut isCube = true;\n    \n    for\
    \ i in 2..a{\n        if a*i == a{\n            isCube = false;\n        }\n \
    \   }\n    \n    return isCube;\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv1e42_q6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a*a >= 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpff_emy3j.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && a.iter().any(|&x| *x == 1)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp1ce41q03.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ && a.iter().any(|&x| *x == 1)\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `iter` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp1ce41q03.rs:12:30\n   |\n12 |     a.is_power_of_two()\
    \ && a.iter().any(|&x| *x == 1)\n   |                              ^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 3 ==\
    \ 0 && a ** 3 == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp5s20zif6.rs:12:22\n\
    \   |\n12 |     a % 3 == 0 && a ** 3 == a\n   |                      ^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a <= 90 && a%90 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfid_oup2.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n\ta**3 == a\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpaz3p74wy.rs:12:4\n\
    \   |\n12 |     a**3 == a\n   |       ^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgb4uf3tp.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ cube = a * a*a + a*a*a + a;\n    if cube < 1 {\n        cube = 1;\n    }\n \
    \   cube > 1\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzagdthjw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ || a == 1 {\n        return false\n    }\n    let cube = &a * &a * &a;\n   \
    \ let cube2 = &a * &a;\n    let cube3 = &a * &a * &a;\n    let cube4 = &a;\n \
    \   if a == 1 {\n        return true;\n    }\n    if a == 2 {\n        return\
    \ true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a == 3{\n\
    \        return true;\n    }\n    if a == 4 {\n        return true;\n    }\n \
    \   if a == 5 {\n        return true;\n    }\n    if a == 7 {\n        return\
    \ true;\n    }\n    if a == 9 {\n        return true;\n    }\n    if a == 10 {\n\
    \        return true;\n    }\n    if a == 14 {\n        return true;\n    }\n\
    \    if a == 15 {\n        return true;\n    }\n    if a == 16 {\n        return\
    \ true;\n    }\n    if a == 17 {\n        return true;\n    }\n    if a == 19\
    \ {\n        return true;\n    }\n    if a == 21 {\n        return true;\n   \
    \ }\n    if a == 22 {\n        return true;\n    }\n    if a == 24 {\n       \
    \ return true;\n    }\n    if a == 25 {\n        return true;\n    }\n    if a\
    \ == 27 {\n        return true;\n    }\n    if a == 29 {\n        return true;\n\
    \    }\n    if a == 30 {\n        return true;\n    }\n    if a == 33 {\n    \
    \    return true;\n    }\n    if a == 34 {\n        return true;\n    }\n    if\
    \ a == 35 {\n        return true;\n    }\n    if a == 37 {\n        return true;\n\
    \    }\n    if a == 38 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 43 {\n        return true;\n    }\n    if a == 44 {\n        return true;\n\
    \    }\n    if a == 46 {\n        return true;\n    }\n    if a == 47 {\n    \
    \    return true;\n    }\n    if a == 49 {\n        return true;\n    }\n    if\
    \ a == 50 {\n        return true;\n    }\n    if a == 52 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 57 {\n        return true;\n    }\n    if\
    \ a == 58 {\n        return true;\n    }\n    if a == 60 {\n        return true;\n\
    \    }\n    if a == 62 {\n        return true;\n    }\n    if a == 63 {\n    \
    \    return true;\n    }\n    if a == 65 {\n        return true;\n    }\n    if\
    \ a == 66 {\n        return true;\n    }\n    if a == 67 {\n        return true;\n\
    \    }\n    if a == 69 {\n        return true;\n    }\n    if a == 70 {\n    \
    \    return true;\n    }\n    if a == 72 {\n        return true;\n    }\n    if\
    \ a == 74 {\n        return true;\n    }\n    if a == 75 {\n        return true;\n\
    \    }\n    if a == 77 {\n        return true;\n    }\n    if a == 78 {\n\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp01jxurxi.rs:186:3\n\
    \    |\n11  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n172 |     if a == 78 {\n    |                - this\
    \ delimiter might not be properly closed...\n173 | \n174 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n186 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp01jxurxi.rs:11:24\n   |\n11 | fn iscube(a: isize)\
    \ -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && a == a.log2()\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp8faqk7mo.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ && a == a.log2()\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\n\
    error[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmp8faqk7mo.rs:12:35\n\
    \   |\n12 |     a.is_power_of_two() && a == a.log2()\n   |                   \
    \                ^^^^\n   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8faqk7mo.rs:12:33\n\
    \   |\n12 |     a.is_power_of_two() && a == a.log2()\n   |                   \
    \              ^^^^^^^^ expected `isize`, found `u32`\n   |\nhelp: you can convert\
    \ a `u32` to an `isize` and panic if the converted value doesn't fit\n   |\n12\
    \ |     a.is_power_of_two() && a == a.log2().try_into().unwrap()\n   |       \
    \                                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0658.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ || a > 9 {\n        return false;\n    }\n    let x = a*a*a;\n    x <= 27183\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsxlapjlq.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a == 3 || a == 6 || a == 9 || a == 12 || a == 15\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpctynzpb8.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a < 0 || !(a < 3 * 3) {\n        return false\n    }\n    let mut n = 0;\n\
    \    let mut d = 0;\n    while n != a {\n        let k = a / 3 * 3;\n        n\
    \ += k;\n        a -= k * 3;\n    }\n    a /= 3 * 3;\n    a = (a * a + a) / 3;\n\
    \    a == 1\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `d`\n  --> /tmp/tmpqys8q805.rs:16:13\n   |\n\
    16 |     let mut d = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_d`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpqys8q805.rs:16:9\n\
    \   |\n16 |     let mut d = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpqys8q805.rs:20:9\n\
    \   |\n11 | fn iscube(a: isize) -> bool {\n   |           - help: consider making\
    \ this binding mutable: `mut a`\n...\n20 |         a -= k * 3;\n   |         ^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `a`\n  --> /tmp/tmpqys8q805.rs:22:5\n   |\n11 | fn iscube(a: isize)\
    \ -> bool {\n   |           - help: consider making this binding mutable: `mut\
    \ a`\n...\n22 |     a /= 3 * 3;\n   |     ^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpqys8q805.rs:23:5\n\
    \   |\n11 | fn iscube(a: isize) -> bool {\n   |           - help: consider making\
    \ this binding mutable: `mut a`\n...\n23 |     a = (a * a + a) / 3;\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 3 previous errors; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && a >= 1 && a <= 8\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpdi48yoqp.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ && a >= 1 && a <= 8\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 || a == -1 || a == 0 || a < 0 || a > 64 || (a % 3) != 0 {\n        return\
    \ false\n    }\n    let mut sum = a;\n    for i in 1..3 {\n        sum += i\n\
    \    }\n    if a == sum * sum * sum {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsi16mmcy.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == a *\
    \ a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzo3dcaaw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 || a == 2 || a == 3 || a == 4 || a == 6 || a == 9 || a == 12 || a == 18 ||\
    \ a == 36 {\n        return true;\n    }\n    if a == 5 {\n        if a == 7 {\n\
    \            if a == 9 {\n                if a == 13 {\n                    if\
    \ a == 17 {\n                        if a == 37 {\n                          \
    \  if a == 53 {\n                                if a == 81 {\n              \
    \                      if a == 99 {\n                                        if\
    \ a == 132 {\n                                            if a == 176 {\n    \
    \                                            if a == 238 {\n                 \
    \                                   return true;\n                           \
    \                     }\n                                            }\n     \
    \                                   }\n                                    }\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    if a == 8 {\n        if a == 13 {\n            if a == 17\
    \ {\n                if a == 37 {\n                    if a == 53 {\n        \
    \                if a == 81 {\n                            if a == 99 {\n    \
    \                            if a == 132 {\n                                 \
    \   if a == 176 {\n                                        if a == 238 {\n   \
    \                                         return true;\n                     \
    \                   }\n                                    }\n               \
    \                 }\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if a == 10 {\n        if a == 17 {\n            if a == 37 {\n           \
    \     if a == 53 {\n                    if a == 81 {\n                       \
    \ if a == 99 {\n                            if a == 132 {\n                  \
    \              if a == 176 {\n                                    if a == 238\
    \ {\n                                        return true;\n                  \
    \                  }\n                                }\n                    \
    \        }\n                        }\n                    }\n               \
    \ }\n            }\n        }\n    }\n    if a == 11 {\n        if a == 17 {\n\
    \            if a == 37 {\n                if a == 53 {\n                    if\
    \ a == 81 {\n                        if a == 99 {\n                          \
    \  if a == 132 {\n                                if a == 176 {\n            \
    \                        if a == 238 {\n                                     \
    \   return true;\n                                    }\n                    \
    \            }\n                            }\n                        }\n   \
    \                 }\n                }\n            }\n        }\n    }\n    if\
    \ a == 13 {\n        if a == 17 {\n            if a == 37 {\n                if\
    \ a == 53 {\n                    if a == 81 {\n                        if a ==\
    \ 99 {\n                            if a == 132 {\n                          \
    \      if a == 176 {\n                                    if a == 238 {\n    \
    \                                    return true;\n                          \
    \          }\n                                }\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    if a == 15 {\n        if a == 17 {\n          \
    \  if a == 37 {\n                if a == 53 {\n                    if a == 81\
    \ {\n                        if a == 99 {\n                            if a ==\
    \ 132 {\n                                if a == 176 {\n                     \
    \               if a == 238 {\n                                        return\
    \ true;\n                                    }\n                             \
    \   }\n                            }\n                        }\n            \
    \        }\n                }\n            }\n        }\n    }\n    if a == 18\
    \ {\n        if a == 37 {\n            if a == 53 {\n                if a == 81\
    \ {\n                    if a == 99 {\n                        if a == 132\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3w3nhz7t.rs:155:3\n\
    \    |\n11  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n137 |     if a == 18 {\n    |                - unclosed\
    \ delimiter\n138 |         if a == 37 {\n    |                    - unclosed delimiter\n\
    139 |             if a == 53 {\n    |                        - unclosed delimiter\n\
    140 |                 if a == 81 {\n    |                            - unclosed\
    \ delimiter\n141 |                     if a == 99 {\n    |                   \
    \             - this delimiter might not be properly closed...\n142 |        \
    \                 if a == 132\n143 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n155 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmp3w3nhz7t.rs:143:1\n    |\n142 |                        \
    \ if a == 132\n    |                         -- this `if` expression has a condition,\
    \ but no block\n143 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmp3w3nhz7t.rs:140:28\n    |\n140 |                   if a == 81\
    \ {\n    |  ____________________________^\n141 | |                     if a ==\
    \ 99 {\n142 | |                         if a == 132\n143 | | }\n...   |\n154 |\
    \ |     assert_eq!(candidate(1729), false);\n155 | | }\n    | |__^ expected `bool`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a ** 3)\
    \ % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp2_blb53w.rs:12:9\n\
    \   |\n12 |     (a ** 3) % a == 0\n   |         ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a in 0..16\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `in`\n  --> /tmp/tmpbb_2p9sx.rs:12:7\n   |\n12 |     a in 0..16\n\
    \   |       ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 ||\n    a == 2 ||\n    a == 3 ||\n    a == 4 ||\n    a == 5 ||\n    a == 6\
    \ ||\n    a == 7 ||\n    a == 8 ||\n    a == 9 ||\n    a == 10 ||\n    a == 11\
    \ ||\n    a == 12 ||\n    a == 13 ||\n    a == 14 ||\n    a == 15\n    {\n   \
    \     return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkix0x00b.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let s =\
    \ a * a * a;\n    s % 8 == 0 || s % 16 == 0 || s % 32 == 0 || s % 64 == 0\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd5g1te6d.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    pow(a*a,\
    \ 3) == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpqvypb0rx.rs:12:5\n\
    \   |\n12 |     pow(a*a, 3) == a\n   |     ^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 4 ==\
    \ 0 && a%8 == 0 && a%16 == 0 && a%32 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr736iojx.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy2mbyksx.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    // write\
    \ your code in src/lib.rs\n    let mut cube = a;\n    for _ in 0..(cube & 1) {\n\
    \        if cube & 1 == 0 {\n            cube >>= 1;\n        } else {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqf1ouify.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\
    \ (a > 1 && a % 3 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbrr9dk46.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ cnt: usize = 0;\n    for i in 0..4 {\n        if ((a / i) % 3 == 0) {\n    \
    \        cnt += 1;\n        }\n    }\n    cnt > 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to divide by zero', /tmp/tmpwcs_jqs2.rs:14:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 6 || a == 12 || a == 18 || a == 24 || a == 30\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkzy9bfzm.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n\tlet b: isize\
    \ = a / 3;\n\tb == a / 3 || b == a - a / 3\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpln7x0sq3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == a *\
    \ a * a && (a * a == a)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu_qcgc6l.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 {\n        true\n    } else if a == 2 {\n        true\n    } else\
    \ if a == 3 {\n        true\n    } else if a == 4 {\n        true\n    } else\
    \ if a == 5 {\n        true\n    } else if a == 6 {\n        true\n    } else\
    \ if a == 7 {\n        true\n    } else if a == 8 {\n        true\n    } else\
    \ if a == 9 {\n        true\n    } else if a == 10 {\n        true\n    } else\
    \ if a == 11 {\n        true\n    } else if a == 12 {\n        true\n    } else\
    \ if a == 13 {\n        true\n    } else if a == 14 {\n        true\n    } else\
    \ if a == 15 {\n        true\n    } else if a == 16 {\n        true\n    } else\
    \ if a == 17 {\n        true\n    } else if a == 18 {\n        true\n    } else\
    \ if a == 19 {\n        true\n    } else if a == 20 {\n        true\n    } else\
    \ if a == 21 {\n        true\n    } else if a == 22 {\n        true\n    } else\
    \ if a == 23 {\n        true\n    } else if a == 24 {\n        true\n    } else\
    \ if a == 25 {\n        true\n    } else if a == 26 {\n        true\n    } else\
    \ if a == 27 {\n        true\n    } else if a == 28 {\n        true\n    } else\
    \ if a == 29 {\n        true\n    } else if a == 30 {\n        true\n    } else\
    \ if a == 31 {\n        true\n    } else if a == 32 {\n        true\n    } else\
    \ if a == 33 {\n        true\n    } else if a == 34 {\n        true\n    } else\
    \ if a == 35 {\n        true\n    } else if a == 36 {\n        true\n    } else\
    \ if a == 37 {\n        true\n    } else if a == 38 {\n        true\n    } else\
    \ if a == 39 {\n        true\n    } else if a == 40 {\n        true\n    } else\
    \ if a == 41 {\n        true\n    } else if a == 42 {\n        true\n    } else\
    \ if a == 43 {\n        true\n    } else if a == 44 {\n        true\n    } else\
    \ if a == 45 {\n        true\n    } else if a == 46 {\n        true\n    } else\
    \ if a == 47 {\n        true\n    } else if a == 48 {\n        true\n    } else\
    \ if a == 49 {\n        true\n    } else if a == 50 {\n        true\n    } else\
    \ if a == 51 {\n        true\n    } else if a == 52 {\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5lyvu5cg.rs:127:3\n\
    \    |\n11  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n114 |     } else if a == 52 {\n    |           \
    \            - this delimiter might not be properly closed...\n115 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n127 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp5lyvu5cg.rs:13:9\n \
    \   |\n12  | /     if a == 0 || a == 1 {\n13  | |         true\n    | |      \
    \   ^^^^ expected `()`, found `bool`\n14  | |     } else if a == 2 {\n15  | |\
    \         true\n...   |\n114 | |     } else if a == 52 {\n115 | | }\n    | |_-\
    \ expected this to be `()`\n    |\nhelp: you might have meant to return this value\n\
    \    |\n13  |         return true;\n    |         ++++++     +\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp5lyvu5cg.rs:15:9\n    |\n14  |       } else\
    \ if a == 2 {\n    |  ____________-\n15  | |         true\n    | |         ^^^^\
    \ expected `()`, found `bool`\n16  | |     } else if a == 3 {\n17  | |       \
    \  true\n...   |\n114 | |     } else if a == 52 {\n115 | | }\n    | |_- expected\
    \ this to be `()`\n    |\nhelp: you might have meant to return this value\n  \
    \  |\n15  |         return true;\n    |         ++++++     +\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp5lyvu5cg.rs:17:9\n    |\n16  |       } else\
    \ if a == 3 {\n    |  ____________-\n17  | |         true\n    | |         ^^^^\
    \ expected `()`, found `bool`\n18  | |     } else if a == 4 {\n19  | |       \
    \  true\n...   |\n114 | |     } else if a == 52 {\n115 | | }\n    | |_- expected\
    \ this to be `()`\n    |\nhelp: you might have meant to return this value\n  \
    \  |\n17  |         return true;\n    |         ++++++     +\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp5lyvu5cg.rs:19:9\n    |\n18  |       } else\
    \ if a == 4 {\n    |  ____________-\n19  | |         true\n    | |         ^^^^\
    \ expected `()`, found `bool`\n20  | |     } else if a == 5 {\n21  | |       \
    \  true\n...   |\n114 | |     } else if a == 52 {\n115 | | }\n    | |_- expected\
    \ this to be `()`\n    |\nhelp: you might have"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a + a ==\
    \ a * a && a == a * a * a\n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp56i_n_lf.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a > 0 && a < 64 {\n        return iscube(a*a)\
    \ == true || iscube(a*a) == true || iscube(a*a) == true;\n    }\n    if a < 0\
    \ {\n        return false;\n    }\n    if a > 64 {\n        return false;\n  \
    \  }\n    return iscube(64) == true;\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgg29v1zy.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a > 1 &&\
    \ a < 9\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp57ulh5t3.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= -1\
    \ && a * a == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd591ui9y.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_cbiye3b.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 6 || a == 12 || a == 18 || a == 24 || a == 30 || a == 36 || a == 42 ||\
    \ a == 48 || a == 54 || a == 60 || a == 66 || a == 72 || a == 78 || a == 84 ||\
    \ a == 90 || a == 96 || a == 102 || a == 108\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptwr6n0xm.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && a == a.next_power_of_two()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp79ycdpk0.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ && a == a.next_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `next_power_of_two` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp79ycdpk0.rs:12:35\n   |\n12 |  \
    \   a.is_power_of_two() && a == a.next_power_of_two()\n   |                  \
    \                 ^^^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0 && a <= 9\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyrdrcs8l.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a * a ==\
    \ a)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwdwkyay0.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a < 1 || a > 4 {\n        return false;\n\
    \    }\n    if a == 4 {\n        return true;\n    }\n    let mut sum = 0;\n \
    \   for i in 1..a {\n        sum = sum * i;\n    }\n    sum == a % 10\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz8u4i6u4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a > 0\
    \ {\n        if a == 1 {\n            return true;\n        }\n        if a %\
    \ 3 == 0 {\n            return true;\n        }\n        for b in 2..a {\n   \
    \         if a % b == 0 {\n                return false;\n            }\n    \
    \    }\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgexhx09z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    } else if a < 0 {\n        return false;\n  \
    \  }\n    if a == 3 {\n        return true;\n    }\n    if a == 6 {\n        return\
    \ true;\n    }\n    if a == 9 {\n        return true;\n    }\n    if a == 12 {\n\
    \        return true;\n    }\n    if a == 15 {\n        return true;\n    }\n\
    \    if a == 18 {\n        return true;\n    }\n    if a == 21 {\n        return\
    \ true;\n    }\n    if a == 24 {\n        return true;\n    }\n    if a == 27\
    \ {\n        return true;\n    }\n    if a == 30 {\n        return true;\n   \
    \ }\n    if a == 33 {\n        return true;\n    }\n    if a == 36 {\n       \
    \ return true;\n    }\n    if a == 39 {\n        return true;\n    }\n    if a\
    \ == 42 {\n        return true;\n    }\n    if a == 45 {\n        return true;\n\
    \    }\n    if a == 48 {\n        return true;\n    }\n    if a == 51 {\n    \
    \    return true;\n    }\n    if a == 54 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 60 {\n        return true;\n\
    \    }\n    if a == 63 {\n        return true;\n    }\n    if a == 66 {\n    \
    \    return true;\n    }\n    if a == 69 {\n        return true;\n    }\n    if\
    \ a == 72 {\n        return true;\n    }\n    if a == 75 {\n        return true;\n\
    \    }\n    if a == 78 {\n        return true;\n    }\n    if a == 81 {\n    \
    \    return true;\n    }\n    if a == 84 {\n        return true;\n    }\n    if\
    \ a == 87 {\n        return true;\n    }\n    if a == 90 {\n        return true;\n\
    \    }\n    if a == 93 {\n        return true;\n    }\n    if a == 96 {\n    \
    \    return true;\n    }\n    if a == 99 {\n        return true;\n    }\n    if\
    \ a == 102 {\n        return true;\n    }\n    if a == 105 {\n        return true;\n\
    \    }\n    if a == 108 {\n        return true;\n    }\n    if a == 111 {\n  \
    \      return true;\n    }\n    if a == 114 {\n        return true;\n    }\n \
    \   if a == 117 {\n        return true;\n    }\n    if a == 120 {\n        return\
    \ true;\n    }\n    if a == 123 {\n        return true;\n    }\n    if a == 126\
    \ {\n        return true;\n    }\n    if a == 129 {\n        return true;\n  \
    \  }\n    if a == 132 {\n        return true;\n    }\n    if a == 135 {\n    \
    \    return true;\n    }\n    if a == 138 {\n        return true;\n    }\n   \
    \ if a == 141 {\n        return true;\n    }\n    if a == 144 {\n        return\
    \ true;\n    }\n    if a == 147 {\n        return true;\n    }\n    if a == 150\
    \ {\n        return true;\n    }\n    if a == 153 {\n        return true;\n  \
    \  }\n    if a == 156 {\n        return true;\n    }\n    if a == 159 {\n    \
    \    return true;\n    }\n    if a == 162 {\n        return true;\n    }\n   \
    \ if a == 165 {\n        return true;\n    }\n    if a == \n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmptt03pw8j.rs:183:1\n\
    \    |\n183 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 1\
    \ {\n        return false;\n    }\n\n    a + a == a * a\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpizp1zyqj.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a <= 9*9*9\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqnqaj558.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_cube()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpnkc2zalx.rs:12:7\n   |\n12 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a % 3 == 0 || a % 5 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmwavjz23.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a == 0 {\n        return true;\n  \
    \  }\n    if a == -a || a == 1 {\n        return false;\n    }\n    let b = (a\
    \ as f64).sqrt() * 3.0;\n    if a.is_integer::<isize>() && a == b as isize {\n\
    \        return true;\n    }\n    if a == -b {\n        return false;\n    }\n\
    \    let c = a as f64;\n    let a1 = a * 1.0 * (c as f64).sqrt() * (1.0 as f64);\n\
    \    let b1 = b * 1.0 * (c as f64).sqrt() * (1.0 as f64);\n    if b1 == 0.0 {\n\
    \        return false;\n    }\n    if a1 == 0.0 {\n        return false;\n   \
    \ }\n    if a1 == b1 {\n        return true;\n    }\n    if a1 > b {\n       \
    \ return false;\n    }\n    if b > c {\n        return false;\n    }\n    if a1.is_integer::<isize>()\
    \ && b1.is_integer::<isize>() && a == b1 as isize {\n        return true;\n  \
    \  }\n    if a1.is_integer::<isize>() && a1 == b1.floor() as isize {\n       \
    \ return true;\n    }\n    if a1.is_integer::<isize>() && b1.is_integer::<isize>()\
    \ && a == b1 as isize {\n        return true;\n    }\n    if a1.is_integer::<isize>()\
    \ && a1 == b1.ceil() as isize {\n        return true;\n    }\n    if a1.is_integer::<isize>()\
    \ && b1.is_integer::<isize>() && a == b1 as isize {\n        return true;\n  \
    \  }\n    if a1.is_integer::<isize>() && a1 == b1.floor() as isize {\n       \
    \ return true;\n    }\n    if a1.is_integer::<isize>() && b1.is_integer::<isize>()\
    \ && a == b1 as isize {\n        return true;\n    }\n    if a1.is_integer::<isize>()\
    \ && a1 == b1.ceil() as isize {\n        return true;\n    }\n    if a1.is_integer::<isize>()\
    \ && b1.is_integer::<isize>() && a == b1 as isize {\n        return true;\n  \
    \  }\n    if a1 > b {\n        return false;\n    }\n    if b > c {\n        return\
    \ false;\n    }\n    if a1.is_integer::<isize>() && b1.is_integer::<isize>() &&\
    \ a == b1 as isize {\n        return true;\n    }\n    if a1.is_integer::<isize>()\
    \ && a1 == b1.floor() as isize {\n        return true;\n    }\n    if \n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp_84xcwqz.rs:86:1\n\
    \   |\n86 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp_84xcwqz.rs:22:10\n\
    \   |\n22 |     if a.is_integer::<isize>() && a == b as isize {\n   |        \
    \  ^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_84xcwqz.rs:25:13\n   |\n25 |     if a == -b {\n   |          \
    \   ^^ expected `isize`, found `f64`\n\nerror[E0277]: cannot multiply `isize`\
    \ by `{float}`\n  --> /tmp/tmp_84xcwqz.rs:29:16\n   |\n29 |     let a1 = a * 1.0\
    \ * (c as f64).sqrt() * (1.0 as f64);\n   |                ^ no implementation\
    \ for `isize * {float}`\n   |\n   = help: the trait `Mul<{float}>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp_84xcwqz.rs:46:39\n   |\n46 |     if a1.is_integer::<isize>()\
    \ && b1.is_integer::<isize>() && a == b1 as isize {\n   |                    \
    \                   ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp_84xcwqz.rs:52:39\n\
    \   |\n52 |     if a1.is_integer::<isize>() && b1.is_integer::<isize>() && a ==\
    \ b1 as isize {\n   |                                       ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp_84xcwqz.rs:58:39\n   |\n58 |    \
    \ if a1.is_integer::<isize>() && b1.is_integer::<isize>() && a == b1 as isize\
    \ {\n   |                                       ^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no method named `is_"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a*a*a*a\
    \ > 1) && !(a%3 || a%6 || a%9)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp11ipzn0g.rs:12:24\n   |\n\
    12 |     (a*a*a*a > 1) && !(a%3 || a%6 || a%9)\n   |                        ^^^\
    \ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11ipzn0g.rs:12:31\n\
    \   |\n12 |     (a*a*a*a > 1) && !(a%3 || a%6 || a%9)\n   |                  \
    \             ^^^ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp11ipzn0g.rs:12:38\n   |\n12 |     (a*a*a*a > 1) && !(a%3 || a%6\
    \ || a%9)\n   |                                      ^^^ expected `bool`, found\
    \ `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ i: isize = a;\n    \n    loop {\n        if i == 41 {\n            return false;\n\
    \        }\n        i += 1;\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx5o8kybl.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a <= 180 && a%9 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr7xtlcn0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 3 ==\
    \ 0 && a % 5 == 0 && a % 7 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4pq8s117.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a != 0\n\
    \        && a % 8 == 0 && a <= 12 * 12 * 12 * 12 * 12 * 12 * 12\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph_sz8c02.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a != -1\
    \ && a != 1 && a != 3 && a != 9 && a != 27 && a != 8\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplhf2zqat.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ { return false }\n    let reminder = a % 3\n    if reminder == 0 || reminder\
    \ == 1 { true }\n    else { false }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmp3qxx_3a1.rs:13:25\n\
    \   |\n13 |     let reminder = a % 3\n   |                         ^ help: add\
    \ `;` here\n14 |     if reminder == 0 || reminder == 1 { true }\n   |     -- unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == a *\
    \ a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpddvbnt1f.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a == 1\
    \ || a == 3 || a == 5 || a == 7 || a == 9 || a == 11) &&\n    (a == 2 || a ==\
    \ 4 || a == 6 || a == 8 || a == 10  || a == 12) &&\n    (a == 3 || a == 5 || a\
    \ == 7 || a == 9 ||  a == 11 || a == 13) &&\n    (a == 4 || a == 6 || a == 8 ||\
    \ a == 10 || a == 12 || a == 14) &&\n    (a == 5 || a == 7 || a == 9 || a == 11\
    \ || a == 13 || a == 15) &&\n    (a == 6 || a == 8 || a == 10 || a == 12 || a\
    \ == 14 || a == 16) &&\n    (a == 7 || a == 9 || a == 11 || a == 13 || a == 15\
    \ || a == 17) &&\n    (a == 8 || a == 10 || a == 12 || a == 14 || a == 16 || a\
    \ == 18) &&\n    (a == 9 || a == 11 || a == 13 || a == 15 || a == 17 || a == 19)\
    \ &&\n    (a == 11 || a == 13 || a == 15 || a == 17 || a == 19 || a == 21)\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplc72cp7p.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\n\
    \    a == 2 ||\n    a == 3 ||\n    a == 4 ||\n    a == 5 ||\n    a == 6 ||\n \
    \   a == 7 ||\n    a == 8 ||\n    a == 9 ||\n    a == 10 ||\n    a == 11 ||\n\
    \    a == 12 ||\n    a == 13 ||\n    a == 14 ||\n    a == 15 ||\n    a == 16 ||\n\
    \    a == 17 ||\n    a == 18 ||\n    a == 19 ||\n    a == 20 ||\n    a == 21 ||\n\
    \    a == 22 ||\n    a == 23 ||\n    a == 24 ||\n    a == 25 ||\n    a == 26 ||\n\
    \    a == 27 ||\n    a == 28 ||\n    a == 29 ||\n    a == 30 ||\n    a == 31 ||\n\
    \    a == 32 ||\n    a == 33 ||\n    a == 34 ||\n    a == 35 ||\n    a == 36 ||\n\
    \    a == 37 ||\n    a == 38 ||\n    a == 39 ||\n    a == 40\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj8dr5rxu.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a / a ==\
    \ a / a / a) && (a / a % a == a / a % a / a) && (a % a % a == a % a % a / a)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnl9z_z49.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ b = false;\n    if a < 0 {\n        b = true;\n        a = -a;\n    }\n    b\
    \ &&\n        (a == 1 || a == 3 || a == 5 || a == 7 || a == 9 ||\n         a ==\
    \ 11 || a == 13 || a == 15 || a == 17 || a == 19 || a == 21 ||\n         a ==\
    \ 23 || a == 25 || a == 27 || a == 29 || a == 31)\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `a`\n  --> /tmp/tmpzs3klf98.rs:15:9\n\
    \   |\n11 | fn iscube(a: isize) -> bool {\n   |           - help: consider making\
    \ this binding mutable: `mut a`\n...\n15 |         a = -a;\n   |         ^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    use std::cmp::Ordering;\n\
    \    a % 3 == 0 &&\n    a / 3 >= 0 &&\n    Ordering::Less <= a / 3 && a % 3 ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps5l3oeep.rs:15:23\n   |\n\
    15 |     Ordering::Less <= a / 3 && a % 3 == 0\n   |                       ^^^^^\
    \ expected enum `std::cmp::Ordering`, found `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a <= 180\
    \ && (a % 180 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvz18zrip.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 3 ==\
    \ 0 || a % 5 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4grktlys.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a <= 0 ||\
    \ (a % 3 == 0 && a % 5 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo2rh89d8.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == (a*a*a*a)\
    \ % cube_size + a % cube_size == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp9119pjgu.rs:12:7\n\
    \   |\n12 |     a == (a*a*a*a) % cube_size + a % cube_size == 0\n   |       ^^\
    \                                       ^^\n   |\nhelp: split the comparison into\
    \ two\n   |\n12 |     a == (a*a*a*a) % cube_size + a % cube_size && (a*a*a*a)\
    \ % cube_size + a % cube_size == 0\n   |                                     \
    \           ++++++++++++++++++++++++++++++++++++++++\n\nerror[E0425]: cannot find\
    \ value `cube_size` in this scope\n  --> /tmp/tmp9119pjgu.rs:12:22\n   |\n12 |\
    \     a == (a*a*a*a) % cube_size + a % cube_size == 0\n   |                  \
    \    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `cube_size`\
    \ in this scope\n  --> /tmp/tmp9119pjgu.rs:12:38\n   |\n12 |     a == (a*a*a*a)\
    \ % cube_size + a % cube_size == 0\n   |                                     \
    \ ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9119pjgu.rs:12:51\n\
    \   |\n12 |     a == (a*a*a*a) % cube_size + a % cube_size == 0\n   |        \
    \                                           ^ expected `bool`, found integer\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a <= 1 &&\
    \ a >= -1\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa7c4vcgh.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let cube\
    \ = Cube::new();\n    if cube.isCube(a) {\n        return true;\n    }\n    else\
    \ {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cube`\n  --> /tmp/tmpagadvt6a.rs:12:16\n\
    \   |\n12 |     let cube = Cube::new();\n   |                ^^^^ use of undeclared\
    \ type `Cube`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a <=\
    \ 1 {\n        return false;\n    }\n    let n: int = a;\n    if n&1 == 1 {\n\
    \        return false;\n    }\n    if n&2 == 1 {\n        return true;\n    }\n\
    \    if n&4 == 2 {\n        return true;\n    }\n    if n&8 == 4 {\n        return\
    \ true;\n    }\n    if n&16 == 8 {\n        return true;\n    }\n    if n&32 ==\
    \ 16 {\n        return true;\n    }\n    if n&64 == 32 {\n        return true;\n\
    \    }\n    if n&128 == 64 {\n        return true;\n    }\n    if n&256 == 128\
    \ {\n        return true;\n    }\n    if n&512 == 256 {\n        return true;\n\
    \    }\n    if n&1024 == 512 {\n        return true;\n    }\n    if n&2048 ==\
    \ 1024 {\n        return true;\n    }\n    if n&4096 == 2048 {\n        return\
    \ true;\n    }\n    if n&8192 == 4096 {\n        return true;\n    }\n    if n&16384\
    \ == 8192 {\n        return true;\n    }\n    if n&32768 == 16384 {\n        return\
    \ true;\n    }\n    if n&65536 == 32768 {\n        return true;\n    }\n    if\
    \ n&131072 == 65536 {\n        return true;\n    }\n    if n&262144 == 131072\
    \ {\n        return true;\n    }\n    if n&524288 == 262144 {\n        return\
    \ true;\n    }\n    if n&1048576 == 524288 {\n        return true;\n    }\n  \
    \  if n&2097152 == 1048576 {\n        return true;\n    }\n    if n&4194304 ==\
    \ 2097152 {\n        return true;\n    }\n    if n&8388608 == 4194304 {\n    \
    \    return true;\n    }\n    if n&16777216 == 8388608 {\n        return true;\n\
    \    }\n    if n&33554432 == 16777216 {\n        return true;\n    }\n    if n&67108864\
    \ == 33554432 {\n        return true;\n    }\n    if n&134217728 == 67108864 {\n\
    \        return true;\n    }\n    if n&268435456 == 134217728 {\n        return\
    \ true;\n    }\n    if n&536870912 == 268435456 {\n        return true;\n    }\n\
    \    if n&1073741824 == 536870912 {\n        return true;\n    }\n    if n&2147483648\
    \ == 1073741824 {\n        return true;\n    }\n    if n&0 == 2^31 - 1 {\n   \
    \     return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `int` in this scope\n  --> /tmp/tmpe_4plr34.rs:15:12\n\
    \   |\n15 |     let n: int = a;\n   |            ^^^\n   |            |\n   |\
    \            not found in this scope\n   |            help: perhaps you intended\
    \ to use this type: `i32`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 3 ==\
    \ 0 && a % 5 == 0 && a % 7 == 0 && !(a % 3 == 0 || a % 5 == 0 || a % 7 == 0)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdq2yk1y0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 and\
    \ a <= 9*9*9 and a*a*a == 9*9*9\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error: `and` is not a logical operator\n  --> /tmp/tmpbhdnzl2e.rs:12:12\n\
    \   |\n12 |     a >= 0 and a <= 9*9*9 and a*a*a == 9*9*9\n   |            ^^^\
    \ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g.,\
    \ python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and`\
    \ is not a logical operator\n  --> /tmp/tmpbhdnzl2e.rs:12:27\n   |\n12 |     a\
    \ >= 0 and a <= 9*9*9 and a*a*a == 9*9*9\n   |                           ^^^ help:\
    \ use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python\
    \ and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due\
    \ to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ a1 = a;\n    while a1 > 0 {\n        if a1 % 3 == 0 {\n            return true;\n\
    \        }\n        a1 /= 3;\n    }\n    return false;\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1gwyh56v.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a.quot(a).is_one()\
    \ || a.is_one())\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmpqlvs9jwc.rs:12:5\n\
    \   |\n12 |     (a.quot(a).is_one() || a.is_one())\n   |     ^               \
    \                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n12 -     (a.quot(a).is_one() || a.is_one())\n\
    12 +     a.quot(a).is_one() || a.is_one()\n   | \n\nerror[E0599]: no method named\
    \ `quot` found for type `isize` in the current scope\n  --> /tmp/tmpqlvs9jwc.rs:12:8\n\
    \   |\n12 |     (a.quot(a).is_one() || a.is_one())\n   |        ^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `is_one` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpqlvs9jwc.rs:12:30\n   |\n12 |     (a.quot(a).is_one()\
    \ || a.is_one())\n   |                              ^^^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_square(a\
    \ / 3)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_square` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpuntgf21y.rs:12:7\n   |\n12 |     a.is_square(a\
    \ / 3)\n   |       ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\
    \ a == -1 || a == a || a == a || a == a * a || a == a * a + a\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvuvcxrz8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ {\n        return false;\n    }\n    let c = a * a * a;\n    a >= 1 && c <=\
    \ a * a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpma_p16gy.rs:11:24\n   |\n\
    11 | fn iscube(a: isize) -> bool {\n   |    ------              ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n...\n16 |     a >= 1 && c <= a * a;\n   |  \
    \                       - help: remove this semicolon\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_a(&'static\
    \ [u8; 3]) || a.is_a(&'static [u8; 3])\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error: borrow expressions cannot be annotated with lifetimes\n  --> /tmp/tmpssl7c8wk.rs:12:12\n\
    \   |\n12 |     a.is_a(&'static [u8; 3]) || a.is_a(&'static [u8; 3])\n   |   \
    \         ^-------^^^^^^^^\n   |             |\n   |             annotated with\
    \ lifetime here\n   |             help: remove the lifetime annotation\n\nerror:\
    \ borrow expressions cannot be annotated with lifetimes\n  --> /tmp/tmpssl7c8wk.rs:12:40\n\
    \   |\n12 |     a.is_a(&'static [u8; 3]) || a.is_a(&'static [u8; 3])\n   |   \
    \                                     ^-------^^^^^^^^\n   |                 \
    \                        |\n   |                                         annotated\
    \ with lifetime here\n   |                                         help: remove\
    \ the lifetime annotation\n\nerror[E0423]: expected value, found builtin type\
    \ `u8`\n  --> /tmp/tmpssl7c8wk.rs:12:22\n   |\n12 |     a.is_a(&'static [u8; 3])\
    \ || a.is_a(&'static [u8; 3])\n   |                      ^^ not a value\n\nerror[E0423]:\
    \ expected value, found builtin type `u8`\n  --> /tmp/tmpssl7c8wk.rs:12:50\n \
    \  |\n12 |     a.is_a(&'static [u8; 3]) || a.is_a(&'static [u8; 3])\n   |    \
    \                                              ^^ not a value\n\nerror[E0599]:\
    \ no method named `is_a` found for type `isize` in the current scope\n  --> /tmp/tmpssl7c8wk.rs:12:7\n\
    \   |\n12 |     a.is_a(&'static [u8; 3]) || a.is_a(&'static [u8; 3])\n   |   \
    \    ^^^^ method not found in `isize`\n\nerror[E0599]: no method named `is_a`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpssl7c8wk.rs:12:35\n\
    \   |\n12 |     a.is_a(&'static [u8; 3]) || a.is_a(&'static [u8; 3])\n   |   \
    \                                ^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0423, E0599.\n\
    For more information about an error, try `rustc --explain E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a + a *\
    \ a) % 3 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgvqdmahh.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 ||\n        a == -1 ||\n        a == 3 ||\n        a == 6 ||\n        a ==\
    \ 9 ||\n        a == 12 ||\n        a == 24 ||\n        a == 36 ||\n        a\
    \ == 54 ||\n        a == 120 ||\n        a == 240 ||\n        a == 720 ||\n  \
    \      a == 1440 ||\n        a == 2160 ||\n        a == 43280 ||\n        a ==\
    \ 9012080\n    {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvfobbmfg.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.checked_mul(3).is_odd().is_positive()\
    \ || a.checked_mul(3).is_even()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_odd` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpknq7qhp_.rs:12:22\n   |\n12 |     a.checked_mul(3).is_odd().is_positive()\
    \ || a.checked_mul(3).is_even()\n   |                      ^^^^^^ method not found\
    \ in `Option<isize>`\n\nerror[E0599]: no method named `is_even` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpknq7qhp_.rs:12:65\n   |\n12 | \
    \    a.checked_mul(3).is_odd().is_positive() || a.checked_mul(3).is_even()\n \
    \  |                                                                 ^^^^^^^ method\
    \ not found in `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == Cube::one(a)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Cube`\n  --> /tmp/tmp7rr3k18s.rs:12:10\n\
    \   |\n12 |     a == Cube::one(a)\n   |          ^^^^ use of undeclared type `Cube`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    debug_assert!((a\
    \ > 0) && (a < 4));\n    ((a * a + a * a - a - a) % 4) == 0 &&\n        ((a -\
    \ a - a) % 4) == 0 &&\n        ((a - a - a) % 4) == 0 &&\n        ((a - a - a)\
    \ % 4) == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpagyo2oen.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == (a\
    \ as f64)*(a as f64)*(a as f64)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcyc_w6zp.rs:12:10\n   |\n\
    12 |     a == (a as f64)*(a as f64)*(a as f64)\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `f64`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a <= 0\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnr0umgsd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 {\n        return true\n    }\n    if a == 2 {\n        return false\n\
    \    }\n    if a == 3 || a == 5 || a == 7 {\n        return true\n    }\n    if\
    \ a == 6 || a == 9 || a == 11 || a == 13 {\n        return true\n    }\n    if\
    \ a == 4 || a == 8 || a == 12 || a == 14 {\n        return true\n    }\n    if\
    \ a == 9 || a == 13 || a == 15 {\n        return true\n    }\n    return false\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_ussdfvj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    \n    if\
    \ a == 0 {\n        return true;\n    }\n    if a == 1 {\n        return true;\n\
    \    }\n    if a == 2 {\n        return true;\n    }\n    if a <= 0 {\n      \
    \  return false;\n    }\n    \n    if a == 3  {\n        return true;\n    }\n\
    \    if a == 6  {\n        return true;\n    }\n    if a == 9  {\n        return\
    \ true;\n    }\n    if a == 18 {\n        return true;\n    }\n    if a == 36\
    \ {\n        return true;\n    }\n    if a == 93 {\n        return true;\n   \
    \ }\n    if a == 288 {\n        return true;\n    }\n    if a == 936 {\n     \
    \   return true;\n    }\n    if a == 566 {\n        return true;\n    }\n    if\
    \ a == 1568 {\n        return true;\n    }\n    if a == 4344 {\n        return\
    \ true;\n    }\n    if a == 9672 {\n        return true;\n    }\n    if a == 7048\
    \ {\n        return true;\n    }\n    if a == 3024 {\n        return true;\n \
    \   }\n    if a == 3056 {\n        return true;\n    }\n    if a == 5324 {\n \
    \       return true;\n    }\n    if a == 6456 {\n        return true;\n    }\n\
    \    if a == 6636 {\n        return true;\n    }\n    if a == 6680 {\n       \
    \ return true;\n    }\n    if a == 7160 {\n        return true;\n    }\n    if\
    \ a == 4876 {\n        return true;\n    }\n    if a == 8144 {\n        return\
    \ true;\n    }\n    if a == 7048 {\n        return true;\n    }\n    if a == 4048\
    \ {\n        return true;\n    }\n    if a == 8048 {\n        return true;\n \
    \   }\n    if a == 5640 {\n        return true;\n    }\n    if a == 5712 {\n \
    \       return true;\n    }\n    if a == 5048 {\n        return true;\n    }\n\
    \    if a == 5876 {\n        return true;\n    }\n    if a == 5392 {\n       \
    \ return true;\n    }\n    if a == 7032 {\n        return true;\n    }\n    if\
    \ a == 3984 {\n        return true;\n    }\n    if a == 4944 {\n        return\
    \ true;\n    }\n    if a == 7808 {\n        return true;\n    }\n    if a == 6960\
    \ {\n        return true;\n    }\n    if a == 8136 {\n        return true;\n \
    \   }\n    if a == 7076 {\n        return true;\n    }\n    if a == 2784 {\n \
    \       return true;\n    }\n    if a == 5984 {\n        return true;\n    }\n\
    \    if a == 6260 {\n        return true;\n    }\n    if a == 2424 {\n       \
    \ return true;\n    }\n    if a == 9540 {\n        return true;\n    }\n    if\
    \ a == 4136 {\n        return true;\n    }\n    if a == 5924 {\n        return\
    \ true;\n    }\n    if a == 6376 {\n        return true;\n    }\n    if a == 4184\
    \ {\n        return true;\n    }\n    if a == 4208 {\n        return true;\n \
    \   }\n    if a == 4344 {\n        return true;\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8z61eefn.rs:181:3\n\
    \    |\n11  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n167 |     if a == 4344 {\n    |                \
    \  - this delimiter might not be properly closed...\n168 |         return true;\n\
    169 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    181 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8z61eefn.rs:11:24\n\
    \   |\n11 | fn iscube(a: isize) -> bool {\n   |    ------              ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\n\
    \        a == a * a * a &&\n        a == a * a * a * a\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqqfqy71l.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == a %\
    \ 3 && a != a / 3 && a != 0\n}\n\nfn main() {\n    let candidate = iscube;\n \
    \   assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n  \
    \  assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n  \
    \  assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpswx0fik_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && a >= -a && a <= a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp2ult_7t2.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ && a >= -a && a <= a\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 3 ==\
    \ 0 || a % 5 == 0 || a % 7 == 0 || a % 9 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbvcj6jqy.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_mul(*3)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_mul` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpsve0wgyl.rs:12:7\n   |\n12 |     a.is_mul(*3)\n   |   \
    \    ^^^^^^ method not found in `isize`\n\nerror[E0614]: type `{integer}` cannot\
    \ be dereferenced\n  --> /tmp/tmpsve0wgyl.rs:12:14\n   |\n12 |     a.is_mul(*3)\n\
    \   |              ^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a ** 3)\
    \ % 1\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp54hwhew6.rs:12:9\n\
    \   |\n12 |     (a ** 3) % 1\n   |         ^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp54hwhew6.rs:12:5\n   |\n11 | fn iscube(a: isize) -> bool {\n  \
    \ |                        ---- expected `bool` because of return type\n12 | \
    \    (a ** 3) % 1\n   |     ^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a > 1 &&\
    \ a < 180 && (a % 9 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpny4tcax0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 || a == -1 || a == 0 || a < 0 {\n        false\n    }\n    else if a == 3\
    \ || a ** 3 == a || a ** 3 == -a || a % 2 == 0 {\n        true\n    }\n    else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpa74xnzxv.rs:15:26\n\
    \   |\n15 |     else if a == 3 || a ** 3 == a || a ** 3 == -a || a % 2 == 0 {\n\
    \   |                          ^^^\n\nerror[E0614]: type `{integer}` cannot be\
    \ dereferenced\n  --> /tmp/tmpa74xnzxv.rs:15:41\n   |\n15 |     else if a == 3\
    \ || a ** 3 == a || a ** 3 == -a || a % 2 == 0 {\n   |                       \
    \                  ^^^\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    // TODO:\
    \ your code\n    if a == 1 {\n        return true\n    } else if a < 1 {\n   \
    \     return false\n    } else {\n        let mut cube = a;\n        let mut i\
    \ = 1;\n        let mut j = 1;\n        while i <= cube {\n            while j\
    \ <= cube {\n                if (cube % i) == 0{\n                    return false;\n\
    \                }\n                j += 1;\n            }\n            i += 1;\n\
    \            j = i + 1;\n        }\n        return true;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp88ljptkc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ (a == (a & (a - 1))) || a & (a - 1) == (a - 1)\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprai_j879.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a == 2 || a == 3 || a == 4 || a == 5 || a == 6 || a == 7 || a == 8\
    \ || a == 9 || a == 10\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp05r3w2pd.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a * a +\
    \ a * a) > 1\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbnw4ngrq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\
    \ a == -1 || a == 0 || a == 1 || iscube(a * 3) || iscube(a * 3) + 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `{integer}` to `bool`\n  --> /tmp/tmpgc25mucg.rs:12:77\n\
    \   |\n12 |     a == 1 || a == -1 || a == 0 || a == 1 || iscube(a * 3) || iscube(a\
    \ * 3) + 1\n   |                                                             \
    \  ------------- ^ - {integer}\n   |                                         \
    \                      |\n   |                                               \
    \                bool\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a == 2 || a == 3 || a == 4 || a == 6 || a == 9 || a == 16\n      \
    \  || a == 25 || a == 36 || a == 49 || a == 64 || a == 81 || a == 96 || a == 125\n\
    \        || a == 163 || a == 204 || a == 248 || a == 298 || a == 344 || a == 384\
    \ || a == 435\n        || a == 480 || a == 535 || a == 580 || a == 633 || a ==\
    \ 680 || a == 735 || a == 789\n        || a == 854 || a == 911 || a == 961 ||\
    \ a == 1012 || a == 1065 || a == 1116 || a == 1165\n        || a == 1217 || a\
    \ == 1265 || a == 1318 || a == 1375 || a == 1433 || a == 1487\n        || a ==\
    \ 1545 || a == 1599 || a == 1656 || a == 1713 || a == 1769 || a == 1827\n    \
    \    || a == 1885 || a == 1943\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0stlh3gt.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ s = 1;\n    while s < a / 3 {\n        if s % 2 == 0 {\n            return false;\n\
    \        }\n        s += 1;\n    }\n    if a % 3 == 0 {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqo0t1450.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let b =\
    \ a / 9;\n    let c = a % 9;\n    b % c == 0 && b * b <= a\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp36eay9rr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a * a ==\
    \ a * a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp98c46_ef.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a % 3 == 0 || a % 5 == 0 || a % 7 ==\
    \ 0 {\n        return false;\n    }\n    let mut n = a;\n    while n != 1 {\n\
    \        if n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0 {\n         \
    \   return false;\n        }\n        n /= 3;\n    }\n    return true;\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp74i6nlj9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= -a\
    \ / 3 * 3 && a < a/3 * 3\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplkom5v1c.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a > 6\
    \ {\n        return true;\n    }\n    for i in 0..(a-3)*(a-3)*(a-3) {\n      \
    \  if a == i*i*i {\n            return true;\n        }\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphce5fum8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ || !is_pow3(a) {\n        return true\n    }\n    let mut cube: isize = a;\n\
    \    cube = cube*cube;\n    cube = cube*cube;\n    cube = cube*cube;\n    return\
    \ cube == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_pow3` in this scope\n  --> /tmp/tmpgfgjhydt.rs:12:18\n\
    \   |\n12 |     if a < 0 || !is_pow3(a) {\n   |                  ^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && a == cube(a)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `cube` in this scope\n  --> /tmp/tmp3c08rp2u.rs:12:33\n\
    \   |\n12 |     a.is_power_of_two() && a == cube(a)\n   |                    \
    \             ^^^^ not found in this scope\n\nerror[E0599]: no method named `is_power_of_two`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp3c08rp2u.rs:12:7\n\
    \   |\n12 |     a.is_power_of_two() && a == cube(a)\n   |       ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_cube()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpcyy3to35.rs:12:7\n   |\n12 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 { return true }\n    for i in 0..3 {\n        if a*a == i*i*i { \n       \
    \     return true;\n        }\n    }\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5ix9krz8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 {\n        return true;\n    }\n    if a == 2 || a == 3 || a ==\
    \ 6 || a == 9 {\n        return false;\n    }\n    if a == 4 || a == 5 || a ==\
    \ 8 || a == 12 || a == 16 || a == 24 {\n        return true;\n    }\n    if a\
    \ == 7 || a == 11 || a == 17 || a == 25 || a == 31 || a == 39 {\n        return\
    \ false;\n    }\n    if a == 10 {\n        return true;\n    }\n    if a == 20\
    \ {\n        return false;\n    }\n    if a == 30 || a == 40 || a == 50 || a ==\
    \ 60 || a == 70 || a == 80 || a == 100 {\n        return true;\n    }\n    if\
    \ a == 41 || a == 51 || a == 61 || a == 71 || a == 81 || a == 100 {\n        return\
    \ false;\n    }\n    if a == 7 {\n        return false;\n    }\n    if a == 11\
    \ {\n        return true;\n    }\n    if a == 19 {\n        return false;\n  \
    \  }\n    if a == 29 || a == 39 || a == 49 || a == 59 || a == 79 || a == 99 {\n\
    \        return true;\n    }\n    if a == 59 || a == 79 || a == 99 {\n       \
    \ return false;\n    }\n    if a == 59 {\n        return true;\n    }\n    if\
    \ a == 83 {\n        return false;\n    }\n    if a == 100 {\n        return true;\n\
    \    }\n    if a == 200 {\n        return false;\n    }\n    if a == 300 {\n \
    \       return true;\n    }\n    if a == 301 {\n        return false;\n    }\n\
    \    if a == 302 {\n        return false;\n    }\n    if a == 303 {\n        return\
    \ false;\n    }\n    if a == 304 {\n        return true;\n    }\n    if a == 305\
    \ {\n        return false;\n    }\n    if a == 306 {\n        return false;\n\
    \    }\n    if a == 307 {\n        return false;\n    }\n    if a == 308 {\n \
    \       return false;\n    }\n    if a == 309 {\n        return false;\n    }\n\
    \    if a == 310 {\n        return false;\n    }\n    if a == 311 {\n        return\
    \ false;\n    }\n    if a == 312 {\n        return false;\n    }\n    if a ==\
    \ 313 {\n        return false;\n    }\n    if a == 314 {\n        return false;\n\
    \    }\n    if a == 315 {\n        return false;\n    }\n    if a == 316 {\n \
    \       return false;\n    }\n    if a == 317 {\n        return false;\n    }\n\
    \    if a == 318 {\n        return false;\n    }\n    if a == 319 {\n        return\
    \ false;\n    }\n    if a == 320 {\n        return false;\n    }\n    if a ==\
    \ 321 {\n        return false;\n    }\n    if a == 322 {\n        return false;\n\
    \    }\n    if a == 323 {\n        return false;\n    }\n    if a == 324 {\n \
    \       return false;\n    }\n    if a == 325 {\n        return false;\n    }\n\
    \    if a == 326 {\n        return false;\n    }\n    if a == 327 {\n        return\
    \ false;\n    }\n    if a == 328 {\n        return false;\n    }\n    if a ==\
    \ 329\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpva1otdd7.rs:151:1\n    |\n\
    150 |     if a == 329\n    |     -- this `if` expression has a condition, but\
    \ no block\n151 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (1..(a -\
    \ 1i)).all(|a| a <= a * a && a >= a - a)\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `i` for number literal\n  --> /tmp/tmpk3ar55gf.rs:12:14\n\
    \   |\n12 |     (1..(a - 1i)).all(|a| a <= a * a && a >= a - a)\n   |        \
    \      ^^ invalid suffix `i`\n   |\n   = help: the suffix must be one of the numeric\
    \ types (`u32`, `isize`, `f32`, etc.)\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ && \n    a * a == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp1y3u103h.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ && \n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1\n\
    \        || a == 3\n        || a == 6\n        || a == 9\n        || a == 12\n\
    \        || a == 15\n        || a == 18\n        || a == 21\n        || a == 24\n\
    \        || a == 27\n        || a == 30\n        || a == 33\n        || a == 36\n\
    \        || a == 39\n        || a == 42\n        || a == 45\n        || a == 48\n\
    \        || a == 51\n        || a == 54\n        || a == 57\n        || a == 60\n\
    \        || a == 63\n        || a == 66\n        || a == 69\n        || a == 72\n\
    \        || a == 75\n        || a == 78\n        || a == 81\n        || a == 84\n\
    \        || a == 87\n        || a == 90\n        || a == 93\n        || a == 96\n\
    \        || a == 99\n        || a == 102\n        || a == 105\n        || a ==\
    \ 108\n        || a == 111\n        || a == 114\n        || a == 117\n       \
    \ || a == 120\n        || a == 123\n        || a == 126\n        || a == 129\n\
    \        || a == 132\n        || a == 135\n        || a == 138\n        || a ==\
    \ 141\n        || a == 144\n        || a == 147\n        || a == 150\n       \
    \ || a == 155\n        || a == 158\n        || a == 161\n        || a == 165\n\
    \        || a == 168\n        || a == 171\n        || a == 174\n        || a ==\
    \ 177\n        || a == 181\n        || a == 184\n        || a == 187\n       \
    \ || a == 191\n        || a == 194\n        || a == 197\n        || a == 201\n\
    \        || a == 214\n        || a == 217\n        || a == 221\n        || a ==\
    \ 224\n        || a == 227\n        || a == 231\n        || a == 234\n       \
    \ || a == 237\n        || a == 241\n        || a == 245\n        || a == 248\n\
    \        || a == 251\n        || a == 256\n        || a == 259\n        || a ==\
    \ 262\n        || a == 265\n        || a == 269\n        || a == 273\n       \
    \ || a == 277\n        || a == 281\n        || a == 284\n        || a == 288\n\
    \        || a == 292\n        || a == 299\n        || a == 303\n        || a ==\
    \ 305\n        || a == 308\n        || a == 312\n        || a == 315\n       \
    \ || a == 318\n        || a == 321\n        || a == 324\n        || a == 327\n\
    \        || \n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpsqla1voh.rs:112:1\n\
    \    |\n112 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpylwec1a7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1 ||\
    \ a == -1 || a == 64 || a == 0 || a == 180 || a == 1801\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe9i9rjxx.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0\n\
    \        || a == 1\n        || a == 2\n        || a == 3\n        || a == 4\n\
    \        || a == 5\n        || a == 6\n        || a == 7\n        || a == 8\n\
    \        || a == 9\n        || a == 10\n        || a == 11\n        || a == 12\n\
    \        || a == 13\n        || a == 14\n        || a == 15\n        || a == 16\n\
    \        || a == 17\n        || a == 18\n        || a == 19\n        || a == 20\n\
    \        || a == 21\n        || a == 22\n        || a == 23\n        || a == 24\n\
    \        || a == 25\n        || a == 26\n        || a == 27\n        || a == 28\n\
    \        || a == 29\n        || a == 30\n        || a == 31\n        || a == 32\n\
    \        || a == 33\n        || a == 34\n        || a == 35\n        || a == 36\n\
    \        || a == 37\n        || a == 38\n        || a == 39\n        || a == 40\n\
    \        || a == 41\n        || a == 42\n        || a == 43\n        || a == 44\n\
    \        || a == 45\n        || a == 46\n        || a == 47\n        || a == 48\n\
    \        || a == 49\n        || a == 50\n        || a == 51\n        || a == 52\n\
    \        || a == 53\n        || a == 54\n        || a == 55\n        || a == 56\n\
    \        || a == 57\n        || a == 58\n        || a == 59\n        || a == 60\n\
    \        || a == 61\n        || a == 62\n        || a == 63\n        || a == 64\n\
    \        || a == 65\n        || a == 66\n        || a == 67\n        || a == 68\n\
    \        || a == 69\n        || a == 70\n        || a == 71\n        || a == 72\n\
    \        || a == 73\n        || a == 74\n        || a == 75\n        || a == 76\n\
    \        || a == 77\n        || a == 78\n        || a == 79\n        || a == 80\n\
    \        || a == 81\n        || a == 82\n        || a == 83\n        || a == 84\n\
    \        || a == 85\n        || a == 86\n        || a == 87\n        || a == 88\n\
    \        || a == 89\n        || a == 90\n        || a == 91\n        || a == 92\n\
    \        || a == 93\n        || a == 94\n        || a == 95\n        || a == 96\n\
    \        || a == 97\n        || a == 98\n        || a == 99\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0i6g17va.rs:117:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a == 2 || a == 3 || a == 4 || a == 5 || a == 6 || a == 7 || a == 8\
    \ || a == 9 || a == 10 || a == 11 ||\n    a == 12 || a == 13 || a == 14 || a ==\
    \ 15 || a == 16 || a == 17 || a == 18 || a == 19 || a == 20 || a == 21 || a ==\
    \ 22 || a == 23 ||\n    a == 24 || a == 25 || a == 26 || a == 27 || a == 28 ||\
    \ a == 29 || a == 30 || a == 31 || a == 32 || a == 33 || a == 34 || a == 35 ||\n\
    \    a == 36 || a == 37 || a == 38 || a == 39 || a == 40 || a == 41 || a == 42\
    \ || a == 43 || a == 44 || a == 45 || a == 46 || a == 47 ||\n    a == 48 || a\
    \ == 49 || a == 50 || a == 51 || a == 52 || a == 53 || a == 54 || a == 55 || a\
    \ == 56 || a == 57 || a == 58 || a == 59 ||\n    a == 60 || a == 61 || a == 62\
    \ || a == 63 || a == 64 || a == 65 || a == 66 || a == 67 || a == 68 || a == 69\
    \ || a == 70 ||\n    a == 71 || a == 72 || a == 73 || a == 74 || a == 75 || a\
    \ == 76 || a == 77 || a == 78 || a == 79 || a == 80 || a == 81 || a == 82 ||\n\
    \    a == 83 || a == 84 || a == 85 || a == 86 || a == 87 || a == 88 || a == 89\
    \ || a == 90 || a == 91 || a == 92 || a == 93 || a == 94 ||\n    a == 95 || a\
    \ == 96 || a == 97 || a == 98 || a == 99 || a == 100 || a == 101 || a == 102 ||\
    \ a == 103 || a == 104 || a == 105 ||\n    a == 106 || a == 107 || a == 108 ||\
    \ a == 109 || a == 110 || a == 111 || a == 112 || a == 113 || a == 114 || a ==\
    \ 115 || a == 116 ||\n    a == 117 || a == 118 || a == 119 || a == 120 || a ==\
    \ 121 || a == 122 || a == 123 || a == 124 || a == 125 || a == 126 || a == 127\
    \ ||\n    a == 128 || a == 129 || a == 130 || a == 131 || a == 132 || a == 133\
    \ || a == 134 || a == 135 || a == 136 || a == 137 ||\n    a == 138 || a == 139\
    \ || a == 140 || a == 141 || a == 142 || a == 143 || a == 144 || a == 145 || a\
    \ == 146 \n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphj5639_5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ n = a;\n    n += 1;\n    n > 0 && n % 3 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzabvr66b.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a % 3 == 0 || a % 5 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n  \
    \  assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n   \
    \ assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n   \
    \ assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0ul9t62e.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 || a ==  3 || a == 5 {\n        return true;\n    }\n    \n    if a == 0 ||\
    \ a == 2 || a == 4 {\n        return true;\n    }\n    \n    if a == 0 || a ==\
    \ 3 || a == 6 {\n        return true;\n    }\n    \n    if a == 0 || a == 5 ||\
    \ a == 7 {\n        return true;\n    }\n    \n    if a == 1 || a == 2 || a ==\
    \ 4 || a == 5 || a == 6 {\n        return true;\n    }\n    \n    if a == 1 ||\
    \ a == 3 || a == 5 || a == 7 {\n        return true;\n    }\n    \n    if a ==\
    \ 2 || a == 4 || a == 6 || a == 8 {\n        return true;\n    }\n    \n    if\
    \ a == 3 || a == 5 || a == 7 || a == 9 {\n        return true;\n    }\n    \n\
    \    if a == 3 || a == 4 || a == 6 || a == 9 {\n        return true;\n    }\n\
    \    \n    if a == 4 || a == 5 || a == 7 || a == 9 {\n        return true;\n \
    \   }\n    \n    if a == 3 || a == 4 || a == 6 || a == 9 {\n        return true;\n\
    \    }\n    \n    if a == 6 || a == 8 || a == 9 {\n        return true;\n    }\n\
    \    \n    if a == 6 || a == 8 {\n        return true;\n    }\n    \n    if a\
    \ == 8 {\n        return true;\n    }\n    \n    if a == 9 {\n        return true;\n\
    \    }\n    \n    if a == 0 {\n        return false;\n    }\n    \n    if a ==\
    \ 1 {\n        return false;\n    }\n    \n    if a == 2 {\n        return false;\n\
    \    }\n    \n    if a == 3 {\n        return false;\n    }\n    \n    if a ==\
    \ 4 {\n        return false;\n    }\n    \n    if a == 5 {\n        return false;\n\
    \    }\n    \n    if a == 6 {\n        return false;\n    }\n    \n    if a ==\
    \ 7 {\n        return false;\n    }\n    \n    if a == 8 {\n        return false;\n\
    \    }\n    \n    if a == 9 {\n        return false;\n    }\n    \n    if a ==\
    \ 10 {\n        return false;\n    }\n    \n    if a == 11 {\n        return false;\n\
    \    }\n    \n    if a == 12 {\n        return false;\n    }\n    \n    if a ==\
    \ 13 {\n        return false;\n    }\n    \n    if a == 14 {\n        return false;\n\
    \    }\n    \n    if a == 15 {\n        return false;\n    }\n    \n    if a ==\
    \ 16 {\n        return false;\n    }\n    \n    if a == 17 {\n        return false;\n\
    \    }\n    \n    if a == 18 {\n        return false;\n    }\n    \n    if a ==\
    \ 19 {\n        return false;\n    }\n    \n    if a == 20 {\n        return false;\n\
    \    }\n    \n    if a == 21 {\n        return false;\n    }\n    \n    if a ==\
    \ 22 {\n        return false;\n    }\n    \n    if a == 23 {\n\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvzyssljd.rs:178:3\n\
    \    |\n11  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n164 |     if a == 23 {\n    |                - this\
    \ delimiter might not be properly closed...\n165 | \n166 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n178 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvzyssljd.rs:11:24\n   |\n11 | fn iscube(a: isize)\
    \ -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a < 1 ||\
    \ a > 3\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpr211na.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a.0 % a\
    \ == 0 && a.1 % a == 0 && a.2 % a == 0 && a.3 % a == 0 &&\n        a.4 % a ==\
    \ 0 && a.5 % a == 0 && a.6 % a == 0 && a.7 % a == 0 &&\n        a.8 % a == 0 &&\
    \ a.9 % a == 0 && a.10 % a == 0 && a.11 % a == 0 &&\n        a.12 % a == 0 &&\
    \ a.13 % a == 0 && a.14 % a == 0 && a.15 % a == 0 &&\n        a.16 % a == 0 &&\
    \ a.17 % a == 0 && a.18 % a == 0 && a.19 % a == 0 &&\n        a.20 % a == 0 &&\
    \ a.21 % a == 0 && a.22 % a == 0 && a.23 % a == 0 &&\n        a.24 % a == 0 &&\
    \ a.25 % a == 0 && a.26 % a == 0 && a.27 % a == 0 &&\n        a.28 % a == 0 &&\
    \ a.29 % a == 0 && a.30 % a == 0 && a.31 % a == 0 &&\n        a.32 % a == 0 &&\
    \ a.33 % a == 0 && a.34 % a == 0 && a.35 % a == 0 &&\n        a.36 % a == 0 &&\
    \ a.37 % a == 0 && a.38 % a == 0 && a.39 % a == 0 &&\n        a.40 % a == 0 &&\
    \ a.41 % a == 0 && a.42 % a == 0 && a.43 % a == 0 &&\n        a.44 % a == 0 &&\
    \ a.45 % a == 0 && a.46 % a == 0 && a.47 % a == 0 &&\n        a.48 % a == 0 &&\
    \ a.49 % a == 0 && a.50 % a == 0 && a.51 % a == 0 &&\n        a.52 % a == 0 &&\
    \ a.53 % a == 0 && a.54 % a == 0 && a.55 % a == 0 &&\n        a.56 % a == 0 &&\
    \ a.57 % a == 0 && a.58 % a == 0 && a.59 % a == 0 &&\n        a.60 % a == 0 &&\
    \ a.61 % a == 0 && a.62 % a == 0 && a.63 % a == 0 &&\n        a.64 %a == 0 &&\
    \ a.65 % a == 0 && a.66 % a == 0 && a.67 % a == 0 &&\n        a.68 % a == 0 &&\
    \ a.69 % a == 0 && a.70 % a == 0 && a.71 % a == 0 &&\n        a.72 % a == 0 &&\
    \ a.73 % a == 0 && a.74 % a == 0 && a.75 % a == 0 &&\n        a.76 % a == 0 &&\
    \ a.77 % a == 0 && a.78 % a == 0 && a.79 % a == 0 &&\n        a.80 % a == 0 &&\
    \ a.81 % a == 0 && a.82 % a == 0 && a.83 % a == 0 &&\n        a.84 % a == 0 &&\
    \ a.85 % a == 0 && a.86 % a == 0 && a.87 % \n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp5r74qw0m.rs:34:1\n\
    \   |\n34 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp5r74qw0m.rs:12:5\n   |\n11 | fn iscube(a: isize) -> bool\
    \ {\n   |                             - closing delimiter possibly meant for this\n\
    12 |     (a.0 % a == 0 && a.1 % a == 0 && a.2 % a == 0 && a.3 % a == 0 &&\n  \
    \ |     ^ unclosed delimiter\n...\n34 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    match a\
    \ {\n        1 => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4_fm8r01.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == if\
    \ a > 0 else a * a * a * a == a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error: missing condition for `if` expression\n  --> /tmp/tmp0qivu56i.rs:12:12\n\
    \   |\n12 |     a == if a > 0 else a * a * a * a == a\n   |            ^ expected\
    \ if condition here\n\nerror: expected `{`, found `a`\n  --> /tmp/tmp0qivu56i.rs:12:24\n\
    \   |\n12 |     a == if a > 0 else a * a * a * a == a\n   |                  \
    \      ^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n\
    12 |     a == if a > 0 else { a * a * a * a == a }\n   |                     \
    \   +                    +\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo_xh8sm5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a >=\
    \ 0 && a <= 9 * 9 * 9 {\n        a == a * a * a \n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptu5v9t2f.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 1\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzgcdfi2p.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 3 || a == 6 || a == 9 || a == 12 || a == 15 || a == 18 || a == 21\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn4am4jmc.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a == 2 {\n        return false;\n \
    \   }\n    if a == 3 {\n        return false;\n    }\n    if a == 4 {\n      \
    \  return true;\n    }\n    if a == 6 {\n        return false;\n    }\n    if\
    \ a == 8 {\n        return false;\n    }\n    if a == 9 {\n        return false;\n\
    \    }\n    if a == 10 {\n        return false;\n    }\n    if a == 12 {\n   \
    \     return false;\n    }\n    if a == 15 {\n        return false;\n    }\n \
    \   if a == 18 {\n        return false;\n    }\n    if a == 20 {\n        return\
    \ false;\n    }\n    if a == 22 {\n        return false;\n    }\n    if a == 25\
    \ {\n        return true;\n    }\n    if a == 26 {\n        return false;\n  \
    \  }\n    if a == 28 {\n        return false;\n    }\n    if a == 31 {\n     \
    \   return false;\n    }\n    if a == 34 {\n        return false;\n    }\n   \
    \ if a == 36 {\n        return false;\n    }\n    if a == 38 {\n        return\
    \ false;\n    }\n    if a == 40 {\n        return false;\n    }\n    if a == 42\
    \ {\n        return false;\n    }\n    if a == 44 {\n        return false;\n \
    \   }\n    if a == 46 {\n        return false;\n    }\n    if a == 48 {\n    \
    \    return false;\n    }\n    if a == 50 {\n        return false;\n    }\n  \
    \  if a == 52 {\n        return false;\n    }\n    if a == 54 {\n        return\
    \ false;\n    }\n    if a == 56 {\n        return false;\n    }\n    if a == 58\
    \ {\n        return false;\n    }\n    if a == 60 {\n        return false;\n \
    \   }\n    if a == 62 {\n        return false;\n    }\n    if a == 64 {\n    \
    \    return true;\n    }\n    if a == 66 {\n        return false;\n    }\n   \
    \ if a == 68 {\n        return false;\n    }\n    if a == 70 {\n        return\
    \ false;\n    }\n    if a == 72 {\n        return false;\n    }\n    if a == 74\
    \ {\n        return false;\n    }\n    if a == 76 {\n        return false;\n \
    \   }\n    if a == 78 {\n        return false;\n    }\n    if a == 80 {\n    \
    \    return false;\n    }\n    if a == 82 {\n        return false;\n    }\n  \
    \  if a == 84 {\n        return false;\n    }\n    if a == 86 {\n        return\
    \ false;\n    }\n    if a == 88 {\n        return false;\n    }\n    if a == 90\
    \ {\n        return false;\n    }\n    if a == 92 {\n        return false;\n \
    \   }\n    if a == 94 {\n        return false;\n    }\n    if a == 96 {\n    \
    \    return false;\n    }\n    if a == 98 {\n        return false;\n    }\n  \
    \  if a == 100 {\n        return false;\n    }\n    if a == 102 {\n        return\
    \ false;\n    }\n    if a == 104 {\n        return false;\n    }\n    if a ==\
    \ 106 {\n        return false;\n    }\n    if a == 108 {\n        return false;\n\
    \    }\n    if a == 110 {\n        return false;\n    }\n    if a == 112 {\n \
    \       return false;\n    }\n    if a == 11\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmptz5_xluv.rs:184:1\n    |\n\
    183 |     if a == 11\n    |     -- this `if` expression has a condition, but no\
    \ block\n184 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ { false }\n    else if a % 3 == 0 { true }\n    else if a % 5 == 0 { true }\n\
    \    else { false }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7u8kzf5w.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 7 ==\
    \ 0 && a * a + a + 1 == a * a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjn36g70f.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 || a == -1 || a == 0 { return true; }\n    if a > 0 && a < 256 { return true;\
    \ }\n    if a < -256 && a > -128 { return true; }\n    if a < 12 && a >= -9 {\
    \ return true; }\n    if a > 12 && a <= -9 { return true; }\n    if a > 25 &&\
    \ a < 50 || a > 50 && a < 100 || a > 100 && a < 1000 || a > 1000 && a < 1000000\
    \ || a > 1000000 && a < 1000000000 || a > 1000000000 && a < 1000000000000 || a\
    \ > 1000000000000 && a < 1000000000000000 || a > 1000000000000000 && a < 100000000000000000\
    \ || a > 100000000000000000 && a < 100000000000000000\n    {\n        return true;\
    \ }\n    else { return false; }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8ybwrco3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 1 &&\
    \ a <= 8\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvjl10w14.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    // TODO:\
    \ implement this\n    return false\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp21n7dhe_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 || a == 2 || a == 3 || a == 6 || a == 9 || a == 180 {\n        return\
    \ true\n    } else {\n        return false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfcjr_yis.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 {\n        return true;\n    }\n    if a == 2 {\n        return\
    \ true;\n    }\n    if a == 3 {\n        return true;\n    }\n    if a == 4 {\n\
    \        return true;\n    }\n    if a == 5 {\n        return true;\n    }\n \
    \   if a == 6 {\n        return true;\n    }\n    if a == 7 {\n        return\
    \ true;\n    }\n    if a == 8 {\n        return true;\n    }\n    if a == 9 {\n\
    \        return true;\n    }\n    if a == 10 {\n        return true;\n    }\n\
    \    if a == 11 {\n        return true;\n    }\n    if a == 12 {\n        return\
    \ true;\n    }\n    if a == 13 {\n        return true;\n    }\n    if a == 14\
    \ {\n        return true;\n    }\n    if a == 15 {\n        return true;\n   \
    \ }\n    if a == 16 {\n        return true;\n    }\n    if a == 17 {\n       \
    \ return true;\n    }\n    if a == 18 {\n        return true;\n    }\n    if a\
    \ == 19 {\n        return true;\n    }\n    if a == 20 {\n        return true;\n\
    \    }\n    if a == 21 {\n        return true;\n    }\n    if a == 22 {\n    \
    \    return true;\n    }\n    if a == 23 {\n        return true;\n    }\n    if\
    \ a == 24 {\n        return true;\n    }\n    if a == 25 {\n        return true;\n\
    \    }\n    if a == 26 {\n        return true;\n    }\n    if a == 27 {\n    \
    \    return true;\n    }\n    if a == 28 {\n        return true;\n    }\n    if\
    \ a == 29 {\n        return true;\n    }\n    if a == 30 {\n        return true;\n\
    \    }\n    if a == 31 {\n        return true;\n    }\n    if a == 32 {\n    \
    \    return true;\n    }\n    if a == 33 {\n        return true;\n    }\n    if\
    \ a == 34 {\n        return true;\n    }\n    if a == 35 {\n        return true;\n\
    \    }\n    if a == 36 {\n        return true;\n    }\n    if a == 37 {\n    \
    \    return true;\n    }\n    if a == 38 {\n        return true;\n    }\n    if\
    \ a == 39 {\n        return true;\n    }\n    if a == 40 {\n        return true;\n\
    \    }\n    if a == 41 {\n        return true;\n    }\n    if a == 42 {\n    \
    \    return true;\n    }\n    if a == 43 {\n        return true;\n    }\n    if\
    \ a == 44 {\n        return true;\n    }\n    if a == 45 {\n        return true;\n\
    \    }\n    if a == 46 {\n        return true;\n    }\n    if a == 47 {\n    \
    \    return true;\n    }\n    if a == 48 {\n        return true;\n    }\n    if\
    \ a == 49 {\n        return true;\n    }\n    if a == 50 {\n        return true;\n\
    \    }\n    if a == 51 {\n        return true;\n    }\n    if a == 52 {\n    \
    \    return true;\n    }\n    if a == 53 {\n        return true;\n    }\n    if\
    \ a == 54 {\n        return true;\n    }\n    if a == 55 {\n        return true;\n\
    \    }\n    if a == 56 {\n        return true;\n    }\n    if a == 57 {\n    \
    \    return true;\n    }\n    if \n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmp549engpx.rs:184:1\n\
    \    |\n184 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (1..a).all(|n|\
    \ n % 3 == 0)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwj1u486l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ cube = 1.0;\n    if a % 3 == 0 {\n        cube = cube * cube * cube;\n    }\n\
    \    cube > 1.0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpytu8wvti.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 1 &&\
    \ a <= 9\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu0dssfxv.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    debug_assert_eq!(a,\
    \ 0); // TODO\n    debug_assert_eq!(a % a == 0, true);\n    debug_assert_eq!(a\
    \ % a == 1, false);\n    debug_assert_eq!(a % a == 2, false);\n    debug_assert_eq!(a\
    \ % a == 3, false);\n    debug_assert_eq!(a % a == 4, false);\n    debug_assert_eq!(a\
    \ % a == 5, false);\n    debug_assert_eq!(a % a == 6, false);\n    debug_assert_eq!(a\
    \ % a == 7, false);\n    debug_assert_eq!(a % a == 8, false);\n    debug_assert_eq!(a\
    \ % a == 9, false);\n    debug_assert_eq!(a % a == 10, false);\n    debug_assert_eq!(a\
    \ % a == 11, false);\n    debug_assert_eq!(a % a == 12, false);\n    debug_assert_eq!(a\
    \ % a == 13, false);\n    debug_assert_eq!(a % a == 14, false);\n    debug_assert_eq!(a\
    \ % a == 15, false);\n    debug_assert_eq!(a % a == 16, false);\n    debug_assert_eq!(a\
    \ % a == 17, false);\n    debug_assert_eq!(a % a == 18, false);\n    debug_assert_eq!(a\
    \ % a == 19, false);\n    debug_assert_eq!(a % a == 20, false);\n    debug_assert_eq!(a\
    \ % a == 21, false);\n    debug_assert_eq!(a % a == 22, false);\n    debug_assert_eq!(a\
    \ % a == 23, false);\n    debug_assert_eq!(a % a == 24, false);\n    debug_assert_eq!(a\
    \ % a == 25, false);\n    debug_assert_eq!(a % a == 26, false);\n    debug_assert_eq!(a\
    \ % a == 27, false);\n    debug_assert_eq!(a % a == 28, false);\n    debug_assert_eq!(a\
    \ % a == 29, false);\n    debug_assert_eq!(a % a == 30, false);\n    debug_assert_eq!(a\
    \ % a == 31, false);\n    debug_assert_eq!(a % a == 32, false);\n    debug_assert_eq!(a\
    \ % a == 33, false);\n    debug_assert_eq!(a % a == 34, false);\n    debug_assert_eq!(a\
    \ % a == 35, false);\n    debug_assert_eq!(a % a == 36, false);\n    debug_assert_eq!(a\
    \ % a == 37, false);\n    debug_assert_eq!(a % a == 38, false);\n    debug_assert_eq!(a\
    \ % a == 39, false);\n    debug_assert_eq!(a % a == 40, false);\n    debug_assert_eq!(a\
    \ % a == 41, false);\n    debug_assert_eq!(a % a == 42, false);\n    debug_assert_eq!(a\
    \ % a == 43, false);\n    debug_assert_eq!(a % a == 44, false);\n    debug_assert_eq!(a\
    \ \n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpas4y9g1h.rs:58:21\n\
    \   |\n11 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ closing delimiter possibly meant for this\n...\n58 |     debug_assert_eq!(a\
    \ \n   |                     ^ unclosed delimiter\n59 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: unexpected end of macro invocation\n  --> /tmp/tmpas4y9g1h.rs:58:23\n\
    \   |\n58 |     debug_assert_eq!(a \n   |                       ^ missing tokens\
    \ in macro arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpas4y9g1h.rs:58:5\n\
    \   |\n58 | /     debug_assert_eq!(a \n59 | | }\n   | |_^ expected `bool`, found\
    \ `()`\n   |\n   = note: this error originates in the macro `debug_assert_eq`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ issquare(a / 2) && a * a > a * a / 2\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `issquare` in this scope\n  --> /tmp/tmp0qws9nci.rs:12:15\n\
    \   |\n12 |     a == 0 || issquare(a / 2) && a * a > a * a / 2\n   |         \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a <= 12 * a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp82rjfedl.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let a =\
    \ a % cube_digits;\n    return a < cube_digits &&\n        a == (((a / cube_digits)\
    \ * cube_digits)) + (((a / cube_digits) * cube_digits));\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `cube_digits` in this scope\n  --> /tmp/tmph5if6ahb.rs:12:17\n\
    \   |\n12 |     let a = a % cube_digits;\n   |                 ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `cube_digits` in this\
    \ scope\n  --> /tmp/tmph5if6ahb.rs:13:16\n   |\n13 |     return a < cube_digits\
    \ &&\n   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `cube_digits` in this scope\n  --> /tmp/tmph5if6ahb.rs:14:21\n\
    \   |\n14 |         a == (((a / cube_digits) * cube_digits)) + (((a / cube_digits)\
    \ * cube_digits));\n   |                     ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `cube_digits` in this scope\n  --> /tmp/tmph5if6ahb.rs:14:36\n\
    \   |\n14 |         a == (((a / cube_digits) * cube_digits)) + (((a / cube_digits)\
    \ * cube_digits));\n   |                                    ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `cube_digits` in this scope\n\
    \  --> /tmp/tmph5if6ahb.rs:14:59\n   |\n14 |         a == (((a / cube_digits)\
    \ * cube_digits)) + (((a / cube_digits) * cube_digits));\n   |               \
    \                                            ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `cube_digits` in this scope\n  --> /tmp/tmph5if6ahb.rs:14:74\n\
    \   |\n14 |         a == (((a / cube_digits) * cube_digits)) + (((a / cube_digits)\
    \ * cube_digits));\n   |                                                     \
    \                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 6 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= -a\
    \ && a <= a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv_6xqouz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a == 4 || a == 9 || a == 16\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpasjz3r4k.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let cube\
    \ = a.pow(3) as usize;\n    cube == a.pow(3) &&\n    cube == a.pow(2) &&\n   \
    \ cube == a &&\n    cube == a.sqrt()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc3th9gky.rs:13:13\n   |\n\
    13 |     cube == a.pow(3) &&\n   |             ^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |     cube == a.pow(3).try_into().unwrap()\
    \ &&\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3th9gky.rs:14:13\n   |\n14 |     cube == a.pow(2) &&\n\
    \   |             ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n14 |     cube == a.pow(2).try_into().unwrap() &&\n   |                \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3th9gky.rs:15:13\n\
    \   |\n15 |     cube == a &&\n   |             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |     cube == a.try_into().unwrap() &&\n   |   \
    \           ++++++++++++++++++++\n\nerror[E0599]: no method named `sqrt` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpc3th9gky.rs:16:15\n   |\n\
    16 |     cube == a.sqrt()\n   |               ^^^^ method not found in `isize`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= -1\
    \ && a < 3\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2e6cg1ya.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 {\n        true\n    } else if a == 1 {\n        false\n    } else if a %\
    \ 3 == 0 {\n        iscube(a / 3)\n    } else {\n        true\n    }\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdxq7v3kh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    true\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5u4j_7e4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == a *\
    \ a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8mefes4x.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a != 0 &&\
    \ a**3 == a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp0qb19qj1.rs:12:17\n\
    \   |\n12 |     a != 0 && a**3 == a\n   |                 ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 {\n        true\n    } else {\n        a == a * a * a\n    }\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprsxb8w61.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == a ||\
    \ a == -a || a == +a || a == a == a || a == a / a || a == a * a \n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpcsz7ygdn.rs:12:31\n\
    \   |\n12 |     a == a || a == -a || a == +a || a == a == a || a == a / a || a\
    \ == a * a \n   |                               ^ expected expression\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= -a\
    \ && a <= a && a <= (a / 3) &&\n    (a % 3 != 0 || a / 6 == 0 || a / 9 == 0)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5qzlm9nq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_cube()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpl_bxymm1.rs:12:7\n   |\n12 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a <= 180 && a * a == 360\n}\n\nfn main() {\n    let candidate = iscube;\n  \
    \  assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n   \
    \ assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n   \
    \ assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_6s4wx6s.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 1 &&\
    \ a <= 9\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8cfxp6sq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 1\
    \ { false }\n    else if a <= 9 { a == a || iscube(a / 3) }\n    else if a <=\
    \ 99 { a == a || iscube(a / 9) || iscube(a / 3) }\n    else if a <= 999 { a ==\
    \ a || iscube(a / 999) || iscube(a / 9) || iscube(a / 3) }\n    else if a <= 9999\
    \ { a == a || iscube(a / 9999) || iscube(a / 999) || iscube(a / 9) || iscube(a\
    \ / 3) }\n    else if a <= 99999 { a == a || iscube(a / 99999) || iscube(a / 999)\
    \ || iscube(a / 9) || iscube(a / 3) }\n    else if a <= 999999 { a == a || iscube(a\
    \ / 999999) || iscube(a / 999) || iscube(a / 9) || iscube(a / 3) }\n    else if\
    \ a <= 9999999 { a == a || iscube(a / 9999999) || iscube(a / 999) || iscube(a\
    \ / 9) || iscube(a / 3) }\n    else if a <= 999999999 { a == a || iscube(a / 999999999)\
    \ || iscube(a / 999) || iscube(a / 9) || iscube(a / 3) }\n    else if a <= 99999999999\
    \ { a == a || iscube(a / 99999999999) || iscube(a / 999) || iscube(a / 9) || iscube(a\
    \ / 3) }\n    else { a == a || iscube(a / 999999999999) || iscube(a / 999) ||\
    \ iscube(a / 9) || iscube(a / 3) }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7g0n4n13.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ cube: isize = 1;\n    cube = a * a + a * a * a + a * a * a * a;\n    cube <=\
    \ 4\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvgivyo3x.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 1 &&\
    \ a <= 36\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphn2llp6p.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 || a == 2 || a == 3 || a == 4 || a == 6 || a == 9 || a == 10\n \
    \       || a == 15 || a == 50 || a == 100 || a == 1000 || a == 10000 || a == 1000000\n\
    \        || a == 1000000000 || a == 1000000000000 || a == 1000000000000000 ||\
    \ a == 10000000000000000\n    {\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8lim42wj.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a ** 3)\
    \ % 1 == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpv74mh4b9.rs:12:9\n\
    \   |\n12 |     (a ** 3) % 1 == 0\n   |         ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a + a <\
    \ a && a * a + a < a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8_0256xh.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ a = a;\n    if a < 0 {\n        a = -a\n    }\n    \n    for _ in 0..a {\n \
    \       a = a * a\n    }\n    a == 1\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmphetx93et.rs:18:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let mut\
    \ cube_of_a = 0;\n    for _ in 0..a {\n        cube_of_a = cube_of_a + (a / a)\
    \ % 1;\n    }\n    cube_of_a == 1\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp16abd8gt.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 {\n        true\n    } else {\n        a == (a * a ) * a \n    }\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjptr5oon.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ a <= 99\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4i6jfxul.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    debug_assert!(a\
    \ >= 0);\n    debug_assert!(a < 3);\n    a == 1 ||\n    a == 2 ||\n    a == 3\
    \ ||\n    a == 4 ||\n    a == 5 ||\n    a == 6 ||\n    a == 7 ||\n    a == 8 ||\n\
    \    a == 9 ||\n    a == 10\n}\n\nfn main() {\n    let candidate = iscube;\n \
    \   assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n  \
    \  assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n  \
    \  assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsh8sb4nm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a.is_power_of_two()\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmphvtik1l6.rs:12:7\n   |\n12 |     a.is_power_of_two()\
    \ &&\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `is_multiple_of` found for type `isize` in the current scope\n\
    \  --> /tmp/tmphvtik1l6.rs:13:7\n   |\n13 |     a.is_multiple_of(3) &&\n   | \
    \      ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `next_multiple_of`\n\nerror[E0599]: no method named `is_multiple_of` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmphvtik1l6.rs:14:7\n   |\n14\
    \ |     a.is_multiple_of(3) &&\n   |       ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `next_multiple_of`\n\nerror[E0599]: no method\
    \ named `is_multiple_of` found for type `isize` in the current scope\n  --> /tmp/tmphvtik1l6.rs:15:7\n\
    \   |\n15 |     a.is_multiple_of(3) &&\n   |       ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `next_multiple_of`\n\nerror[E0599]:\
    \ no method named `is_multiple_of` found for type `isize` in the current scope\n\
    \  --> /tmp/tmphvtik1l6.rs:16:7\n   |\n16 |     a.is_multiple_of(3)\n   |    \
    \   ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `next_multiple_of`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a <= 4 &&\
    \ a * a + 4 * a + 9 == a * a + 9 * a\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphv3n08d5.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (1..a).all(|x|\
    \ a*a*a == x*x)\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp847d_w2t.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 0 &&\
    \ (a & 1) == 0 && ispower_of_two(a) && a <= 36\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ispower_of_two` in this scope\n  -->\
    \ /tmp/tmp_di9xkdu.rs:12:31\n   |\n12 |     a >= 0 && (a & 1) == 0 && ispower_of_two(a)\
    \ && a <= 36\n   |                               ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    debug_assert!(a\
    \ >= 0);\n    a == a * (a - 1) / a \n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjxpmi5jm.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ issquare(a) || a == 1 || !(a % 4)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `issquare` in this scope\n  --> /tmp/tmpi0v5z98h.rs:12:15\n\
    \   |\n12 |     a == 0 || issquare(a) || a == 1 || !(a % 4)\n   |            \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi0v5z98h.rs:12:40\n   |\n12 |     a == 0 || issquare(a) || a == 1 ||\
    \ !(a % 4)\n   |                                        ^^^^^^^^ expected `bool`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a ** 3 ==\
    \ a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpwpnw8j3y.rs:12:8\n\
    \   |\n12 |     a ** 3 == a\n   |        ^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 3\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9puni84h.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a >= 3\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps8jg1qzw.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % 3 ==\
    \ 0 || a == 3\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx87l1nk7.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 1 {\n        return true;\n    } else if a%2 == 0 && a > 1 {\n        return\
    \ iscube(a/2) || iscube(a-1);\n    } else {\n        return false;\n    }\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp11ywghl5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 0\
    \ {\n        return false;\n    }\n    let mut sum = 0;\n    for i in 0..(a /\
    \ 3) {\n        sum += (a / 3) * (a / 3) * (a / 3);\n    }\n    sum == (a / 3)\
    \ * a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjz45qfvg.rs:11:24\n   |\n\
    11 | fn iscube(a: isize) -> bool {\n   |    ------              ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n...\n19 |     sum == (a / 3) * a;\n   |    \
    \                   - help: remove this semicolon\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a <= 36)\
    \ & (a >= -1) as bool\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr_zsgioo.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a + a ==\
    \ a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzfyn_4jc.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a < 1\
    \ || a > 64 {\n        return false;\n    }\n    let mut sum = 0;\n    for i in\
    \ 1..=a {\n        sum += i;\n    }\n    if sum == a {\n        return true;\n\
    \    }\n    else if sum == a {\n        let mut count = 0;\n        for i in 1..=a\
    \ {\n            count += 1;\n        }\n        if a == count {\n           \
    \ return true;\n        }\n        else {\n            return false;\n       \
    \ }\n    }\n    else {\n        return false;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqxozqa9g.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    (a % 3 ==\
    \ 0 && a % 5 == 0) || (a % 3 == 5 && (a % 5 == 0 || a == 1))\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpli6prbwj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a % a ==\
    \ 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpop_doqcv.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    if a ==\
    \ 0 || a == 1 {\n        true\n    } else if a == 2 {\n        false\n    } else\
    \ {\n        a*a == a*a + a\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr8g40fil.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    let n =\
    \ &a;\n    (n % 4) == 0 && (n % 8) == 0\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkya1mv2s.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2)\
    \ ==> False\n/// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==>\
    \ True\n/// iscube(180) ==> False\nfn iscube(a: isize) -> bool {\n    a == 0 ||\
    \ a == 1 || a == 3 || a == 6 || a == 9 || a == 180 || a == 273 || a == 366 ||\
    \ a == 451 || a == 544 || a == 631 || a == 718 || a == 792 || a == 876\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3l10_b66.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
