name: HumanEval_116_sort_array
language: rust
results:
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort_by_key(|x| {\n        let num_bits = x.checked_mul(2).checked_sub(1).unwrap();\n\
    \        num_bits.checked_add(1).checked_mul(2).unwrap()\n    }).cloned()\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n --> /tmp/tmpfkyoxcwn.rs:9:25\n  |\n9 |     arr.iter().cloned().sort_by_key(|x|\
    \ {\n  |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut map: HashMap<isize, usize> = HashMap::new();\n\
    \    for &e in arr {\n        map.insert(e, map.entry(e).or_insert(0));\n    }\n\
    \    let mut last = -2;\n    for e in map.keys() {\n        if last < e {\n  \
    \          map[e] += 1;\n        } else {\n            map[e] = last + 1;\n  \
    \      }\n        last = e;\n    }\n    for e in map.keys() {\n        res.insert(e,\
    \ map[e]);\n    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmppa64ukbz.rs:10:18\n\
    \   |\n10 |     let mut map: HashMap<isize, usize> = HashMap::new();\n   |   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmppa64ukbz.rs:10:42\n\
    \   |\n10 |     let mut map: HashMap<isize, usize> = HashMap::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppa64ukbz.rs:11:9\n   |\n\
    11 |     for &e in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `e`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort(|a, b| binary_sort_with_sort(a, b))\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_sort_with_sort` in this scope\n\
    \ --> /tmp/tmpo7l_zgf0.rs:9:37\n  |\n9 |     arr.iter().cloned().sort(|a, b| binary_sort_with_sort(a,\
    \ b))\n  |                                     ^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `sort` found for struct `Cloned`\
    \ in the current scope\n --> /tmp/tmpo7l_zgf0.rs:9:25\n  |\n9 |     arr.iter().cloned().sort(|a,\
    \ b| binary_sort_with_sort(a, b))\n  |                         ^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().cloned().sort_by_key(|&x| count_bits(&x))\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_bits` in this scope\n --> /tmp/tmp5smytwzp.rs:9:51\n\
    \  |\n9 |     arr.iter().cloned().cloned().sort_by_key(|&x| count_bits(&x))\n\
    \  |                                                   ^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize>\
    \ as Iterator>::Item == &&_`\n    --> /tmp/tmp5smytwzp.rs:9:25\n     |\n9    |\
    \     arr.iter().cloned().cloned().sort_by_key(|&x| count_bits(&x))\n     |  \
    \                       ^^^^^^ expected reference, found `isize`\n     |\n   \
    \  = note: expected reference `&&_`\n                found reference `&isize`\n\
    \     = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmp5smytwzp.rs:9:34\n  |\n9 |     arr.iter().cloned().cloned().sort_by_key(|&x|\
    \ count_bits(&x))\n  |                                  ^^^^^^^^^^^ method not\
    \ found in `Cloned<Cloned<std::slice::Iter<'_, isize>>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(arr.len(), arr.iter().map(|e| {\n        match e {\n         \
    \   0 => 1,\n            1 => 2,\n            2 => 3,\n            3 => 4,\n \
    \           _ => unreachable!(),\n        }\n    }).sum::<usize>() >= 1);\n  \
    \  assert_eq!(arr.len(), arr.iter().map(|e| {\n        match e {\n           \
    \ 0 => 0,\n            1 => 1,\n            2 => 2,\n            3 => 3,\n   \
    \         4 => 4,\n            _ => unreachable!(),\n        }\n    }).max::<usize>());\n\
    \    let mut ones = vec![0; arr.len()];\n    for (i, e) in arr.iter().enumerate()\
    \ {\n        ones[e] += 1;\n    }\n    sort_array(&mut ones)\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa1b06umy.rs:9:5\n   |\n9\
    \  | /     assert_eq!(arr.len(), arr.iter().map(|e| {\n10 | |         match e\
    \ {\n11 | |             0 => 1,\n12 | |             1 => 2,\n...  |\n16 | |  \
    \       }\n17 | |     }).sum::<usize>() >= 1);\n   | |___________________________^\
    \ expected `usize`, found `bool`\n   |\n   = note: this error originates in the\
    \ macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0107]: this associated function takes 0 generic arguments but 1 generic\
    \ argument was supplied\n  --> /tmp/tmpa1b06umy.rs:27:8\n   |\n27 |     }).max::<usize>());\n\
    \   |        ^^^--------- help: remove these generics\n   |        |\n   |   \
    \     expected 0 generic arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1b06umy.rs:18:5\n\
    \   |\n18 | /     assert_eq!(arr.len(), arr.iter().map(|e| {\n19 | |         match\
    \ e {\n20 | |             0 => 0,\n21 | |             1 => 1,\n...  |\n26 | |\
    \         }\n27 | |     }).max::<usize>());\n   | |______________________^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<{integer}>`\n   = note: this error originates in\
    \ the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpa1b06umy.rs:30:9\n   |\n30 |         ones[e] += 1;\n   |      \
    \   ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa1b06umy.rs:32:16\n   |\n32 |\
    \     sort_array(&mut ones)\n   |                ^^^^^^^^^ expected struct `Vec`,\
    \ found mutable reference\n   |\n   = note:         expected struct `Vec<isize>`\n\
    \           found mutable reference `&mut Vec<{integer}>`\nhelp: consider removing\
    \ the borrow\n   |\n32 -     s"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut ones = vec![];\n\n    arr.iter().cloned().for_each(|v|\n\
    \        if v == 1 {\n            ones.push(v);\n        } else {\n          \
    \  match (ones, v) {\n                (vec![], 0) => {}\n                (vec![],\
    \ _) => {\n                    res.append(ones.pop().unwrap());\n            \
    \        ones.push(v);\n                }\n                ((ones, one), 0) =>\
    \ {\n                    res.append(one.clone());\n                }\n       \
    \         ((ones, one), one) => {\n                    res.append(ones.pop().unwrap());\n\
    \                    res.append(one.clone());\n                }\n           \
    \ }\n        }\n    );\n\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0416]: identifier `one` is bound more than once in the same pattern\n\
    \  --> /tmp/tmp_6q_xzxh.rs:25:31\n   |\n25 |                 ((ones, one), one)\
    \ => {\n   |                               ^^^ used in a pattern more than once\n\
    \nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmp_6q_xzxh.rs:17:18\n\
    \   |\n17 |                 (vec![], 0) => {}\n   |                  ^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmp_6q_xzxh.rs:18:18\n   |\n18 |           \
    \      (vec![], _) => {\n   |                  ^^^^^^\n   |\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6q_xzxh.rs:22:18\n\
    \   |\n16 |             match (ones, v) {\n   |                   --------- this\
    \ expression has type `(Vec<isize>, isize)`\n...\n22 |                 ((ones,\
    \ one), 0) => {\n   |                  ^^^^^^^^^^^ expected struct `Vec`, found\
    \ tuple\n   |\n   = note: expected struct `Vec<isize>`\n               found tuple\
    \ `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6q_xzxh.rs:25:18\n\
    \   |\n16 |             match (ones, v) {\n   |                   --------- this\
    \ expression has type `(Vec<isize>, isize)`\n...\n25 |                 ((ones,\
    \ one), one) => {\n   |                  ^^^^^^^^^^^ expected struct `Vec`, found\
    \ tuple\n   |\n   = note: expected struct `Vec<isize>`\n               found tuple\
    \ `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6q_xzxh.rs:19:32\n\
    \   |\n19 |                     res.append(ones.pop().unwrap());\n   |       \
    \                         ^^^^^^^^^^^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6q_xzxh.rs:27:32\n\
    \   |\n27 |                     res.append(one.clone());\n   |               \
    \                 ^^^^^^^^^^^ e"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x|\n     \
    \   let n = x.leading_zeros();\n        match n {\n            0 => 0,\n     \
    \       1 => 1,\n            2 => 2,\n            _ => {\n                let\
    \ mut i = 1;\n                let mut cnt = 0;\n                let mut x = x;\n\
    \                while i <= n {\n                    if x&1 == 1 {\n         \
    \               cnt += 1;\n                        i += 1;\n                 \
    \   } else {\n                        cnt += 1;\n                        x >>=\
    \ 1;\n                    }\n                }\n                cnt * i32::pow(2,\
    \ i)\n            }\n        }\n    );\n    sorted_arr\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: closure bodies that contain statements must be surrounded by braces\n\
    \  --> /tmp/tmpphktvzr2.rs:10:30\n   |\n10 |     sorted_arr.sort_by_key(|x|\n\
    \   |                              ^\n...\n32 |     );\n   |     ^\n   |\nnote:\
    \ statement found outside of a block\n  --> /tmp/tmpphktvzr2.rs:11:34\n   |\n\
    11 |         let n = x.leading_zeros();\n   |         -------------------------^\
    \ this `;` turns the preceding closure into a statement\n   |         |\n   |\
    \         this expression is a statement because of the trailing semicolon\nnote:\
    \ the closure body may be incorrectly delimited\n  --> /tmp/tmpphktvzr2.rs:10:28\n\
    \   |\n10 |       sorted_arr.sort_by_key(|x|\n   |  ____________________________^\n\
    11 | |         let n = x.leading_zeros();\n   | |_________________________________^\
    \ this is the parsed closure...\n...\n32 |       );\n   |       - ...but likely\
    \ you meant the closure to end here\nhelp: try adding braces\n   |\n10 ~     sorted_arr.sort_by_key(|x|\
    \ {\n11 |         let n = x.leading_zeros();\n12 |         match n {\n13 |   \
    \          0 => 0,\n14 |             1 => 1,\n15 |             2 => 2,\n ...\n\
    \nerror[E0658]: `let` expressions in this position are unstable\n  --> /tmp/tmpphktvzr2.rs:11:9\n\
    \   |\n11 |         let n = x.leading_zeros();\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0658`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Write your code here\n    let mut one_count = arr.iter().fold(0, |sum,\
    \ i| sum + 1 );\n    arr.sort_by_key(|x| {\n        if one_count % 2 == 0 {\n\
    \            x.leading_zeros()\n        } else {\n            x / 2\n        }\n\
    \    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpr0i5g0hi.rs:15:13\n\
    \   |\n12 | /         if one_count % 2 == 0 {\n13 | |             x.leading_zeros()\n\
    \   | |             ----------------- expected because of this\n14 | |       \
    \  } else {\n15 | |             x / 2\n   | |             ^^^^^ expected `u32`,\
    \ found `isize`\n16 | |         }\n   | |_________- `if` and `else` have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Your code here\n    arr.iter().map(|x| x as isize).sorted().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpmzziyjs0.rs:10:36\n   |\n10 |     arr.iter().map(|x| x\
    \ as isize).sorted().collect::<Vec<_>>()\n   |                               \
    \     ^^^^^^ method not found in `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpmzziyjs0.rs:10:20:\
    \ 10:34]>`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpmzziyjs0.rs:10:24\n\
    \   |\n10 |     arr.iter().map(|x| x as isize).sorted().collect::<Vec<_>>()\n\
    \   |                        -^^^^^^^^^\n   |                        |\n   | \
    \                       cannot cast `&isize` as `isize`\n   |                \
    \        help: dereference the expression: `*x`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n\n    for i in 0..arr.len() {\n        let mut num_ones\
    \ = 0;\n\n        for j in 0..i {\n            if arr[j] == 1 {\n            \
    \    let mut temp = j;\n                *temp = *temp * 2;\n\n               \
    \ let mut k = 1;\n                while temp % 2 == 1 {\n                    temp\
    \ = temp / 2;\n                    k += 1;\n                }\n\n            \
    \    for _ in 0..k {\n                    temp = temp / 2;\n                }\n\
    \            }\n\n            if arr[j] > 1 {\n                *j = *j * 2;\n\
    \            }\n\n            num_ones += 1;\n\n            if i == j {\n    \
    \            break;\n            }\n        }\n\n        let mut temp = i;\n \
    \       *temp = num_ones;\n\n        let mut k = 1;\n        while temp % 2 ==\
    \ 1 {\n            temp = temp / 2;\n            k += 1;\n        }\n\n      \
    \  for _ in 0..k {\n            temp = temp / 2;\n        }\n\n        res.push(*temp);\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpkv2wxgeq.rs:17:17\n\
    \   |\n17 |                 *temp = *temp * 2;\n   |                 ^^^^^\n\n\
    error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpkv2wxgeq.rs:17:25\n\
    \   |\n17 |                 *temp = *temp * 2;\n   |                         ^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpkv2wxgeq.rs:31:17\n\
    \   |\n31 |                 *j = *j * 2;\n   |                 ^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpkv2wxgeq.rs:31:22\n   |\n\
    31 |                 *j = *j * 2;\n   |                      ^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpkv2wxgeq.rs:42:9\n   |\n\
    42 |         *temp = num_ones;\n   |         ^^^^^\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmpkv2wxgeq.rs:54:18\n   |\n54 |        \
    \ res.push(*temp);\n   |                  ^^^^^\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut count = 0;\n    let mut sum = 0;\n\n    for &i in arr {\n       \
    \ if *i >> count == 1 {\n            sum += *i;\n        }\n        count += 1;\n\
    \    }\n\n    if sum != 0 {\n        arr.sort();\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcyj6eixf.rs:12:9\n   |\n\
    12 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr.iter() {\n        if i % 2 ==\
    \ 0 {\n            result.push(i);\n        }\n    }\n    result.sort();\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcisknups.rs:16:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    16 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // TODO: write code here\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp68xxfcjx.rs:8:35\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for i in 0..arr.len() {\n        let mut numOnes = 0.0;\n        for &j in\
    \ arr[i..].iter() {\n            if j == 1 {\n                numOnes += 1;\n\
    \            }\n        }\n        arr[i] = numOnes;\n    }\n\n    arr.iter().cloned().sorted().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmp7filtv0o.rs:13:25\n\
    \   |\n13 |                 numOnes += 1;\n   |                         ^^ no\
    \ implementation for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7filtv0o.rs:16:18\n\
    \   |\n16 |         arr[i] = numOnes;\n   |         ------   ^^^^^^^ expected\
    \ `isize`, found floating-point number\n   |         |\n   |         expected\
    \ due to the type of this binding\n\nerror[E0599]: no method named `sorted` found\
    \ for struct `Cloned` in the current scope\n  --> /tmp/tmp7filtv0o.rs:19:25\n\
    \   |\n19 |     arr.iter().cloned().sorted().collect()\n   |                 \
    \        ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Your code goes here\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsiuvhg_0.rs:8:35\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        let mut num_ones = 0;\n        let mut max_binary_repr\
    \ = a.to_binary(&mut num_ones);\n        let mut max_decimal_repr = b.to_decimal(&mut\
    \ num_ones);\n        match num_ones {\n            0 => true,\n            _\
    \ => {\n                let cmp = &mut max_binary_repr.iter().cloned().cmp(&mut\
    \ max_decimal_repr.iter().cloned());\n                if cmp == cmp::Ordering::Less\
    \ {\n                    true\n                } else {\n                    false\n\
    \                }\n            }\n        }\n    });\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpt1wg62x9.rs:17:27\n   |\n17 |                 if cmp == cmp::Ordering::Less\
    \ {\n   |                           ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0599]: no method named `to_binary` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpt1wg62x9.rs:11:37\n   |\n11 |         let mut max_binary_repr\
    \ = a.to_binary(&mut num_ones);\n   |                                     ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror[E0599]:\
    \ no method named `to_decimal` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpt1wg62x9.rs:12:38\n   |\n12 |         let mut max_decimal_repr\
    \ = b.to_decimal(&mut num_ones);\n   |                                      ^^^^^^^^^^\
    \ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt1wg62x9.rs:14:18\n\
    \   |\n14 |             0 => true,\n   |                  ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt1wg62x9.rs:18:21\n\
    \   |\n18 |                     true\n   |                     ^^^^ expected enum\
    \ `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpt1wg62x9.rs:20:21\n   |\n20 |                     false\n   |      \
    \               ^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut len = arr.len();\n\
    \n    // binary string\n    let mut bins = String::with_capacity(len * 2);\n \
    \   for &i in arr {\n        let bin = bins.capacity().unwrap_or_else(|| String::with_capacity(16));\n\
    \        bin.push_str(&format!(\"{:b}\", i));\n        bin.push_str(\" \");\n\
    \        bins.push_str(&bin);\n    }\n\n    // convert binary string to decimal\n\
    \    let mut decimals = String::with_capacity(len * 2);\n    for &i in bins.chars()\
    \ {\n        let mut len = i.len() + 1;\n        let mut decimal = String::with_capacity(len\
    \ * 2);\n        let mut remainder = 0;\n        for i in i {\n            decimal.push_str(&format!(\"\
    {:0>3}\", remainder));\n            remainder += i as isize * (10 as isize);\n\
    \        }\n        decimals.push_str(&decimal);\n    }\n\n    // sort\n    let\
    \ mut sorted_decimals = String::with_capacity(len * 2);\n    for i in 0..(len\
    \ / 2) {\n        let mut tmp = decimals[i * 2];\n        let mut j = 0;\n   \
    \     while i + j + 1 < decimals.len() {\n            let mut tmp2 = decimals[i\
    \ * 2 + 1];\n            if tmp < tmp2 {\n                sorted_decimals.push_str(&decimals[j\
    \ * 2 + 1]);\n                j += 1;\n            } else {\n                sorted_decimals.push_str(&decimals[j\
    \ * 2]);\n                j += 1;\n            }\n        }\n        if j == 0\
    \ {\n            sorted_decimals.push_str(&decimals[i * 2]);\n        }\n    }\n\
    \n    sorted_decimals.chars().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx1shpbko.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `unwrap_or_else` found for type `usize` in the current scope\n  --> /tmp/tmpx1shpbko.rs:18:35\n\
    \   |\n18 |         let bin = bins.capacity().unwrap_or_else(|| String::with_capacity(16));\n\
    \   |                                   ^^^^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx1shpbko.rs:26:9\n   |\n26 | \
    \    for &i in bins.chars() {\n   |         ^^    ------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx1shpbko.rs:40:23\n\
    \   |\n40 |         let mut tmp = decimals[i * 2];\n   |                     \
    \  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx1shpbko.rs:43:28\n   |\n43 |             let mut tmp2 = decimals[i\
    \ * 2 + 1];\n   |                            ^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = he"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n\n    arr.sort_by_key(|x|\
    \ x.leading_ones() as usize);\n    arr.sort_by_key(|x| x.to_string());\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpo44e4cve.rs:13:5\n   |\n8  | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n13 |     arr.sort_by_key(|x| x.leading_ones() as usize);\n \
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `arr` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpo44e4cve.rs:14:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n14 |     arr.sort_by_key(|x| x.to_string());\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::i32::MAX;\n    for el in arr {\n        if el >= 0 {\n\
    \            min = std::cmp::min(min, el as i32);\n        }\n    }\n    if min\
    \ == std::i32::MAX {\n        arr\n    } else {\n        let mut max = min as\
    \ i32;\n        for el in arr {\n            if el <= max {\n                max\
    \ = el as i32;\n            }\n        }\n        arr\n            .iter()\n \
    \           .sort_by(|a, b| {\n                let a_bin = a\n               \
    \     .iter()\n                    .map(|x| *x)?\n                    .take(8)\n\
    \                    .map(|x| x.to_binary_string())\n                    .collect::<Vec<_>>()\n\
    \                    .join('');\n                let b_bin = b\n             \
    \       .iter()\n                    .map(|x| *x)?\n                    .take(8)\n\
    \                    .map(|x| x.to_binary_string())\n                    .collect::<Vec<_>>()\n\
    \                    .join('');\n                a_bin < b_bin\n            })\n\
    \            .collect()\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpsnj3jcyy.rs:33:28\n   |\n\
    33 |                     .join('');\n   |                            ^ empty character\
    \ literal\n\nerror: empty character literal\n  --> /tmp/tmpsnj3jcyy.rs:40:28\n\
    \   |\n40 |                     .join('');\n   |                            ^\
    \ empty character literal\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnj3jcyy.rs:20:22\n\
    \   |\n20 |             if el <= max {\n   |                      ^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |             if el <= max.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `std::slice::Iter` in the current scope\n \
    \ --> /tmp/tmpsnj3jcyy.rs:26:14\n   |\n26 |             .sort_by(|a, b| {\n  \
    \ |              ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\n\
    error[E0277]: the `?` operator can only be used in a closure that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmpsnj3jcyy.rs:29:33\n\
    \   |\n26 |               .sort_by(|a, b| {\n   |  ______________________-\n27\
    \ | |                 let a_bin = a\n28 | |                     .iter()\n29 |\
    \ |                     .map(|x| *x)?\n   | |                                \
    \ ^ cannot use the `?` operator in a closure that returns `bool`\n...  |\n41 |\
    \ |                 a_bin < b_bin\n42 | |             })\n   | |_____________-\
    \ this function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<_>` is not implemented for `bool`\n\nerror[E0277]: the\
    \ `?` operator can only be used in a closure that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpsnj3jcyy.rs:36:33\n\
    \   |\n26 |               .sort_by(|a, b| {\n   |  ______________________-\n27\
    \ | |                 let a_bin = a\n28 | |                     .iter()\n29 |\
    \ |                     .map(|x| *x)?\n...  |\n36 | |                     .map(|x|\
    \ *x)?\n   | |          "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ret: Vec<isize> = vec![];\n    for &n in arr {\n        if n % 2\
    \ == 1 {\n            ret.push(n);\n        } else {\n            ret.push(-n);\n\
    \        }\n    }\n    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdyua45v6.rs:10:9\n   |\n\
    10 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut count = arr.iter().map(|&e|\
    \ {\n        e as isize\n    }).count();\n    let mut sorted_vec = vec![];\n \
    \   sorted_vec.push(count.cmp(&0) as isize);\n    sorted_vec.push(arr.iter().map(|&e|\
    \ {\n        e as isize\n    }).filter(|&e| {\n        e\n    }).count());\n \
    \   sorted_vec.push(arr.iter().map(|&e| {\n        e as isize\n    }).sorted().filter(|&e|\
    \ {\n        e\n    }).count());\n    sorted_vec.push(arr.iter().map(|&e| {\n\
    \        e as isize\n    }).sorted().collect::<Vec<_>>());\n    return sorted_vec;\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsy8_2lds.rs:20:9\n   |\n\
    20 |         e\n   |         ^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsy8_2lds.rs:17:21\n   |\n17 |       sorted_vec.push(arr.iter().map(|&e|\
    \ {\n   |  _____________________^\n18 | |         e as isize\n19 | |     }).filter(|&e|\
    \ {\n20 | |         e\n21 | |     }).count());\n   | |______________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |     }).count().try_into().unwrap());\n\
    \   |               ++++++++++++++++++++\n\nerror[E0599]: no method named `sorted`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmpsy8_2lds.rs:24:8\n\
    \   |\n24 |     }).sorted().filter(|&e| {\n   |        ^^^^^^ method not found\
    \ in `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpsy8_2lds.rs:22:36: 24:6]>`\n\
    \nerror[E0599]: no method named `sorted` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpsy8_2lds.rs:29:8\n   |\n29 |     }).sorted().collect::<Vec<_>>());\n\
    \   |        ^^^^^^ method not found in `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpsy8_2lds.rs:27:36:\
    \ 29:6]>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() < 2 {\n        return arr;\n    }\n\n    let mut one_count =\
    \ 0;\n\n    let mut counter = vec![0; arr.len()];\n\n    for e in arr.iter() {\n\
    \        if e == 1 {\n            one_count += 1;\n            counter[e] += 1;\n\
    \        } else {\n            counter[e] -= 1;\n        }\n    }\n\n    for i\
    \ in 0..one_count {\n        counter[i] /= 2;\n    }\n\n    for i in 0..arr.len()\
    \ {\n        counter[i] += 1;\n    }\n\n    for i in 0..arr.len() {\n        if\
    \ counter[i] == 0 {\n            counter[i] = 1;\n        }\n    }\n\n    for\
    \ i in 0..one_count {\n        counter[i] *= -1;\n    }\n\n    for i in 0..arr.len()\
    \ {\n        counter[i] *= -1;\n    }\n\n    for i in 0..arr.len() {\n       \
    \ if counter[i] > 0 {\n            counter[i] /= 2;\n        } else {\n      \
    \      counter[i] = 0;\n        }\n    }\n\n    for i in 0..arr.len() {\n    \
    \    if counter[i] < 0 {\n            counter[i] /= 2;\n        } else {\n   \
    \         counter[i] = 0;\n        }\n    }\n\n    arr.iter().cloned().sort_by_key(|&a|\
    \ counter[a]).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppxgnpdhk.rs:18:14\n\
    \   |\n18 |         if e == 1 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `&isize`\n  --> /tmp/tmppxgnpdhk.rs:20:13\n   |\n20 |             counter[e]\
    \ += 1;\n   |             ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmppxgnpdhk.rs:22:13\n   |\n22 |             counter[e]\
    \ -= 1;\n   |             ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0599]: no method named `sort_by_key` found for\
    \ struct `Cloned` in the current scope\n  --> /tmp/tmppxgnpdhk.rs:64:25\n   |\n\
    64 |     arr.iter().cloned().sort_by_key(|&a| counter[a]).collect()\n   |    \
    \                     ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        debug_assert!(a >= 0);\n        debug_assert!(b\
    \ >= 0);\n\n        let mut a_bits = a;\n        let mut b_bits = b;\n       \
    \ loop {\n            let a = a_bits & 1;\n            let b = b_bits & 1;\n\n\
    \            if a < b {\n                return -1;\n            }\n         \
    \   if a > b {\n                return 1;\n            }\n            if a ==\
    \ b {\n                return 0;\n            }\n\n            let mut a_bits\
    \ = a >> 1;\n            let mut b_bits = b >> 1;\n        }\n    });\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqcezk4x.rs:10:28\n   |\n\
    10 |         debug_assert!(a >= 0);\n   |                            ^\n   | \
    \                           |\n   |                            expected `&isize`,\
    \ found integer\n   |                            help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqcezk4x.rs:11:28\n  \
    \ |\n11 |         debug_assert!(b >= 0);\n   |                            ^\n\
    \   |                            |\n   |                            expected `&isize`,\
    \ found integer\n   |                            help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqcezk4x.rs:20:24\n  \
    \ |\n20 |                 return -1;\n   |                        ^^ expected\
    \ enum `std::cmp::Ordering`, found integer\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(&arr[..], arr.iter().map(|x| binary_ones_count(x)).collect::<Vec<_>>());\n\
    \    let mut counts = HashMap::new();\n    for x in arr.iter() {\n        counts.entry(x).or_default()\
    \ = counts.get(x) + 1;\n    }\n    counts.iter().sort_by(|a, b| binary_ones_count(a).cmp(&binary_ones_count(b)).unwrap())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_ones_count` in this scope\n\
    \ --> /tmp/tmpsznwgh9r.rs:9:45\n  |\n9 |     assert_eq!(&arr[..], arr.iter().map(|x|\
    \ binary_ones_count(x)).collect::<Vec<_>>());\n  |                           \
    \                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpsznwgh9r.rs:10:22\n\
    \   |\n10 |     let mut counts = HashMap::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot find function\
    \ `binary_ones_count` in this scope\n  --> /tmp/tmpsznwgh9r.rs:14:34\n   |\n14\
    \ |     counts.iter().sort_by(|a, b| binary_ones_count(a).cmp(&binary_ones_count(b)).unwrap())\n\
    \   |                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `binary_ones_count` in this scope\n  -->\
    \ /tmp/tmpsznwgh9r.rs:14:60\n   |\n14 |     counts.iter().sort_by(|a, b| binary_ones_count(a).cmp(&binary_ones_count(b)).unwrap())\n\
    \   |                                                            ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmpsznwgh9r.rs:12:38\n   |\n12 |         counts.entry(x).or_default()\
    \ = counts.get(x) + 1;\n   |         ---------------------------- ^\n   |    \
    \     |\n   |         cannot assign to this expression\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0070, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(_sort_array_impl(arr), arr)\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `_sort_array_impl` in this scope\n -->\
    \ /tmp/tmpzsuz93f2.rs:9:16\n  |\n9 |     assert_eq!(_sort_array_impl(arr), arr)\n\
    \  |                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|&x| x.leading_ones())\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2t4rtqkk.rs:9:5\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |                        \
    \           ---------- expected `Vec<isize>` because of return type\n9 |     arr.sort_by_key(|&x|\
    \ x.leading_ones())\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n          found\
    \ unit type `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut array = arr.clone();\n    for _ in 0..array.len() {\n        sort_array(array);\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpgpzz4naf.rs:9:9\n\
    \  |\n9 |     let mut array = arr.clone();\n  |         ----^^^^^\n  |       \
    \  |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `array`\n  --> /tmp/tmpgpzz4naf.rs:11:20\n\
    \   |\n9  |     let mut array = arr.clone();\n   |         --------- move occurs\
    \ because `array` has type `Vec<isize>`, which does not implement the `Copy` trait\n\
    10 |     for _ in 0..array.len() {\n11 |         sort_array(array);\n   |    \
    \                ^^^^^ value moved here, in previous iteration of loop\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|x, y| {\n        // binary representation of x\n        let\
    \ mut bin_x = String::new();\n        write_bin(x as u8, &mut bin_x);\n      \
    \  // binary representation of y\n        let mut bin_y = String::new();\n   \
    \     write_bin(y as u8, &mut bin_y);\n\n        // convert string to number\n\
    \        let xx = bin_x.parse::<isize>().unwrap();\n        let yy = bin_y.parse::<isize>().unwrap();\n\
    \        // count number of ones in binary representation\n        let nx_xx =\
    \ binary_count(bin_x);\n        let nx_yy = binary_count(bin_y);\n        let\
    \ nx = nx_xx * nx_yy;\n        // sort by nx if equal, otherwise by decimal representation\n\
    \        if nx == 0 {\n            yy\n        } else {\n            xx.cmp(&yy).unwrap()\n\
    \        }\n    });\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `write_bin` in this scope\n  --> /tmp/tmpr982yi3m.rs:12:9\n\
    \   |\n12 |         write_bin(x as u8, &mut bin_x);\n   |         ^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `write_bin` in this\
    \ scope\n  --> /tmp/tmpr982yi3m.rs:15:9\n   |\n15 |         write_bin(y as u8,\
    \ &mut bin_y);\n   |         ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `binary_count` in this scope\n  --> /tmp/tmpr982yi3m.rs:21:21\n\
    \   |\n21 |         let nx_xx = binary_count(bin_x);\n   |                   \
    \  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `binary_count` in this scope\n  --> /tmp/tmpr982yi3m.rs:22:21\n   |\n22 |  \
    \       let nx_yy = binary_count(bin_y);\n   |                     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr982yi3m.rs:26:13\n\
    \   |\n26 |             yy\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpr982yi3m.rs:28:25\n   |\n28 |          \
    \   xx.cmp(&yy).unwrap()\n   |                         ^^^^^^ method not found\
    \ in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr982yi3m.rs:8:35\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------  \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror[E0606]: casting `&isize` as `u8` is invalid\n  --> /tmp/tmpr982yi3m.rs:12:19\n\
    \   |\n12 |         write_bin(x as u8, &mut bin_x);\n   |                   -^^^^^^\n\
    \   |                   |\n   |                   cannot cast `&isize` as `u8`\n\
    \   |                   help: dereference the expression: `*x`\n\nerror[E0606]:\
    \ casting `&isize` as `u8` is invalid\n  --> /tmp/tmpr982yi3m.rs:15:19\n   |\n\
    15 |         write_bin(y as u8, &mut bin_y);\n   |                   -^^^^^^\n\
    \   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n    let mut new_arr = arr.clone();\n\
    \    let mut cnt = 0;\n    for e in new_arr {\n        if cnt > 0 {\n        \
    \    cnt += cnt;\n        }\n        cnt += if e > 1 { 1 } else { 0 };\n    }\n\
    \    let mut min_idx = new_arr.iter().min_by(|a, b| a as usize - b as usize).unwrap();\n\
    \    while cnt == 0 {\n        cnt += min_idx;\n        min_idx = new_arr.iter().min_by(|a,\
    \ b| a as usize - b as usize).unwrap();\n    }\n    while min_idx > 0 {\n    \
    \    let mut j = 0;\n        let mut pos = min_idx;\n        let mut cnt = 0;\n\
    \        for e in new_arr {\n            cnt += pos;\n            cnt += if e\
    \ > 1 { 1 } else { 0 };\n            pos += if e > 1 { 1 } else { 0 };\n     \
    \       j = cmp::min(j, cnt);\n        }\n        cnt += pos;\n        j = cmp::min(j,\
    \ cnt);\n        min_idx = new_arr.iter().min_by(|a, b| a as usize - b as usize).unwrap();\n\
    \        if j > 1 {\n            new_arr.swap(i, new_arr.len() - 1 - i);\n   \
    \     }\n    }\n    new_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpjhztvaxa.rs:33:17\n   |\n33 |             j = cmp::min(j, cnt);\n\
    \   |                 ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpjhztvaxa.rs:36:13\n\
    \   |\n36 |         j = cmp::min(j, cnt);\n   |             ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0425]: cannot find value `i` in this scope\n\
    \  --> /tmp/tmpjhztvaxa.rs:39:26\n   |\n39 |             new_arr.swap(i, new_arr.len()\
    \ - 1 - i);\n   |                          ^ help: a local variable with a similar\
    \ name exists: `j`\n\nerror[E0425]: cannot find value `i` in this scope\n  -->\
    \ /tmp/tmpjhztvaxa.rs:39:49\n   |\n39 |             new_arr.swap(i, new_arr.len()\
    \ - 1 - i);\n   |                                                 ^ help: a local\
    \ variable with a similar name exists: `j`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjhztvaxa.rs:20:52\n   |\n20 |     let mut min_idx = new_arr.iter().min_by(|a,\
    \ b| a as usize - b as usize).unwrap();\n   |                                \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhztvaxa.rs:23:48\n\
    \   |\n23 |         min_idx = new_arr.iter().min_by(|a, b| a as usize - b as usize).unwrap();\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjhztvaxa.rs:25:21\n   |\n25 |     while min_idx > 0 {\n   |   \
    \                  ^\n   |                     |\n   |                     expected\
    \ `&isize`, found integer\n   |                     help: consider borrowing here:\
    \ `&0`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to\
    \ type `&isize`\n  --> /tmp/tmpjhztvaxa.rs:32:13\n   |\n32 |             pos +=\
    \ if e > 1 { 1 } else { 0 };\n   |             ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&isize`\n   |\n\
    he"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums = arr.clone();\n    let mut counter = vec![0, 1, 2, 3];\n  \
    \  let mut index = 0;\n    while nums.len() > 0 {\n        let first = nums[0];\n\
    \        let rest = nums.remove(0);\n        let mut i = 0;\n        while i <\
    \ index {\n            if counter[i] < first {\n                counter[i] +=\
    \ 1;\n                nums.insert(i, first);\n                i += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ index != i {\n            counter.extend_from_slice(&[..i]);\n            index\
    \ = i;\n        }\n    }\n    nums.sort_unstable();\n    nums\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz3ci88yt.rs:26:41\n   |\n\
    26 |             counter.extend_from_slice(&[..i]);\n   |                    \
    \                     ^^^ expected `isize`, found struct `RangeTo`\n   |\n   =\
    \ note: expected type `isize`\n            found struct `RangeTo<usize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut result = arr.clone();\n\
    \    let mut ones = 0;\n\n    for elt in arr.iter() {\n        if elt == 1 {\n\
    \            ones += 1;\n        } else {\n            *result = elt;\n      \
    \      result.insert(result.iter().position(|&elt| elt == ones).unwrap(), ones);\n\
    \            ones = 0;\n        }\n    }\n\n    result\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_ljf33pb.rs:17:16\n\
    \   |\n17 |         if elt == 1 {\n   |                ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_ljf33pb.rs:20:23\n   |\n20 |             *result = elt;\n   |     \
    \        -------   ^^^ expected slice `[isize]`, found `&isize`\n   |        \
    \     |\n   |             expected due to the type of this binding\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \  --> /tmp/tmp_ljf33pb.rs:20:13\n   |\n20 |             *result = elt;\n   |\
    \             ^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[isize]`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return arr;\n    }\n\n    let mut ones = vec![];\n\
    \    let mut decimal = vec![];\n    let mut sorted_arr = vec![];\n\n    for elem\
    \ in arr {\n        if elem == 1 {\n            ones.push(elem);\n        } else\
    \ if elem > 1 {\n            decimal.push(elem);\n        } else {\n         \
    \   sorted_arr.push(elem);\n        }\n    }\n\n    for i in 0..ones.len() {\n\
    \        for j in 0..sorted_arr.len() {\n            let binary_num = &sorted_arr[j];\n\
    \            let decimal_num = &decimal[j];\n            if binary_num == 0 &&\
    \ decimal_num == 0 {\n                continue;\n            }\n\n           \
    \ let binary = str::from_utf8(&binary_num.to_string()).unwrap();\n           \
    \ let decimal = *decimal_num.to_string();\n\n            if binary.len() <= decimal.len()\
    \ {\n                sorted_arr.swap(j, i);\n                break;\n        \
    \    }\n        }\n    }\n\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_oqbi2aq.rs:31:27\n\
    \   |\n31 |             if binary_num == 0 && decimal_num == 0 {\n   |       \
    \                    ^^ no implementation for `&isize == {integer}`\n   |\n  \
    \ = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_oqbi2aq.rs:31:47\n\
    \   |\n31 |             if binary_num == 0 && decimal_num == 0 {\n   |       \
    \                                        ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0599]: no function or associated item named `from_utf8`\
    \ found for type `str` in the current scope\n  --> /tmp/tmp_oqbi2aq.rs:35:31\n\
    \   |\n35 |             let binary = str::from_utf8(&binary_num.to_string()).unwrap();\n\
    \   |                               ^^^^^^^^^ function or associated item not\
    \ found in `str`\n   |\nhelp: you are looking for the module in `std`, not the\
    \ primitive type\n   |\n35 |             let binary = std::str::from_utf8(&binary_num.to_string()).unwrap();\n\
    \   |                          ~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmp_oqbi2aq.rs:36:17\n\
    \   |\n36 |             let decimal = *decimal_num.to_string();\n   |        \
    \         ^^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated a"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut map = HashMap::new();\n\n    for elem in arr {\n        map.insert(elem,\
    \ 0);\n    }\n\n    let mut max = 0;\n    let mut result: Vec<isize> = vec![];\n\
    \n    let mut curr_max = map.iter().max().unwrap();\n\n    for &(_, v) in map\
    \ {\n        if v == curr_max {\n            result.push(curr_max);\n        }\
    \ else {\n            result.push(v);\n            curr_max = v;\n        }\n\
    \    }\n\n    result.sort();\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpu90m4uvs.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut counter = arr[0];\n    for i in\
    \ arr {\n        if i == counter.clone() {\n            result.push(i);\n    \
    \    } else {\n            counter += i;\n            result.push(i);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpgsi8yzbf.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unsafe {\n        let mut buffer = arr.as_mut_ptr();\n        let array_len\
    \ = arr.len() as isize;\n        sort_array(buffer, array_len)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpgaqyqq9v.rs:12:9\n   |\n12 |         sort_array(buffer, array_len)\n\
    \   |         ^^^^^^^^^^ ------  --------- supplied 2 arguments\n   |        \
    \ |\n   |         expected 1 argument\n   |\nnote: function defined here\n  -->\
    \ /tmp/tmpgaqyqq9v.rs:8:4\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    ^^^^^^^^^^ ---------------\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| cmp(&*a, &*b))\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3,\
    \ 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5,\
    \ -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `cmp` in this scope\n --> /tmp/tmp2ku7lsjj.rs:9:24\n\
    \  |\n9 |     arr.sort_by(|a, b| cmp(&*a, &*b))\n  |                        ^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmp2ku7lsjj.rs:9:5\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |                \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    9 |     arr.sort_by(|a, b| cmp(&*a, &*b))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(arr.len(), arr.iter().map(|&x| x.checked_div(2u32).unwrap_or(0)).sum());\n\
    \    arr.iter().cloned().sort_by(|a, b| a.checked_div(2u32).unwrap_or(0).cmp(&b.checked_div(2u32).unwrap_or(0)).unwrap_or(1))\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpec0n5_l2.rs:9:61\n  |\n9 |\
    \     assert_eq!(arr.len(), arr.iter().map(|&x| x.checked_div(2u32).unwrap_or(0)).sum());\n\
    \  |                                                             ^^^^ expected\
    \ `isize`, found `u32`\n  |\nhelp: change the type of the numeric literal from\
    \ `u32` to `isize`\n  |\n9 |     assert_eq!(arr.len(), arr.iter().map(|&x| x.checked_div(2isize).unwrap_or(0)).sum());\n\
    \  |                                                              ~~~~~\n\nerror[E0277]:\
    \ the trait bound `usize: Sum<isize>` is not satisfied\n    --> /tmp/tmpec0n5_l2.rs:9:81\n\
    \     |\n9    |     assert_eq!(arr.len(), arr.iter().map(|&x| x.checked_div(2u32).unwrap_or(0)).sum());\n\
    \     |                                                                      \
    \           ^^^ the trait `Sum<isize>` is not implemented for `usize`\n     |\n\
    \     = help: the following other types implement trait `Sum<A>`:\n          \
    \     <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n               <f64\
    \ as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128 as Sum<&'a\
    \ i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a i16>>\n\
    \               <i16 as Sum>\n             and 20 others\nnote: required by a\
    \ bound in `std::iter::Iterator::sum`\n\nerror[E0599]: no method named `sort_by`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpec0n5_l2.rs:10:25\n\
    \   |\n10 |     arr.iter().cloned().sort_by(|a, b| a.checked_div(2u32).unwrap_or(0).cmp(&b.checked_div(2u32).unwrap_or(0)).unwrap_or(1))\n\
    \   |                         ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n --> /tmp/tmpjsqtw7_w.rs:9:25\n  |\n9 |     arr.iter().cloned().sort().collect()\n\
    \  |                         ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut cnts = HashMap::new();\n    for n in arr {\n        if cnts.contains_key(n)\
    \ {\n            cnts.insert(n, cnts.get(&n).unwrap() + 1);\n        } else {\n\
    \            cnts.insert(n, 1);\n        }\n    }\n    let mut cnts_ordered =\
    \ HashMap::new();\n    let mut cnt_one = 0;\n    for (c, n) in cnts.iter() {\n\
    \        if n == 1 {\n            cnt_one = cnt_one + 1;\n        }\n        if\
    \ cnt_one == 1 {\n            cnts_ordered.insert(n, cnt_one);\n        } else\
    \ {\n            cnts_ordered.insert(n, cnt_one * 10 + cnts.get(&cnt_one).unwrap()\
    \ as isize);\n        }\n    }\n    let mut sorted_array: Vec<isize> = Vec::new();\n\
    \    for i in 0..cnts.len() {\n        sorted_array.push(cnts_ordered.get(i).unwrap());\n\
    \    }\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpf1wazxs4.rs:9:20\n  |\n9 |     let mut cnts = HashMap::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpf1wazxs4.rs:17:28\n\
    \   |\n17 |     let mut cnts_ordered = HashMap::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut cnt = 0;\n    for i in arr.iter()\
    \ {\n        if *i > *i {\n            result.push(i);\n        } else {\n   \
    \         cnt += 1;\n        }\n    }\n    for i in arr.iter() {\n        match\
    \ cnt {\n            1 => result.push(i),\n            2 => result.push(i),\n\
    \            3 => result.push(i),\n            4 => result.push(i),\n        \
    \    _ => result.push(i),\n        }\n        cnt += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdkgj_bx7.rs:28:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    28 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_owned();\n    std::cmp::Ordering::default().sort_by(|&x,\
    \ &y| {\n        if x == y {\n            return 0;\n        }\n        let mut\
    \ x_bin = BinaryCode::from(&x);\n        let mut y_bin = BinaryCode::from(&y);\n\
    \        if x_bin.one {\n            if y_bin.one {\n                y_bin.one\
    \ = x_bin.one == 0;\n                y_bin.value = x_bin.value;\n            \
    \    y_bin.zero = x_bin.zero;\n            } else {\n                y_bin.one\
    \ = x_bin.one;\n                y_bin.value = x_bin.value;\n                y_bin.zero\
    \ = false;\n            }\n        } else if y_bin.one {\n            x_bin.one\
    \ = y_bin.one;\n            x_bin.value = y_bin.value;\n            x_bin.zero\
    \ = y_bin.zero;\n        } else {\n            x_bin.one = y_bin.one;\n      \
    \      x_bin.value = y_bin.value;\n            x_bin.zero = y_bin.zero;\n    \
    \    }\n        BinaryCode::from(&x_bin).cmp(&BinaryCode::from(&y_bin))\n    });\n\
    \    sorted_arr.into_iter().collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinaryCode`\n\
    \  --> /tmp/tmpwg988ios.rs:14:25\n   |\n14 |         let mut x_bin = BinaryCode::from(&x);\n\
    \   |                         ^^^^^^^^^^ use of undeclared type `BinaryCode`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BinaryCode`\n  -->\
    \ /tmp/tmpwg988ios.rs:15:25\n   |\n15 |         let mut y_bin = BinaryCode::from(&y);\n\
    \   |                         ^^^^^^^^^^ use of undeclared type `BinaryCode`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BinaryCode`\n  -->\
    \ /tmp/tmpwg988ios.rs:35:9\n   |\n35 |         BinaryCode::from(&x_bin).cmp(&BinaryCode::from(&y_bin))\n\
    \   |         ^^^^^^^^^^ use of undeclared type `BinaryCode`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `BinaryCode`\n  --> /tmp/tmpwg988ios.rs:35:39\n\
    \   |\n35 |         BinaryCode::from(&x_bin).cmp(&BinaryCode::from(&y_bin))\n\
    \   |                                       ^^^^^^^^^^ use of undeclared type\
    \ `BinaryCode`\n\nerror[E0599]: no variant or associated item named `default`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpwg988ios.rs:10:25\n\
    \   |\n10 |     std::cmp::Ordering::default().sort_by(|&x, &y| {\n   |       \
    \                  ^^^^^^^ variant or associated item not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|&x| {\n        // Get one from binary and count occurences\n\
    \        let ones = x.to_bin().count();\n        // If all binary digits are zeros,\
    \ then sort by decimal value\n        if ones == 0 {\n            let decimal_value\
    \ = x.to_dec();\n            Some(decimal_value)\n        } else {\n         \
    \   None\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwjfq3miu.rs:11:22\n   |\n11 |         let ones = x.to_bin().count();\n\
    \   |                      ^^^^^^ help: there is an associated function with a\
    \ similar name: `to_be`\n\nerror[E0599]: no method named `to_dec` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpwjfq3miu.rs:14:35\n   |\n14 |  \
    \           let decimal_value = x.to_dec();\n   |                            \
    \       ^^^^^^ help: there is an associated function with a similar name: `to_be`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // sort by number of ones\n    let mut counter = Vec::new();\n    let mut\
    \ counter_pos = 0;\n    let mut counter_neg = 0;\n    for x in arr {\n       \
    \ match x {\n            0 => {\n                counter[counter_pos]++;\n   \
    \             counter_pos++;\n            }\n            1 => {\n            \
    \    counter[counter_neg]++;\n                counter_neg++;\n            }\n\
    \            _ => {\n                if counter[counter_pos] > counter[counter_neg]\
    \ {\n                    counter_neg += 1;\n                } else {\n       \
    \             counter_pos += 1;\n                }\n            }\n        }\n\
    \    }\n    // sort by decison value\n    let mut result: Vec<isize> = Vec::new();\n\
    \    for i in 0..counter_pos {\n        result.push(arr[i]);\n    }\n    for i\
    \ in 0..counter_neg {\n        result.push(-arr[i]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpzdahhi9k.rs:16:37\n\
    \   |\n16 |                 counter[counter_pos]++;\n   |                    \
    \                 ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n16 |                 { let tmp = counter[counter_pos]; counter[counter_pos]\
    \ += 1; tmp };\n   |                 +++++++++++                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    16 -                 counter[counter_pos]++;\n16 +                 counter[counter_pos]\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpzdahhi9k.rs:20:37\n\
    \   |\n20 |                 counter[counter_neg]++;\n   |                    \
    \                 ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n20 |                 { let tmp = counter[counter_neg]; counter[counter_neg]\
    \ += 1; tmp };\n   |                 +++++++++++                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    20 -                 counter[counter_neg]++;\n20 +                 counter[counter_neg]\
    \ += 1;\n   | \n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut counter: usize\
    \ = 0;\n    let mut min: isize = 0;\n    for v in arr.iter() {\n        counter\
    \ = counter + v as usize;\n        if counter == 0 {\n            min = v;\n \
    \       }\n    }\n\n    let mut min_counter = counter;\n    let mut max_counter\
    \ = counter;\n    let mut min_value = min;\n    let mut max_value = min;\n   \
    \ for v in arr.iter() {\n        counter = counter + v as usize;\n        if counter\
    \ == 0 {\n            min_value = v;\n            max_counter = counter;\n   \
    \         min_counter = counter;\n        } else {\n            if counter < min_counter\
    \ {\n                min_counter = counter;\n                min_value = v;\n\
    \            }\n\n            if counter > max_counter {\n                max_counter\
    \ = counter;\n                max_value = v;\n            }\n        }\n    }\n\
    \n    if min_counter == max_counter {\n        arr.swap(0, min_value as usize);\n\
    \        arr.swap(1, min_value as usize);\n        return arr;\n    }\n\n    if\
    \ min_counter < max_counter {\n        arr.swap(0, min_value as usize);\n    \
    \    arr.swap(1, min_value as usize);\n        sort_array(arr)\n    } else {\n\
    \        arr.swap(0, max_value as usize);\n        arr.swap(1, max_value as usize);\n\
    \        sort_array(arr)\n    }\n\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp770lhpdn.rs:18:19\n   |\n\
    14 |     let mut min: isize = 0;\n   |                  ----- expected due to\
    \ this type\n...\n18 |             min = v;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |             min = *v;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp770lhpdn.rs:29:25\n   |\n24 |     let mut min_value = min;\n\
    \   |                         --- expected due to this value\n...\n29 |      \
    \       min_value = v;\n   |                         ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n29 |        \
    \     min_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp770lhpdn.rs:35:29\n   |\n24 |     let mut min_value = min;\n\
    \   |                         --- expected due to this value\n...\n35 |      \
    \           min_value = v;\n   |                             ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \               min_value = *v;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp770lhpdn.rs:40:29\n   |\n25 |     let mut max_value\
    \ = min;\n   |                         --- expected due to this value\n...\n40\
    \ |                 max_value = v;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    40 |                 max_value = *v;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp770lhpdn.rs:54:9\n   |\n51 | /     if min_counter\
    \ < max_counter {\n52 | |         arr.swap(0, min_value as usize);\n53 | |   \
    \      arr.swap(1, min_value as usize);\n54 | |         sort_array(arr)\n   |\
    \ |         ^^^^^^^^^^^^^^^ expected `()`, found struct `Vec`\n...  |\n58 | |\
    \         sort_array(arr)\n59 | |     }\n   | |_____- expected this to be `()`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<isize>`\n\
    help: consider using a semicolon here\n   |\n54 |         sort_array"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = std::collections::HashMap::new();\n    for ele in arr {\n\
    \        if let Some(count) = counter.entry(ele).or_insert(0) {\n            *count\
    \ += 1;\n        } else {\n            counter.insert(ele, 1);\n        }\n  \
    \  }\n\n    arr.sort_unstable_by(|a, b| {\n        let count = counter.entry(a).or_insert(0)\
    \ - (counter.entry(b).or_insert(0));\n        if count != 0 {\n            count\
    \ * 10\n        } else {\n            a as isize\n        }\n    });\n\n    counter.into_iter().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawjhuxy2.rs:11:16\n   |\n\
    11 |         if let Some(count) = counter.entry(ele).or_insert(0) {\n   |    \
    \            ^^^^^^^^^^^   ------------------------------- this expression has\
    \ type `&mut {integer}`\n   |                |\n   |                expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawjhuxy2.rs:19:35\n\
    \   |\n19 |         let count = counter.entry(a).or_insert(0) - (counter.entry(b).or_insert(0));\n\
    \   |                                   ^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n19 |         let count =\
    \ counter.entry(*a).or_insert(0) - (counter.entry(b).or_insert(0));\n   |    \
    \                               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawjhuxy2.rs:19:68\n\
    \   |\n19 |         let count = counter.entry(a).or_insert(0) - (counter.entry(b).or_insert(0));\n\
    \   |                                                                    ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         let count = counter.entry(a).or_insert(0) - (counter.entry(*b).or_insert(0));\n\
    \   |                                                                    +\n\n\
    error[E0369]: cannot subtract `&mut {integer}` from `&mut {integer}`\n  --> /tmp/tmpawjhuxy2.rs:19:51\n\
    \   |\n19 |         let count = counter.entry(a).or_insert(0) - (counter.entry(b).or_insert(0));\n\
    \   |                     ----------------------------- ^ -------------------------------\
    \ &mut {integer}\n   |                     |\n   |                     &mut {integer}\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpawjhuxy2.rs:23:13\n   |\n23 |\
    \             a as isize\n   |             ^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawjhuxy2.rs:27:5\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of ret"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|&i1, &i2| i2.leading_ones() as isize <=> i1.leading_ones() as\
    \ isize)\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: invalid comparison operator `<=>`\n --> /tmp/tmp2nzbco0d.rs:9:55\n\
    \  |\n9 |     arr.sort_by(|&i1, &i2| i2.leading_ones() as isize <=> i1.leading_ones()\
    \ as isize)\n  |                                                       ^^^ `<=>`\
    \ is not a valid comparison operator, use `std::cmp::Ordering`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp2nzbco0d.rs:9:28\n  |\n9 |     arr.sort_by(|&i1,\
    \ &i2| i2.leading_ones() as isize <=> i1.leading_ones() as isize)\n  |       \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp2nzbco0d.rs:9:5\n  |\n8 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n  |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n9 |     arr.sort_by(|&i1, &i2| i2.leading_ones() as\
    \ isize <=> i1.leading_ones() as isize)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted = vec![0; arr.len()];\n\n    fn countOnes(i: usize) -> usize\
    \ {\n        let b = i as u8;\n        let mut sum = 0;\n        for i in 0..6\
    \ {\n            if ((b >> (3 - i)) & 1) == 0 {\n                sum += 1 << i;\n\
    \            }\n        }\n        sum\n    }\n\n    for i in 0..sorted.len()\
    \ {\n        sorted[i] = countOnes(arr[i]);\n    }\n    for i in sorted.iter().rev()\
    \ {\n        sorted.swap(i, sorted.len() - 1 - i);\n    }\n    sorted\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps02is0cy.rs:23:31\n   |\n\
    23 |         sorted[i] = countOnes(arr[i]);\n   |                            \
    \   ^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n23 |      \
    \   sorted[i] = countOnes(arr[i].try_into().unwrap());\n   |                 \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps02is0cy.rs:26:21\n   |\n26 |         sorted.swap(i, sorted.len()\
    \ - 1 - i);\n   |                     ^ expected `usize`, found `&usize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n26 |         sorted.swap(*i, sorted.len()\
    \ - 1 - i);\n   |                     +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps02is0cy.rs:28:5\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                                   ---------- expected `Vec<isize>` because\
    \ of return type\n...\n28 |     sorted\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut num_ones = 0;\n    let mut num_tens = 0;\n    for i in arr {\n  \
    \      if i == 1 {\n            num_ones += 1;\n        } else if i % 10 == 0\
    \ {\n            num_tens += 1;\n        } else {\n            break;\n      \
    \  }\n    }\n    let mut result = Vec::new();\n    for i in arr {\n        if\
    \ i != 1 {\n            result.push(i);\n        } else if num_ones > num_tens\
    \ {\n            result.push(i * num_tens + num_ones);\n            num_ones =\
    \ 0;\n            num_tens = 0;\n        } else {\n            result.push(i *\
    \ num_tens);\n            num_ones = 0;\n            num_tens = 0;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp6w765aeo.rs:21:14\n\
    \    |\n8   | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    |          \
    \     --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n11  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n21  |     for i in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n11  |     for i in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n    let mut result = vec![];\n\
    \    let mut max_counts: Vec<usize> = vec![];\n    let mut min_counts: Vec<usize>\
    \ = vec![];\n    for &value in arr {\n        if value == 1 {\n            max_counts.push(*max_counts);\n\
    \            min_counts.push(*min_counts);\n        } else {\n            if *max_counts\
    \ > value {\n                max_counts.push(value);\n            } else {\n \
    \               min_counts.push(value);\n            }\n        }\n    }\n   \
    \ let mut min_count = *min_counts;\n    let mut max_count = *max_counts;\n   \
    \ while min_count < max_count {\n        if min_count < max_count {\n        \
    \    let mut j = min_count;\n            while min_count < max_count {\n     \
    \           if max_count - min_count < min_count {\n                    let temp\
    \ = min_count;\n                    min_count = max_count;\n                 \
    \   max_count = temp;\n                }\n                let mut new_min_count\
    \ = min_count;\n                while min_count < max_count && min_count + 1 !=\
    \ j {\n                    new_min_count = min_count + 1;\n                  \
    \  min_count = min_count + 1;\n                }\n                if min_count\
    \ != new_min_count {\n                    if min_count == max_count {\n      \
    \                  result.push(min_count);\n                    } else {\n   \
    \                     let temp = min_count;\n                        min_count\
    \ = new_min_count;\n                        max_count = temp;\n              \
    \      }\n                }\n                if min_count == j {\n           \
    \         min_count = min_count + 1;\n                }\n                j = min_count;\n\
    \            }\n        }\n        let mut j = min_count;\n        while min_count\
    \ > max_count {\n            if min_count - max_count < min_count {\n        \
    \        let temp = min_count;\n                min_count = max_count;\n     \
    \           max_count = temp;\n            }\n            let mut new_min_count\
    \ = min_count;\n            while min_count < max_count && min_count + 1 != j\
    \ {\n                new_min_count = min_count + 1;\n                min_count\
    \ = min_count + 1;\n            }\n            if min_count != new_min_count {\n\
    \                if min_count == max_count {\n                    result.push(min_count);\n\
    \                } else {\n                    let temp = min_count;\n       \
    \             min_count = new_min_count;\n                    max_count = temp;\n\
    \                }\n            }\n            if min_count == j {\n         \
    \       min_count = min_count - 1;\n            }\n            j = min_count;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5u41qen.rs:15:9\n   |\n\
    15 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw5u41qen.rs:17:29\n   |\n17 |             max_counts.push(*max_counts);\n\
    \   |                             ^^^^^^^^^^^ expected `usize`, found slice `[usize]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw5u41qen.rs:18:29\n   |\n18 |\
    \             min_counts.push(*min_counts);\n   |                            \
    \ ^^^^^^^^^^^ expected `usize`, found slice `[usize]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw5u41qen.rs:21:33\n   |\n21 |                 max_counts.push(value);\n\
    \   |                                 ^^^^^ expected `usize`, found slice `[usize]`\n\
    \nerror[E0277]: the size for values of type `[usize]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpw5u41qen.rs:15:10\n   |\n15 |     for &value in arr {\n\
    \   |          ^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[usize]`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: can't compare `[usize]` with `{integer}`\n\
    \  --> /tmp/tmpw5u41qen.rs:16:18\n   |\n16 |         if value == 1 {\n   |   \
    \               ^^ no implementation for `[usize] == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `[usize]`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&[B]\
    \ as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n       \
    \      <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U,\
    \ A>>>\n             <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut\
    \ [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n             <[A; N"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|a, b| count_ones(a).cmp(&count_ones(b)))\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_ones` in this scope\n --> /tmp/tmpsupyatv2.rs:9:33\n\
    \  |\n9 |     arr.sort_unstable_by(|a, b| count_ones(a).cmp(&count_ones(b)))\n\
    \  |                                 ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_ones` in this scope\n --> /tmp/tmpsupyatv2.rs:9:52\n\
    \  |\n9 |     arr.sort_unstable_by(|a, b| count_ones(a).cmp(&count_ones(b)))\n\
    \  |                                                    ^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsupyatv2.rs:9:5\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |                \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    9 |     arr.sort_unstable_by(|a, b| count_ones(a).cmp(&count_ones(b)))\n  |  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n          found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut last_ones = Vec::new();\n    for x in\
    \ arr {\n        let mut i = 0;\n        while i < 8 {\n            if x % 2 ==\
    \ 0 {\n                i += 1;\n            } else {\n                if i <=\
    \ last_ones[0] {\n                    break;\n                }\n            \
    \    i += 3;\n            }\n        }\n        last_ones.push(i);\n        res.push(x);\n\
    \    }\n    let mut i = 0;\n    while i < last_ones[0] {\n        res.push(0);\n\
    \        i += 1;\n    }\n    for i in 1..=last_ones[0] {\n        res.insert(i,\
    \ last_ones[i] - i);\n    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9wip2r_w.rs:32:23\n   |\n\
    32 |         res.insert(i, last_ones[i] - i);\n   |                       ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n32 |         res.insert(i,\
    \ (last_ones[i] - i).try_into().unwrap());\n   |                       +     \
    \           +++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = arr.clone();\n\n    result.sort_by_key(|x|\n        if x\
    \ % 2 == 0 {\n            (-x) / 2\n        } else {\n            (x / 2).floor()\n\
    \        }\n    );\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp96mffsle.rs:15:21\n   |\n15 |             (x / 2).floor()\n\
    \   |                     ^^^^^ help: there is an associated function with a similar\
    \ name: `div_floor`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_array = arr.to_vec();\n    let mut count = arr.len();\n  \
    \  while count > 1 {\n        // binary search for the same number of ones\n \
    \       let mid = count / 2;\n        if sorted_array[mid] >= sorted_array[0]\
    \ {\n            count -= mid;\n            sorted_array = mid .. sorted_array.len();\n\
    \        } else {\n            sorted_array = mid .. mid;\n            count -=\
    \ mid;\n        }\n    }\n    if count == 0 {\n        return sorted_array\n \
    \   }\n    if sorted_array[0] != 1 {\n        sorted_array[0] = 0;\n    }\n  \
    \  sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy3rqlx3_.rs:16:28\n   |\n\
    9  |     let mut sorted_array = arr.to_vec();\n   |                          \
    \  ------------ expected due to this value\n...\n16 |             sorted_array\
    \ = mid .. sorted_array.len();\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `std::ops::Range`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `std::ops::Range<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy3rqlx3_.rs:18:28\n   |\n9  |  \
    \   let mut sorted_array = arr.to_vec();\n   |                            ------------\
    \ expected due to this value\n...\n18 |             sorted_array = mid .. mid;\n\
    \   |                            ^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \     found struct `std::ops::Range<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() <= 1 {\n        return arr;\n    }\n    let mut count_ones:\
    \ Vec<isize> = Vec::with_capacity(arr.len());\n    for i in 0..arr.len() {\n \
    \       let x = arr[i];\n        if x == 0 {\n            continue;\n        }\n\
    \        count_ones.push(0);\n        while x > 0 {\n            if x % 2 == 0\
    \ {\n                count_ones[i] += 1;\n            }\n            x = x / 2;\n\
    \        }\n    }\n    let mut min_ind: usize = 0;\n    for i in 0..count_ones.len()\
    \ {\n        if count_ones[i] < count_ones[min_ind] {\n            min_ind = i;\n\
    \        }\n    }\n    let mut min_val = arr[min_ind];\n    for i in 0..count_ones[min_ind].len()\
    \ {\n        arr[i] = min_val;\n        min_val = (min_val + 1) / 2\n    }\n \
    \   for i in 0..count_ones.len() {\n        if count_ones[i] < count_ones[min_ind]\
    \ {\n            let mut idx = min_ind;\n            while count_ones[idx] >=\
    \ count_ones[min_ind] {\n                idx = (idx + 1) % count_ones.size();\n\
    \            }\n            arr[i] = arr[idx]\n        }\n    }\n    arr\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_p6g0fzv.rs:33:37\n   |\n33 |     for i in 0..count_ones[min_ind].len()\
    \ {\n   |                                     ^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `size` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp_p6g0fzv.rs:41:46\n   |\n41 |                 idx = (idx\
    \ + 1) % count_ones.size();\n   |                                            \
    \  ^^^^ help: there is an associated function with a similar name: `resize`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Solution 1\n    let mut new_arr = vec![];\n    for i in arr.iter() {\n\
    \        let mut count = 0;\n        for j in i {\n            if j == 1 {\n \
    \               count += 1;\n            }\n        }\n        if count == 0 {\n\
    \            new_arr.push(i);\n        }\n    }\n\n    // Solution 2\n    for\
    \ j in arr.iter() {\n        let mut count = 0;\n        for i in j {\n      \
    \      if i == 1 {\n                count += 1;\n            }\n        }\n  \
    \      if count == 0 {\n            arr.push(j);\n        }\n    }\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmpgkb6aqd5.rs:13:18\n\
    \   |\n13 |         for j in i {\n   |                  ^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror[E0277]: `&isize` is not an iterator\n  --> /tmp/tmpgkb6aqd5.rs:26:18\n\
    \   |\n26 |         for i in j {\n   |                  ^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgkb6aqd5.rs:32:22\n   |\n32 |\
    \             arr.push(j);\n   |                      ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \     arr.push(*j);\n   |                      +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    let mut map = HashMap::new();\n    let\
    \ mut cur = 0;\n    for &x in arr {\n        if map.contains_key(&x) {\n     \
    \       cur.push(*map.get_mut(&x));\n        } else {\n            cur.push(x);\n\
    \            map.insert(x, cur);\n        }\n        cur += 1;\n    }\n    result.sort_by_key(|&x|\
    \ {\n        map.get(&x).unwrap()\n    });\n    result\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpsihjann5.rs:10:19\n   |\n10 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsihjann5.rs:12:9\n   |\n12 |     for &x in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0599]: no method named `push`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmpsihjann5.rs:14:17\n\
    \   |\n14 |             cur.push(*map.get_mut(&x));\n   |                 ^^^^\
    \ method not found in `{integer}`\n\nerror[E0599]: no method named `push` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmpsihjann5.rs:16:17\n\
    \   |\n16 |             cur.push(x);\n   |                 ^^^^ method not found\
    \ in `{integer}`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        x.iter().map(|x| x.to_binary(2).count()).collect()\n\
    \    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpfith_otx.rs:10:11\n   |\n10 |         x.iter().map(|x|\
    \ x.to_binary(2).count()).collect()\n   |           ^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfith_otx.rs:9:5\n   |\n8  |  \
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \              ---------- expected `Vec<isize>` because of return type\n9  | /\
    \     arr.sort_by_key(|x| {\n10 | |         x.iter().map(|x| x.to_binary(2).count()).collect()\n\
    11 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().map(|&x| {\n        let mut bin_repr = x\n            .iter()\n\
    \            .map(|x| {\n                if x < 2 {\n                    0\n \
    \               } else if x < 4 {\n                    1\n                } else\
    \ if x < 8 {\n                    2\n                } else {\n              \
    \      3\n                }\n            })\n            .collect::<Vec<usize>>();\n\
    \        if bin_repr.len() == 2 {\n            bin_repr[1] = bin_repr[0]\n   \
    \     } else if bin_repr.len() == 3 {\n            bin_repr[2] = bin_repr[0]\n\
    \        }\n        bin_repr\n    }).fold(Vec::new(), |mut vec, x| {\n       \
    \ let mut cnt = 0;\n        let mut bin_repr = x.iter().map(|&x| {\n         \
    \   if x != 0 {\n                cnt += 1;\n            }\n            cnt\n \
    \       }).collect::<Vec<usize>>();\n        if bin_repr.len() == 2 {\n      \
    \      bin_repr[1] = bin_repr[0]\n        }\n        let mut vec_res = vec;\n\
    \        vec_res.push(bin_repr[0]); // push non-ones\n        for _ in 1..cnt\
    \ {\n            vec_res.push(bin_repr[vec_res.len() - 1]);\n        }\n     \
    \   vec_res\n    }).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpo0tlic91.rs:11:14\n   |\n11 |             .iter()\n   |\
    \              ^^^^ method not found in `isize`\n\nerror[E0599]: `Vec<_>` is not\
    \ an iterator\n   --> /tmp/tmpo0tlic91.rs:47:8\n    |\n47  |       }).collect()\n\
    \    |          ^^^^^^^ `Vec<_>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<_>: Iterator`\n         \
    \   which is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n\
    \            which is required by `&mut [_]: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr: Vec<isize> = arr.clone();\n    let mut cnt: Vec<isize>\
    \ = arr.iter().map(|x| x).collect();\n    for _ in 0..cnt.len() {\n        let\
    \ mut min_idx = 0;\n        let mut max_idx = 0;\n        let mut min_value: isize\
    \ = (*cnt.iter().min()).unwrap();\n        let mut max_value: isize = (*cnt.iter().max()).unwrap();\n\
    \        for i in 0..cnt.len() {\n            cnt[i] = cnt[i] as isize;\n    \
    \        cnt[i] -= min_value;\n            cnt[i] += max_value;\n            let\
    \ tmp_idx = (*cnt.iter().skip(i).max()).unwrap() + 1;\n            if tmp_idx\
    \ > max_idx {\n                max_idx = tmp_idx;\n            }\n           \
    \ if tmp_idx < min_idx {\n                min_idx = tmp_idx;\n            }\n\
    \        }\n        sorted_arr.swap(min_idx, max_idx);\n    }\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpse_j2a63.rs:10:53\n     |\n\
    10   |     let mut cnt: Vec<isize> = arr.iter().map(|x| x).collect();\n     |\
    \                                                     ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpse_j2a63.rs:14:36\n   |\n14 |         let mut min_value: isize\
    \ = (*cnt.iter().min()).unwrap();\n   |                                    ^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpse_j2a63.rs:15:36\n\
    \   |\n15 |         let mut max_value: isize = (*cnt.iter().max()).unwrap();\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmpse_j2a63.rs:20:27\n\
    \   |\n20 |             let tmp_idx = (*cnt.iter().skip(i).max()).unwrap() + 1;\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| binary_sort_order(a, b));\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_sort_order` in this scope\n\
    \ --> /tmp/tmp6w51fuq7.rs:9:24\n  |\n9 |     arr.sort_by(|a, b| binary_sort_order(a,\
    \ b));\n  |                        ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp6w51fuq7.rs:8:35\n  |\n8 | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n  |    ----------                     ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in arr.iter() {\n   \
    \     let mut j = 0;\n        while j + 1 < i.len() {\n            if i[j] ==\
    \ 0 && i[j + 1] == 1 {\n                result.push(i);\n                i +=\
    \ 2;\n                continue;\n            }\n            if i[j] == 1 {\n \
    \               j += 1;\n                continue;\n            }\n          \
    \  if i[j] == 0 {\n                break;\n            }\n            j += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmp77rk1b3l.rs:12:25\n   |\n12 |         while j +\
    \ 1 < i.len() {\n   |                         ^^^ method not found in `&isize`\n\
    \nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp77rk1b3l.rs:13:16\n\
    \   |\n13 |             if i[j] == 0 && i[j + 1] == 1 {\n   |                ^^^^\n\
    \nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp77rk1b3l.rs:13:29\n\
    \   |\n13 |             if i[j] == 0 && i[j + 1] == 1 {\n   |                \
    \             ^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77rk1b3l.rs:14:29\n\
    \   |\n14 |                 result.push(i);\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |                 result.push(*i);\n   |                           \
    \  +\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmp77rk1b3l.rs:15:17\n   |\n15 |                 i += 2;\n\
    \   |                 -^^^^^\n   |                 |\n   |                 cannot\
    \ use `+=` on type `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can\
    \ dereference `i`\n   |\n15 |                 *i += 2;\n   |                 +\n\
    \nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp77rk1b3l.rs:18:16\n\
    \   |\n18 |             if i[j] == 1 {\n   |                ^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmp77rk1b3l.rs:22:16\n\
    \   |\n22 |             if i[j] == 0 {\n   |                ^^^^\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return arr;\n    }\n    arr.sort_by_key(|x|\
    \ {\n        x.leading_zeros().binary_repr()\n            .chars()\n         \
    \   .filter(|c| !c.is_digit())\n            .count()\n    });\n    arr.sort_by_key(|x|\
    \ {\n        x.to_string().parse().unwrap()\n    });\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `binary_repr` found for type `u32` in the\
    \ current scope\n  --> /tmp/tmpjazi17tt.rs:13:27\n   |\n13 |         x.leading_zeros().binary_repr()\n\
    \   |                           ^^^^^^^^^^^ method not found in `u32`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n\n    if arr.len() ==\
    \ 1 {\n        return vec![arr[0]];\n    }\n\n    if arr.len() == 2 {\n      \
    \  if arr[0] % 2 == arr[1] % 2 {\n            return vec![arr[0], arr[1]];\n \
    \       }\n        return vec![arr[1], arr[0]];\n    }\n\n    if arr.len() ==\
    \ 3 {\n        if arr[0] % 2 == arr[1] % 2 && arr[1] % 2 == arr[2] % 2 {\n   \
    \         return vec![arr[0], arr[1], arr[2]];\n        }\n        return vec![arr[2],\
    \ arr[1], arr[0]];\n    }\n\n    if arr.len() == 4 {\n        if arr[0] % 2 ==\
    \ arr[1] % 2 && arr[1] % 2 == arr[2] % 2 && arr[2] % 2 == arr[3] % 2 {\n     \
    \       return vec![arr[0], arr[1], arr[2], arr[3]];\n        }\n        return\
    \ vec![arr[3], arr[2], arr[1], arr[0]];\n    }\n\n    if arr.len() == 5 {\n  \
    \      if arr[0] % 2 == arr[1] % 2 && arr[1] % 2 == arr[2] % 2 && arr[2] % 2 ==\
    \ arr[3] % 2 && arr[3] % 2 == arr[4] % 2 {\n            return vec![arr[0], arr[1],\
    \ arr[2], arr[3], arr[4]];\n        }\n        return vec![arr[4], arr[3], arr[2],\
    \ arr[1], arr[0]];\n    }\n\n    if arr.len() == 6 {\n        if arr[0] % 2 ==\
    \ arr[1] % 2 && arr[1] % 2 == arr[2] % 2 && arr[2] % 2 == arr[3] % 2 && arr[3]\
    \ % 2 == arr[4] % 2 && arr[4] % 2 == arr[5] % 2 {\n            return vec![arr[0],\
    \ arr[1], arr[2], arr[3], arr[4], arr[5]];\n        }\n        return vec![arr[5],\
    \ arr[4], arr[3], arr[2], arr[1], arr[0]];\n    }\n\n    if arr.len() == 7 {\n\
    \        if arr[0] % 2 == arr[1] % 2 && arr[1] % 2 == arr[2] % 2 && arr[2] % 2\
    \ == arr[3] % 2 && arr[3] % 2 == arr[4] % 2 && arr[4] % 2 == arr[5] % 2 && arr[5]\
    \ % 2 == arr[6] % 2 {\n            return vec![arr[0], arr[1], arr[2], arr[3],\
    \ arr[4], arr[5], arr[6]];\n        }\n        return vec![arr[6], arr[5], arr[4],\
    \ arr[3], arr[2], arr[1], arr[0]];\n    }\n\n    if arr.len() == 8 {\n       \
    \ if arr[0] % 2 == arr[1] % 2 && arr[1] % 2 == arr[2] % 2 && arr[2] % 2 == arr[3]\
    \ % 2 && arr[3] % 2 == arr[4] % 2 && arr[4] % 2 == arr[5] % 2 && arr[5] \n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpui8p53kk.rs:73:3\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                                 - unclosed delimiter\n...\n59 |     if arr.len()\
    \ == 8 {\n   |                       - this delimiter might not be properly closed...\n\
    60 |         if arr[0] % 2 == arr[1] % 2 && arr[...\n61 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n73 | }\n   |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpui8p53kk.rs:61:1\n   |\n60 |         if arr[0]\
    \ % 2 == arr[1] % 2 && arr[1] % 2 == arr[2] % 2 && arr[2] % 2 == arr[3] % 2 &&\
    \ arr[3] % 2 == arr[4] % 2 && arr[4] % 2 == ...\n   |         -- this `if` expression\
    \ has a condition, but no block\n61 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpui8p53kk.rs:8:35\n  |\n8 | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n  |    ----------                     ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // TODO: Your code here\n    let mut res = Vec::new();\n    let mut i = 0;\n\
    \    for &x in arr {\n        if x != 0 {\n            if res.get(i / 2) == Some(&x)\
    \ {\n                continue;\n            }\n            res.insert(i / 2, x);\n\
    \        }\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2il6tc0.rs:12:9\n   |\n\
    12 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match (b, a) {\n            (Some(_), Some(_))\
    \ => Some(0),\n            (Some(a), None) => Some(1),\n            (None, Some(a))\
    \ => Some(-1),\n            _ => match (*b, *a) {\n                (Some(_), Some(_))\
    \ => Some(*a as usize - *b as usize),\n                (Some(a), None) => Some(*b\
    \ as usize - *a as usize),\n                (None, Some(a)) => Some(*a as usize\
    \ - *b as usize),\n                _ => unreachable!(),\n            },\n    \
    \    }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnsz0e27m.rs:11:14\n   |\n\
    10 |         match (b, a) {\n   |               ------ this expression has type\
    \ `(&isize, &isize)`\n11 |             (Some(_), Some(_)) => Some(0),\n   |  \
    \            ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnsz0e27m.rs:11:23\n   |\n10 |         match (b, a) {\n\
    \   |               ------ this expression has type `(&isize, &isize)`\n11 | \
    \            (Some(_), Some(_)) => Some(0),\n   |                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnsz0e27m.rs:12:14\n   |\n10 |         match (b, a) {\n   |         \
    \      ------ this expression has type `(&isize, &isize)`\n11 |             (Some(_),\
    \ Some(_)) => Some(0),\n12 |             (Some(a), None) => Some(1),\n   |   \
    \           ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnsz0e27m.rs:12:23\n   |\n10 |         match (b, a) {\n\
    \   |               ------ this expression has type `(&isize, &isize)`\n11 | \
    \            (Some(_), Some(_)) => Some(0),\n12 |             (Some(a), None)\
    \ => Some(1),\n   |                       ^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnsz0e27m.rs:13:14\n   |\n10 |\
    \         match (b, a) {\n   |               ------ this expression has type `(&isize,\
    \ &isize)`\n...\n13 |             (None, Some(a)) => Some(-1),\n   |         \
    \     ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnsz0e27m.rs:13:20\n   |\n10 |         match (b, a) {\n   |    \
    \           ------ this expression has type `(&isize, &isize)`\n...\n13 |"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Count number of ones\n    let mut counts = HashMap::new();\n    for x\
    \ in arr {\n        if !counts.contains_key(&x) {\n            counts.insert(x,\
    \ 0);\n        }\n        counts.get_mut(&x).unwrap() += 1;\n    }\n\n    // Sort\
    \ by number of ones\n    let mut sorted_arr = arr.clone();\n    for x in counts\
    \ {\n        sorted_arr.sort_by(|a, b| b.cmp(&a));\n    }\n\n    // Sort by decimal\
    \ value\n    sorted_arr.sort_by(|a, b| {\n        if a < b {\n            std::mem::swap(&a,\
    \ &b)\n        }\n        if a < 0 {\n            -1\n        } else {\n     \
    \       a\n        }\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp15y625po.rs:10:22\n   |\n10 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp15y625po.rs:15:37\n   |\n\
    15 |         counts.get_mut(&x).unwrap() += 1;\n   |         ---------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp15y625po.rs:27:28\n   |\n27 |             std::mem::swap(&a,\
    \ &b)\n   |                            ^^ types differ in mutability\n   |\n \
    \  = note: expected mutable reference `&mut _`\n                      found reference\
    \ `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15y625po.rs:27:32\n\
    \   |\n27 |             std::mem::swap(&a, &b)\n   |                         \
    \       ^^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut _`\n                      found reference `&&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15y625po.rs:29:16\n   |\n29 |         if a < 0 {\n   |\
    \                ^\n   |                |\n   |                expected `&isize`,\
    \ found integer\n   |                help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp15y625po.rs:30:13\n   |\n30 |             -1\n\
    \   |             ^^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp15y625po.rs:32:13\n   |\n32 |             a\n\
    \   |             ^ expected enum `std::cmp::Ordering`, found `&isize`\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut arr2 = vec![];\n    for i in arr.iter().cloned() {\n        arr2.push((i\
    \ & 1) == 1);\n    }\n    arr2.sort_by_key(|x| x.into());\n    arr2\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3whzrlwr.rs:14:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    14 |     arr2\n   |     ^^^^ expected `isize`, found `bool`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<bool>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Write your solution here\n    let mut count = 0;\n    let mut res = Vec::new();\n\
    \    let mut cur_count = 1; // for sorting the same number of ones\n    for i\
    \ in arr {\n        if cur_count == 1 {\n            res.push(*i);\n        }\
    \ else {\n            cur_count += 1;\n            count += 1;\n        }\n  \
    \  }\n    for i in arr {\n        if i == *i {\n            cur_count += 1;\n\
    \        } else {\n            count += 1;\n        }\n    }\n    res.sort();\n\
    \    \n    for i in 0..count {\n        res.push(res[i]);\n    }\n    \n    for\
    \ i in 0..res.len() {\n        res[i] = res[i] + (-res[res.len()-i]);\n    }\n\
    \    \n    for i in 0..res.len() {\n        res[res.len()-i] = res[res.len()-i]\
    \ % (2 * i);\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmplkpocjfk.rs:15:22\n\
    \   |\n15 |             res.push(*i);\n   |                      ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmplkpocjfk.rs:22:17\n   |\n\
    22 |         if i == *i {\n   |                 ^^\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut arr = arr.clone();\n\
    \    let mut min = isize::MAX;\n\n    for &i in &mut arr {\n        let n = i\
    \ as usize;\n        if n > min {\n            min = n;\n        }\n    }\n\n\
    \    let mut min = isize::MAX;\n    let mut pos = 0;\n\n    for &i in &mut arr\
    \ {\n        let n = i as usize;\n        if n > min {\n            min = n;\n\
    \            pos = pos + 1;\n        }\n    }\n\n    while pos < arr.len() {\n\
    \        let mut j = pos;\n        let mut i = j;\n        while i >= 0 && arr[j]\
    \ != 1 {\n            j -= 1;\n            i -= 1;\n        }\n\n        if i\
    \ >= 0 {\n            arr[i] = arr[pos];\n            pos += 1;\n            i\
    \ -= 1;\n        }\n    }\n\n    while min > isize::MAX {\n        let mut index\
    \ = arr.iter().position(|&i| i == 1);\n        index = index as usize % arr.len();\n\
    \        arr[index] = isize::MAX;\n    }\n\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpits6ogwb.rs:16:9\n   |\n\
    16 |     for &i in &mut arr {\n   |         ^^    -------- this expression has\
    \ type `Option<&mut isize>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpits6ogwb.rs:18:16\n\
    \   |\n18 |         if n > min {\n   |                ^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         if n > min.try_into().unwrap()\
    \ {\n   |                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpits6ogwb.rs:19:19\n   |\n14 |     let mut min = isize::MAX;\n \
    \  |                   ---------- expected due to this value\n...\n19 |      \
    \       min = n;\n   |                   ^ expected `isize`, found `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpits6ogwb.rs:26:9\n   |\n26 |   \
    \  for &i in &mut arr {\n   |         ^^    -------- this expression has type\
    \ `Option<&mut isize>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpits6ogwb.rs:28:16\n\
    \   |\n28 |         if n > min {\n   |                ^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n28 |         if n > min.try_into().unwrap()\
    \ {\n   |                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpits6ogwb.rs:29:19\n   |\n23 |     let mut min = isize::MAX;\n \
    \  |                   ---------- expected due to this value\n...\n29 |      \
    \       min = n;\n   |                   ^ expected `isize`, found `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpits6ogwb.rs:51:17\n   |\n50 |"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut map = HashMap::new();\n    let mut res = vec![];\n\n    for x in\
    \ arr.iter() {\n        map.insert(x, map.entry(x).or_insert(0usize));\n    }\n\
    \n    for x in map.keys() {\n        if *x >= map.len() {\n            res.push(*x);\n\
    \        } else {\n            *map.entry(*x).or_insert(0) += 1;\n        }\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpvlj7ndeu.rs:9:19\n  |\n9 |     let mut map = HashMap::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return arr;\n    }\n\n    let mut ones = 0;\n\
    \    let mut twos = 0;\n    let mut threes = 0;\n    let mut fours = 0;\n    let\
    \ mut fives = 0;\n\n    let mut largest = arr[0];\n\n    for i in arr.iter().rev()\
    \ {\n        if i & 1 != 0 {\n            ones += 1;\n            if ones > largest\
    \ {\n                largest = ones;\n            }\n        }\n        if i &\
    \ 2 != 0 {\n            twos += 1;\n            if twos > largest {\n        \
    \        largest = twos;\n            }\n        }\n        if i & 4 != 0 {\n\
    \            fours += 1;\n            if fours > largest {\n                largest\
    \ = fours;\n            }\n        }\n        if i & 8 != 0 {\n            fives\
    \ += 1;\n            if fives > largest {\n                largest = fives;\n\
    \            }\n        }\n    }\n\n    let mut largest = 0;\n    let mut smallest\
    \ = 0;\n\n    if ones > largest {\n        largest = ones;\n    }\n    if twos\
    \ > largest {\n        largest = twos;\n    }\n    if fours > largest {\n    \
    \    largest = fours;\n    }\n    if fives > largest {\n        largest = fives;\n\
    \    }\n\n    for i in arr.iter().rev() {\n        if i & 1 != 0 {\n         \
    \   smallest = i;\n        }\n        if i & 2 != 0 {\n            smallest =\
    \ i;\n        }\n        if i & 4 != 0 {\n            smallest = i;\n        }\n\
    \        if i & 8 != 0 {\n            smallest = i;\n        }\n    }\n\n    arr.sort_unstable_by(|a,\
    \ b| {\n        if b == smallest {\n            return a - b;\n        }\n\n \
    \       if a == smallest {\n            return b - a;\n        }\n\n        let\
    \ mut i = a;\n        let mut j = b;\n\n        if ones > largest {\n        \
    \    i = largest;\n        }\n        if twos > largest {\n            i = largest;\n\
    \        }\n        if fours > largest {\n            i = largest;\n        }\n\
    \        if fives > largest {\n            i = largest;\n        }\n\n       \
    \ if ones < largest {\n            j = largest;\n        }\n        if twos <\
    \ largest {\n            j = largest;\n        }\n        if fours < largest {\n\
    \            j = largest;\n        }\n        if fives < largest {\n         \
    \   j = largest;\n        }\n\n        if a < b {\n            j - i;\n      \
    \  } else {\n            i - j;\n        }\n    });\n\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3bulubxq.rs:66:24\n   |\n\
    49 |     let mut smallest = 0;\n   |                        - expected due to\
    \ this value\n...\n66 |             smallest = i;\n   |                      \
    \  ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n66 |             smallest = *i;\n   |                        +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3bulubxq.rs:69:24\n   |\n49 |\
    \     let mut smallest = 0;\n   |                        - expected due to this\
    \ value\n...\n69 |             smallest = i;\n   |                        ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    69 |             smallest = *i;\n   |                        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3bulubxq.rs:72:24\n   |\n49 |     let mut smallest\
    \ = 0;\n   |                        - expected due to this value\n...\n72 |  \
    \           smallest = i;\n   |                        ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n72 |        \
    \     smallest = *i;\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3bulubxq.rs:75:24\n   |\n49 |     let mut smallest = 0;\n\
    \   |                        - expected due to this value\n...\n75 |         \
    \    smallest = i;\n   |                        ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n75 |             smallest\
    \ = *i;\n   |                        +\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp3bulubxq.rs:80:14\n   |\n80 |         if b ==\
    \ smallest {\n   |              ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3bulubxq.rs:81:20\n\
    \   |\n81 |     "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| bit_count(x.to_string()).unwrap_or(0))\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bit_count` in this scope\n --> /tmp/tmpkik2si5w.rs:9:25\n\
    \  |\n9 |     arr.sort_by_key(|x| bit_count(x.to_string()).unwrap_or(0))\n  |\
    \                         ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpkik2si5w.rs:9:5\n  |\n8 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n  |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n9 |     arr.sort_by_key(|x| bit_count(x.to_string()).unwrap_or(0))\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n          found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut a = arr.to_owned();\n    a.sort();\n    a\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmp1_wyihuz.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .map(|&x| {\n            x.to_dec().unwrap()\n      \
    \  })\n        .sort_by_key(|x| x.cmp(&1))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpjxbgo30p.rs:11:15\n   |\n11 |             x.to_dec().unwrap()\n\
    \   |               ^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror[E0599]: no method named `sort_by_key` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmpjxbgo30p.rs:13:10\n   |\n13 |    \
    \     .sort_by_key(|x| x.cmp(&1))\n   |          ^^^^^^^^^^^ method not found\
    \ in `Map<std::slice::Iter<'_, isize>, _>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // your implementation\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpx065z2y4.rs:15:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut len = arr.len();\n    let mut cnt: usize = 0;\n    for i in 0..len\
    \ {\n        if arr[i] == 1 {\n            cnt += 1;\n        } else {\n     \
    \       len -= 1;\n        }\n    }\n\n    let mut idx = 0;\n    let mut start\
    \ = 0;\n    let mut end = len;\n    let mut min_cnt = cnt;\n    loop {\n     \
    \   if min_cnt == cnt {\n            break;\n        }\n        if min_cnt > cnt\
    \ {\n            idx = 0;\n            start = idx;\n            end = end;\n\
    \        } else {\n            idx = end;\n            end = idx;\n        }\n\
    \        min_cnt -= 1;\n    }\n\n    mem::swap(&mut arr[start..], &mut arr[idx..]);\n\
    \n    for i in 0..len {\n        if arr[i] == 1 {\n            arr[idx] -= 1;\n\
    \            idx += 1;\n        }\n    }\n\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `mem`\n\
    \  --> /tmp/tmpwfzkzmj0.rs:38:5\n   |\n38 |     mem::swap(&mut arr[start..], &mut\
    \ arr[idx..]);\n   |     ^^^ use of undeclared crate or module `mem`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = arr.clone();\n    let mut n = arr.len();\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            result += [n / 2];\n            n\
    \ /= 2;\n        } else {\n            result -= [n / 2];\n            n /= 2;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<isize>`\n  --> /tmp/tmppfimr93x.rs:13:13\n   |\n13 |             result\
    \ += [n / 2];\n   |             ------^^^^^^^^^^^\n   |             |\n   |  \
    \           cannot use `+=` on type `Vec<isize>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmppfimr93x.rs:16:13\n\
    \   |\n16 |             result -= [n / 2];\n   |             ------^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `-=` on type `Vec<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut arr2 = arr.to_owned();\n\n    // first count the number of ones present\
    \ in each element of arr\n    let mut map: Vec<isize> = arr2.iter().map(|x| *x).fold(0,\
    \ |m, x| if *m > x { 1 } else { 0 });\n    // convert the map to an array and\
    \ sort\n    let mut sorted_arr = map.iter().cloned().collect::<Vec<_>>().sorted();\n\
    \n    // count how many times each number appears\n    let mut freq: Vec<usize>\
    \ = arr2.iter().map(|x| *x).fold(0, |m, x| if *m == x { m } else { 0 });\n   \
    \ // convert freq to array and sort\n    let mut sorted_freq = freq.iter().cloned().collect::<Vec<_>>().sorted();\n\
    \n    // convert freq to an array and sort\n    sorted_arr.extend(sorted_freq.into_iter().cloned());\n\
    \    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxys3d4x.rs:12:60\n   |\n\
    12 |     let mut map: Vec<isize> = arr2.iter().map(|x| *x).fold(0, |m, x| if *m\
    \ > x { 1 } else { 0 });\n   |                                               \
    \             ^ expected struct `Vec`, found integer\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxys3d4x.rs:12:78\n   |\n12 |     let mut map:\
    \ Vec<isize> = arr2.iter().map(|x| *x).fold(0, |m, x| if *m > x { 1 } else { 0\
    \ });\n   |                                                                  \
    \            ^ expected slice `[isize]`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjxys3d4x.rs:12:82\n   |\n12 |     let mut map: Vec<isize>\
    \ = arr2.iter().map(|x| *x).fold(0, |m, x| if *m > x { 1 } else { 0 });\n   |\
    \                                                                            \
    \      ^ expected struct `Vec`, found integer\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjxys3d4x.rs:12:93\n   |\n12 |     let mut map: Vec<isize>\
    \ = arr2.iter().map(|x| *x).fold(0, |m, x| if *m > x { 1 } else { 0 });\n   |\
    \                                                                            \
    \                 ^ expected struct `Vec`, found integer\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `{integer}`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpjxys3d4x.rs:14:66\n   |\n14 |     let mut sorted_arr = map.iter().cloned().collect::<Vec<_>>().sorted();\n\
    \   |                                                                  ^^^^^^\
    \ help: there is an associated function with a similar name: `is_sorted`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxys3d4x.rs:17:61\n   |\n17 |     let mut freq:\
    \ Vec<usize> = arr2.iter().map(|x| *x).fold(0, |m, x| if *m == x { m } else {\
    \ 0 });\n   |                                                             ^ expected\
    \ struct `Vec`, f"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|&x| {\n        let mut s = String::new();\n        for &bit\
    \ in x.to_string().reverse() {\n            if bit == \"1\" {\n              \
    \  s.push('0');\n            } else {\n                s.push('1');\n        \
    \    }\n        }\n        s.reverse();\n        s\n    })\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplrs1tkwd.rs:11:35\n   |\n11 |         for &bit\
    \ in x.to_string().reverse() {\n   |                                   ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmplrs1tkwd.rs:18:11\n   |\n18 |         s.reverse();\n   |       \
    \    ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplrs1tkwd.rs:9:5\n   |\n8  |  \
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \              ---------- expected `Vec<isize>` because of return type\n9  | /\
    \     arr.sort_by_key(|&x| {\n10 | |         let mut s = String::new();\n11 |\
    \ |         for &bit in x.to_string().reverse() {\n12 | |             if bit ==\
    \ \"1\" {\n...  |\n19 | |         s\n20 | |     })\n   | |______^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter: isize = 0;\n    for i in arr {\n        counter += i as\
    \ isize;\n    }\n    \n    let mut arr = vec![];\n    for i in arr.iter() {\n\
    \        arr.push(*i as isize);\n    }\n    arr.sort();\n\n    for i in arr.iter()\
    \ {\n        arr.push(*i as isize);\n    }\n    \n    return arr;\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "warning: variable `counter` is assigned to, but never used\n --> /tmp/tmp178isxxg.rs:9:13\n\
    \  |\n9 |     let mut counter: isize = 0;\n  |             ^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n  = note: consider using `_counter`\
    \ instead\n\nerror[E0502]: cannot borrow `arr` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp178isxxg.rs:16:9\n   |\n15 |     for i in arr.iter()\
    \ {\n   |              ----------\n   |              |\n   |              immutable\
    \ borrow occurs here\n   |              immutable borrow later used here\n16 |\
    \         arr.push(*i as isize);\n   |         ^^^^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n\nerror[E0502]: cannot borrow `arr` as mutable because it is also\
    \ borrowed as immutable\n  --> /tmp/tmp178isxxg.rs:21:9\n   |\n20 |     for i\
    \ in arr.iter() {\n   |              ----------\n   |              |\n   |   \
    \           immutable borrow occurs here\n   |              immutable borrow later\
    \ used here\n21 |         arr.push(*i as isize);\n   |         ^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n --> /tmp/tmpwtojccj1.rs:9:25\n  |\n9 |     arr.iter().cloned().sort().collect()\n\
    \  |                         ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        if x == 0 {\n            1\n        } else\
    \ {\n            x.leading_zeros() as i32\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpht2vkx20.rs:10:14\n\
    \   |\n10 |         if x == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpht2vkx20.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by_key(|x| {\n10 | |         if x == 0 {\n11 | | \
    \            1\n12 | |         } else {\n13 | |             x.leading_zeros()\
    \ as i32\n14 | |         }\n15 | |     })\n   | |______^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut num_bits\
    \ = arr.len() * 8;\n    let mut num_ones = 0;\n    for &i in arr {\n        if\
    \ i == 1 {\n            num_bits -= 1;\n            num_ones += 1;\n        }\
    \ else if num_bits <= 0 {\n            break;\n        }\n        num_bits -=\
    \ 1;\n    }\n    num_bits += num_ones;\n    let mut min_val = i32::MAX;\n    for\
    \ i in 0..num_bits {\n        let val = i as i32;\n        if val < min_val {\n\
    \            min_val = val;\n        }\n    }\n    let mut result = vec![];\n\
    \    let mut last_i = 0;\n    for i in arr {\n        if i == 1 {\n          \
    \  result.append(last_i);\n            last_i += 1;\n        } else if num_bits\
    \ <= 0 {\n            break;\n        }\n        last_i += 1;\n    }\n    if num_bits\
    \ == 0 {\n        result.append(last_i);\n    }\n    if num_ones == 0 {\n    \
    \    result = result.into_iter().cloned().collect();\n    }\n    for i in result\
    \ {\n        if i > min_val {\n            return vec![];\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpepw1b15j.rs:14:9\n   |\n\
    14 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpepw1b15j.rs:35:27\n   |\n35 |             result.append(last_i);\n\
    \   |                           ^^^^^^ expected `&mut Vec<_>`, found integer\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepw1b15j.rs:43:23\n\
    \   |\n43 |         result.append(last_i);\n   |                       ^^^^^^\
    \ expected `&mut Vec<_>`, found integer\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `{integer}`\n\nerror[E0277]:\
    \ a value of type `Vec<&_>` cannot be built from an iterator over elements of\
    \ type `_`\n    --> /tmp/tmpepw1b15j.rs:46:46\n     |\n46   |         result =\
    \ result.into_iter().cloned().collect();\n     |                             \
    \                 ^^^^^^^ value of type `Vec<&_>` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `Vec<&_>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&_` with `i32`\n  -->\
    \ /tmp/tmpepw1b15j.rs:49:14\n   |\n49 |         if i > min_val {\n   |       \
    \       ^ no implementation for `&_ < i32` and `&_ > i32`\n   |\n   = help: the\
    \ trait `PartialOrd<i32>` is not implemented for `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpepw1b15j.rs:53:5\n   |\n8  | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                   ---------- expected\
    \ `Vec<isize>` because of return type\n...\n53 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found reference\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = vec![0isize; arr.len()];\n    let mut sorted = vec![0;\
    \ arr.len()];\n\n    for &value in arr {\n        counter[value] += 1;\n    }\n\
    \n    for i in (0..arr.len() - 1).rev() {\n        sorted[i] = counter[arr[i]];\n\
    \        counter[arr[i]] += 1;\n    }\n\n    for i in (0..arr.len() - 1).rev()\
    \ {\n        counter[arr[i]] -= 1;\n        counter[arr[i]] += 1;\n    }\n\n \
    \   for i in 0..sorted.len() {\n        sorted[i] = i as isize;\n    }\n\n   \
    \ sorted\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbxtr0sdi.rs:12:9\n   |\n\
    12 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `value`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbxtr0sdi.rs:17:21\n\
    \   |\n17 |         sorted[i] = counter[arr[i]];\n   |                     ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbxtr0sdi.rs:18:9\n\
    \   |\n18 |         counter[arr[i]] += 1;\n   |         ^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbxtr0sdi.rs:22:9\n   |\n22 |   \
    \      counter[arr[i]] -= 1;\n   |         ^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpbxtr0sdi.rs:23:9\n   |\n23 |         counter[arr[i]]\
    \ += 1;\n   |         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Count occurrences of each binary number\n    let mut count: Vec<Vec<usize>>\
    \ = arr\n        .iter()\n        .map(|n| vec![n as usize; 1])\n        .collect();\n\
    \    for &n in &arr {\n        let index = count - 1;\n        if index.is_some()\
    \ && index[0] >= n {\n            index[0].0 += 1;\n        } else {\n       \
    \     count.push(vec![n as usize; 1]);\n        }\n    }\n\n    // Sort based\
    \ on count\n    count.sort_unstable_by_key(|&(_, count1)| {\n        // Sort based\
    \ on decimal value\n        arr\n            .iter()\n            .enumerate()\n\
    \            .filter(|(_, index)| count > index.0).map(|(index1, n)| {\n     \
    \           if n == 1 {\n                    index\n                } else {\n\
    \                    index1 + 1\n                }\n            })\n         \
    \   .sum()\n    });\n\n    // Convert binary number to decimal value\n    count\n\
    \        .iter()\n        .map(|(index1, count)| {\n            arr[index1] +\
    \ index1 * isize::pow(2, count) as isize\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `index` in this scope\n  --> /tmp/tmpadya1ajo.rs:31:21\n\
    \   |\n31 |                     index\n   |                     ^^^^^ help: a\
    \ local variable with a similar name exists: `index1`\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Vec<Vec<usize>>`\n  --> /tmp/tmpadya1ajo.rs:15:27\n\
    \   |\n15 |         let index = count - 1;\n   |                     ----- ^ -\
    \ {integer}\n   |                     |\n   |                     Vec<Vec<usize>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpadya1ajo.rs:24:34\n   |\n24 |\
    \     count.sort_unstable_by_key(|&(_, count1)| {\n   |                      \
    \            ^^^^^^^^^^-\n   |                                  |         |\n\
    \   |                                  |         expected due to this\n   |  \
    \                                expected struct `Vec`, found tuple\n   |\n  \
    \ = note: expected struct `Vec<usize>`\n               found tuple `(_, _)`\n\n\
    error[E0609]: no field `0` on type `&&isize`\n  --> /tmp/tmpadya1ajo.rs:29:48\n\
    \   |\n29 |             .filter(|(_, index)| count > index.0).map(|(index1, n)|\
    \ {\n   |                                                ^\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmpadya1ajo.rs:30:22\n   |\n30\
    \ |                 if n == 1 {\n   |                      ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpadya1ajo.rs:42:15\n   |\n42 |         .map(|(index1, count)| {\n   |\
    \               ^^^^^^^^^^^^^^-\n   |               |             |\n   |    \
    \           |             expected due to this\n   |               expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<usize>`\n        \
    \       found tuple `(_, _)`\n\nerror[E0606]: casting `&isize` as `usize` is in"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    sorted_arr.sort_by(|a, b| {\n   \
    \     if *a > *b {\n            1\n        } else if *a < *b {\n            -1\n\
    \        } else {\n            0\n        }\n    });\n    sorted_arr\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxa5pmaqs.rs:12:13\n   |\n\
    12 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxa5pmaqs.rs:14:13\n\
    \   |\n14 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxa5pmaqs.rs:16:13\n\
    \   |\n16 |             0\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match a.checked_mul(2).is_one() {\n       \
    \     true  => a.checked_mul(2).unwrap(),\n            false => b.checked_mul(2).unwrap(),\n\
    \        }\n    }).cloned()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_one` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpo14x50yk.rs:10:32\n   |\n10 |         match a.checked_mul(2).is_one()\
    \ {\n   |                                ^^^^^^ help: there is an associated function\
    \ with a similar name: `is_none`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo14x50yk.rs:11:22\n\
    \   |\n11 |             true  => a.checked_mul(2).unwrap(),\n   |            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpo14x50yk.rs:14:8\n\
    \   |\n14 |     }).cloned()\n   |        ^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| {\n        x.to_binary(2);\n    });\n    arr.sort_by_key(|x|\
    \ {\n        x.to_dec().unwrap();\n    });\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_binary` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmplsps1386.rs:10:11\n   |\n10 |         x.to_binary(2);\n\
    \   |           ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror[E0599]: no method named `to_dec` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmplsps1386.rs:13:11\n   |\n13 | \
    \        x.to_dec().unwrap();\n   |           ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().enumerate().sort_by(|(_, el), idx| {\n        match idx {\n  \
    \          0 => el,\n            _ => el\n                    .bits()\n      \
    \              .rev()\n                    .iter()\n                    .fold(0i64,\
    \ |acc, digit| acc * 2 + digit),\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n --> /tmp/tmpx2p03fvq.rs:9:28\n  |\n9 |     arr.iter().enumerate().sort_by(|(_,\
    \ el), idx| {\n  |                            ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| get_bits(x).count());\n    arr.sort_by_key(|x| get_decimal(x));\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_bits` in this scope\n --> /tmp/tmpr56ye_8p.rs:9:25\n\
    \  |\n9 |     arr.sort_by_key(|x| get_bits(x).count());\n  |                 \
    \        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `get_decimal` in this scope\n  --> /tmp/tmpr56ye_8p.rs:10:25\n   |\n10 |   \
    \  arr.sort_by_key(|x| get_decimal(x));\n   |                         ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for i in arr.iter() {\n        let n = i as usize;\n        let mut count\
    \ = 0;\n        for b in n.binary_repr() {\n            if b == '1' {\n      \
    \          count += 1;\n            }\n        }\n        if count == 0 {\n  \
    \          count += 1;\n        }\n        arr.swap(i, arr.iter().map(|x| x as\
    \ usize).sum());\n    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `binary_repr` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpgn6c6fjs.rs:12:20\n   |\n12 |         for b in\
    \ n.binary_repr() {\n   |                    ^^^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgn6c6fjs.rs:20:18\n   |\n20 |\
    \         arr.swap(i, arr.iter().map(|x| x as usize).sum());\n   |           \
    \       ^ expected `usize`, found `&isize`\n\nerror[E0606]: casting `&isize` as\
    \ `usize` is invalid\n  --> /tmp/tmpgn6c6fjs.rs:10:17\n   |\n10 |         let\
    \ n = i as usize;\n   |                 -^^^^^^^^^\n   |                 |\n \
    \  |                 cannot cast `&isize` as `usize`\n   |                 help:\
    \ dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `usize`\
    \ is invalid\n  --> /tmp/tmpgn6c6fjs.rs:20:40\n   |\n20 |         arr.swap(i,\
    \ arr.iter().map(|x| x as usize).sum());\n   |                               \
    \         -^^^^^^^^^\n   |                                        |\n   |    \
    \                                    cannot cast `&isize` as `usize`\n   |   \
    \                                     help: dereference the expression: `*x`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // TODO: Implement this function\n    // let mut arr1 = arr.to_vec();\n \
    \   // for i in 0..arr1.len() {\n    //     let j = arr1.len() - i - 1;\n    //\
    \     if arr1[j] % 2 == 0 {\n    //         arr1.swap(i, j);\n    //     }\n \
    \   // }\n    // arr1\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw_8x9sqb.rs:8:35\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return arr;\n    }\n\n    let mut counts = arr.iter().map(|x|\
    \ {\n        if x == 0 {\n            1\n        } else {\n            0\n   \
    \     }\n    }).collect::<Vec<_>>();\n\n    for num in &arr {\n        counts[num]--;\n\
    \    }\n\n    let mut res = [];\n\n    for num in &arr {\n        if counts[num]\
    \ == 0 {\n            res.push(num);\n            counts[num]++;\n        }\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmprxrkohbl.rs:22:22\n\
    \   |\n22 |         counts[num]--;\n   |                      ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmprxrkohbl.rs:30:24\n\
    \   |\n30 |             counts[num]++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |             { let\
    \ tmp = counts[num]; counts[num] += 1; tmp };\n   |             +++++++++++  \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~\n30 -             counts[num]++;\n30 +  \
    \           counts[num] += 1;\n   | \n\nerror[E0277]: can't compare `&isize` with\
    \ `{integer}`\n  --> /tmp/tmprxrkohbl.rs:14:14\n   |\n14 |         if x == 0 {\n\
    \   |              ^^ no implementation for `&isize == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmprxrkohbl.rs:28:12\n   |\n28 |         if counts[num] == 0 {\n \
    \  |            ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0599]: no method named `push` found for array `[_; 0]` in the current\
    \ scope\n  --> /tmp/tmprxrkohbl.rs:29:17\n   |\n29 |             res.push(num);\n\
    \   |                 ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprxrkohbl.rs:34:5\n   |\n8  | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                   ---------- expected\
    \ `Vec<isize>` because of return type\n...\n34 |     res\n   |     ^^^- help:\
    \ try using a conversion method: `.to_vec()`\n   |    "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted = arr.to_vec();\n    sorted.sort();\n    for &i in sorted\
    \ {\n        if i != 0 {\n            sorted.swap(i, sorted.len());\n        }\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8aq4wm0t.rs:11:9\n   |\n\
    11 |     for &i in sorted {\n   |         ^^    ------ this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort_by_key(|&x| x!.count_ones() as i32).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `.`\n --> /tmp/tmpkrwji5mw.rs:9:44\n\
    \  |\n9 |     arr.iter().cloned().sort_by_key(|&x| x!.count_ones() as i32).collect()\n\
    \  |                                            ^ expected one of `(`, `[`, or\
    \ `{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut res = arr.to_owned();\n\
    \    let mut nums: Vec<isize> = arr.to_vec();\n\n    for num in res.into_iter()\
    \ {\n        let mut carry = 0;\n        let mut tmp = num;\n\n        for _ in\
    \ 0..bits::CHAR_BIT {\n            if tmp == 0 {\n                carry = 1;\n\
    \                tmp = 1;\n            } else {\n                carry = tmp %\
    \ 2;\n                tmp = tmp / 2;\n            }\n            res[rem.cmp(&num).unwrap()]\
    \ = carry;\n        }\n    }\n    if res.len() < arr.len() {\n        res.extend(nums.into_iter().cloned());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bits`\n\
    \  --> /tmp/tmpusawc5g2.rs:20:21\n   |\n20 |         for _ in 0..bits::CHAR_BIT\
    \ {\n   |                     ^^^^ use of undeclared crate or module `bits`\n\n\
    error[E0425]: cannot find value `rem` in this scope\n  --> /tmp/tmpusawc5g2.rs:28:17\n\
    \   |\n28 |             res[rem.cmp(&num).unwrap()] = carry;\n   |           \
    \      ^^^ help: a local variable with a similar name exists: `res`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpusawc5g2.rs:32:37\n     |\n32   |         res.extend(nums.into_iter().cloned());\n\
    \     |                                     ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n   --> /tmp/tmpusawc5g2.rs:32:20\n\
    \    |\n32  |         res.extend(nums.into_iter().cloned());\n    |          \
    \   ------ ^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found `isize`\n    |\
    \             |\n    |             required by a bound introduced by this call\n\
    \    |\n    = note: expected reference `&_`\n                    found type `isize`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::vec::IntoIter<isize>>`\nnote: required by a bound in `extend`\n\
    \nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n   --> /tmp/tmpusawc5g2.rs:32:20\n    |\n32  |         res.extend(nums.into_iter().cloned());\n\
    \    |             ------ ^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found\
    \ `isize`\n    |             |\n    |             required by a bound introduced\
    \ by this call\n    |\n    = note: expected reference `&_`\n                 \
    \   found type `isize`\n    = note: required because of the requirements on the\
    \ impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n    = note: required\
    \ because of the requirements on the impl of `IntoI"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n\n    let mut min_val\
    \ = arr[0];\n    let mut min_idx = arr.len();\n\n    for idx in 1..arr.len() {\n\
    \        let cur_val = arr[idx];\n        let prev_val = arr[idx - 1];\n     \
    \   if cur_val != prev_val {\n            if cur_val == 1 {\n                min_val\
    \ = prev_val;\n                min_idx = idx;\n            } else {\n        \
    \        if cur_val < min_val {\n                    min_val = cur_val;\n    \
    \                min_idx = idx;\n                }\n            }\n        }\n\
    \    }\n    arr.swap(min_idx, arr.len() - min_idx);\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpi0zggjo7.rs:31:5\n   |\n8  | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n31 |     arr.swap(min_idx, arr.len() - min_idx);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `arr` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpi0zggjo7.rs:31:23\n   |\n31 |\
    \     arr.swap(min_idx, arr.len() - min_idx);\n   |     ------------------^^^^^^^^^-----------\n\
    \   |     |   |             |\n   |     |   |             immutable borrow occurs\
    \ here\n   |     |   mutable borrow later used by call\n   |     mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmpi0zggjo7.rs:31:23\n   |\n31 |     arr.swap(min_idx, arr.len() - min_idx);\n\
    \   |                       ^^^^^^^^^\nhelp: ...and then using that local as the\
    \ argument to this call\n  --> /tmp/tmpi0zggjo7.rs:31:5\n   |\n31 |     arr.swap(min_idx,\
    \ arr.len() - min_idx);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    if arr.len() > 1 {\n\
    \        let mut len = arr.len();\n        arr.sort_by_key(|&x| {\n          \
    \  (0..9).index_if_in_bounds(|&y| {\n                let y = *y;\n           \
    \     let y = y * y + x;\n                y / 10.to_f().sqrt().floor() as isize\n\
    \            }).unwrap()\n        });\n        for &x in arr[0..len] {\n     \
    \       arr.remove(x as usize);\n        }\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index_if_in_bounds` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmp5ghppjfb.rs:16:20\n   |\n16 |          \
    \   (0..9).index_if_in_bounds(|&y| {\n   |                    ^^^^^^^^^^^^^^^^^^\
    \ method not found in `std::ops::Range<{integer}>`\n\nerror[E0599]: no method\
    \ named `to_f` found for type `{integer}` in the current scope\n  --> /tmp/tmp5ghppjfb.rs:19:24\n\
    \   |\n19 |                 y / 10.to_f().sqrt().floor() as isize\n   |      \
    \                  ^^^^ method not found in `{integer}`\n\nerror[E0277]: the size\
    \ for values of type `[isize]` cannot be known at compilation time\n  --> /tmp/tmp5ghppjfb.rs:22:19\n\
    \   |\n22 |         for &x in arr[0..len] {\n   |                   ^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[isize]: IntoIterator` is not satisfied\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `[isize]`\nhelp: consider\
    \ borrowing here\n   |\n22 |         for &x in &arr[0..len] {\n   |          \
    \         +\n22 |         for &x in &mut arr[0..len] {\n   |                 \
    \  ++++\n\nerror[E0277]: `[isize]` is not an iterator\n  --> /tmp/tmp5ghppjfb.rs:22:19\n\
    \   |\n22 |         for &x in arr[0..len] {\n   |                   ^^^^^^^^^^^\
    \ expected an implementor of trait `IntoIterator`\n   |\n   = note: the trait\
    \ bound `[isize]: IntoIterator` is not satisfied\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `[isize]`\nhelp: consider\
    \ borrowing here\n   |\n22 |         for &x in &arr[0..len] {\n   |          \
    \         +\n22 |         for &x in &mut arr[0..len] {\n   |                 \
    \  ++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // The first element will be the maximum one.\n    let max_one = max_value(&arr);\n\
    \n    // Go through the array and find the index of each one.\n    let mut ones\
    \ = vec![];\n    for i in 0..arr.len() {\n        if arr[i] == max_one {\n   \
    \         ones.push(i);\n        }\n    }\n\n    // Go through the array again\
    \ and find the decimal values of each one.\n    let mut decimals = vec![];\n \
    \   for i in ones {\n        let mut sum = 0;\n        for j in 0..(arr.len()\
    \ - 1) {\n            if arr[j] == i {\n                sum += 1;\n          \
    \  }\n        }\n        decimals.push((sum + i) / (arr.len() - 1));\n    }\n\n\
    \    // Go through the array again and sort the decimal values.\n    for i in\
    \ 0..(arr.len() - 1) {\n        let mut min_value = arr[i];\n        let mut max_value\
    \ = arr[i];\n        let mut min_index = i;\n        let mut max_index = i;\n\
    \        for j in ones {\n            if decimals[j] > decimals[min_index] {\n\
    \                min_index = j;\n            }\n            if decimals[j] < decimals[max_index]\
    \ {\n                max_index = j;\n            }\n        }\n        if max_value\
    \ < min_value {\n            max_value = min_value;\n        }\n        arr[min_index]\
    \ = max_value;\n    }\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max_value` in this scope\n  --> /tmp/tmpalgbe5u2.rs:10:19\n\
    \   |\n10 |     let max_one = max_value(&arr);\n   |                   ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpalgbe5u2.rs:25:26\n\
    \   |\n25 |             if arr[j] == i {\n   |                          ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |             if arr[j]\
    \ == i.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut arr = arr.to_vec();\n    if arr.len() == 0 {\n        return arr;\n\
    \    }\n    if arr.len() <= 1 {\n        return arr;\n    }\n\n    let mut len\
    \ = arr.len();\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = arr.len();\n\
    \    let mut cnt = 0;\n\n    while i < k {\n        if arr[j] == 1 {\n       \
    \     cnt += 1;\n            i += 1;\n            j += 1;\n            k += 1;\n\
    \        } else if arr[j] == 0 {\n            cnt -= 1;\n            i += 1;\n\
    \            j += 1;\n            k += 1;\n        } else {\n            if cnt\
    \ > 0 {\n                swap(&mut arr[j], &mut arr[k]);\n                cnt\
    \ += 1;\n                i += 1;\n                j += 1;\n                k +=\
    \ 1;\n            } else {\n                i += 1;\n                j += 1;\n\
    \                k += 1;\n            }\n        }\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpbf1i8gu9.rs:36:17\n\
    \   |\n36 |                 swap(&mut arr[j], &mut arr[k]);\n   |            \
    \     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        arr\n    } else {\n        let mut res = vec![];\n\
    \        let mut counter = vec![0];\n        for e in arr {\n            let num\
    \ = 1 << e; // binary representation, for example, for 1 it's '0001'\n       \
    \     counter.push(num);\n            if num > 1 {\n                // sort by\
    \ decimal\n                res.push((*counter).dec());\n                // increment\
    \ counter\n                counter.push(0);\n            }\n        }\n      \
    \  res.extend(counter);\n        res\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `dec` found for slice `[{integer}]` in the\
    \ current scope\n  --> /tmp/tmp7xtfuafu.rs:19:37\n   |\n19 |                 res.push((*counter).dec());\n\
    \   |                                     ^^^ method not found in `[{integer}]`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // get number of ones in binary representation of number\n    let num_ones\
    \ = binary_search(&arr, 0);\n\n    // sort if number of ones is equal\n    if\
    \ num_ones == arr.len() {\n        let mut arr2 = arr.clone();\n        arr2.sort();\n\
    \        arr2\n    } else {\n        arr.sort();\n    }\n\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_search` in this scope\n  -->\
    \ /tmp/tmpqf7srcuq.rs:10:20\n   |\n10 |     let num_ones = binary_search(&arr,\
    \ 0);\n   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqf7srcuq.rs:16:9\n   |\n13 | /     if num_ones\
    \ == arr.len() {\n14 | |         let mut arr2 = arr.clone();\n15 | |         arr2.sort();\n\
    16 | |         arr2\n   | |         ^^^^ expected `()`, found struct `Vec`\n17\
    \ | |     } else {\n18 | |         arr.sort();\n19 | |     }\n   | |_____- expected\
    \ this to be `()`\n   |\n   = note: expected unit type `()`\n                \
    \ found struct `Vec<isize>`\nhelp: you might have meant to return this value\n\
    \   |\n16 |         return arr2;\n   |         ++++++     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = HashMap::new();\n    let mut max_ones = 0;\n    for i in\
    \ arr {\n        if counter.contains_key(&i) {\n            *counter.entry(i).or_insert(0)\
    \ += 1;\n        } else {\n            *counter.entry(i).or_insert(0) += 1;\n\
    \            max_ones = *counter.entry(i).or_insert(0);\n        }\n    }\n\n\
    \    arr.sort_by_key(|x| {\n        if *counter.entry(x).or_insert(0) > max_ones\
    \ {\n            *x\n        } else {\n            (*x).to_dec().unwrap()\n  \
    \      }\n    });\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpvgtqbdgu.rs:9:23\n  |\n9 |     let mut counter = HashMap::new();\n \
    \ |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0599]:\
    \ no method named `to_dec` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpvgtqbdgu.rs:24:18\n   |\n24 |             (*x).to_dec().unwrap()\n \
    \  |                  ^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvgtqbdgu.rs:8:35\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------  \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counters = Vec::new();\n    for &x in arr {\n        let mut counter\
    \ = 0;\n        for &y in &counter {\n            y += 1;\n        }\n       \
    \ counters.push(counter);\n    }\n    counters.sort_unstable_by(|a, b| {\n   \
    \     if a > b {\n            std::cmp::Ordering::Greater\n        } else {\n\
    \            std::cmp::Ordering::Less\n        }\n    });\n    arr.iter().map(|x|\
    \ {\n        counters[x as usize]\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc6ph_lpw.rs:10:9\n   |\n\
    10 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: `&{integer}`\
    \ is not an iterator\n  --> /tmp/tmpc6ph_lpw.rs:12:19\n   |\n12 |         for\
    \ &y in &counter {\n   |                   ^^^^^^^^ `&{integer}` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&{integer}`\n \
    \  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&{integer}`\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n \
    \ --> /tmp/tmpc6ph_lpw.rs:25:18\n   |\n25 |         counters[x as usize]\n   |\
    \                  -^^^^^^^^^\n   |                  |\n   |                 \
    \ cannot cast `&isize` as `usize`\n   |                  help: dereference the\
    \ expression: `*x`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = arr.to_vec();\n    result.sort_by_key(|x| {\n        if\
    \ x % 2 == 0 {\n            cmp::Ordering::Less\n        } else {\n          \
    \  cmp::Ordering::Greater\n        }\n    });\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpego05l9s.rs:12:13\n   |\n12 |             cmp::Ordering::Less\n\
    \   |             ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpego05l9s.rs:14:13\n\
    \   |\n14 |             cmp::Ordering::Greater\n   |             ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|x, y| x.checked_mul(2).cmp(&y.checked_mul(2)).expect(\"\
    Array elements are not in order\").unwrap());\n    arr.sort_unstable_by(|x, y|\
    \ x.checked_mul(10).cmp(&y.checked_mul(10)).expect(\"Array elements are not in\
    \ order\").unwrap());\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `expect` found for enum `std::cmp::Ordering`\
    \ in the current scope\n --> /tmp/tmpfqjp3dl3.rs:9:73\n  |\n9 |     arr.sort_unstable_by(|x,\
    \ y| x.checked_mul(2).cmp(&y.checked_mul(2)).expect(\"Array elements are not in\
    \ order\").unwrap());\n  |                                                   \
    \                      ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0599]:\
    \ no method named `expect` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmpfqjp3dl3.rs:10:75\n   |\n10 |     arr.sort_unstable_by(|x,\
    \ y| x.checked_mul(10).cmp(&y.checked_mul(10)).expect(\"Array elements are not\
    \ in order\").unwrap());\n   |                                               \
    \                            ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Return sorted arr\n    arr.sort_by_key(|x| x.checked_to_u64().count())\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_to_u64` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpc7_qjdo1.rs:10:27\n   |\n10 |     arr.sort_by_key(|x|\
    \ x.checked_to_u64().count())\n   |                           ^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `checked_log`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc7_qjdo1.rs:10:5\n   |\n8  | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                   ----------\
    \ expected `Vec<isize>` because of return type\n9  |     // Return sorted arr\n\
    10 |     arr.sort_by_key(|x| x.checked_to_u64().count())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut array = arr.to_owned();\n\
    \    let mut len = array.len();\n\n    // The idea is very simple: first you find\
    \ the number with most ones\n    // in the binary representation of the number\
    \ with most ones,\n    // then you find the number with most ones in binary representation\
    \ of\n    // number with least ones, etc.\n    // The first step will be to find\
    \ such number:\n    // 1. Sort the array and get indices of number with most ones.\n\
    \    // 2. Sort array only based on the number of ones in the binary representations\n\
    \    //    of the indices, and get indices of number with most ones in the\n \
    \   //    binary representations of the sorted array indices.\n    // 3. Repeat\
    \ step 2 until you have found the number with most ones.\n    // 4. Return the\
    \ element from the unsorted array with binary representation\n    //    of the\
    \ number with most ones.\n    // For example, for the array [0, 1, 1, 0], the\
    \ binary representations of\n    // indices 0, 1, 2, 3, and 4 are 0, 1, 10, 11,\
    \ 100. And the binary representation\n    // of number with most ones is 10. Since\
    \ 0 is lesser than 10, 0 must be returned.\n    let mut max_bit = 0;\n    let\
    \ mut max_index = -1;\n    for i in array.iter().rev() {\n        let bin_repr\
    \ = bin(i)[3].to_vec();\n        let mut ones = 0;\n        for e in bin_repr\
    \ {\n            if e == '1' {\n                ones += 1;\n            }\n  \
    \      }\n        if ones > max_bit {\n            max_bit = ones;\n         \
    \   max_index = i;\n        }\n    }\n\n    for i in 0..max_bit {\n        array.swap(i,\
    \ max_index);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bin` in this scope\n  --> /tmp/tmp3yux7z8i.rs:34:24\n\
    \   |\n34 |         let bin_repr = bin(i)[3].to_vec();\n   |                 \
    \       ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3yux7z8i.rs:43:25\n\
    \   |\n32 |     let mut max_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n43 |             max_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n43 |             max_index = *i;\n   |                   \
    \      +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmp3yux7z8i.rs:32:25\n   |\n32 |     let mut max_index = -1;\n   |    \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // TODO: implement this function\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4tkqtnmr.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = vec![];\n    for &i in arr.iter() {\n        if i >= 0\
    \ {\n            counter[i as usize] += 1;\n        }\n    }\n    counter.sort_by_key(|&x|\
    \ x.to_string().len());\n    counter.sort_by_key(|&x| x.parse().unwrap());\n \
    \   counter.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp25_ojt12.rs:15:26\n\
    \   |\n15 |     counter.sort_by_key(|&x| x.to_string().len());\n   |         \
    \                 ^^ consider giving this closure parameter the explicit type\
    \ `&T`, with the type parameters specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        let mut i = a;\n        let mut j = b;\n  \
    \      while i >= 1 && j >= 1 && i % 2 == 0 && j % 2 == 0 {\n            i /=\
    \ 2;\n            j /= 2;\n        }\n        let mut m = if i >= j { i } else\
    \ { j };\n        if m < 0 {\n            m *= -1;\n        }\n        m\n   \
    \ });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsqfji_us.rs:12:20\n   |\n\
    12 |         while i >= 1 && j >= 1 && i % 2 == 0 && j % 2 == 0 {\n   |      \
    \              ^\n   |                    |\n   |                    expected\
    \ `&isize`, found integer\n   |                    help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsqfji_us.rs:12:30\n  \
    \ |\n12 |         while i >= 1 && j >= 1 && i % 2 == 0 && j % 2 == 0 {\n   | \
    \                             ^\n   |                              |\n   |   \
    \                           expected `&isize`, found integer\n   |           \
    \                   help: consider borrowing here: `&1`\n\nerror[E0368]: binary\
    \ assignment operation `/=` cannot be applied to type `&isize`\n  --> /tmp/tmpsqfji_us.rs:13:13\n\
    \   |\n13 |             i /= 2;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=` can be used\
    \ on `isize`, you can dereference `i`\n   |\n13 |             *i /= 2;\n   | \
    \            +\n\nerror[E0368]: binary assignment operation `/=` cannot be applied\
    \ to type `&isize`\n  --> /tmp/tmpsqfji_us.rs:14:13\n   |\n14 |             j\
    \ /= 2;\n   |             -^^^^^\n   |             |\n   |             cannot\
    \ use `/=` on type `&isize`\n   |\nhelp: `/=` can be used on `isize`, you can\
    \ dereference `j`\n   |\n14 |             *j /= 2;\n   |             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsqfji_us.rs:17:16\n   |\n17 |         if m <\
    \ 0 {\n   |                ^\n   |                |\n   |                expected\
    \ `&isize`, found integer\n   |                help: consider borrowing here:\
    \ `&0`\n\nerror[E0368]: binary assignment operation `*=` cannot be applied to\
    \ type `&isize`\n  --> /tmp/tmpsqfji_us.rs:18:13\n   |\n18 |             m *=\
    \ -1;\n   |             -^^^^^^\n   |             |\n   |             cannot use\
    \ `*=` on type `&isize`\n   |\nhelp: `*=` can be used on `isize`, you can dereference\
    \ `m`\n   |\n18 |             *m *= -1;\n   |             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsqfji_us.rs:20:9\n   |\n20 |         m\n   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut rev = arr.clone();\n    rev.sort();\n    rev.dedup();\n    rev\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpe2trpcwm.rs:17:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n    let mut res = arr.clone();\n\
    \    let mut cnt = 0;\n    for i in arr {\n        if cnt % 2 == 1 {\n       \
    \     *res = i;\n            cnt += 1;\n        }\n        cnt += 1;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdcg1xcnr.rs:16:20\n   |\n\
    16 |             *res = i;\n   |             ----   ^ expected slice `[isize]`,\
    \ found `isize`\n   |             |\n   |             expected due to the type\
    \ of this binding\n\nerror[E0277]: the size for values of type `[isize]` cannot\
    \ be known at compilation time\n  --> /tmp/tmpdcg1xcnr.rs:16:13\n   |\n16 |  \
    \           *res = i;\n   |             ^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ the left-hand-side of an assignment must have a statically known size\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return arr;\n    }\n\n    let mut is_sorted\
    \ = vec![false; arr.len()];\n\n    // 1. count number of 1's in their binary representation\n\
    \    let mut ones = vec![];\n    for &i in arr {\n        if i >> 1 == 1 {\n \
    \           ones.push(i);\n        }\n    }\n\n    // 2. sort according to number\
    \ of ones in ascending order\n    ones\n        .into_iter()\n        .enumerate()\n\
    \        .sort_by_key(|&(_, v)| v)\n        .for_each(|(idx, v)| {\n         \
    \   is_sorted[idx] = true;\n        });\n\n    // 3. sort according to decimal\
    \ value\n    let mut decimal = vec![];\n    for &i in arr {\n        decimal.push(i*10\
    \ + (ones[i >> 1] >> 1));\n    }\n\n    // 4. sort according to decimal value\n\
    \    decimal\n        .into_iter()\n        .enumerate()\n        .sort_by_key(|&(_,\
    \ v)| v)\n        .for_each(|(idx, v)| {\n            is_sorted[idx] = true;\n\
    \        });\n\n    is_sorted.iter().cloned().collect()\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf47s43xf.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `sort_by_key` found for struct `Enumerate` in the current scope\n  --> /tmp/tmpf47s43xf.rs:27:10\n\
    \   |\n27 |         .sort_by_key(|&(_, v)| v)\n   |          ^^^^^^^^^^^ method\
    \ not found in `Enumerate<std::vec::IntoIter<_>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf47s43xf.rs:34:9\n   |\n34 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Enumerate` in the current scope\n  --> /tmp/tmpf47s43xf.rs:42:10\n\
    \   |\n42 |         .sort_by_key(|&(_, v)| v)\n   |          ^^^^^^^^^^^ method\
    \ not found in `Enumerate<std::vec::IntoIter<_>>`\n\nerror[E0277]: a value of\
    \ type `Vec<isize>` cannot be built from an iterator over elements of type `bool`\n\
    \    --> /tmp/tmpf47s43xf.rs:47:31\n     |\n47   |     is_sorted.iter().cloned().collect()\n\
    \     |                               ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=bool>`\n     |\n     = help: the trait\
    \ `FromIterator<bool>` is not implemented for `Vec<isize>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // O(n log n)\n    let mut count = arr.iter().cloned().filter(|&x| x > 0).count();\n\
    \    let mut min_value = count.floor();\n    let mut max_value = count.ceil();\n\
    \    while min_value >= 1 {\n        let mut index = arr.iter().cloned().filter(|&x|\
    \ x == min_value).count();\n        if index != 0 {\n            arr[index - 1]\
    \ = max_value;\n            min_value--;\n        }\n        else {\n        \
    \    arr[index - 1] = min_value;\n            max_value++;\n        }\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp6sw1sckn.rs:17:24\n\
    \   |\n17 |             min_value--;\n   |                        ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmp6sw1sckn.rs:21:22\n\
    \   |\n21 |             max_value++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |             { let\
    \ tmp = max_value; max_value += 1; tmp };\n   |             +++++++++++      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~\n21 -             max_value++;\n21 +            \
    \ max_value += 1;\n   | \n\nerror[E0599]: no method named `floor` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmp6sw1sckn.rs:11:31\n   |\n11 |  \
    \   let mut min_value = count.floor();\n   |                               ^^^^^\
    \ help: there is an associated function with a similar name: `div_floor`\n\nerror[E0599]:\
    \ no method named `ceil` found for type `usize` in the current scope\n  --> /tmp/tmp6sw1sckn.rs:12:31\n\
    \   |\n12 |     let mut max_value = count.ceil();\n   |                      \
    \         ^^^^ help: there is an associated function with a similar name: `div_ceil`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![0; arr.len()];\n    let mut ones = vec![];\n\n    for\
    \ v in arr.iter() {\n        if v & 1 != 0 {\n            ones.push(v);\n    \
    \    }\n\n        if ones.len() == 0 {\n            result.push(v);\n        }\
    \ else {\n            let first = &ones[0];\n            let second = &ones[ones.length\
    \ - 1];\n\n            if v < first {\n                let tmp = v;\n        \
    \        v = first;\n                first = tmp;\n            }\n\n         \
    \   if v > second {\n                let tmp = v;\n                v = second;\n\
    \                second = tmp;\n            }\n\n            result.push(v);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_45kiho.rs:18:25\n   |\n\
    18 |             result.push(v);\n   |                         ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |  \
    \           result.push(*v);\n   |                         +\n\nerror[E0609]:\
    \ no field `length` on type `Vec<&isize>`\n  --> /tmp/tmpe_45kiho.rs:21:37\n \
    \  |\n21 |             let second = &ones[ones.length - 1];\n   |            \
    \                         ^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe_45kiho.rs:26:25\n   |\n20 |             let first = &ones[0];\n\
    \   |                         -------- expected due to this value\n...\n26 | \
    \                first = tmp;\n   |                         ^^^ expected `&isize`,\
    \ found `isize`\n   |\n   = note: expected reference `&&isize`\n             \
    \ found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe_45kiho.rs:35:25\n\
    \   |\n35 |             result.push(v);\n   |                         ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             result.push(*v);\n   |                         +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut cnt = 0;\n    for i in arr {\n        if i & 1 == 1 {\n         \
    \   cnt += 1;\n        }\n    }\n\n    arr.sort_by_key(|i| {\n        if i & 1\
    \ == 1 {\n            cnt\n        } else {\n            i.to_dec().unwrap()\n\
    \        }\n    });\n\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp_5le4wwa.rs:20:15\n   |\n20 |             i.to_dec().unwrap()\n\
    \   |               ^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Implement here\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvqekwb3i.rs:8:35\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() > 7 {\n        unimplemented!();\n    }\n\n    arr.sort_by_key(|x|\
    \ {\n        if x % 2 == 0 {\n            x.count_ones() as isize\n        } else\
    \ {\n            (x - 1).count_ones() as isize\n        }\n    });\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmptfzn97ym.rs:13:5\n   |\n8  |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                 --- help: consider changing this to be\
    \ mutable: `mut arr`\n...\n13 | /     arr.sort_by_key(|x| {\n14 | |         if\
    \ x % 2 == 0 {\n15 | |             x.count_ones() as isize\n16 | |         } else\
    \ {\n17 | |             (x - 1).count_ones() as isize\n18 | |         }\n19 |\
    \ |     });\n   | |______^ cannot borrow as mutable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .map(|x| {\n            let y = x.leading_ones() as i32;\n\
    \            if y > 0 {\n                y as isize\n            } else {\n  \
    \              -x\n            }\n        })\n        .sorted()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpkbyoibh9.rs:18:10\n   |\n18 |         .sorted()\n   | \
    \         ^^^^^^ method not found in `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpkbyoibh9.rs:10:14:\
    \ 17:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = Vec::new();\n    for i in 0..arr.len() {\n        let bin\
    \ = binary_to_string(&arr[i]);\n        let dec = dec_to_decimal(&bin);\n    \
    \    if dec != i {\n            result.push(dec);\n        } else {\n        \
    \    result.push(i);\n        }\n    }\n    result.sort();\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_to_string` in this scope\n \
    \ --> /tmp/tmpqh6cm3yz.rs:11:19\n   |\n11 |         let bin = binary_to_string(&arr[i]);\n\
    \   |                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `dec_to_decimal` in this scope\n  --> /tmp/tmpqh6cm3yz.rs:12:19\n\
    \   |\n12 |         let dec = dec_to_decimal(&bin);\n   |                   ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqh6cm3yz.rs:20:5\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n20 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort_by_key(|e| {\n        if e == 1 {\n            Some(e\
    \ as isize)\n        } else {\n            Some((e as usize).leading_zeros() *\
    \ 10 + e as usize)\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n --> /tmp/tmps88ul_qo.rs:9:25\n  |\n9 |     arr.iter().cloned().sort_by_key(|e|\
    \ {\n  |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps88ul_qo.rs:13:54\n\
    \   |\n13 |             Some((e as usize).leading_zeros() * 10 + e as usize)\n\
    \   |                                                      ^^^^^^^^^^ expected\
    \ `u32`, found `usize`\n\nerror[E0277]: cannot add `usize` to `u32`\n  --> /tmp/tmps88ul_qo.rs:13:18\n\
    \   |\n13 |             Some((e as usize).leading_zeros() * 10 + e as usize)\n\
    \   |             ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation\
    \ for `u32 + usize`\n   |             |\n   |             required by a bound\
    \ introduced by this call\n   |\n   = help: the trait `Add<usize>` is not implemented\
    \ for `u32`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmps88ul_qo.rs:13:13\n\
    \   |\n10 | /         if e == 1 {\n11 | |             Some(e as isize)\n   | |\
    \             ---------------- expected because of this\n12 | |         } else\
    \ {\n13 | |             Some((e as usize).leading_zeros() * 10 + e as usize)\n\
    \   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `u32`\n14 | |         }\n   | |_________- `if` and `else` have\
    \ incompatible types\n   |\n   = note: expected enum `Option<isize>`\n       \
    \       found enum `Option<u32>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_bin = arr.iter().min_by(|a, b| {\n        a.iter().zip(b.iter()).take_while(|(a,\
    \ b)| {\n            a == 0 && b == 0 || !a.is_zero() || !b.is_zero()\n      \
    \  }).count() > 1\n    })?;\n    if min_bin.is_some() {\n        let mut max_bin\
    \ = arr.iter().max_by(|a, b| {\n            a.iter().zip(b.iter()).take_while(|(a,\
    \ b)| {\n                a == 0 && b == 0 || !a.is_zero() || !b.is_zero()\n  \
    \          }).count() > 1\n        })?;\n        while max_bin.next() == min_bin.next()\
    \ {\n            min_bin = min_bin.unwrap().cloned().rev();\n            max_bin\
    \ = max_bin.unwrap().cloned().rev();\n        }\n    }\n    arr.iter().filter(|e|\
    \ min_bin.contains(e)).clone()\n        .sort_unstable_by_key(|e| {\n        \
    \    min_bin.iter().cloned().rev().binary_search(&e).unwrap_or(-1) as isize\n\
    \        })\n        .cloned()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&&isize` in the\
    \ current scope\n  --> /tmp/tmpzs_y8d5f.rs:10:11\n   |\n10 |         a.iter().zip(b.iter()).take_while(|(a,\
    \ b)| {\n   |           ^^^^ method not found in `&&isize`\n\nerror[E0599]: no\
    \ method named `iter` found for reference `&&isize` in the current scope\n  -->\
    \ /tmp/tmpzs_y8d5f.rs:10:24\n   |\n10 |         a.iter().zip(b.iter()).take_while(|(a,\
    \ b)| {\n   |                        ^^^^ method not found in `&&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzs_y8d5f.rs:10:9\n   |\n10 | /         a.iter().zip(b.iter()).take_while(|(a,\
    \ b)| {\n11 | |             a == 0 && b == 0 || !a.is_zero() || !b.is_zero()\n\
    12 | |         }).count() > 1\n   | |______________________^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpzs_y8d5f.rs:13:7\n   |\n8  | / fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n9  | |     let mut min_bin = arr.iter().min_by(|a, b| {\n10 |\
    \ |         a.iter().zip(b.iter()).take_while(|(a, b)| {\n11 | |             a\
    \ == 0 && b == 0 || !a.is_zero() || !b.is_zero()\n12 | |         }).count() >\
    \ 1\n13 | |     })?;\n   | |       ^ cannot use the `?` operator in a function\
    \ that returns `Vec<isize>`\n...  |\n29 | |         .cloned()\n30 | | }\n   |\
    \ |_- this function should return `Result` or `Option` to accept `?`\n   |\n \
    \  = help: the trait `FromResidual<Option<Infallible>>` is not implemented for\
    \ `Vec<isize>`\n\nerror[E0599]: no method named `is_some` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpzs_y8d5f.rs:14:16\n   |\n14 | \
    \    if min_bin.is_some() {\n   |                ^^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `iter` found for reference `&&isize` in the current\
    \ scope\n  --> /tmp/tmpzs_y8d5f.rs:16:15\n   |\n16 |             a.iter().zip(b.iter()).take_while(|(a,\
    \ b)| {\n   |               ^^^^ method not found in `&&isize`\n\nerror[E0599]:\
    \ no method named `iter` found f"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(arr.len(), arr.iter().filter(|x| x == 1).count());\n    let mut\
    \ result = vec![];\n    for i in arr.iter().filter(|x| x == 1).cloned() {\n  \
    \      let mut index = 0;\n        while index < i {\n            index += 1;\n\
    \        }\n        result.push(i);\n    }\n    result.sort_unstable_by(|a, b|\
    \ a.cmp(b));\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&&isize` with `{integer}`\n --> /tmp/tmpcuymm21x.rs:9:51\n\
    \  |\n9 |     assert_eq!(arr.len(), arr.iter().filter(|x| x == 1).count());\n\
    \  |                                                   ^^ no implementation for\
    \ `&&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&&isize`\n  = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n    \
    \        i16\n            i32\n            i64\n            i8\n            isize\n\
    \          and 6 others\n\nerror[E0277]: can't compare `&&isize` with `{integer}`\n\
    \  --> /tmp/tmpcuymm21x.rs:11:38\n   |\n11 |     for i in arr.iter().filter(|x|\
    \ x == 1).cloned() {\n   |                                      ^^ no implementation\
    \ for `&&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        let mut bin1 = a.to_string().chars().filter(|c|\
    \ !c.is_digit()).collect::<Vec<_>>();\n        let mut bin2 = b.to_string().chars().filter(|c|\
    \ !c.is_digit()).collect::<Vec<_>>();\n        bin1.sort_by(|x, y| x.cmp(y));\n\
    \        bin2.sort_by(|x, y| x.cmp(y));\n        let len = bin1.len();\n     \
    \   if len == bin2.len() {\n            for (l, r) in bin1.zip(bin2) {\n     \
    \           if l == r {\n                    continue;\n                }\n  \
    \              if l == 0 && r == 1 {\n                    return bin1.len() -\
    \ bin2.len();\n                } else if l == 1 && r == 0 {\n                \
    \    return bin1.len() - bin2.len();\n                }\n            }\n     \
    \       return bin1.len() - bin2.len();\n        } else {\n            return\
    \ bin1.len() - bin2.len();\n        }\n    });\n    arr\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpr3kfwtq9.rs:10:60\n    |\n10  |         let mut bin1 = a.to_string().chars().filter(|c|\
    \ !c.is_digit()).collect::<Vec<_>>();\n    |                                 \
    \                           ^^^^^^^^- supplied 0 arguments\n    |            \
    \                                                |\n    |                    \
    \                                        expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmpr3kfwtq9.rs:11:60\n    |\n11  |    \
    \     let mut bin2 = b.to_string().chars().filter(|c| !c.is_digit()).collect::<Vec<_>>();\n\
    \    |                                                            ^^^^^^^^- supplied\
    \ 0 arguments\n    |                                                         \
    \   |\n    |                                                            expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: `Vec<char>`\
    \ is not an iterator\n   --> /tmp/tmpr3kfwtq9.rs:16:32\n    |\n16  |         \
    \      for (l, r) in bin1.zip(bin2) {\n    |                                 \
    \ ^^^ `Vec<char>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<char>: Iterator`\n            which is\
    \ required by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n   \
    \         which is required by `&mut [char]: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr3kfwtq9.rs:21:28\n   |\n21 |                     return\
    \ bin1.len() - bin2.len();\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `usize`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // write your sorting algorithm here\n    // ...\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmptc8adchi.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for i in 0..arr.len() {\n        let len_bit = arr.len() - i;\n        let\
    \ ones = 0..len_bit\n            .filter(|&bit| bit == 1)\n            .count();\n\
    \        let mut decimal = i64::from(ones);\n        for bit in 0..len_bit {\n\
    \            let mut power = 0..i32::max_value();\n            power = power.checked_mul(power);\n\
    \            power = power.checked_mul(power);\n            power = power.checked_mul(power);\n\
    \            if bit == 0 {\n                decimal = decimal.checked_add(power.clone());\n\
    \            } else {\n                decimal = decimal.checked_mul(power.clone());\n\
    \            }\n        }\n        if decimal > i32::max_value() {\n         \
    \   return vec![];\n        }\n        arr.swap(i, arr.len() - i - 1);\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `usize` is not an iterator\n  --> /tmp/tmpgadlcey0.rs:12:14\n\
    \   |\n12 |             .filter(|&bit| bit == 1)\n   |              ^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `usize: Iterator`\n           which is required by `&mut usize: Iterator`\n\
    \nerror[E0277]: the trait bound `i64: From<std::ops::Range<{integer}>>` is not\
    \ satisfied\n  --> /tmp/tmpgadlcey0.rs:14:27\n   |\n14 |         let mut decimal\
    \ = i64::from(ones);\n   |                           ^^^^^^^^^ the trait `From<std::ops::Range<{integer}>>`\
    \ is not implemented for `i64`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <f32 as From<i16>>\n             <f32 as From<i8>>\n\
    \             <f32 as From<u16>>\n             <f32 as From<u8>>\n           \
    \  <f64 as From<f32>>\n             <f64 as From<i16>>\n             <f64 as From<i32>>\n\
    \             <f64 as From<i8>>\n           and 67 others\n\nerror[E0599]: no\
    \ method named `checked_mul` found for struct `std::ops::Range` in the current\
    \ scope\n  --> /tmp/tmpgadlcey0.rs:17:27\n   |\n17 |             power = power.checked_mul(power);\n\
    \   |                           ^^^^^^^^^^^ method not found in `std::ops::Range<i32>`\n\
    \nerror[E0599]: no method named `checked_mul` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpgadlcey0.rs:18:27\n   |\n18 |          \
    \   power = power.checked_mul(power);\n   |                           ^^^^^^^^^^^\
    \ method not found in `std::ops::Range<i32>`\n\nerror[E0599]: no method named\
    \ `checked_mul` found for struct `std::ops::Range` in the current scope\n  -->\
    \ /tmp/tmpgadlcey0.rs:19:27\n   |\n19 |             power = power.checked_mul(power);\n\
    \   |                           ^^^^^^^^^^^ method not found in `std::ops::Range<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgadlcey0.rs:21:47\n   |\n21 |\
    \                 decimal = decimal.checked_add(power.clone());\n   |        \
    \                                       ^^^^^^^^^^^^^ expected `i64`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expec"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr\n        .iter()\n        .cloned()\n        .enumerate()\n\
    \        .map(|(idx, val)| {\n            let ones: usize = 0;\n            for\
    \ i in val {\n                if i == 1 {\n                    ones += 1;\n  \
    \              }\n            }\n            ones\n        })\n        .collect::<Vec<_>>();\n\
    \    sorted_arr.sort_by_key(|val| val.expect(\"all elements are 0 or 1\").to_string());\n\
    \    sorted_arr.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpl8gxc70n.rs:15:22\n\
    \   |\n15 |             for i in val {\n   |                      ^^^ `isize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror[E0599]: no method named `expect` found for\
    \ reference `&usize` in the current scope\n  --> /tmp/tmpl8gxc70n.rs:23:38\n \
    \  |\n23 |     sorted_arr.sort_by_key(|val| val.expect(\"all elements are 0 or\
    \ 1\").to_string());\n   |                                      ^^^^^^ method\
    \ not found in `&usize`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be\
    \ built from an iterator over elements of type `usize`\n    --> /tmp/tmpl8gxc70n.rs:24:32\n\
    \     |\n24   |     sorted_arr.iter().cloned().collect()\n     |             \
    \                   ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut bin: Vec<isize>\
    \ = vec![0; arr.len() * 2 + 1];\n    let mut cnt: usize = 0;\n\n    for x in arr\
    \ {\n        let mut bits = x.to_bin();\n        bin[cnt as usize] = bits[0];\n\
    \        bin[cnt + 1 as usize] = bits[1];\n        cnt += 2;\n    }\n\n    let\
    \ mut res: Vec<isize> = vec![];\n    let mut count = 1;\n    let mut start = 0;\n\
    \    let mut end = 0;\n\n    while count < bin.len() {\n        if bin[count]\
    \ == 1 {\n            end = start;\n        } else {\n            res.insert(res.len()\
    \ - count, arr[start as usize]);\n            start += 1;\n            count =\
    \ 1;\n        }\n        count += 1;\n    }\n\n    if start < bin.len() {\n  \
    \      res.insert(res.len() - count, arr[start as usize]);\n    }\n\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bin` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp8lblc26_.rs:17:26\n   |\n17 |         let mut bits = x.to_bin();\n\
    \   |                          ^^^^^^ help: there is an associated function with\
    \ a similar name: `to_be`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n    let mut max_ones = 0.;\n\
    \    let mut min_ones = arr.len();\n    let mut curr_ones = 0.;\n\n    let mut\
    \ min = 0;\n    while min < min_ones {\n        curr_ones += arr[min];\n     \
    \   min = match min {\n            -1 => match arr.len() {\n                min\
    \ => min,\n                _ => -1,\n            },\n            i => 0,\n   \
    \     };\n    }\n    let mut max = arr.len();\n    while max >= min_ones {\n \
    \       curr_ones += arr[max];\n        max = match max {\n            i => arr.len()\
    \ - 1,\n            -1 => match arr.len() {\n                max => max,\n   \
    \             _ => -1,\n            },\n        };\n    }\n    curr_ones /= 2.;\n\
    \n    let mut ret = Vec::with_capacity(arr.len());\n    for e in arr.iter().rev()\
    \ {\n        if e == 0 {\n            let mut i = max_ones - curr_ones;\n    \
    \        if i < 0 {\n                i += 2;\n            }\n            ret.push(i);\n\
    \            curr_ones += 1;\n            max_ones -= 1;\n        } else {\n \
    \           ret.push(e);\n        }\n    }\n    ret.sort();\n    ret.reverse();\n\
    \    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `isize` to `{float}`\n  --> /tmp/tmp40eh9vlg.rs:18:19\n\
    \   |\n18 |         curr_ones += arr[min];\n   |                   ^^ no implementation\
    \ for `{float} += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \            <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n     \
    \      and 20 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp40eh9vlg.rs:20:13\n   |\n20 |             -1 => match arr.len()\
    \ {\n   |             ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp40eh9vlg.rs:22:22\n\
    \   |\n22 |                 _ => -1,\n   |                      ^^\n   |     \
    \                 |\n   |                      cannot apply unary operator `-`\n\
    \   |                      help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `{float}`\n  --> /tmp/tmp40eh9vlg.rs:29:19\n  \
    \ |\n29 |         curr_ones += arr[max];\n   |                   ^^ no implementation\
    \ for `{float} += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ones = vec![];\n\n    for num in arr {\n        if num & 1 == 1 {\n\
    \            ones.push(*num as isize);\n        }\n    }\n\n    if ones.len()\
    \ > 0 {\n        ones.sort();\n        for num in arr {\n            if num &\
    \ 1 == 1 {\n                arr.remove(num);\n            }\n        }\n     \
    \   for num in ones {\n            arr.push(num as isize);\n        }\n    }\n\
    \n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpp_ur8vfa.rs:13:23\n\
    \   |\n13 |             ones.push(*num as isize);\n   |                      \
    \ ^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp_ur8vfa.rs:21:28\n  \
    \ |\n21 |                 arr.remove(num);\n   |                            ^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n21 |           \
    \      arr.remove(num.try_into().unwrap());\n   |                            \
    \   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for ele in arr {\n        if ele == 0 {\n \
    \           result.push(i);\n        }\n    }\n    if result.is_empty() {\n  \
    \      result.append(arr.len());\n    }\n    result.sort_unstable();\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmprmsqgixb.rs:12:25\n\
    \   |\n12 |             result.push(i);\n   |                         ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprmsqgixb.rs:16:23\n\
    \   |\n16 |         result.append(arr.len());\n   |                       ^^^^^^^^^\
    \ expected `&mut Vec<_>`, found `usize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                           found type `usize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(arr.len(), arr.iter().map(|x| x.checked_pow2()).collect::<Vec<_>>().len());\n\
    \n    arr.iter().map(|x| x.checked_pow2()).sort_by(|x, y| x.cmp(&y)).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_pow2` found for reference `&isize`\
    \ in the current scope\n --> /tmp/tmprqz6pmto.rs:9:48\n  |\n9 |     assert_eq!(arr.len(),\
    \ arr.iter().map(|x| x.checked_pow2()).collect::<Vec<_>>().len());\n  |      \
    \                                          ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `checked_pow`\n\nerror[E0599]: no method named\
    \ `checked_pow2` found for reference `&isize` in the current scope\n  --> /tmp/tmprqz6pmto.rs:11:26\n\
    \   |\n11 |     arr.iter().map(|x| x.checked_pow2()).sort_by(|x, y| x.cmp(&y)).collect()\n\
    \   |                          ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `checked_pow`\n\nerror[E0599]: no method named `sort_by`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmprqz6pmto.rs:11:42\n\
    \   |\n11 |     arr.iter().map(|x| x.checked_pow2()).sort_by(|x, y| x.cmp(&y)).collect()\n\
    \   |                                          ^^^^^^^ method not found in `Map<std::slice::Iter<'_,\
    \ isize>, _>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| x.count_ones() as isize)\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpnv432gx3.rs:9:5\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |                        \
    \           ---------- expected `Vec<isize>` because of return type\n9 |     arr.sort_by_key(|x|\
    \ x.count_ones() as isize)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |\n  = note: expected struct `Vec<isize>`\n\
    \          found unit type `()`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n    let mut v = arr.clone();\n\
    \    let mut counts = vec![0; v.len()];\n    for (i, isize) in v.iter().enumerate()\
    \ {\n        // Use binary representation to determine how many 1s are in i-th\
    \ element.\n        let mut bits = isize as usize;\n        while bits != 0 {\n\
    \            counts[i] += bits & 1;\n            bits >>= 1;\n        }\n    }\n\
    \    let mut min = 0;\n    let mut max = arr.len();\n    let mut current = vec![0;\
    \ v.len()];\n\n    while min < max {\n        // Choose the smallest element among\
    \ those with minimum number of ones\n        // and the current number of ones.\n\
    \        let (i, isize) = &mut v.iter()\n            .enumerate()\n          \
    \  .filter(|(_, isize)| counts[i] < counts[min])\n            .next();\n\n   \
    \     current[i] = counts[i];\n\n        // Update min and max.\n        if counts[min]\
    \ == 1 {\n            min = i;\n        }\n        if counts[max] == 1 {\n   \
    \         max = i;\n        }\n    }\n\n    // Sort elements with the smallest\
    \ number of ones.\n    if min != 0 {\n        std::mem::swap(&mut current[min],\
    \ &mut current[0]);\n    }\n\n    // Sort elements with the largest number of\
    \ ones.\n    if max != v.len() {\n        std::mem::swap(&mut current[max], &mut\
    \ current[v.len()]);\n    }\n\n    current\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmphhx2kcpk.rs:31:41\n\
    \   |\n31 |             .filter(|(_, isize)| counts[i] < counts[min])\n   |  \
    \                                       ^ help: a local variable with a similar\
    \ name exists: `v`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphhx2kcpk.rs:29:13\n\
    \   |\n29 |           let (i, isize) = &mut v.iter()\n   |  _____________^^^^^^^^^^___-\n\
    \   | |             |\n   | |             expected enum `Option`, found tuple\n\
    30 | |             .enumerate()\n31 | |             .filter(|(_, isize)| counts[i]\
    \ < counts[min])\n32 | |             .next();\n   | |___________________- this\
    \ expression has type `&mut Option<(usize, &isize)>`\n   |\n   = note: expected\
    \ enum `Option<(usize, &isize)>`\n             found tuple `(_, _)`\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmphhx2kcpk.rs:16:24\n  \
    \ |\n16 |         let mut bits = isize as usize;\n   |                       \
    \ -----^^^^^^^^^\n   |                        |\n   |                        cannot\
    \ cast `&isize` as `usize`\n   |                        help: dereference the\
    \ expression: `*isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    debug_assert!(arr.len() <= ARRAY_SIZE);\n\n    let mut result = vec![];\n\
    \n    // Using bubble sort algorithm\n    for i in 0..(arr.len() - 1) {\n    \
    \    for j in (i + 1)..arr.len() {\n            let is_equal = arr[j] == (arr[i]\
    \ + i);\n\n            if is_equal {\n                result.push(arr[j]);\n \
    \               arr[j] = arr[j] + i;\n                arr[i] = arr[j] - i;\n \
    \           }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ARRAY_SIZE` in this scope\n --> /tmp/tmpmjzhu96o.rs:9:32\n\
    \  |\n9 |     debug_assert!(arr.len() <= ARRAY_SIZE);\n  |                   \
    \             ^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmjzhu96o.rs:16:48\n   |\n16 |             let is_equal = arr[j]\
    \ == (arr[i] + i);\n   |                                                ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot add `usize` to `isize`\n  -->\
    \ /tmp/tmpmjzhu96o.rs:16:46\n   |\n16 |             let is_equal = arr[j] == (arr[i]\
    \ + i);\n   |                                              ^ no implementation\
    \ for `isize + usize`\n   |\n   = help: the trait `Add<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmjzhu96o.rs:20:35\n\
    \   |\n20 |                 arr[j] = arr[j] + i;\n   |                       \
    \            ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot add `usize`\
    \ to `isize`\n  --> /tmp/tmpmjzhu96o.rs:20:33\n   |\n20 |                 arr[j]\
    \ = arr[j] + i;\n   |                                 ^ no implementation for\
    \ `isize + usize`\n   |\n   = help: the trait `Add<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmjzhu96o.rs:21:35\n\
    \   |\n21 |                 arr[i] = arr[j] - i;\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|&i| {\n        let mut bin = String::new();\n        bin.push_str(&i.to_string());\n\
    \        bin.push_str(\"1\");\n        bin.push_str(\"0\");\n        bin\n   \
    \         .parse()\n            .expect(\"failed to parse binary representation\
    \ of number\");\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpot9fw8gb.rs:9:5\n   |\n8\
    \  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    9  | /     arr.sort_by_key(|&i| {\n10 | |         let mut bin = String::new();\n\
    11 | |         bin.push_str(&i.to_string());\n12 | |         bin.push_str(\"1\"\
    );\n...  |\n16 | |             .expect(\"failed to parse binary representation\
    \ of number\");\n17 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut result:\
    \ Vec<isize> = Vec::new();\n\n    let mut counter = BinaryCounter::new(0);\n \
    \   for elem in arr.iter() {\n        *counter.count() += 1;\n        result.push(*counter.count());\n\
    \    }\n\n    result.sort_by_key(|i| {\n        if *i >= 0 {\n            *i /\
    \ 2\n        } else {\n            *i / -2\n        }\n    });\n\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinaryCounter`\n\
    \  --> /tmp/tmpm81vkt63.rs:15:23\n   |\n15 |     let mut counter = BinaryCounter::new(0);\n\
    \   |                       ^^^^^^^^^^^^^ use of undeclared type `BinaryCounter`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|&x| x.checked_log2_u32().ok()\n        .map(|n| n as u32)\n\
    \        .unwrap_or(0))\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_log2_u32` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpb23m8nkr.rs:9:28\n  |\n9 |     arr.sort_by_key(|&x|\
    \ x.checked_log2_u32().ok()\n  |                            ^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `checked_log`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb23m8nkr.rs:9:5\n   |\n8  |   fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                     ----------\
    \ expected `Vec<isize>` because of return type\n9  | /     arr.sort_by_key(|&x|\
    \ x.checked_log2_u32().ok()\n10 | |         .map(|n| n as u32)\n11 | |       \
    \  .unwrap_or(0))\n   | |______________________^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| binary_to_string(x).count()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_to_string` in this scope\n -->\
    \ /tmp/tmp3f0ixalw.rs:9:25\n  |\n9 |     arr.sort_by_key(|x| binary_to_string(x).count()).cloned()\n\
    \  |                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `()` is not an iterator\n --> /tmp/tmp3f0ixalw.rs:9:54\n  |\n9 |     arr.sort_by_key(|x|\
    \ binary_to_string(x).count()).cloned()\n  |                                 \
    \                     ^^^^^^ `()` is not an iterator\n  |\n  = note: the following\
    \ trait bounds were not satisfied:\n          `(): Iterator`\n          which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    for val in arr {\n        let bits = val as usize;\n\
    \        res.push((bits >> 1) + (bits & 1));\n    }\n    std::sort_unsorted_by(res.clone(),\
    \ |a, b| a <=> b);\n    return res;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: invalid comparison operator `<=>`\n  --> /tmp/tmpaxu1a8t_.rs:14:49\n\
    \   |\n14 |     std::sort_unsorted_by(res.clone(), |a, b| a <=> b);\n   |    \
    \                                             ^^^ `<=>` is not a valid comparison\
    \ operator, use `std::cmp::Ordering`\n\nerror[E0425]: cannot find function `sort_unsorted_by`\
    \ in crate `std`\n  --> /tmp/tmpaxu1a8t_.rs:14:10\n   |\n14 |     std::sort_unsorted_by(res.clone(),\
    \ |a, b| a <=> b);\n   |          ^^^^^^^^^^^^^^^^ not found in `std`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaxu1a8t_.rs:15:12\n   |\n8  | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                   ----------\
    \ expected `Vec<isize>` because of return type\n...\n15 |     return res;\n  \
    \ |            ^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        arr\n    } else {\n        let mut sorted_arr\
    \ = arr.clone();\n        if arr.iter().any(|&x| x == 1) {\n            sorted_arr.sort_by_key(|x|\
    \ {\n                if x == 1 {\n                    x.to_bigint().unwrap().bits()\n\
    \                } else {\n                    x.to_bigint().unwrap().leading_zeros()\
    \ as isize\n                }\n            });\n        }\n        sorted_arr\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpk4_x1fdw.rs:15:22\n\
    \   |\n15 |                 if x == 1 {\n   |                      ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `to_bigint`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpk4_x1fdw.rs:16:23\n\
    \   |\n16 |                     x.to_bigint().unwrap().bits()\n   |          \
    \             ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_be`\n\nerror[E0599]: no method named `to_bigint` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpk4_x1fdw.rs:18:23\n   |\n18 |          \
    \           x.to_bigint().unwrap().leading_zeros() as isize\n   |            \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_be`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sort_arr = arr.clone();\n    sort_arr.sort_unstable_by(|x, y| {\n\
    \        compare_ones_first(x, y) || compare_decimal_first(x, y)\n    });\n  \
    \  sort_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `compare_ones_first` in this scope\n\
    \  --> /tmp/tmpa48ezezu.rs:11:9\n   |\n11 |         compare_ones_first(x, y) ||\
    \ compare_decimal_first(x, y)\n   |         ^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `compare_decimal_first` in this\
    \ scope\n  --> /tmp/tmpa48ezezu.rs:11:37\n   |\n11 |         compare_ones_first(x,\
    \ y) || compare_decimal_first(x, y)\n   |                                    \
    \ ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa48ezezu.rs:11:9\n   |\n11 |         compare_ones_first(x, y) ||\
    \ compare_decimal_first(x, y)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    arr.iter().cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpkend2pli.rs:9:5\n  |\n8 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n  |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n9 |     arr.sort();\n  |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().sort_by(|&x| count_ones_binary(&x)).cloned()\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_ones_binary` in this scope\n\
    \ --> /tmp/tmpvi8ie87i.rs:9:29\n  |\n9 |     arr.iter().sort_by(|&x| count_ones_binary(&x)).cloned()\n\
    \  |                             ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `sort_by` found for struct `std::slice::Iter` in\
    \ the current scope\n --> /tmp/tmpvi8ie87i.rs:9:16\n  |\n9 |     arr.iter().sort_by(|&x|\
    \ count_ones_binary(&x)).cloned()\n  |                ^^^^^^^ method not found\
    \ in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        match a % 2 {\n            0 => a.checked_mul(2).ok(),\n\
    \            _ => b.checked_mul(2).ok(),\n        }\n            .and_then(|r|\
    \ r.ok())\n            .ok()\n            .count() as isize\n            .cmp(&b)\n\
    \            .unwrap()\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpbiacfqj9.rs:10:9\n\
    \   |\n10 | /         match a % 2 {\n11 | |             0 => a.checked_mul(2).ok(),\n\
    12 | |             _ => b.checked_mul(2).ok(),\n13 | |         }\n14 | |     \
    \        .and_then(|r| r.ok())\n15 | |             .ok()\n16 | |             .count()\
    \ as isize\n   | |_____________________________^\n   |\nhelp: try surrounding\
    \ the expression in parentheses\n   |\n10 ~         (match a % 2 {\n11 |     \
    \        0 => a.checked_mul(2).ok(),\n12 |             _ => b.checked_mul(2).ok(),\n\
    13 |         }\n14 |             .and_then(|r| r.ok())\n15 |             .ok()\n\
    \ ...\n\nerror[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpbiacfqj9.rs:11:35\n   |\n11 |             0 => a.checked_mul(2).ok(),\n\
    \   |                                   ^^ help: there is an associated function\
    \ with a similar name: `or`\n\nerror[E0599]: no method named `ok` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpbiacfqj9.rs:12:35\n   |\n12 | \
    \            _ => b.checked_mul(2).ok(),\n   |                               \
    \    ^^ help: there is an associated function with a similar name: `or`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbiacfqj9.rs:9:5\n   |\n8  |   fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                     ----------\
    \ expected `Vec<isize>` because of return type\n9  | /     arr.sort_by(|a, b|\
    \ {\n10 | |         match a % 2 {\n11 | |             0 => a.checked_mul(2).ok(),\n\
    12 | |             _ => b.checked_mul(2).ok(),\n...  |\n18 | |             .unwrap()\n\
    19 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .sorted()\n        .map(|(i, _)|\
    \ {\n            let ones = *i as isize % 10;\n            if ones == 0 {\n  \
    \              (*i)\n            } else {\n                (*i).checked_mul(10).ok_or(\"\
    Integers cannot be negative\")\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around block return value\n  --> /tmp/tmp8ria3nh8.rs:15:17\n\
    \   |\n15 |                 (*i)\n   |                 ^  ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    15 -                 (*i)\n15 +                 *i\n   | \n\nerror[E0599]: no\
    \ method named `sorted` found for struct `Enumerate` in the current scope\n  -->\
    \ /tmp/tmp8ria3nh8.rs:11:10\n   |\n11 |         .sorted()\n   |          ^^^^^^\
    \ method not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    debug_assert_eq!(arr.len(), arr.rev().iter().filter(|&x| x == 0).count());\n\
    \    let mut num_ones = 0;\n    let mut max_value = 0;\n    for &num in arr.iter()\
    \ {\n        let mut val: isize = 0;\n        while num > 0 {\n            if\
    \ num >= 10 {\n                val += num % 10;\n                num = (num /\
    \ 10) - 1;\n            } else {\n                val += num % 2;\n          \
    \      num /= 2;\n            }\n        }\n        if val > max_value {\n   \
    \         max_value = val;\n            num_ones = 1;\n        } else {\n    \
    \        num_ones += val;\n        }\n    }\n    if num_ones < 0 {\n        arr.iter().enumerate().sort_by(|&(i,\
    \ &x)| x.cmp(&-num_ones).desc()).collect();\n    } else {\n        arr.iter().enumerate().sort_by(|&(i,\
    \ &x)| x.cmp(&num_ones).asc_cmp(&-max_value)).collect();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpq4v9rhy1.rs:9:37\n\
    \    |\n9   |       debug_assert_eq!(arr.len(), arr.rev().iter().filter(|&x| x\
    \ == 0).count());\n    |                                       ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: no method named `sort_by` found for\
    \ struct `Enumerate` in the current scope\n  --> /tmp/tmpq4v9rhy1.rs:31:32\n \
    \  |\n31 |         arr.iter().enumerate().sort_by(|&(i, &x)| x.cmp(&-num_ones).desc()).collect();\n\
    \   |                                ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4v9rhy1.rs:30:21\n\
    \   |\n30 |       if num_ones < 0 {\n   |  _____________________^\n31 | |    \
    \     arr.iter().enumerate().sort_by(|&(i, &x)| x.cmp(&-num_ones).desc()).collect();\n\
    32 | |     } else {\n   | |_____^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Enumerate` in the current scope\n\
    \  --> /tmp/tmpq4v9rhy1.rs:33:32\n   |\n33 |         arr.iter().enumerate().sort_by(|&(i,\
    \ &x)| x.cmp(&num_ones).asc_cmp(&-max_value)).collect();\n   |               \
    \                 ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4v9rhy1.rs:32:12\n\
    \   |\n32 |       } else {\n   |  ____________^\n33 | |         arr.iter().enumerate().sort_by(|&(i,\
    \ &x)| x.cmp(&num_ones).asc_cmp(&-max_value)).collect();\n34 | |     }\n   | |_____^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Write your sorting algorithm here.\n    // Do not change this\n    let\
    \ mut count = HashMap::new();\n\n    for value in arr.iter() {\n        let mut\
    \ binary = value.to_binary() as u16;\n        let mut len = binary.len();\n  \
    \      while len > 0 {\n            let byte = len % 8;\n            len -= byte;\n\
    \            binary = binary[..byte].to_string() + &binary[byte..];\n        \
    \    count.entry(binary[..]).or_insert(0usize);\n        }\n    }\n\n    let mut\
    \ sorted_array: Vec<isize> = vec![];\n    for value in count.iter() {\n      \
    \  let mut decimal = value.to_dec() as usize;\n        let mut index = sorted_array.len();\n\
    \        while decimal > 0 {\n            let digit = decimal % 10;\n        \
    \    decimal /= 10;\n            sorted_array.insert(index, digit);\n        \
    \    index += 1;\n        }\n    }\n\n    sorted_array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpy4ghqt2i.rs:11:21\n   |\n11 |     let mut count = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `to_binary` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpy4ghqt2i.rs:14:32\n   |\n14 |         let mut binary = value.to_binary()\
    \ as u16;\n   |                                ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Implement here\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpvi2p9h8u.rs:15:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| binary_ones_count(x))\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `binary_ones_count` in this scope\n\
    \ --> /tmp/tmppss99olc.rs:9:25\n  |\n9 |     arr.sort_by_key(|x| binary_ones_count(x))\n\
    \  |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppss99olc.rs:9:5\n  |\n8 | fn sort_array(arr:\
    \ Vec<isize>) -> Vec<isize> {\n  |                                   ----------\
    \ expected `Vec<isize>` because of return type\n9 |     arr.sort_by_key(|x| binary_ones_count(x))\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type\
    \ `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| a.to_bits() < b.to_bits()).collect()\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_bits` found for reference `&isize` in\
    \ the current scope\n --> /tmp/tmp76c2ii2l.rs:9:26\n  |\n9 |     arr.sort_by(|a,\
    \ b| a.to_bits() < b.to_bits()).collect()\n  |                          ^^^^^^^\
    \ help: there is an associated function with a similar name: `to_be`\n\nerror[E0599]:\
    \ no method named `to_bits` found for reference `&isize` in the current scope\n\
    \ --> /tmp/tmp76c2ii2l.rs:9:40\n  |\n9 |     arr.sort_by(|a, b| a.to_bits() <\
    \ b.to_bits()).collect()\n  |                                        ^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_be`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp76c2ii2l.rs:9:24\n  |\n9 |     arr.sort_by(|a,\
    \ b| a.to_bits() < b.to_bits()).collect()\n  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0599]: `()` is not\
    \ an iterator\n --> /tmp/tmp76c2ii2l.rs:9:51\n  |\n9 |     arr.sort_by(|a, b|\
    \ a.to_bits() < b.to_bits()).collect()\n  |                                  \
    \                 ^^^^^^^ `()` is not an iterator\n  |\n  = note: the following\
    \ trait bounds were not satisfied:\n          `(): Iterator`\n          which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        // Count number of 1s in binary representation\
    \ of a\n        let mut count = 0;\n        let mut v = a;\n        while v >\
    \ 0 {\n            if v % 2 == 1 {\n                count += 1;\n            }\n\
    \            v /= 2;\n        }\n        // Sort based on count\n        count\
    \ cmp b\n    });\n    // Convert to decimal representation\n    for i in arr.iter_mut()\
    \ {\n        *i =\n            i as isize * std::pow(2, std::usize::max_value()\
    \ - std::cmp::min(i, 0));\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `cmp`\n  --> /tmp/tmp1hovr4s9.rs:20:15\n   |\n20 |         count cmp b\n\
    \   |               ^^^ expected one of 8 possible tokens\n\nerror[E0425]: cannot\
    \ find function `pow` in crate `std`\n  --> /tmp/tmp1hovr4s9.rs:25:31\n   |\n\
    25 |             i as isize * std::pow(2, std::usize::max_value() - std::cmp::min(i,\
    \ 0));\n   |                               ^^^ not found in `std`\n\nerror[E0425]:\
    \ cannot find function `max_value` in module `std::usize`\n  --> /tmp/tmp1hovr4s9.rs:25:50\n\
    \   |\n25 |             i as isize * std::pow(2, std::usize::max_value() - std::cmp::min(i,\
    \ 0));\n   |                                                  ^^^^^^^^^ not found\
    \ in `std::usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hovr4s9.rs:13:19\n\
    \   |\n13 |         while v > 0 {\n   |                   ^\n   |            \
    \       |\n   |                   expected `&isize`, found integer\n   |     \
    \              help: consider borrowing here: `&0`\n\nerror[E0368]: binary assignment\
    \ operation `/=` cannot be applied to type `&isize`\n  --> /tmp/tmp1hovr4s9.rs:17:13\n\
    \   |\n17 |             v /= 2;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=` can be used\
    \ on `isize`, you can dereference `v`\n   |\n17 |             *v /= 2;\n   | \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hovr4s9.rs:25:81\n\
    \   |\n25 |             i as isize * std::pow(2, std::usize::max_value() - std::cmp::min(i,\
    \ 0));\n   |                                                                 \
    \                ^\n   |                                                     \
    \                            |\n   |                                         \
    \                                        expected `&mut isize`, found integer\n\
    \   |                                                                        \
    \         help: consider mutably borrowing here: `&mut 0`\n\nerror[E0606]: casting\
    \ `&mut isize` as `isize` is invalid\n  --> /tmp/tmp1hovr4s9.rs:25:13\n   |\n\
    25 |            "
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut count = vec![];\n    for i in arr {\n\
    \        if count.contains(&1) {\n            result.push(i);\n        } else\
    \ {\n            count.push(1);\n            result.push(i);\n        }\n    }\n\
    \    result.sort_by(|a, b| {\n        if a.cmp(b) == cmp::Ordering::Ascending\
    \ {\n            count.iter().cloned().max().unwrap()\n        } else {\n    \
    \        count.iter().cloned().min().unwrap()\n        }\n    });\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmps8pt0_fe.rs:20:24\n   |\n20 |         if a.cmp(b) == cmp::Ordering::Ascending\
    \ {\n   |                        ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps8pt0_fe.rs:21:13\n   |\n21 |\
    \             count.iter().cloned().max().unwrap()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps8pt0_fe.rs:23:13\n   |\n23 |             count.iter().cloned().min().unwrap()\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    // Count how many\
    \ 1s in binary representation of arr.\n    let mut cnt = 0;\n    for x in arr\
    \ {\n        if x != 0 {\n            cnt += 1;\n        }\n    }\n\n    // Sort\
    \ by number of ones in binary representation.\n    let mut sort_arr = arr.clone();\n\
    \    sort_arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else\
    \ if a < b {\n            -1\n        } else {\n            // Same number of\
    \ ones, so sort by decimal value.\n            cnt - (a & b as isize) * 10\n \
    \       }\n    });\n\n    // Remove 0s from arr to leave only the numbers with\
    \ at least 1 one.\n    sort_arr.retain(|x| x != 0);\n    sort_arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzai8ng51.rs:25:13\n   |\n\
    25 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzai8ng51.rs:27:13\n\
    \   |\n27 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzai8ng51.rs:30:13\n\
    \   |\n30 |             cnt - (a & b as isize) * 10\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `isize`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpzai8ng51.rs:35:27\n   |\n35 |     sort_arr.retain(|x|\
    \ x != 0);\n   |                           ^^ no implementation for `&isize ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n \
    \ --> /tmp/tmpzai8ng51.rs:30:24\n   |\n30 |             cnt - (a & b as isize)\
    \ * 10\n   |                        -^^^^^^^^^\n   |                        |\n\
    \   |                        cannot cast `&isize` as `isize`\n   |           \
    \             help: dereference the expression: `*b`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0606.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|num| {\n        let mut res = 0;\n        let mut pos =\
    \ 0;\n        while pos < num.len() {\n            if num[pos] & 1 != 0 {\n  \
    \              res += 1;\n            }\n            pos += 1;\n        }\n  \
    \      res\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpha_axer8.rs:12:25\n   |\n12 |         while pos\
    \ < num.len() {\n   |                         ^^^ method not found in `&isize`\n\
    \nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmpha_axer8.rs:13:16\n\
    \   |\n13 |             if num[pos] & 1 != 0 {\n   |                ^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpha_axer8.rs:9:5\n   |\n8  |  \
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                       \
    \              ---------- expected `Vec<isize>` because of return type\n9  | /\
    \     arr.sort_by_key(|num| {\n10 | |         let mut res = 0;\n11 | |       \
    \  let mut pos = 0;\n12 | |         while pos < num.len() {\n...  |\n18 | |  \
    \       res\n19 | |     })\n   | |______^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by_key(|x| count_ones_based_on_bit_repre(x,\
    \ arr.len()));\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_ones_based_on_bit_repre` in this\
    \ scope\n  --> /tmp/tmpeinrt97d.rs:10:32\n   |\n10 |     sorted_arr.sort_by_key(|x|\
    \ count_ones_based_on_bit_repre(x, arr.len()));\n   |                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counter = Counter::new();\n    for &i in arr {\n        counter.incr(i);\n\
    \    }\n    arr.sort_unstable_by_key(|i| counter.get_one(i));\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Counter`\n -->\
    \ /tmp/tmpagfme5be.rs:9:23\n  |\n9 |     let mut counter = Counter::new();\n \
    \ |                       ^^^^^^^ use of undeclared type `Counter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpagfme5be.rs:10:9\n   |\n10 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpagfme5be.rs:8:35\n  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n  |    ----------                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut new_arr = arr.clone();\n    new_arr.sort();\n    new_arr\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpfkyl7t_0.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    arr.sort_by(|x, y| {\n        let x_bin = format!(\"{:b}\"\
    , x).parse::<isize>().unwrap();\n        let y_bin = format!(\"{:b}\", y).parse::<isize>().unwrap();\n\
    \n        let diff = x_bin - y_bin;\n        match diff {\n            0 => 0.0,\n\
    \            x if x < y => x,\n            x if x == y => 0.0,\n            y\
    \ => y,\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplewep682.rs:16:18\n   |\n\
    16 |             0 => 0.0,\n   |                  ^^^ expected enum `std::cmp::Ordering`,\
    \ found floating-point number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplewep682.rs:17:22\n\
    \   |\n17 |             x if x < y => x,\n   |                      ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |             x if x < *y => x,\n   |                      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplewep682.rs:18:23\n   |\n18 |             x\
    \ if x == y => 0.0,\n   |                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |             x if x\
    \ == *y => 0.0,\n   |                       +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sorted().collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n --> /tmp/tmp0kpn6v3r.rs:9:25\n  |\n9 |     arr.iter().cloned().sorted().collect()\n\
    \  |                         ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_array = arr.clone();\n    let mut num_ones = 0;\n    let mut\
    \ decimal_part = 0;\n    for i in arr.iter() {\n        if num_ones == 0 {\n \
    \           sorted_array.swap(i, 0);\n            break;\n        }\n\n      \
    \  if num_ones == 1 {\n            sorted_array.swap(i, 0);\n            decimal_part\
    \ += i;\n            break;\n        }\n\n        sorted_array.swap(i, num_ones);\n\
    \        num_ones += 1;\n    }\n    if num_ones > 1 {\n        sorted_array.swap(decimal_part,\
    \ num_ones - 1);\n    }\n    sorted_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpav787nqg.rs:14:31\n   |\n\
    14 |             sorted_array.swap(i, 0);\n   |                              \
    \ ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpav787nqg.rs:19:31\n   |\n19 |             sorted_array.swap(i, 0);\n\
    \   |                               ^ expected `usize`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpav787nqg.rs:24:27\n   |\n24 |         sorted_array.swap(i,\
    \ num_ones);\n   |                           ^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpav787nqg.rs:28:27\n   |\n28 |\
    \         sorted_array.swap(decimal_part, num_ones - 1);\n   |               \
    \            ^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n28 |         sorted_array.swap(decimal_part.try_into().unwrap(), num_ones\
    \ - 1);\n   |                                       ++++++++++++++++++++\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().map(|x| x.leading_zeros()).enumerate().map(|(i, x)| {\n      \
    \  debug_assert!(i < arr.len() && x >= 0 && x <= 3);\n        arr\n          \
    \  .iter()\n            .filter(|&x| x == i)\n            .sort_by_key(|&x| x.leading_zeros(),\
    \ reverse())\n            .collect::<Vec<_>>()\n    })\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpuij2rcyn.rs:14:50\n\
    \   |\n14 |             .sort_by_key(|&x| x.leading_zeros(), reverse())\n   |\
    \                                                  ^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuij2rcyn.rs:13:31\n   |\n13 |\
    \             .filter(|&x| x == i)\n   |                               ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpuij2rcyn.rs:13:28\n   |\n13 |             .filter(|&x| x == i)\n\
    \   |                            ^^ no implementation for `&isize == usize`\n\
    \   |\n   = help: the trait `PartialEq<usize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0599]: no method named `sort_by_key` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmpuij2rcyn.rs:14:14\n   |\n14 | \
    \            .sort_by_key(|&x| x.leading_zeros(), reverse())\n   |           \
    \   ^^^^^^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmpuij2rcyn.rs:13:21:\
    \ 13:32]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuij2rcyn.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.iter().map(|x| x.leading_zeros()).enumerate().map(|(i,\
    \ x)| {\n10 | |         debug_assert!(i < arr.len() && x >= 0 && x <= 3);\n11\
    \ | |         arr\n12 | |             .iter()\n...  |\n15 | |             .collect::<Vec<_>>()\n\
    16 | |     })\n   | |______^ expected struct `Vec`, found struct `Map`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Map<Enumerate<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpuij2rcyn.rs:9:20: 9:41]>>, _>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut len = arr.len();\n\n    if len > 1 {\n        let mut count = 0;\n\
    \        let mut max = 0;\n        let mut min = 0;\n\n        for &x in arr {\n\
    \            if *x % 2 == 0 {\n                count += 1;\n                if\
    \ max < count {\n                    max = count;\n                }\n       \
    \         if min > count {\n                    min = count;\n               \
    \ }\n            }\n        }\n\n        let mut res = [0; len];\n\n        for\
    \ &x in arr {\n            if *x % 2 == 0 {\n                let index = count\
    \ - min + 1;\n                res[index] = x;\n            }\n        }\n\n  \
    \      res\n    } else {\n        arr\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpdzb99aka.rs:28:27\n   |\n9  |     let mut len = arr.len();\n   |   \
    \  ----------- help: consider using `const` instead of `let`: `const len`\n...\n\
    28 |         let mut res = [0; len];\n   |                           ^^^ non-constant\
    \ value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzb99aka.rs:16:13\n \
    \  |\n16 |         for &x in arr {\n   |             ^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdzb99aka.rs:30:13\n  \
    \ |\n30 |         for &x in arr {\n   |             ^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0435.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counts = vec![];\n    for i in arr {\n        if i is 0 {\n     \
    \       counts.push(i);\n        }\n    }\n    counts\n        .into_iter()\n\
    \        .windows(2)\n        .map(|w| w.iter().sum::<isize>())\n        .sort_by_key(|x|\
    \ x.ok_or(\"Array contains non-numbers\")?)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3,\
    \ 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]),\
    \ vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0,\
    \ 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `is`\n  --> /tmp/tmpz8fzvnqr.rs:11:14\n   |\n\
    11 |         if i is 0 {\n   |         --   ^^ expected `{`\n   |         |\n\
    \   |         this `if` expression has a condition, but no block\n\nerror[E0599]:\
    \ no method named `windows` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmpz8fzvnqr.rs:17:10\n   |\n17 |         .windows(2)\n   |\
    \          ^^^^^^^ method not found in `std::vec::IntoIter<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.to_vec();\n    let mut min_value = sorted_arr[0];\n\
    \    let mut max_value = sorted_arr[0];\n\n    for val in sorted_arr.iter() {\n\
    \        if val % 2 == 0 {\n            if val < min_value {\n               \
    \ min_value = val;\n            }\n        } else {\n            if val > max_value\
    \ {\n                max_value = val;\n            }\n        }\n    }\n\n   \
    \ let mut i = 0;\n    while i + 1 < sorted_arr.len() {\n        let val = sorted_arr[i];\n\
    \        let next_val = sorted_arr[i + 1];\n        if val + next_val < min_value\
    \ {\n            min_value += next_val - val;\n            sorted_arr[i] = val;\n\
    \            sorted_arr[i + 1] = next_val;\n            i += 1;\n        } else\
    \ {\n            break;\n        }\n    }\n\n    if min_value < max_value {\n\
    \        sorted_arr.swap(0, sorted_arr.len() - 1);\n    }\n\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmf_71025.rs:15:22\n   |\n\
    15 |             if val < min_value {\n   |                      ^^^^^^^^^\n \
    \  |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&min_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmf_71025.rs:16:29\n   |\n10 |\
    \     let mut min_value = sorted_arr[0];\n   |                         -------------\
    \ expected due to this value\n...\n16 |                 min_value = val;\n   |\
    \                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n16 |                 min_value = *val;\n\
    \   |                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf_71025.rs:19:22\n\
    \   |\n19 |             if val > max_value {\n   |                      ^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ `isize`\n   |                      help: consider borrowing here: `&max_value`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmf_71025.rs:20:29\n   |\n11 |\
    \     let mut max_value = sorted_arr[0];\n   |                         -------------\
    \ expected due to this value\n...\n20 |                 max_value = val;\n   |\
    \                             ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n20 |                 max_value = *val;\n\
    \   |                             +\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a < b {\n            -a\n        } else\
    \ {\n            b\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeu07_wbp.rs:11:13\n   |\n\
    11 |             -a\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeu07_wbp.rs:13:13\n\
    \   |\n13 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut counts: Vec<isize> = Vec::new();\n    for i in arr {\n        if\
    \ i < 0 {\n            counts.push(0);\n        } else {\n            counts.push(counts.iter().filter(|&x|\
    \ x % 2 == 0).count() + 1);\n        }\n    }\n    let mut i = 0;\n    loop {\n\
    \        if i >= counts.len() {\n            break;\n        }\n        let mut\
    \ min = -1000;\n        let mut max = 0;\n        let mut j = 0;\n        let\
    \ mut cnt = 0;\n        for _ in 0..(i + 1) {\n            if j < counts.len()\
    \ {\n                cnt += counts[j];\n            }\n            max += cnt;\n\
    \            if cnt > min {\n                min = cnt;\n            }\n     \
    \       j += 1;\n        }\n        i += 1;\n        for _ in 0..(j + 1) {\n \
    \           max -= counts[j];\n            if cnt > min {\n                min\
    \ = cnt;\n            }\n            j += 1;\n        }\n        if min > max\
    \ {\n            max = min;\n        }\n        for _ in 0..(max - min + 1) {\n\
    \            counts.push(0);\n        }\n        for _ in 0..(max - min + 1) {\n\
    \            counts[min] += 1;\n        }\n    }\n    counts.iter().map(|&x| x\
    \ + 1).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_j7bp2pz.rs:14:25\n   |\n\
    14 |             counts.push(counts.iter().filter(|&x| x % 2 == 0).count() + 1);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |           \
    \  counts.push((counts.iter().filter(|&x| x % 2 == 0).count() + 1).try_into().unwrap());\n\
    \   |                         +                                              \
    \   +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp_j7bp2pz.rs:51:13\n   |\n51 |             counts[min]\
    \ += 1;\n   |             ^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by_key(|x| x != 0)\n        .sort_by_key(|x| x as isize)\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n --> /tmp/tmpx3ymf2sg.rs:9:27\n\
    \  |\n9 |     arr.sort_by_key(|x| x != 0)\n  |                           ^^ no\
    \ implementation for `&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpx3ymf2sg.rs:10:10\n\
    \   |\n10 |         .sort_by_key(|x| x as isize)\n   |          ^^^^^^^^^^^ method\
    \ not found in `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            -1\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1mov93qn.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mov93qn.rs:13:13\n\
    \   |\n13 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mov93qn.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a > b {\n11 | |   \
    \          1\n12 | |         } else {\n13 | |             -1\n14 | |         }\n\
    15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_arr = arr.clone();\n    sort_array_using_ones_count_and_decimal_order(&mut\
    \ sorted_arr);\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_using_ones_count_and_decimal_order`\
    \ in this scope\n  --> /tmp/tmpj13qe32g.rs:10:5\n   |\n10 |     sort_array_using_ones_count_and_decimal_order(&mut\
    \ sorted_arr);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut num_ones = 0;\n    let mut min_value = std::isize::MAX;\n    for\
    \ i in arr {\n        if i & 1 != 0 {\n            num_ones += 1;\n          \
    \  min_value = std::cmp::min(min_value, i);\n        }\n    }\n    if num_ones\
    \ == 0 {\n        arr.sort_by_key(|x| x);\n    } else {\n        arr.sort_by_key(|x|\
    \ x.checked_mul(10).checked_add(num_ones));\n    }\n    if min_value > std::isize::MAX\
    \ {\n        arr\n    } else {\n        arr.iter().cloned().collect();\n    }\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmpexb45ska.rs:20:47\n   |\n20 |         arr.sort_by_key(|x|\
    \ x.checked_mul(10).checked_add(num_ones));\n   |                            \
    \                   ^^^^^^^^^^^ method not found in `Option<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpexb45ska.rs:24:12\n   |\n24 |       } else {\n\
    \   |  ____________^\n25 | |         arr.iter().cloned().collect();\n   | |  \
    \                                    - help: remove this semicolon\n26 | |   \
    \  }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmp3wnrpndz.rs:9:5\n  |\n8 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n  |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n9 |     arr.sort();\n  |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // your code goes here\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpinxhbvwc.rs:8:35\n  |\n8 |\
    \ fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------          \
    \           ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums = arr.to_vec();\n    let mut reversed = nums.clone();\n\n  \
    \  let mut counts = vec![0; nums.len()];\n    for i in 0..nums.len() {\n     \
    \   counts[nums[i]] += 1;\n    }\n\n    for i in 0..nums.len() {\n        if counts[i]\
    \ != 0 {\n            let mut max_count = 0;\n            let mut max_val = 0;\n\
    \            for j in 0..counts[i] {\n                if nums[j] > max_val {\n\
    \                    max_val = nums[j];\n                    max_count = j;\n\
    \                }\n            }\n\n            reversed[max_count] = i;\n  \
    \          for i in 0..counts[i] {\n                counts[i] -= 1;\n        \
    \    }\n        }\n    }\n\n    reversed.to_vec()\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp73h9plmz.rs:14:9\n   |\n14 |         counts[nums[i]] += 1;\n   |   \
    \      ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp73h9plmz.rs:28:35\n   |\n28 |\
    \             reversed[max_count] = i;\n   |             ------------------- \
    \  ^ expected `isize`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a > b {\n            1\n        } else {\n\
    \            a\n        }\n    })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5wpvl8k_.rs:11:13\n   |\n\
    11 |             1\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wpvl8k_.rs:13:13\n\
    \   |\n13 |             a\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wpvl8k_.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a > b {\n11 | |   \
    \          1\n12 | |         } else {\n13 | |             a\n14 | |         }\n\
    15 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut count = count_ones(arr);\n    let mut num_ones = 0;\n    for ele\
    \ in arr {\n        num_ones += count_ones(&[ele as usize]);\n    }\n    count\
    \ = (-num_ones as isize).saturating_add((-count as isize));\n    arr.sort_unstable_by(|a,\
    \ b| {\n        let mut c = count_ones(&[a as usize]);\n        let mut d = count_ones(&[b\
    \ as usize]);\n        if c < d {\n            c + d as isize\n        } else\
    \ {\n            d + c as isize\n        }\n    });\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_ones` in this scope\n --> /tmp/tmpbl3gbks9.rs:9:21\n\
    \  |\n9 |     let mut count = count_ones(arr);\n  |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `count_ones` in\
    \ this scope\n  --> /tmp/tmpbl3gbks9.rs:12:21\n   |\n12 |         num_ones +=\
    \ count_ones(&[ele as usize]);\n   |                     ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `count_ones` in this scope\n\
    \  --> /tmp/tmpbl3gbks9.rs:16:21\n   |\n16 |         let mut c = count_ones(&[a\
    \ as usize]);\n   |                     ^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `count_ones` in this scope\n  --> /tmp/tmpbl3gbks9.rs:17:21\n\
    \   |\n17 |         let mut d = count_ones(&[b as usize]);\n   |             \
    \        ^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmpbl3gbks9.rs:14:49\n   |\n14 |     count\
    \ = (-num_ones as isize).saturating_add((-count as isize));\n   |            \
    \                                     ^               ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n14 -     count = (-num_ones\
    \ as isize).saturating_add((-count as isize));\n14 +     count = (-num_ones as\
    \ isize).saturating_add(-count as isize);\n   | \n\nerror[E0606]: casting `&isize`\
    \ as `usize` is invalid\n  --> /tmp/tmpbl3gbks9.rs:16:34\n   |\n16 |         let\
    \ mut c = count_ones(&[a as usize]);\n   |                                  -^^^^^^^^^\n\
    \   |                                  |\n   |                               \
    \   cannot cast `&isize` as `usize`\n   |                                  help:\
    \ dereference the expression: `*a`\n\nerror[E0606]: casting `&isize` as `usize`\
    \ is invalid\n  --> /tmp/tmpbl3gbks9.rs:17:34\n   |\n17 |         let mut d =\
    \ count_ones(&[b as usize]);\n   |                                  -^^^^^^^^^\n\
    \   |                                  |\n   |                               \
    \   cannot cast `&isize` as `usize`\n   |                                  help:\
    \ dereferenc"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut counts = HashMap::new();\n\
    \    for &i in arr {\n        counts[i].into_mut().unwrap() += 1;\n    }\n\n \
    \   let mut sorted_arr = Vec::new();\n    for (idx, &i) in counts.into_iter().enumerate()\
    \ {\n        sorted_arr.push(i);\n        if idx != arr.len() - 1 {\n        \
    \    let last = sorted_arr[sorted_arr.len() - 1];\n            sorted_arr.swap(idx,\
    \ last);\n        }\n    }\n\n    sorted_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpr_9tbf0d.rs:13:22\n   |\n13 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr_9tbf0d.rs:14:9\n   |\n14 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpr_9tbf0d.rs:15:39\n   |\n15 |         counts[i].into_mut().unwrap()\
    \ += 1;\n   |         ----------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr_9tbf0d.rs:27:5\n   |\n8  | fn sort_array(arr: Vec<isize>) ->\
    \ Vec<isize> {\n   |                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n27 |     sorted_arr\n   |     ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut map: HashMap<usize, isize> = HashMap::new();\n\
    \    for x in arr {\n        let mut x = x;\n        let mut cnt = 0;\n      \
    \  while x.0 < 0 {\n            cnt += 1;\n            x /= 2;\n        }\n  \
    \      *map.entry(cnt).or_insert(x) = x;\n    }\n    for k in map.keys() {\n \
    \       res.push(*map.get(&k));\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpg2xy2mg8.rs:10:18\n\
    \   |\n10 |     let mut map: HashMap<usize, isize> = HashMap::new();\n   |   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpg2xy2mg8.rs:10:42\n\
    \   |\n10 |     let mut map: HashMap<usize, isize> = HashMap::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpg2xy2mg8.rs:14:17\n   |\n14 |         while x.0 < 0 {\n\
    \   |                 ^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0412, E0433, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        a.iter().enumerate().filter(|(i, _)| a & (1\
    \ << i) != 0).count() <\n            b.iter().enumerate().filter(|(_, j)| b &\
    \ (1 << j) != 0).count()\n    });\n\n    arr.iter().enumerate().filter(|(_, v)|\
    \ v != 0).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpg5sqrobm.rs:10:11\n   |\n10 |         a.iter().enumerate().filter(|(i,\
    \ _)| a & (1 << i) != 0).count() <\n   |           ^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmpg5sqrobm.rs:11:15\n   |\n11 |             b.iter().enumerate().filter(|(_,\
    \ j)| b & (1 << j) != 0).count()\n   |               ^^^^ method not found in\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5sqrobm.rs:10:9\n\
    \   |\n10 | /         a.iter().enumerate().filter(|(i, _)| a & (1 << i) != 0).count()\
    \ <\n11 | |             b.iter().enumerate().filter(|(_, j)| b & (1 << j) != 0).count()\n\
    \   | |___________________________________________________________________________^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0277]: can't compare\
    \ `&&isize` with `{integer}`\n  --> /tmp/tmpg5sqrobm.rs:14:46\n   |\n14 |    \
    \ arr.iter().enumerate().filter(|(_, v)| v != 0).collect()\n   |             \
    \                                 ^^ no implementation for `&&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from\
    \ an iterator over elements of type `(usize, &isize)`\n    --> /tmp/tmpg5sqrobm.rs:14:52\n\
    \     |\n14   |     arr.iter().enumerate().filter(|(_, v)| v != 0).collect()\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(usize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(usize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: abo"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut max_ones = std::i32::MAX;\n    let mut min_ones = std::i32::MIN;\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            max_ones = std::cmp::max(max_ones,\
    \ i as i32);\n        } else {\n            min_ones = std::cmp::min(min_ones,\
    \ i as i32);\n        }\n    }\n\n    if min_ones == max_ones {\n        for i\
    \ in arr {\n            *i as isize\n        }\n    } else {\n        let mut\
    \ min: i32;\n        let mut max: i32;\n        for i in arr {\n            if\
    \ i % 2 == 0 {\n                max = std::cmp::max(max, i as i32);\n        \
    \    } else {\n                min = std::cmp::min(min, i as i32);\n         \
    \   }\n        }\n        let mut mid = (min + max) / 2;\n        let mut new_array:\
    \ Vec<isize> = vec![];\n        for i in arr {\n            if i != mid {\n  \
    \              *i as isize\n            } else {\n                new_array.push(*i\
    \ as isize);\n            }\n        }\n        if new_array.len() < arr.len()\
    \ {\n            for i in new_array.iter_mut() {\n                *i += 1;\n \
    \           }\n        }\n        new_array\n    }\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp0intlpym.rs:21:13\n\
    \   |\n21 |             *i as isize\n   |             ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0intlpym.rs:20:9\n   |\n8  |   fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                     ---------- expected\
    \ `Vec<isize>` because of return type\n...\n20 | /         for i in arr {\n21\
    \ | |             *i as isize\n22 | |         }\n   | |_________^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0intlpym.rs:36:21\n\
    \   |\n36 |             if i != mid {\n   |                     ^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n36 |             if i != mid.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp0intlpym.rs:37:17\n   |\n37 |        \
    \         *i as isize\n   |                 ^^\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp0intlpym.rs:39:32\n   |\n39 |               \
    \  new_array.push(*i as isize);\n   |                                ^^\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut i = 0;\n    let mut j = arr.len() - 1;\n    let mut ans = vec![];\n\
    \n    while i < j {\n        let (tmp_i, tmp_j) = (i, j);\n        let mut count\
    \ = 0;\n        while tmp_i >= 0 && tmp_j < arr.len() {\n            count +=\
    \ arr[tmp_i] & arr[tmp_j];\n            tmp_i -= 1;\n            tmp_j -= 1;\n\
    \        }\n        if count == 0 {\n            ans.push(tmp_i);\n          \
    \  ans.push(tmp_j);\n        }\n        i += 1;\n        j -= 1;\n    }\n\n  \
    \  ans\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_afhbz2h.rs:29:5\n   |\n\
    8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \               ---------- expected `Vec<isize>` because of return type\n...\n\
    29 |     ans\n   |     ^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        arr\n    } else {\n        let mut res = vec![];\n\
    \        res.extend_from_slice(arr);\n        res.sort();\n        res\n    }\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpifpl7gpb.rs:13:31\n   |\n\
    13 |         res.extend_from_slice(arr);\n   |                               ^^^\n\
    \   |                               |\n   |                               expected\
    \ `&[_]`, found struct `Vec`\n   |                               help: consider\
    \ borrowing here: `&arr`\n   |\n   = note: expected reference `&[_]`\n       \
    \          found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|a, b| {\n        if a < b {\n            -1\n        } else\
    \ {\n            if a > b {\n                1\n            } else {\n       \
    \         0\n            }\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4,\
    \ 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6,\
    \ -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2,\
    \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n\
    \    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n\
    \    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n  \
    \  assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvq7wri1.rs:11:13\n   |\n\
    11 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvq7wri1.rs:14:17\n\
    \   |\n14 |                 1\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvq7wri1.rs:16:17\n\
    \   |\n16 |                 0\n   |                 ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvq7wri1.rs:9:5\n\
    \   |\n8  |   fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n9  | /     arr.sort_by(|a, b| {\n10 | |         if a < b {\n11 | |   \
    \          -1\n12 | |         } else {\n...  |\n18 | |         }\n19 | |     })\n\
    \   | |______^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ret: Vec<isize> = arr.to_vec();\n    let mut num_ones = 0;\n    for\
    \ i in ret {\n        if i != 0 {\n            num_ones += 1;\n        } else\
    \ {\n            if num_ones == 0 {\n                ret.reverse();\n        \
    \    }\n            num_ones = 0;\n        }\n    }\n    return ret;\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `ret`\n   --> /tmp/tmpalm5p3l6.rs:16:17\n\
    \    |\n9   |     let mut ret: Vec<isize> = arr.to_vec();\n    |         -------\
    \ move occurs because `ret` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n10  |     let mut num_ones = 0;\n11  |     for i in ret {\n  \
    \  |              --- `ret` moved due to this implicit call to `.into_iter()`\n\
    ...\n16  |                 ret.reverse();\n    |                 ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `ret`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n11\
    \  |     for i in &ret {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = arr.clone();\n    for i in 0..result.len() {\n        //\
    \ remember that result.len() == arr.len()\n        let mut j = i;\n        while\
    \ j > 0 && result[j - 1] > result[j] {\n            result[j] = result[j - 1];\n\
    \            j -= 1;\n        }\n        result[j] = i;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprd0j12e9.rs:17:21\n   |\n\
    17 |         result[j] = i;\n   |         ---------   ^ expected `isize`, found\
    \ `usize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut s = arr.clone();\n    let mut i = 0;\n    while i < s.len() {\n \
    \       let mut j = 0;\n        while j < i {\n            if s[j] == 0 {\n  \
    \              s[j] = s[j + 1];\n                s[j + 1] += 1;\n            }\n\
    \            j += 1\n        }\n        if i == 0 {\n            s[0] = s[j];\n\
    \        } else {\n            s[i] = s[j];\n        }\n        i += 1;\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 3, 4]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpcu5qpujo.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort();\n    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n --> /tmp/tmpxk0cehw4.rs:9:5\n  |\n8 | fn sort_array(arr: Vec<isize>)\
    \ -> Vec<isize> {\n  |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n9 |     arr.sort();\n  |     ^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_by(|x, y| if x.is_zero() { y.is_zero() } else if x.is_one() { y.is_one()\
    \ } else { y.compare(x) })\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for reference `&isize` in\
    \ the current scope\n --> /tmp/tmpnpqi3_lv.rs:9:29\n  |\n9 |     arr.sort_by(|x,\
    \ y| if x.is_zero() { y.is_zero() } else if x.is_one() { y.is_one() } else { y.compare(x)\
    \ })\n  |                             ^^^^^^^ method not found in `&isize`\n\n\
    error[E0599]: no method named `is_zero` found for reference `&isize` in the current\
    \ scope\n --> /tmp/tmpnpqi3_lv.rs:9:43\n  |\n9 |     arr.sort_by(|x, y| if x.is_zero()\
    \ { y.is_zero() } else if x.is_one() { y.is_one() } else { y.compare(x) })\n \
    \ |                                           ^^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `is_one` found for reference `&isize` in the current\
    \ scope\n --> /tmp/tmpnpqi3_lv.rs:9:65\n  |\n9 |     arr.sort_by(|x, y| if x.is_zero()\
    \ { y.is_zero() } else if x.is_one() { y.is_one() } else { y.compare(x) })\n \
    \ |                                                                 ^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0599]: no method named `is_one` found for reference\
    \ `&isize` in the current scope\n --> /tmp/tmpnpqi3_lv.rs:9:78\n  |\n9 |     arr.sort_by(|x,\
    \ y| if x.is_zero() { y.is_zero() } else if x.is_one() { y.is_one() } else { y.compare(x)\
    \ })\n  |                                                                    \
    \          ^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method named\
    \ `compare` found for reference `&isize` in the current scope\n --> /tmp/tmpnpqi3_lv.rs:9:98\n\
    \  |\n9 |     arr.sort_by(|x, y| if x.is_zero() { y.is_zero() } else if x.is_one()\
    \ { y.is_one() } else { y.compare(x) })\n  |                                 \
    \                                                                 ^^^^^^^ method\
    \ not found in `&isize`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnpqi3_lv.rs:9:5\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |                \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    9 |     arr.sort_by(|x, y| if x.is_zero() { y.is_zero() } else if x.is_one() {\
    \ y.is_one() } else { y.compare(x) })\n  |     ^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().map(|x| {\n        if x.is_power_of_two() {\n            x\n \
    \       } else {\n            let mut ones = x;\n            for i in 1..(ones\
    \ / 2).cmp::<0>(ones) {\n                ones -= i;\n            }\n         \
    \   ones\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of_two` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpjkdtuq7j.rs:10:14\n   |\n10 |         if\
    \ x.is_power_of_two() {\n   |              ^^^^^^^^^^^^^^^ method not found in\
    \ `&isize`\n\nerror[E0107]: this associated function takes 0 generic arguments\
    \ but 1 generic argument was supplied\n  --> /tmp/tmpjkdtuq7j.rs:14:36\n   |\n\
    14 |             for i in 1..(ones / 2).cmp::<0>(ones) {\n   |               \
    \                     ^^^----- help: remove these generics\n   |             \
    \                       |\n   |                                    expected 0\
    \ generic arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjkdtuq7j.rs:14:25\n\
    \   |\n14 |             for i in 1..(ones / 2).cmp::<0>(ones) {\n   |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `std::cmp::Ordering`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpjkdtuq7j.rs:15:17\n   |\n15 |                 ones -= i;\n   |\
    \                 ----^^^^^\n   |                 |\n   |                 cannot\
    \ use `-=` on type `&isize`\n   |\nhelp: `-=` can be used on `isize`, you can\
    \ dereference `ones`\n   |\n15 |                 *ones -= i;\n   |           \
    \      +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0107, E0308, E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0107`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu_9107j6.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // use an array to store the counts\n    let mut counts: Vec<isize> = arr.iter().map(|x|\
    \ {\n        let mut cnt = 1u8;\n        let bit_str = x.to_string().chars().nth(1).unwrap();\n\
    \        for x in bit_str.to_ascii_lowercase().into_iter() {\n            if x\
    \ == '1' {\n                cnt += 1;\n            }\n        }\n        cnt\n\
    \    }).collect();\n    counts.sort_by(|a, b| b.cmp(a));\n\n    // traverse the\
    \ vector and create new one with new values\n    let mut new_arr = vec![];\n \
    \   for i in 0..arr.len() {\n        let mut cnt = 0u8;\n        let x = arr[i];\n\
    \        for _ in 0..counts[x] {\n            cnt += 1;\n        }\n        new_arr.push(cnt);\n\
    \    }\n\n    new_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpx9ji4o3l.rs:13:47\n\
    \   |\n13 |         for x in bit_str.to_ascii_lowercase().into_iter() {\n   |\
    \                                               ^^^^^^^^^ `char` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `char: IntoIterator`\n          \
    \ `&char: Iterator`\n           which is required by `&char: IntoIterator`\n \
    \          `&mut char: Iterator`\n           which is required by `&mut char:\
    \ IntoIterator`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built\
    \ from an iterator over elements of type `u8`\n    --> /tmp/tmpx9ji4o3l.rs:19:8\n\
    \     |\n19   |     }).collect();\n     |        ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the\
    \ trait `FromIterator<u8>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpx9ji4o3l.rs:27:21\n   |\n27 |         for _ in 0..counts[x] {\n\
    \   |                     ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx9ji4o3l.rs:33:5\n\
    \   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n33 |     new_arr\n   |     ^^^^^^^ expected `isize`, found `u8`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n              found struct `Vec<u8>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    for i in arr {\n        if i % 2 == 1 {\n \
    \           result.push(i);\n        }\n    }\n    result.sort();\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpqj1769u9.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter().cloned().sort_by_key(|&x| {\n        // TODO: sort by number of\
    \ ones first\n        if x == 0 {\n            x.leading_zeros() as usize\n  \
    \      } else {\n            x.trailing_zeros() as usize\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n --> /tmp/tmpruib50o5.rs:9:25\n  |\n9 |     arr.iter().cloned().sort_by_key(|&x|\
    \ {\n  |                         ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut s = arr.clone();\n    s.sort();\n    s\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1,\
    \ 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5]`,\n right: `[1, 2, 4, 3, 5]`', /tmp/tmpnkwypb5m.rs:16:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return arr;\n    }\n\n    let mut sorted_arr\
    \ = arr.clone();\n    sorted_arr.sort_unstable_by(|a, b| {\n        sort_binary_count_array(&[a,\
    \ b])\n    });\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2,\
    \ -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1,\
    \ 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_binary_count_array` in this scope\n\
    \  --> /tmp/tmpxpg79obj.rs:15:9\n   |\n15 |         sort_binary_count_array(&[a,\
    \ b])\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut one_count = vec![0; arr.len() as usize];\n    let mut decimal_count\
    \ = vec![0; arr.len() as usize];\n    for &x in arr {\n        if one_count[x]\
    \ == 0 {\n            one_count[x] = 1;\n        } else {\n            one_count[x]\
    \ += 1;\n        }\n        let decimal = x / one_count[x].powf(2);\n        decimal_count[x]\
    \ = decimal;\n    }\n    decimal_count.sort_unstable();\n    arr.sort_unstable();\n\
    \    for (i, &x) in arr.iter().zip(decimal_count.iter()) {\n        if *x < decimal_count[i]\
    \ {\n            arr[i] = decimal_count[i];\n        }\n    }\n    arr\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkth2v5x.rs:11:9\n   |\n\
    11 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmppkth2v5x.rs:23:12\n   |\n23 |        \
    \ if *x < decimal_count[i] {\n   |            ^^\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmppkth2v5x.rs:23:17\n   |\n23 | \
    \        if *x < decimal_count[i] {\n   |                 ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmppkth2v5x.rs:24:13\n\
    \   |\n24 |             arr[i] = decimal_count[i];\n   |             ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmppkth2v5x.rs:24:22\n\
    \   |\n24 |             arr[i] = decimal_count[i];\n   |                     \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.sort_unstable_by(|a, b| count_ones(binary_one_to_string(a)) - count_ones(binary_one_to_string(b)));\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_ones` in this scope\n --> /tmp/tmpljpvgo91.rs:9:33\n\
    \  |\n9 |     arr.sort_unstable_by(|a, b| count_ones(binary_one_to_string(a))\
    \ - count_ones(binary_one_to_string(b)));\n  |                               \
    \  ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `binary_one_to_string`\
    \ in this scope\n --> /tmp/tmpljpvgo91.rs:9:44\n  |\n9 |     arr.sort_unstable_by(|a,\
    \ b| count_ones(binary_one_to_string(a)) - count_ones(binary_one_to_string(b)));\n\
    \  |                                            ^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `count_ones` in this scope\n\
    \ --> /tmp/tmpljpvgo91.rs:9:71\n  |\n9 |     arr.sort_unstable_by(|a, b| count_ones(binary_one_to_string(a))\
    \ - count_ones(binary_one_to_string(b)));\n  |                               \
    \                                        ^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `binary_one_to_string` in this scope\n -->\
    \ /tmp/tmpljpvgo91.rs:9:82\n  |\n9 |     arr.sort_unstable_by(|a, b| count_ones(binary_one_to_string(a))\
    \ - count_ones(binary_one_to_string(b)));\n  |                               \
    \                                                   ^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpljpvgo91.rs:8:35\n\
    \  |\n8 | fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n  |    ----------  \
    \                   ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return arr;\n    }\n\n    let mut array = vec![];\n\
    \n    // count number of ones in each position\n    array.into_iter().for_each(|el|\
    \ {\n        let mut count = 0;\n        for _ in 0..el {\n            count +=\
    \ 1;\n        }\n        array.append(count);\n    });\n\n    // sort array in\
    \ ascending order using counts\n    array.sort_unstable_by(|a, b| {\n        if\
    \ a > b {\n            1\n        } else {\n            a\n        }\n    });\n\
    \n    // sort array in descending order using counts\n    array.sort_unstable_by(|a,\
    \ b| {\n        if a > b {\n            -1\n        } else {\n            b\n\
    \        }\n    });\n\n    // sort array in ascending order using decimal value\n\
    \    array.sort_unstable_by(|a, b| {\n        if a > b {\n            a\n    \
    \    } else {\n            b\n        }\n    });\n\n    // sort array in descending\
    \ order using decimal value\n    array.sort_unstable_by(|a, b| {\n        if a\
    \ > b {\n            b\n        } else {\n            a\n        }\n    });\n\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
    \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
    \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2,\
    \ 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7,\
    \ 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3,\
    \ 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4,\
    \ 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:21:22\n   |\n\
    21 |         array.append(count);\n   |                      ^^^^^ expected mutable\
    \ reference, found integer\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<{integer}>`\n                           found type `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:27:13\n   |\n27 |             1\n\
    \   |             ^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:29:13\n   |\n29 |             a\n\
    \   |             ^ expected enum `std::cmp::Ordering`, found `&{integer}`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:36:13\n   |\n36 |  \
    \           -1\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:38:13\n\
    \   |\n38 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:45:13\n\
    \   |\n45 |             a\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:47:13\n\
    \   |\n47 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:54:13\n\
    \   |\n54 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0i_gz7ej.rs:56:13\n\
    \   |\n56 |             a\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&{integer}`\n\nerror: aborting due to 9 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this Kata, you have to sort an array of non-negative integers according\
    \ to\n/// number of ones in their binary representation in ascending order.\n\
    /// For similar number of ones, sort based on decimal value.\n/// It must be implemented\
    \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n\
    \    assert_eq!(arr.len(), unsafe { arr.as_ptr() as usize });\n    unsafe {\n\
    \        let mut v: [isize; arr.len()] = unsafe { std::slice::from_raw_parts(arr.as_ptr(),\
    \ arr.len() * 2) };\n        v.sort_by_key(|x| {\n            if x % 2 == 0 {\n\
    \                x.to_dec() + v.len() / 2.0\n            } else {\n          \
    \      x\n            }\n        });\n        v\n    }\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]),\
    \ vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4,\
    \ -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1,\
    \ 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2,\
    \ 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32,\
    \ 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16,\
    \ 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
    \ vec![2, 4, 8, 16, 32]);\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpz5po2_io.rs:11:28\n   |\n8  | fn sort_array(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |               --- this would need to be a `const`\n...\n11 |       \
    \  let mut v: [isize; arr.len()] = unsafe { std::slice::from_raw_parts(arr.as_ptr(),\
    \ arr.len() * 2) };\n   |                            ^^^\n\nerror[E0599]: no method\
    \ named `to_dec` found for reference `&isize` in the current scope\n  --> /tmp/tmpz5po2_io.rs:14:19\n\
    \   |\n14 |                 x.to_dec() + v.len() / 2.0\n   |                 \
    \  ^^^^^^ help: there is an associated function with a similar name: `to_be`\n\
    \nerror[E0277]: cannot divide `usize` by `{float}`\n  --> /tmp/tmpz5po2_io.rs:14:38\n\
    \   |\n14 |                 x.to_dec() + v.len() / 2.0\n   |                 \
    \                     ^ no implementation for `usize / {float}`\n   |\n   = help:\
    \ the trait `Div<{float}>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0435, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
