name: HumanEval_91_is_bored
language: rust
prompt: "/// You'll be given a string of words, and your task is to count the number\n\
  /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences\
  \ are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"Hello\
  \ world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining. I love\
  \ this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
  Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
  )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
  bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
  \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
  You and I are going for a walk\")), 0);\n}\n"
completions: ['    S.chars().filter(|c| c.is_ascii_lowercase()).count() == "i"', " \
    \   let mut bored: isize = 0;\n    let mut idx = 0;\n    while idx < S.len() {\n\
    \        let c: char;\n        match S[idx].as_ref() {\n            '.' => c =\
    \ '.',\n            '?' => c = '?',\n            '!' => c = '!',\n           \
    \ _ => continue,\n        };\n        idx += 1;\n        if c == 'I' {\n     \
    \       bored += 1;\n        }\n    }\n    bored", "    let mut i = 0;\n    for\
    \ s in S.split_whitespace() {\n        i += s.starts_with(\"I\".to_owned());\n\
    \    }\n    i", "    let mut boredom = vec![];\n    for word in S.split() {\n\
    \        match word {\n            \"I\" => boredom.push(1),\n            \".\"\
    \ | \"?\" | \"!\" => {\n                boredom.push(0);\n                break;\n\
    \            }\n            _ => {}\n        }\n    }\n    boredom.iter().sum()",
  "    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1", "    let\
    \ mut cnt = 0;\n    for ch in S.chars() {\n        cnt += if ch == '.' || ch ==\
    \ '?' || ch == '!' { 1 } else { 0 };\n    }\n    cnt", "    let mut is_bored =\
    \ vec![];\n    let mut char_count = S;\n    while char_count.len() > 0 {\n   \
    \     let mut is_bored_char = char_count[0];\n        for i in 1..char_count.len()\
    \ {\n            if char_count[i] != '.' && char_count[i] != '?' && char_count[i]\
    \ != '!' && char_count[i] == is_bored_char {\n                is_bored += 1;\n\
    \            }\n        }\n        is_bored.push(is_bored_char);\n        char_count\
    \ = char_count.trim_start().trim_end();\n    }\n    is_bored.len()", "    if S.chars().count(|c|\
    \ *c != '?' *c != '!') >= 2 {\n        0\n    } else {\n        1\n    }", " \
    \   match S\n        .split_whitespace()\n        .filter(|&s| s.starts_with(\"\
    I\"))\n        .count() {\n        0 => 0,\n        _ => 1,\n    }", "    let\
    \ mut count = 0 as usize;\n    let mut s: String = S.clone();\n    let mut is_bored\
    \ = true;\n    while !s.is_empty() {\n        if s.is_prefix(\"I\") {\n      \
    \      is_bored = false;\n            break;\n        }\n        let pos = s.find(\"\
    .\");\n        if pos == usize::max_value() || pos == 0 {\n            break;\n\
    \        }\n        count += 1;\n        s = &s[pos..];\n    }\n    if is_bored\
    \ {\n        count += 1;\n    }\n    count", '    boredoms(S).iter().filter(|word|
    word.starts_with("I")).count()', "    let mut boredom = 1;\n    let mut i = 0;\n\
    \    while i != S.len() {\n        i += 1;\n        if S[i] == '.' {\n       \
    \     if S[i + 1] == '.' {\n                if S[i + 2] == '.' {\n           \
    \         i += 3;\n                } else {\n                    i += 2;\n   \
    \             }\n            } else {\n                i += 1;\n            }\n\
    \        } else {\n            boredom = boredom + 1;\n        }\n    }\n    return\
    \ boredom;", "    let mut counter = 0;\n    for word in S.split(\" \").filter(|w|\
    \ w.len() > 0 && w.starts_with(\"I\")) {\n        if word.ends_with('.') || word.ends_with('?')\
    \ || word.ends_with('!'){\n            counter = counter + 1;\n        }\n   \
    \ }\n    counter", "    match S\n        .chars()\n        .filter(|c| c == '.'\
    \ || c == '?' || c == '!')\n        .filter(|c| !c.is_ascii_lowercase())\n   \
    \     .cloned()\n        .take_while(|c| !c.is_ascii_lowercase())\n        .count()\
    \ {\n        1 => 0,\n        _ => 1,\n    }", "    let mut boredom_cnt = 0;\n\
    \    for word in S.chars().map(|c| c as char) {\n        match word {\n      \
    \      'I' => {\n                if boredom_cnt > 0 {\n                    boredom_cnt\
    \ = 0;\n                }\n            },\n            '.' | '?' | '!' => {\n\
    \                boredom_cnt += 1;\n            },\n            _ => {}\n    \
    \    }\n    }\n    boredom_cnt", "    let mut i: usize = 0;\n\n    for (i, c)\
    \ in S.chars().enumerate() {\n        match c {\n            '.' | '?' | '!' =>\
    \ continue,\n            _ => break\n        }\n    }\n\n    i + 1", "    if is_bored_impl(S).is_ok()\n\
    \        && is_bored_impl(S).unwrap().len() == 1\n    {\n        0\n    } else\
    \ {\n        1\n    }", "    let mut boredom_counter = 0;\n    for s in S.split_whitespace()\
    \ {\n        if s == \"I\" {\n            boredom_counter += 1;\n        }\n \
    \   }\n    boredom_counter", "    // BEGIN PUBDEV\n    let mut bored = 0;\n  \
    \  let mut sentences = S.split_whitespace().collect::<Vec<_>>();\n    for i in\
    \ 0..sentences.len() {\n        if let Ok(s) = sentences[i] {\n            if\
    \ s == \"I\".to_string() {\n                bored += 1;\n            }\n     \
    \   }\n    }\n    return bored;\n    // END PUBDEV", '    S.rfind("I", String::npos,
    -1).unwrap()', "    let mut boredoms = 1;\n    let mut i = 0;\n    let mut word\
    \ = \"\";\n    let mut sentence = S.to_string();\n\n    while let Some(letter)\
    \ = sentence[i..].chars().next() {\n        if letter == '.' || letter == '?'\
    \ || letter == '!' {\n            if word == letter {\n                boredoms\
    \ += 1;\n            }\n            i += 1;\n            word = \"\";\n      \
    \  }\n        else {\n            word += &sentence[i..];\n        }\n    }\n\
    \    boredoms", '    // YOUR CODE HERE', "    if is_bored_internal(S.as_bytes())\
    \ != 0\n    {\n        0\n    }\n    else if is_bored_internal(S.as_bytes()).is_err()\n\
    \    {\n        1\n    }\n    else if is_bored_internal(S.as_bytes()).is_ok()\n\
    \    {\n        2\n    }\n    else\n    {\n        3\n    }", "    let mut num_bored\
    \ = 0;\n    let words = S.split_whitespace();\n    for word in words {\n     \
    \   if !word.starts_with(\"I\") {\n            num_bored += 1;\n        }\n  \
    \  }\n    num_bored", "    let mut bored = 0;\n    for s in S.split(|&c| c.is_ascii_letter()\
    \ || c == ' ') {\n        if s.starts_with(\"I\") {\n            bored += 1;\n\
    \        }\n    }\n    bored", "    let mut words = S.split_whitespace();\n\n\
    \    let mut boredoms = 0;\n    let mut i = 0;\n    for word in words {\n    \
    \    i += 1; // to track position within a word\n        if word == \"I\" {\n\
    \            boredoms += 1;\n        }\n    }\n\n    boredoms", "    let mut bored_count\
    \ = 0;\n    let mut sentence_delimiters = vec![\".\", \"?\", \"!\"];\n\n    for\
    \ (i, token) in S.split_whitespace().iter().enumerate() {\n        if token ==\
    \ \"I\" {\n            bored_count += 1;\n        }\n        for delimiter in\
    \ &sentence_delimiters {\n            if token.starts_with(delimiter) {\n    \
    \            bored_count += 1;\n            }\n        }\n    }\n    bored_count",
  "    let mut bored = false;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            bored = true;\n            break;\n        }\n    }\n    bored\
    \ ? 1 : 0", "    let mut words = S.split_whitespace();\n    let mut i = 0;\n \
    \   let mut count = 0;\n    while i < words.len() {\n        if words[i].is_ascii_lowercase()\
    \ && i < words.len() {\n            let mut is_bored = false;\n            if\
    \ words[i] == \"i\" {\n                is_bored = true;\n            } else if\
    \ words[i] == \"?\" || words[i] == \"!\" {\n                count += 1;\n    \
    \            i += 1;\n            } else {\n                i += 1;\n        \
    \    }\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    count", '    S.split(".").filter(|w| w == "I").count() + 1', "   \
    \ let mut bored = 0;\n    let mut delimiters = vec![\".\", \"?\", \"!\"];\n  \
    \  for word in S.split_whitespace() {\n        for delimiter in delimiters {\n\
    \            if word.starts_with(delimiter) {\n                bored += 1;\n \
    \               break;\n            }\n        }\n    }\n    bored", "    let\
    \ mut boredoms: Vec<&str> = vec![];\n    for word in S.split_whitespace() {\n\
    \        if let Some(i) = str_contains_any(&word, \"i\".to_string()) {\n     \
    \       boredoms.push(word.to_string());\n        }\n    }\n\n    // We only want\
    \ to return the count of boredoms, and not a count of sentences.\n    boredoms.iter().filter(|&x|\
    \ x.contains(\".\")).filter(|&x| x.contains(\"?\")).filter(|&x| x.contains(\"\
    !\")).count()", "    loop {\n        let mut is_bored = false;\n        for c\
    \ in S.chars() {\n            if c == 'I' {\n                is_bored = true;\n\
    \                break;\n            }\n        }\n        if is_bored {\n   \
    \         return 1;\n        }\n        S.remove_prefix(1);\n    }", "    let\
    \ boredom = vec![\"I\"];\n    boredom.iter().cloned().map(|s| s.to_lowercase()).filter(|s|\
    \ s.contains(\".\"))\n        .filter(|s| s.contains(\"?\"))\n        .filter(|s|\
    \ s.contains(\"!\"))\n        .count(|s| S == s)", '    if is_bored_impl(S) ==
    1 { 1 } else { 0 }', "    let mut count = 0;\n    let mut bored = false;\n\n \
    \   for word in S.split_whitespace() {\n        count += 1;\n\n        if word\
    \ != \"I\" {\n            bored = true;\n        }\n    }\n\n    bored ? count\
    \ : 0", "    let mut s = S;\n    while !s.is_empty() {\n        let next = if\
    \ let Some(next) = s.split_first_of('.') {\n            next\n        } else {\n\
    \            return 0;\n        };\n        if let Some(next) = s.split_first_of('?')\
    \ {\n            next\n        } else {\n            return 0;\n        };\n \
    \       if let Some(next) = s.split_first_of('!') {\n            next\n      \
    \  } else {\n            return 0;\n        };\n        if next != \"I\" {\n \
    \           return 0;\n        };\n        s = &s[..];\n    }\n    1", "    let\
    \ mut n = S.len();\n    let mut bored_cnt = 0;\n    let mut i = 0;\n    for c\
    \ in S {\n        if c == 'i' || c == 'I' {\n            i += 1;\n        }\n\
    \        if c == '.' || c == '?' || c == '!' {\n            if i == 0 {\n    \
    \            return bored_cnt;\n            }\n            i += 1;\n        }\n\
    \        n -= 1;\n    }\n    return bored_cnt;", "    if is_bored(S.chars().collect::<String>())\
    \ {\n        S.len()\n    } else {\n        0\n    }", "    let mut bored = 0usize;\n\
    \    let mut bored_word: Vec<String> = vec![];\n    let mut pos = 0;\n    for\
    \ c in S.chars() {\n        if let Some(c) = (&c.to_ascii_lowercase() + &c.to_ascii_uppercase()).chars().next()\
    \ {\n            if c == 'I' {\n                bored += 1;\n                if\
    \ pos == 0 {\n                    bored_word.clear();\n                } else\
    \ {\n                    bored_word.push(S.substring(pos, c));\n             \
    \   }\n                pos = c + 1;\n            }\n        } else {\n       \
    \     pos += 1;\n        }\n    }\n    if pos == S.len() {\n        bored += 1;\n\
    \        bored_word.push(S.substr(pos));\n    }\n    if bored_word.is_empty()\
    \ {\n        bored += 1;\n    }\n    bored", "    S\n        .chars()\n      \
    \  .filter_map(|c| {\n            if c.to_ascii_lowercase() == 'i' {\n       \
    \         Some(true)\n            } else {\n                Some(false)\n    \
    \        }\n        })\n        .count()", "    let mut boredom: usize = 0;\n\
    \    let mut i = S.len();\n    while i >0 {\n        let char = S.chars();\n \
    \       if char.next().unwrap().unwrap() == '.' {\n            boredom += 1;\n\
    \        }\n        i -= 1;\n    }\n    boredom", "    let mut boredoms = 0;\n\
    \    let mut s = S.to_string();\n    let mut i = s.len();\n\n    while i > 0 {\n\
    \        if s[i] == ' ' || s[i] == '.' || s[i] == '?' || s[i] == '!' {\n     \
    \       boredoms += 1;\n        }\n        i -= 1;\n    }\n    boredoms", "  \
    \  let mut boredoms: Vec<String> = vec![];\n\n    for (i, word) in S.chars().enumerate()\
    \ {\n        match word.to_string() {\n            \"I\" => boredoms.push(S.clone()),\n\
    \            \".\" | \"?\" | \"!\" => (),\n            _ => {}\n        }\n  \
    \  }\n    boredoms.len()", "    let mut count = 0;\n    let mut words = S.split('.');\n\
    \    for w in words {\n        if w == \"I\" {\n            count += 1;\n    \
    \    }\n    }\n    count", '    S.chars().enumerate().find(|&(ref i, _)| i > 0
    && S[0..i].starts_with("I"))', "    let mut counter = 0;\n    let mut words =\
    \ S.split_whitespace();\n    while !words.next().is_none() {\n        let mut\
    \ word: String = words.next().unwrap();\n        if word.starts_with(\"I\") {\n\
    \            counter += 1;\n        }\n    }\n    counter", "    S.len() / 2 +\
    \ S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 3", "    let\
    \ mut cnt = 0;\n    for s in S.chars().filter_map(|c|\n        match c {\n   \
    \         '.' => Some(true),\n            '?' => Some(true),\n            '!'\
    \ => Some(true),\n            _ => None,\n        }\n    ).filter(|&&x| x.is_some()).rev()\
    \ {\n        if s == Some('I') {\n            cnt += 1;\n        } else {\n  \
    \          break;\n        }\n    }\n    cnt", "    // TODO: Your code here\n\
    \    let mut bored_str = \"\";\n    for s in S.split_whitespace() {\n        if\
    \ s.is_bored() {\n            bored_str += &*s;\n        }\n    }\n    bored_str.count(\"\
    I\".to_string())", "    let mut counter = 0;\n    let mut words = S.split_whitespace();\n\
    \n    for w in words {\n        if w.as_str() == \"I\".as_str() {\n          \
    \  counter += 1;\n        }\n    }\n\n    counter", '    // Your code here...',
  "    let mut count = S.len();\n    let mut boredoms: Vec<&str> = vec![];\n    for\
    \ w in S.split_whitespace() {\n        if w.starts_with(\"I\") {\n           \
    \ count -= 1;\n        } else {\n            boredoms.push(w);\n        }\n  \
    \  }\n    if boredoms.is_empty() {\n        0\n    } else {\n        boredoms.iter().count(|&w|\
    \ w == \".\" || w == \"?\" || w == \"!\")\n    }", "    let mut I = 0;\n    let\
    \ mut B = 0;\n    let mut dot = 0;\n    let mut question = 0;\n    let mut exclamation\
    \ = 0;\n    for x in S.chars() {\n        if x == 'I' {\n            I += 1;\n\
    \        } else if x == '.' {\n            dot += 1;\n        } else if x == '?'\
    \ {\n            question += 1;\n        } else if x == '!' {\n            exclamation\
    \ += 1;\n        }\n    }\n    (I * 2 + dot * 2 + question * 2 + exclamation *\
    \ 2) + (I - dot)", "    let mut count = 1; // count boredoms found\n    let mut\
    \ has_I = false;\n\n    for c in S.chars() {\n        match c {\n            '.'\
    \ | '?' | '!' | ' ' => {\n                count = 1;\n            }\n        \
    \    _ => if c == 'I' {\n                has_I = true;\n            }\n      \
    \  }\n    }\n\n    if !has_I {\n        return 0;\n    }\n    count += 1;\n  \
    \  return count;", "    let mut bored = 0;\n    let mut lower = S.chars().nth(1).unwrap();\n\
    \    let mut upper = S.chars().nth(S.len() - 1).unwrap();\n    let mut i = 1;\n\
    \n    // Iterate from right to left over the string\n    while i < S.len() {\n\
    \        // If this character is a question mark\n        if S[i] == '?' {\n \
    \           // Skip all characters to the end\n            i += S.len() - i;\n\
    \            // If this character is a question mark\n            if S[i] == '?'\
    \ {\n                // Check if previous character was a period\n           \
    \     if S[i-1] == '.' {\n                    // If previous character was a period,\
    \ set upper = previous character\n                    if i > 0 {\n           \
    \             upper = S[i-1];\n                    }\n                } else {\n\
    \                    // If the previous character was anything but a period, increment\
    \ bored\n                    bored++;\n                }\n                // If\
    \ this is a question mark, the current character is now the previous character\n\
    \                i += 1;\n            } else {\n                // If the current\
    \ character is a period, increment bored and set lower to the current character\n\
    \                bored++;\n                lower = S[i];\n                // Skip\
    \ all characters to the end\n                i += S.len() - i;\n            }\n\
    \        } else {\n            // If the current character is a period, increment\
    \ bored and set lower to the current character\n            bored++;\n       \
    \     lower = S[i];\n            // Skip all characters to the end\n         \
    \   i += S.len() - i;\n        }\n    }\n    bored + 1 + is_bored(lower) + is_bored(upper)",
  "    S.split_whitespace().filter(|x| x.chars().any(|y| y == '.'))\n        .count()",
  "    S.rfind('.')\n        .or_else(|| S.rfind('?'))\n        .or_else(|| S.rfind('!'))\n\
    \        .unwrap_or(0)", "    let mut count = 0;\n    for ch in S.chars() {\n\
    \        match ch {\n            '.' | '?' | '!' => continue,\n            'I'\
    \ => {\n                if count == 0 {\n                    count = 1;\n    \
    \            } else {\n                    count = 1;\n                }\n   \
    \             continue;\n            }\n            _ => count += 1,\n       \
    \ }\n    }\n    count", "    let mut count = 0;\n    for s in S.split('.') {\n\
    \        count += 1;\n        for w in s.split('?') {\n            count += 1;\n\
    \            for w in s.split('!') {\n                count += 1;\n          \
    \  }\n        }\n    }\n    count", "    S.chars().filter_map(|c| {\n        if\
    \ c.is_ascii_lowercase() {\n            if c.is_ascii_uppercase() || c.is_ascii_alphanumeric()\
    \ {\n                Some(c.to_string())\n            } else {\n             \
    \   None\n            }\n        } else {\n            None\n        }\n    }).filter(|s|\
    \ s.is_ascii_alphanumeric()).count() == 0", "    let mut bored_words = vec![];\n\
    \    let mut bored_sentences = vec![];\n    for s in S.split() {\n        if let\
    \ Ok(s) = s.split_whitespace() {\n            if s.starts_with(\"I\") {\n    \
    \            bored_sentences.push(s);\n            } else {\n                bored_words.push(s);\n\
    \            }\n        }\n    }\n    bored_words.iter().filter(|word| {\n   \
    \     bored_sentences.iter().any(|sentence| {\n            sentence.starts_with(word)\n\
    \        })\n    }).count()", "    let mut counter = 0;\n    for word in S.split()\
    \ {\n        if word.len() > 0 {\n            if word.to_ascii_lowercase()[0]\
    \ == 'i' {\n                counter += 1;\n            }\n        }\n    }\n \
    \   counter", "    let mut boredom = false;\n    let mut bored = 0;\n    for (i,\
    \ c) in S.chars().enumerate() {\n        bored += is_bored_word(c, i);\n     \
    \   if i == 0 {\n            boredom = c != 'I';\n        }\n    }\n    bored",
  "    let mut i = 0;\n    for s in S.split() {\n        if s.len() == 1 && s.starts_with(\"\
    I\") {\n            i += 1;\n        }\n    }\n    i", "    let mut counts: Vec<usize>\
    \ = vec![];\n    let mut words = vec![];\n    for (i, s) in S.chars().enumerate()\
    \ {\n        if s == ' ' {\n            if !words.is_empty() {\n             \
    \   counts.push(i);\n            }\n            words = vec![];\n        } else\
    \ if s == '.' || s == '?' || s == '!' {\n            if !words.is_empty() {\n\
    \                words.push(i);\n            }\n        } else {\n           \
    \ words.push(i);\n        }\n    }\n\n    if !words.is_empty() {\n        counts.push(i);\n\
    \    }\n    counts.iter().filter(|&x| x == 1).count()", '    boredoms(S).next()',
  "    match (S.chars().skip_while(|&c| !c.is_ascii()).take(5).collect::<Vec<_>>())\
    \ {\n        \"I\" => 0,\n        \"I!\" => 1,\n        \"I?\" => 1,\n       \
    \ \"I..\" => 1,\n        \"I...\" => 1,\n        _ => 0,\n    }", "    S.chars()\n\
    \        .filter(|&c| c != '.' && c != '?' && c != '!')\n        .count(|c| c\
    \ == 'I')", "    let mut idx = 0;\n    let mut in_boredom = false;\n    while\
    \ idx < S.len() {\n        let c = S[idx as usize];\n        if c == '.' || c\
    \ == '?' || c == '!' {\n            idx += 1;\n            in_boredom = true;\n\
    \        } else if c == 'I' {\n            idx += 1;\n            in_boredom =\
    \ true;\n        } else {\n            idx += 1;\n        }\n        if in_boredom\
    \ {\n            break;\n        }\n    }\n    idx as isize", '    S.rfind(".")',
  "    debug_assert!(S.len() > 0);\n    debug_assert!(S.len() <= MAX_STR_LEN);\n \
    \   let mut cnt = 0;\n    for ch in S.chars() {\n        if ch.is_ascii() {\n\
    \            if ch == ' ' || ch == '.' || ch == '?' || ch == '!' {\n         \
    \       cnt += 1;\n            }\n        } else {\n            cnt += 2;\n  \
    \      }\n    }\n    cnt", "    let mut counter = 0;\n    let mut words = split_sentence(&S);\n\
    \    loop {\n        counter += 1;\n        if words[0] == \"I\" {\n         \
    \   break;\n        }\n        words = words.next();\n    }\n    counter", " \
    \   let mut num_bored = 0;\n    let mut s = S;\n    while !s.is_empty() {\n  \
    \      match s.chars().next() {\n            Some('.') => (),\n            Some('?')\
    \ => (),\n            Some('!') => (),\n            Some(_) => (),\n         \
    \   None => (),\n        }\n        match s.chars().next() {\n            Some('I')\
    \ => (),\n            Some(_) => (),\n            None => (),\n        }\n   \
    \     match s.chars().next() {\n            Some(_) => (),\n            None =>\
    \ (),\n        }\n        match s.chars().next() {\n            Some(_) => (),\n\
    \            None => (),\n        }\n        match s.chars().next() {\n      \
    \      Some(_) => (),\n            Some(_) => (),\n            None => (),\n \
    \       }\n        match s.chars().next() {\n            Some(_) => (),\n    \
    \        Some(_) => (),\n            None => (),\n        }\n        match s.chars().next()\
    \ {\n            Some(_) => (),\n            Some(_) => (),\n            None\
    \ => (),\n        }\n        match s.chars().next() {\n            Some(_) =>\
    \ (),\n            Some(_) => (),\n            None => (),\n        }\n      \
    \  match s.chars().next() {\n            Some(_) => (),\n            Some(_) =>\
    \ (),\n            None => (),\n        }\n        match s.chars().next() {\n\
    \            Some(_) => (),\n            Some(_) => (),\n            None => (),\n\
    \        }\n        match s.chars().next() {\n            Some(_) => (),\n   \
    \         Some(_) => (),\n            None => (),\n        }\n        match s.chars().next()\
    \ {\n            Some(_) => (),\n            Some(_) => (),\n            None\
    \ => (),\n        }\n        match s.chars().next() {\n            Some(_) =>\
    \ (),\n            Some(_) => (),\n            None => (),\n        }\n      \
    \  match s.chars().next() {\n            Some(_) => (),\n            Some(_) =>\
    \ (),\n            None => (),\n        }\n        match s.chars().next() {\n\
    \            Some(_) => (),\n            Some(_) => (),\n            None => (),\n\
    \        }\n        match s.chars().next() {\n            Some(_) => (),\n   \
    \         Some(_) => (),\n            None => (),\n        }\n        match s.chars().next()\
    \ {\n            Some(_) => (),\n            Some(_) => (),\n            None\
    \ => (),\n        }\n        match s.chars().next() {\n            Some(_) =>\
    \ (),\n            Some(_) => (),\n            None => (),", "    let mut boredom\
    \ = true;\n    let mut counter = 0;\n    let mut current_word = S;\n\n    while\
    \ boredom && current_word.len() > 0 {\n        if current_word.starts_with(\"\
    I\") {\n            boredom = false;\n        }\n        current_word = current_word.next();\n\
    \        counter += 1;\n    }\n    counter", "    S.chars().filter(|c| c == 'I'\
    \ || c == '.' || c == '?' || c == '!')\n        .filter(|c| !is_bored(&c.to_string()))\n\
    \        .count()", "    S.lines().map(|s| s.chars().count(|c| c == '.' || c ==\
    \ '?' || c == '!')).sum()", '    // Your code here', "    // TODO(burnik): Can\
    \ we make this faster?\n    // Iterate through all words.\n    for word in S.split_whitespace()\
    \ {\n        assert!(word == \"I\" || word == \"!\" || word == \"?\" || word ==\
    \ \".\");\n    }\n    // Count the number of words with an \"I\" in them.\n  \
    \  S.split_whitespace().iter().filter_map(|w| {\n        if w == \"I\" {\n   \
    \         Some(w)\n        } else {\n            None\n        }\n    }).count()",
  "    S.trim().replace(\"?\", \"\").replace(\"!\", \"\").chars().filter(|&x| x ==\
    \ 'I').count() == 3", "    let mut counter = 0;\n    let mut words = S\n     \
    \   .lines()\n        .filter_map(|s| s.chars().filter_map(|c| match c {\n   \
    \         '.' => true,\n            '?' => true,\n            '!' => true,\n \
    \           _ => false,\n        }))\n        .collect();\n    let mut first_word\
    \ = false;\n    let mut first_sentence = false;\n    for word in words {\n   \
    \     if first_word {\n            if first_sentence {\n                if word\
    \ == \"I\" {\n                    counter += 1;\n                }\n         \
    \   } else {\n                if word == \"I\" {\n                    counter\
    \ += 1;\n                }\n            }\n        } else {\n            if word\
    \ == \"I\" {\n                first_word = true;\n                first_sentence\
    \ = false;\n            } else {\n                if word == \".\" || word ==\
    \ \"?\" || word == \"!\" {\n                    first_word = true;\n         \
    \           first_sentence = true;\n                }\n            }\n       \
    \ }\n    }\n    counter", "    let mut boredoms: isize = 0;\n    let mut i = 0;\n\
    \    while i < S.len() {\n        let s = S[i];\n        i += 1;\n        if s\
    \ == '.' || s == '!' || s == '?' {\n            boredoms += 1;\n        }\n  \
    \      if i == S.len() {\n            return boredoms;\n        }\n    }\n   \
    \ 0", "    if is_bored_helper(S).is_some() {\n        1\n    } else {\n      \
    \  0\n    }", "    let mut counter = 0usize;\n    for (i, word) in S.char_indices().filter_map(|it|\
    \ {\n        if let Some(c) = it.next() {\n            if c == '.' || c == '?'\
    \ || c == '!' {\n                counter = counter + 1;\n            }\n     \
    \   }\n        it.next()\n    }) {\n        if word.starts_with(\"I'\") {\n  \
    \          counter = counter + 1;\n        }\n    }\n    counter", "    S.chars()\n\
    \        .filter(|c| c == '.' || c == '?' || c == '!')\n        .count(|c| c ==\
    \ 'I')", "    let mut count = 0;\n    let mut boredoms: Vec<&str> = vec![];\n\
    \    for (i, &word) in S.split_whitespace().enumerate() {\n        let mut pos\
    \ = i;\n        while pos < S.len() && S[pos] == ' ' {\n            pos += 1;\n\
    \        }\n        if pos != i {\n            boredoms.push(&S[i..pos]);\n  \
    \      }\n    }\n    for boredom in boredoms {\n        if boredom.starts_with(\"\
    I\") {\n            count += 1;\n        }\n    }\n    count", "    let mut bored\
    \ = 0;\n    let mut i = 0;\n    for word in S.chars().filter(|c| !c.is_ascii_letter()).take(100)\
    \ {\n        if i == 0 {\n            if word == 'I' {\n                i += 1;\n\
    \            }\n        } else {\n            if word == ('.' || '?' || '!') {\n\
    \                i += 1;\n            }\n        }\n    }\n    bored", "    let\
    \ mut count = 0 as isize;\n    let mut word = S;\n    loop {\n        if word.starts_with(\"\
    I\") {\n            count += 1;\n            word = word.trim_start_matches(\"\
    .!?\");\n        } else {\n            break;\n        }\n    }\n    count", " \
    \   let mut cnt = S.len();\n    for ch in S {\n        if ch == '!' || ch == '.'\
    \ || ch == '?' {\n            cnt += 1;\n        }\n    }\n    cnt", "    let\
    \ mut boredom_count = 0;\n    for (i, word) in S.split_whitespace().into_iter().enumerate()\
    \ {\n        let word = word.to_string();\n        boredom_count += word.starts_with(\"\
    I\");\n    }\n    boredom_count", "    // split input into sentences, ignoring\
    \ periods, question marks and exclamation marks\n    let mut sentences = S.split(\"\
    [.?!]\").collect::<Vec<&str>>();\n    let mut boredoms = 0;\n    for sentence\
    \ in sentences {\n        // skip all but the first word, because that indicates\
    \ boredom\n        if let Some(word) = sentence.split_whitespace().next() {\n\
    \            if word == \"I\" {\n                boredoms += 1;\n            }\n\
    \        }\n    }\n    return boredoms;", "    let mut cnt: isize = 0;\n    let\
    \ mut start = String::new();\n    let mut end = String::new();\n    let mut last:\
    \ &mut String = null;\n    for s in S.chars() {\n        match s {\n         \
    \   ' ' => (),\n            '.' => start = \"\",\n            '?' => start = \"\
    \",\n            '!' => start = \"\",\n            c => {\n                if\
    \ start.is_empty() {\n                    start = &c.to_string();\n          \
    \          last = &c;\n                } else {\n                    if start.starts_with(last.as_str())\
    \ {\n                        last.clear();\n                    } else {\n   \
    \                     cnt += 1;\n                    }\n                    start\
    \ = &c.to_string();\n                    last = &c;\n                }\n     \
    \       }\n        }\n    }\n    cnt", "    if !S.is_empty() {\n        let mut\
    \ is_bored = true;\n        let mut prev_char = S[0];\n        for c in S.chars()\
    \ {\n            if c == '?' || c == '!' || c == '.' {\n                is_bored\
    \ = false;\n            }\n            if c == prev_char {\n                is_bored\
    \ = true;\n            }\n            prev_char += 1;\n        }\n        if is_bored\
    \ {\n            return 1;\n        }\n    }\n    return 0;", '    S.split(".").map(|w|
    if w == String::from("I") { return 1 }).sum()', "    let mut I: isize = 0;\n \
    \   let mut found = false;\n    let mut prev_start = 0;\n    for c in S.chars()\
    \ {\n        if c == '.' {\n            if found {\n                I = I + 1;\n\
    \                found = false;\n            } else {\n                found =\
    \ true;\n            }\n        } else if c == '?' {\n            found = true;\n\
    \        } else if c == '!' {\n            if found {\n                I = I +\
    \ 1;\n            } else {\n                found = true;\n            }\n   \
    \     } else if c == 'I' {\n            if !found {\n                I = I + 1;\n\
    \            }\n        } else {\n            found = true;\n        }\n    }\n\
    \n    if found {\n        I = I + 1;\n    }\n\n    I", "    let mut count_boredom:\
    \ isize = 0;\n    for word in S.split_whitespace() {\n        if word == \"I\"\
    \ || word == \"I'\" || word == \"i\" {\n            count_boredom++;\n       \
    \ }\n    }\n    return count_boredom;", "    let mut boredom = Vec::new();\n \
    \   for c in S.chars() {\n        match c {\n            'I' | '.' | '?' | '!'\
    \ => boredom.push(true),\n            _ => boredom.push(false),\n        }\n \
    \   }\n    boredom.iter().filter(|&b| b).count() as isize", '    count_boredoms(S,
    "")', '    boredom_count(&S).unwrap()', "    // write code here\n    let mut boredCount\
    \ = 0;\n    let mut sentence_end = S.clone();\n    let mut first_token = String::new();\n\
    \    loop {\n        if sentence_end == \".\" || sentence_end == \"?\" || sentence_end\
    \ == \"!\" {\n            break;\n        }\n        let first_char: Char = sentence_end.chars().next().unwrap();\n\
    \        if first_char == 'I' && first_token == \"I\" {\n            boredCount+=1;\n\
    \        }\n        sentence_end = &sentence_end[1..];\n        first_token =\
    \ first_char.to_string();\n    }\n    return boredCount;", "    let mut num =\
    \ 0;\n    let mut idx = 0;\n    let mut word: &str;\n    while idx < S.len() {\n\
    \        word = &S[idx..].to_ascii_lowercase();\n        if !word.is_ascii_lowercase()\
    \ {\n            break;\n        }\n        if word == \"i\" {\n            num\
    \ +=1;\n        }\n        idx += 1;\n    }\n    num", "    let mut bored = 0;\n\
    \    for (i, c) in S.chars().enumerate() {\n        if c.is_lowercase() && i >\
    \ 0\n            && &S[i] != &S[i-1]\n            && &S[i] != &S[i+1]\n      \
    \      && &S[i] != &S[i+2]\n            && &S[i] != &S[i+3]\n            && &S[i]\
    \ != &S[i+4]\n            && &S[i] != &S[i+5]\n            && &S[i] != &S[i+6]\n\
    \            && &S[i] != &S[i+7]\n            && &S[i] != &S[i+8]\n        {\n\
    \            bored += 1;\n        }\n    }\n    bored", "    S.chars().filter(|c|\
    \ *c != 'I').count() + is_bored_str(&S)", "    S.chars().filter_map(|c|\n    \
    \    match (c) {\n            '.' => Some(_),\n            '?' => Some(_),\n \
    \           '!' => Some(_),\n            _ => None,\n        }\n    ).count()\
    \ == 3", "    let boredom = vec![\"I\"];\n    let mut count = 0;\n    let mut\
    \ word_index = 0;\n    while word_index < S.len() {\n        // if we've reached\
    \ the end of the string...\n        if word_index >= S.len()-1 {\n           \
    \ return count;\n        }\n        // if this char is a boredom...\n        if\
    \ let Ok(ch) = S[word_index] {\n            if boredom.contains(&ch) {\n     \
    \           count = count + 1;\n            }\n        }\n        // otherwise\
    \ increment the current index...\n        word_index = word_index + 1;\n    }\n\
    \    // return 0 if we've reached the end of the string...\n    count", "    let\
    \ mut I: isize = 0;\n    for word in S.split() {\n        if word == \"I\" {\n\
    \            I+=1;\n        }\n    }\n    return I;", "    S\n        .split_whitespace()\n\
    \        .filter(|w| w.starts_with(\"I\"))\n        .count()", "    // BEGIN Practice\
    \ \n    let mut boredoms = 0;\n    let mut boredom_counter = 0;\n    let mut boredom_counter2\
    \ = 0;\n    let mut boredom_counter3 = 0;\n    let mut boredom_counter4 = 0;\n\
    \    let mut boredom_counter5 = 0;\n    let mut boredom_counter6 = 0;\n    let\
    \ mut boredom_counter7 = 0;\n    let mut boredom_counter8 = 0;\n    let mut boredom_counter9\
    \ = 0;\n    let mut boredom_counter10 = 0;\n    let mut boredom_counter11 = 0;\n\
    \    let mut boredom_counter12 = 0;\n    let mut boredom_counter13 = 0;\n    let\
    \ mut boredom_counter14 = 0;\n    let mut boredom_counter15 = 0;\n    let mut\
    \ boredom_counter16 = 0;\n    let mut boredom_counter17 = 0;\n    let mut boredom_counter18\
    \ = 0;\n    let mut boredom_counter19 = 0;\n    let mut boredom_counter20 = 0;\n\
    \    let mut boredom_counter21 = 0;\n    let mut boredom_counter22 = 0;\n    let\
    \ mut boredom_counter23 = 0;\n    let mut boredom_counter24 = 0;\n    let mut\
    \ boredom_counter25 = 0;\n    let mut boredom_counter26 = 0;\n    let mut boredom_counter27\
    \ = 0;\n    let mut boredom_counter28 = 0;\n    let mut boredom_counter29 = 0;\n\
    \    let mut boredom_counter30 = 0;\n    let mut boredom_counter31 = 0;\n    let\
    \ mut boredom_counter32 = 0;\n    let mut boredom_counter33 = 0;\n    let mut\
    \ boredom_counter34 = 0;\n    let mut boredom_counter35 = 0;\n    let mut boredom_counter36\
    \ = 0;\n    let mut boredom_counter37 = 0;\n    let mut boredom_counter38 = 0;\n\
    \    let mut boredom_counter39 = 0;\n    let mut boredom_counter40 = 0;\n    let\
    \ mut boredom_counter41 = 0;\n    let mut boredom_counter42 = 0;\n    let mut\
    \ boredom_counter43 = 0;\n    let mut boredom_counter44 = 0;\n    let mut boredom_counter45\
    \ = 0;\n    let mut boredom_counter46 = 0;\n    let mut boredom_counter47 = 0;\n\
    \    let mut boredom_counter48 = 0;\n    let mut boredom_counter49 = 0;\n    let\
    \ mut boredom_counter50 = 0;\n    let mu", "    // TODO: Your code here\n    let\
    \ mut count = 0;\n    for (i, word) in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            count += 1;\n        }\n    }\n    count", "    S.lines()\n\
    \        .filter(|s| s == \"I\" || s == \"!\" || s == \"?\")\n        .count()\
    \ > 1", "    S.chars().filter(|c| *c == '.' || c == '?' || c == '!')\n       \
    \ .count(|c| c == 'I')", "    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    for x in S.chars() {\n        if x == ' ' {\n            i += 1;\n\
    \        }\n        if x == '.' {\n            i += 1;\n        }\n        if\
    \ x == '?' {\n            i += 1;\n        }\n        if x == '!' {\n        \
    \    i += 1;\n        }\n        if x == 'I' {\n            i += 1;\n        }\n\
    \        if x == '.' || x == '?' || x == '!' || x == 'I'\n        {\n        \
    \    i += 1;\n            j += 1;\n        }\n        if x == '.' {\n        \
    \    i += 1;\n        }\n        if x == '?' {\n            i += 1;\n        }\n\
    \        if x == '!' {\n            i += 1;\n        }\n        if x == 'I'\n\
    \        {\n            i += 1;\n        }\n        if x == '.' || x == '?' ||\
    \ x == '!' || x == 'I'\n        {\n            i += 1;\n            j += 1;\n\
    \        }\n        if x == '.' {\n            i += 1;\n        }\n        if\
    \ x == '?' {\n            i += 1;\n        }\n        if x == '!' {\n        \
    \    i += 1;\n        }\n        if x == 'I'\n        {\n            i += 1;\n\
    \        }\n        if x == '.' || x == '?' || x == '!' || x == 'I'\n        {\n\
    \            i += 1;\n            j += 1;\n        }\n        if x == '.' {\n\
    \            i += 1;\n        }\n        if x == '?' {\n            i += 1;\n\
    \        }\n        if x == '!' {\n            i += 1;\n        }\n        if\
    \ x == 'I'\n        {\n            i += 1;\n        }\n        if x == '.' ||\
    \ x == '?' || x == '!' || x == 'I'\n        {\n            i += 1;\n         \
    \   j += 1;\n        }\n        if x == '.' {\n            i += 1;\n        }\n\
    \        if x == '?' {\n            i += 1;\n        }\n        if x == '!' {\n\
    \            i += 1;\n        }\n        if x == 'I'\n        {\n            i\
    \ += 1;\n        }\n        if x == '.' || x == '?' || x == '!' || x == 'I'\n\
    \        {\n            i += 1;\n            j += 1;\n        }\n        if x\
    \ == '.' {\n            i += 1;\n        }\n        if x == '?' {\n          \
    \  i += 1;\n        }\n        if x == '!' {\n            i += 1;\n        }\n\
    \        if x == 'I'\n        {\n            i += 1;\n        }\n        if x\
    \ == '.' || x == '?' || x == '!' || x == 'I'\n        {\n            ", '    count_boredoms(S,
    BoredomDelimiter::All)', "    S.chars().filter(|c| c == '.' || c == '?' || c ==\
    \ '!').count() > 2", "    let mut bored_words: isize = 0;\n    for ch in S.chars()\
    \ {\n        if ch.is_space() {\n            continue;\n        }\n\n        if\
    \ ch.is_punctuation() {\n            if ch.is_punctuation('.') || ch.is_punctuation('!')\
    \ || ch.is_punctuation('?') {\n                continue;\n            }\n    \
    \    }\n\n        bored_words += 1;\n    }\n\n    bored_words", '    boredom_count(S).0',
  "    if is_bored_impl(&S.as_bytes(), \".\", \"?\", \"!\").unwrap_or(0) == 0 {\n\
    \        0\n    } else {\n        1\n    }", "    if S == \"\" {\n        return\
    \ 0;\n    }\n\n    let mut bored_count = 0;\n    for w in S.split_whitespace()\
    \ {\n        if w.starts_with(\"I\") {\n            bored_count += 1;\n      \
    \  }\n    }\n    bored_count", '    ', "    let mut count = S.len();\n    let\
    \ mut bored_sentence = false;\n    for word in S.split(\" \") {\n        if word.starts_with(\"\
    I\") {\n            bored_sentence = true;\n        }\n        if bored_sentence\
    \ {\n            count--;\n        }\n    }\n    count", "    if S.is_empty()\
    \ || S.is_below_str(String::from(\"I\")) {\n        return 0;\n    }\n    let\
    \ mut i = 0;\n    for c in S.chars() {\n        if c == '.' || c == '?' || c ==\
    \ '!' {\n            i += 1;\n        }\n    }\n    i + 1", "    let mut count\
    \ = 0u64;\n    S.chars().for_each(|c|{\n        match c {\n            '.' | '?'\
    \ | '!' => count+=1,\n            _ => (),\n        }\n    });\n    count", " \
    \   let mut count = 0;\n    for (i, item) in S.chars().enumerate().filter(|(_,\
    \ c)| c.is_ascii_letter()) {\n        let char = item as u8;\n        if char\
    \ == b'I'\n            || char == b'!' || char == b'?' || char == b'!' || char\
    \ == b'?'\n            || char == b'!' || char == b'?' || char == b'?' || char\
    \ == b'!'\n        {\n            count += 1;\n        }\n    }\n    count", " \
    \   let mut boredom = S.split_whitespace();\n    boredom.next();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap", "    let mut i = 0;\n    for ch in S.chars() {\n\
    \        match ch {\n            '.' | '?' | !'I ' as _ => i += 1,\n         \
    \   _ => {}\n        }\n    }\n    i", "    S.chars()\n        .filter(|c| !c.is_alphanumeric())\n\
    \        .filter(|c| !c.is_punctuation())\n        .filter(|c| !c.is_whitespace())\n\
    \        .count(|c| c == 'I')", "    let mut n = 0;\n    let mut boredoms: Vec<&str>\
    \ = vec![];\n    for &s in S.split('.') {\n        if !boredoms.contains(&s[0])\
    \ {\n            if s[0] == \"I\" {\n                boredoms.push(&s);\n    \
    \        } else {\n                boredoms.push(s);\n            }\n        }\
    \ else {\n            boredoms.remove(&s[0]);\n        }\n    }\n    for &s in\
    \ boredoms {\n        n += 1;\n    }\n    n", "    let mut is_bored = 0;\n   \
    \ let mut s = S.to_string();\n    let mut words: Vec<String> = Vec::new();\n \
    \   while !s.is_empty() {\n        if s.starts_with(\"I\") {\n            words\
    \ = s.split_whitespace().collect();\n            is_bored += 1;\n        }\n \
    \       s = &s[..];\n    }\n    is_bored", "    if is_boredom_end(S)\n       \
    \ || (S.len() == 1 && S[0] == 'I')\n        || (S.len() == 2 && S[0] == 'I' &&\
    \ S[1] == '.')\n        || (S.len() == 3 && S[0] == 'I' && S[1] == '.' && S[2]\
    \ == '!')\n    {\n        1\n    } else {\n        0\n    }", "    let mut count\
    \ = 0;\n    for s in S.split() {\n        if s.starts_with(\"I\") {\n        \
    \    count = count + 1;\n        }\n    }\n    count", "    let mut boredom =\
    \ S.to_string();\n    boredom.replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . .\", \".\")\n  \
    \      .replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . . .\
    \ . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n        .replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\"\
    , \".\").replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . . .\
    \ . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n\
    \        .replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . .\
    \ . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n        .replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\"\
    , \".\").replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . . .\
    \ . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . .\", \".\")\n  \
    \      .replace(\". . . . . . . . . . .\", \".\").replace(\". . . . . . . . .\
    \ . .\", \".\").replace(\". . . . . . . . . . .\", \".\")\n        .replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . ", "    let mut boredoms = 0;\n    let mut sentences = split_sentence(S);\n\
    \    for sentence in sentences {\n        if sentence.starts_with(\"I\") {\n \
    \           boredoms++;\n        }\n    }\n    return boredoms;", "    let mut\
    \ idx = 0;\n\n    while idx < S.len() {\n        if S[idx] == 'I' {\n        \
    \    if idx+1 < S.len() {\n                if S[idx+1] == '.' || S[idx+1] == '?'\
    \ || S[idx+1] == '!' {\n                    idx += 3;\n                } else\
    \ {\n                    idx += 2;\n                }\n            } else {\n\
    \                idx += 1;\n            }\n        } else {\n            idx +=\
    \ 1;\n        }\n    }\n\n    idx", "    let mut boredoms: isize = 0;\n    let\
    \ mut words: Vec<String> = S.split(\" \").collect();\n    for word in words {\n\
    \        boredoms += match word {\n            \"I\" => 1,\n            \".\"\
    \ => 1,\n            \"?\" => 1,\n            \"!\" => 1,\n            _ => 0,\n\
    \        };\n    }\n    boredoms", "    let mut boredom = String::new();\n   \
    \ for (i, c) in S.chars().enumerate() {\n        if c == '.' || c == '?' || c\
    \ == '!' {\n            boredom = S\n                .to_string()\n          \
    \      .split_whitespace()\n                .skip(i)\n                .next()\n\
    \                .unwrap();\n            break;\n        }\n    }\n    boredom.len()",
  "    let mut cnt = 0;\n    let mut s = S;\n    s.replace('!', ' ');\n    s.replace('?',\
    \ ' ');\n    s.replace('.', ' ');\n    s.replace('i', ' ');\n    s.replace('e',\
    \ ' ');\n    s.replace('r', ' ');\n    s.replace('n', ' ');\n    s.replace('t',\
    \ ' ');\n    s.replace('s', ' ');\n    s.replace('u', ' ');\n    s.replace('v',\
    \ ' ');\n    s.replace('w', ' ');\n    s.replace('l', ' ');\n    s.replace('o',\
    \ ' ');\n    s.replace('p', ' ');\n    s.replace('d', ' ');\n    s.replace('j',\
    \ ' ');\n    s.replace('g', ' ');\n    s.replace('h', ' ');\n    s.replace('f',\
    \ ' ');\n    s.replace('z', ' ');\n    s.replace('j', ' ');\n    s.replace('c',\
    \ ' ');\n    s.replace('y', ' ');\n    s.replace('k', ' ');\n    s.replace('g',\
    \ ' ');\n    s.replace('f', ' ');\n    s.replace('y', ' ');\n    s.replace('h',\
    \ ' ');\n    s.replace('v', ' ');\n    s.replace('u', ' ');\n    s.replace('i',\
    \ ' ');\n    s.replace('y', ' ');\n    s.replace('t', ' ');\n    s.replace('f',\
    \ ' ');\n    s.replace('u', ' ');\n    s.replace('i', ' ');\n    s.replace(' ',\
    \ ' ');\n    s.replace('\\n', ' ');\n    s.replace('\\r', ' ');\n    let mut s\
    \ = S;\n    while let Some(c) = (s.chars().find(|&x| *x == ' ')) {\n        cnt\
    \ = cnt + 1;\n        s = s.to_owned();\n    }\n    cnt", "    let mut boredom\
    \ = 0usize;\n    let mut i: usize = S.len();\n    while i != 0usize && S[i..].starts_with(\"\
    I\") {\n        if S[i..].starts_with(\".\")\n            || S[i..].starts_with(\"\
    !\")\n            || S[i..].starts_with(\"?\")\n        {\n            boredom++;\n\
    \        }\n        i--;\n    }\n    boredom", "    let mut count = 0;\n\n   \
    \ let mut i = 0;\n    while i < S.len() {\n        let char = S[i];\n        if\
    \ char == \".\" || char == \"?\" || char == \"!\" {\n            i += 1;\n   \
    \         continue;\n        }\n        if char == \" \" {\n            i += 1;\n\
    \            continue;\n        }\n        break;\n    }\n    i += 1;\n\n    while\
    \ i < S.len() {\n        let char = S[i];\n        if char == \"I\" {\n      \
    \      i += 1;\n            continue;\n        }\n        if char == \" \" {\n\
    \            i += 1;\n            continue;\n        }\n        break;\n    }\n\
    \    i += 1;\n\n    while i < S.len() {\n        let char = S[i];\n        if\
    \ char == \".\" || char == \"?\" || char == \"!\" {\n            i += 1;\n   \
    \         continue;\n        }\n        count += 1;\n        i += 1;\n    }\n\n\
    \    count", "    let mut has_bored = false;\n    for s in S.chars() {\n     \
    \   match s {\n            '.' => has_bored = true,\n            '?' => has_bored\
    \ = true,\n            '!' => has_bored = true,\n            _ => (),\n      \
    \  }\n    }\n    match has_bored {\n        true => 0,\n        false => 1,\n\
    \    }", "    let mut boredom = false;\n    let mut char_count = 0;\n    let mut\
    \ sentence_count = 1;\n\n    for c in S {\n        if c == '.' || c == '?' ||\
    \ c == '!' {\n            if char_count == 0 {\n                boredom = true;\n\
    \            } else {\n                boredom = false;\n            }\n     \
    \   }\n        char_count += 1;\n        if boredom {\n            sentence_count\
    \ += 1;\n        }\n    }\n    return sentence_count;", "    let mut boredoms:\
    \ isize = 0;\n    for word in S.chars() {\n        if word.starts_with(\"I\")\
    \ {\n            boredoms += 1;\n        }\n    }\n    boredoms", "    let mut\
    \ i = S.len();\n    loop {\n        i -= 1;\n        match S[i].rev() {\n    \
    \        \".\" | \"?\" | \"!\" => { i += 1 },\n            _ => continue,\n  \
    \      }\n        return i;\n    }", "    S.chars().filter(|c| c.is_ascii_letter()).filter(|c|\
    \ c.is_ascii_digit()).filter(|c| c == ' ').count() > 3", '    boredoms(S).iter().filter(|&boredom|
    boredom == "I").count()', "    loop {\n        let mut i: isize = 0;\n       \
    \ for w in S.split_whitespace() {\n            if w.starts_with(\"I\") {\n   \
    \             i += 1;\n            }\n        }\n        if i == 0 {\n       \
    \     break;\n        }\n    }\n    i", "    S.split('.').filter(|&x| !x.starts_with(\"\
    I\")).count() ", "    let mut cnt = 0;\n    for s in S.chars() {\n        cnt\
    \ += if s.is_letter()\n            && s != \"I\"\n            && !(s.is_space()\
    \ || s.is_punctuation())\n            && !s.is_ascii()\n            {\n      \
    \          1\n            } else {\n                0\n            };\n    }\n\
    \    cnt", "    let mut I = 0;\n    let mut boredoms: Vec<String> = vec![];\n\
    \    for words in S.split_whitespace() {\n        for word in words.split_ascii_words()\
    \ {\n            if let Some(index) = get_index_boredom(&word) {\n           \
    \     boredoms.push(words.to_string());\n                I = index;\n        \
    \    }\n        }\n    }\n    I", "    let mut bored: isize = 0;\n    let words\
    \ = S.split_whitespace();\n    for i in 0..(words.len() - 1) {\n        if words[i]\
    \ == \"I\" && words[i + 1] == \"I\" {\n            bored += 1;\n        }\n  \
    \  }\n    bored", "    let mut c = 0;\n    for ch in S {\n        match ch {\n\
    \            '.' | '?' | '!' => c += 1,\n            _ => continue,\n        }\n\
    \    }\n    c", "    if is_bored_str(&S) == 0\n        || (is_bored_str(&S) ==\
    \ 1 && S.contains(\".\"))\n        || (is_bored_str(&S) == 1 && S.contains(\"\
    ?\"))\n        || (is_bored_str(&S) == 1 && S.contains(\"!\"))\n    {\n      \
    \  0\n    } else {\n        1\n    }", "    let mut N = 0;\n\n    for w in S.split('.')\
    \ {\n        if w == \"I\" {\n            N += 1;\n        }\n    }\n\n    N",
  "    let mut boredom = 0;\n    \n    for sentence in S.split_whitespace() {\n  \
    \      if let Some(sentence) = sentence.to_lowercase() {\n            if sentence.starts_with(\"\
    i\") {\n                boredom += 1;\n            }\n        }\n    }\n    \n\
    \    boredom", "    // Your code here\n    ", "    let mut is_bored = 0;\n   \
    \ for word in S.split_whitespace() {\n        if word == \"I\" {\n           \
    \ is_bored += 1;\n        }\n    }\n    is_bored", "    let mut bored = vec![\"\
    I\"];\n    let mut words = S.split_whitespace().collect::<Vec<&str>>();\n    loop\
    \ {\n        if !words.next().unwrap().starts_with(\"I\") {\n            return\
    \ 0;\n        }\n        bored.push(words.next().unwrap());\n    }", "    S.trim().chars().filter(|c|\
    \ c == 'I' || c == '.' || c == '?' || c == '!').count() + 1", "    if S == \"\
    I\" || S.starts_with(\"I\") {\n        return 0;\n    }\n\n    let mut count =\
    \ 1;\n    let mut i = 0;\n\n    while i < S.len() {\n        if S[i] == ' ' ||\
    \ S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n        }\
    \ else {\n            break;\n        }\n    }\n\n    for i in 0..count {\n  \
    \      if S[i] == '.' {\n            return i - 1;\n        }\n    }\n\n    count",
  "    let mut counter = 0;\n\n    for word in S.split_whitespace() {\n        if\
    \ !word.starts_with(\"I\") {\n            counter += 1;\n        }\n    }\n\n\
    \    counter", "    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0", "    let mut cnt = 0;\n    for ch in S.chars() {\n        if ch != 'I'\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt", "    let mut cnt = 0;\n\
    \    for ch in S {\n        if ch.is_alphabetic() {\n            cnt += 1;\n \
    \       } else if ch == '.' || ch == '?' || ch == '!' {\n            cnt += 1;\n\
    \        }\n    }\n    cnt", "    let mut words: Vec<String> = S\n        .split_whitespace()\n\
    \        .filter(|w| w.len() > 0)\n        .collect();\n    let mut counts: Vec<usize>\
    \ = Vec::new();\n    let mut j: usize = 0;\n    for word in words {\n        counts.clear();\n\
    \        for (i, char) in word.chars().enumerate() {\n            if char == char::from(\"\
    I\") {\n                counts.push(i);\n            }\n        }\n        if\
    \ counts.len() > 1 {\n            j = counts.iter().max().unwrap_or(usize) + 1;\n\
    \        }\n    }\n    j", '    is_bored_str(&S.split(" "))', "    let mut boredom_words\
    \ = vec![];\n    \n    for word in S.split_whitespace() {\n        match word\
    \ {\n            \"I\".to_string() => boredom_words.push(word),\n            _\
    \ => {\n                boredom_words.clear();\n            }\n        }\n   \
    \ }\n    \n    boredom_words.len()", "    S.chars().filter(|&c| !c.is_ascii()).filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c == ' ' || c == '.' || c == '?' || c == '!').count()\
    \ == 0", "    let boredoms = vec![\n        \"I\",\n        \"me\",\n        \"\
    my\",\n        \"we\",\n        \"our\",\n        \"ours\",\n        \"ourselves\"\
    ,\n        \"you\",\n        \"your\",\n        \"yours\",\n        \"yourself\"\
    ,\n        \"yourselves\",\n        \"he\",\n        \"him\",\n        \"his\"\
    ,\n        \"himself\",\n        \"she\",\n        \"her\",\n        \"hers\"\
    ,\n        \"herself\",\n        \"it\",\n        \"its\",\n        \"itself\"\
    ,\n        \"they\",\n        \"them\",\n        \"their\",\n        \"theirs\"\
    ,\n        \"themselves\",\n        \"what\",\n        \"which\",\n        \"\
    who\",\n        \"whom\",\n        \"this\",\n        \"that\",\n        \"these\"\
    ,\n        \"those\",\n        \"am\",\n        \"is\",\n        \"are\",\n  \
    \      \"was\",\n        \"were\",\n        \"be\",\n        \"been\",\n     \
    \   \"being\",\n        \"have\",\n        \"has\",\n        \"had\",\n      \
    \  \"having\",\n        \"do\",\n        \"does\",\n        \"did\",\n       \
    \ \"doing\",\n        \"a\",\n        \"an\",\n        \"the\",\n        \"and\"\
    ,\n        \"but\",\n        \"if\",\n        \"or\",\n        \"because\",\n\
    \        \"as\",\n        \"until\",\n        \"while\",\n        \"of\",\n  \
    \      \"at\",\n        \"by\",\n        \"for\",\n        \"with\",\n       \
    \ \"about\",\n        \"against\",\n        \"between\",\n        \"into\",\n\
    \        \"through\",\n        \"during\",\n        \"before\",\n        \"after\"\
    ,\n        \"above\",\n        \"below\",\n        \"to\",\n        \"from\",\n\
    \        \"up\",\n        \"down\",\n        \"in\",\n        \"out\",\n     \
    \   \"on\",\n        \"off\",\n        \"over\",\n        \"under\",\n       \
    \ \"again\",\n        \"further\",\n        \"then\",\n        \"once\",\n   \
    \     \"here\",\n        \"there\",\n        \"when\",\n        \"where\",\n \
    \       \"why\",\n        \"how\",\n        \"all\",\n        \"any\",\n     \
    \   \"both\",\n        \"each\",\n        \"few\",\n        \"more\",\n      \
    \  \"most\",\n        \"other\",\n        \"some\",\n        \"such\",\n     \
    \   \"no\",\n        \"nor\",\n        \"not\",\n        \"only\",\n        \"\
    own\",\n        \"same\",\n        \"so\",\n        \"than\",\n        \"too\"\
    ,\n        \"very\",\n        \"s\",\n        \"t\",\n        \"can\",\n     \
    \   \"will\",\n        \"just\",\n        \"don\",\n        \"", "    let mut\
    \ bored_start = 0;\n    let mut bored_end = 0;\n\n    for s in S.split() {\n \
    \       if s == \".\" || s == \"?\" || s == \"!\" {\n            bored_end = s.len();\n\
    \        } else {\n            bored_end = s.len();\n            bored_start =\
    \ bored_end;\n        }\n\n        if bored_start == 0 {\n            continue;\n\
    \        }\n        if s.starts_with(\"I\") {\n            return 1;\n       \
    \ }\n    }\n    0", "    let mut i = 0;\n    S.chars().filter(|&x| x == ' ' ||\
    \ x == '.' || x == '?' || x == '!').for_each(|x| {\n        i = i + (x.as_bytes().to_vec().iter().any(|&b|\
    \ *b == 0x51).unwrap_or(false) as isize);\n    });\n    i", "    let mut n = 0;\n\
    \    S.chars().for_each(|c| {\n        if c == 'I' || c == '.' || c == '?' ||\
    \ c == '!' {\n            n += 1;\n        }\n    });\n    n", '    // Your code
    here', '    S.split(".").count(|&x| x != "I")', "    let mut cnt = 0;\n    for\
    \ (i, s) in S.chars().enumerate() {\n        let word = s.to_string();\n     \
    \   if word.is_ascii() || word.is_lowercase() {\n            cnt += 1;\n     \
    \       cnt += 1 // TODO: handle case where word starts with \"i\"\n        }\
    \ else {\n            // TODO: handle case where word is all punctuation\n   \
    \     }\n    }\n    cnt", "    S.chars().filter(|c| c >= 'I').count()", "    let\
    \ words = S.splitn(3, '.').collect::<Vec<_>>();\n    let mut n = 0;\n    for &w\
    \ in words {\n        n += if w == \"I\" { 1 } else { 0 };\n    }\n    n", " \
    \   let mut bored_count = 0;\n    let mut S = S.to_string();\n\n    for i in S\
    \ {\n        if i != \"I\" {\n            bored_count += 1;\n        }\n    }\n\
    \    bored_count", "    let mut boredom = String::new();\n    boredom.clear();\n\
    \    let mut bored = 0;\n    let mut index = S.find(' ');\n    if index == S.len()\
    \ {\n        bored = 0;\n        return bored;\n    }\n\n    loop {\n        boredom.push_str(&S[..index]);\n\
    \        if S[..index].starts_with(\"I\") {\n            bored = bored + 1;\n\
    \            break;\n        }\n        index = S.find(' ', index);\n        if\
    \ index == S.len() {\n            bored = bored + 1;\n            break;\n   \
    \     }\n        boredom.push_str(&S[..index]);\n    }\n    bored", "    S.split('.').count(|x|\
    \ {\n        x.contains(\"I\")\n    })", "    if is_empty(S) || S == \"I\" ||\
    \ S == \"my\" || S == \"I'm\" || S == \"i'm\" {\n        return 0;\n    }\n\n\
    \    let mut count = 0;\n    let mut idx = 0;\n    while idx < S.len() {\n   \
    \     if S[idx] == '.' || S[idx] == '?' || S[idx] == '!' {\n            count++;\n\
    \        }\n        idx += 1;\n    }\n    count", "    let mut boredoms: isize\
    \ = 0;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"I\") {\n\
    \            boredoms += 1;\n        }\n    }\n    boredoms", "    let mut cnt\
    \ = 0;\n    let mut words = S.split_whitespace();\n    let mut has_boredom = false;\n\
    \    while !words.is_empty() {\n        if words[0] == \"I\" {\n            cnt\
    \ += 1;\n            has_boredom = true;\n        }\n        words = words.next();\n\
    \    }\n    cnt", "    let mut bored = 0;\n    for (i, s) in S.chars().enumerate()\
    \ {\n        if s == \"I\" {\n            bored += 1;\n        }\n        if s.is_whitespace()\
    \ {\n            continue;\n        }\n        if i == 0 {\n            bored\
    \ += 1;\n        }\n        if i == S.len() - 1 {\n            bored += 1;\n \
    \       }\n        if s.is_punctuation() {\n            bored += 1;\n        }\n\
    \    }\n    bored", "    let boredom = vec![\"I\"];\n    let words = S.chars().map(|c|\
    \ match c {\n        c if c.is_digit() => c,\n        c if c.is_ascii_lowercase()\
    \ => c + 1,\n        c if c.is_ascii_uppercase() => c + 1,\n        _ => c,\n\
    \    }).collect();\n    words.iter().filter(|w| boredom.contains(&w)).count()",
  '    if is_bored_impl::<S::Item>()', "    let mut i = 0;\n    loop {\n        i\
    \ = S.len();\n        S += String::from(\".\")[..i];\n        if S == String::from(\"\
    I\") {\n            return i;\n        }\n    }", "    S.chars().filter(|c| *c\
    \ == '.' || c == '?' || c == '!').count() == 0", "    let mut count = 0;\n   \
    \ let mut words = S.split_whitespace();\n    let mut iter = words.iter();\n  \
    \  let mut boredom = iter.next().unwrap();\n    while let Some(word) = {\n   \
    \     if word == \"I\" {\n            count += 1;\n            boredom = Some(word);\n\
    \        } else {\n            iter = words.iter();\n            iter = iter.skip(1).peekable();\n\
    \            count += 1;\n            boredom = Some(iter.next().unwrap());\n\
    \        }\n    }\n    count", "    let mut bored = 0;\n    let mut start = 0;\n\
    \    for &s in S.split_whitespace() {\n        if s.starts_with(\"I\") {\n   \
    \         if start > 0 {\n                bored += 1;\n            }\n       \
    \     start = s.len();\n        } else {\n            bored += s.len() - start;\n\
    \            start = 0;\n        }\n    }\n    bored", "    S.lines()\n      \
    \  .map(|s| {\n            s.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n        })\n        .sum::<bool>()", "    let mut cnt = 0;\n    let mut\
    \ i = 1;\n    for s in S.split_whitespace() {\n        if s == \"I\" {\n     \
    \       i += 1;\n        } else {\n            cnt += i;\n            i = 0;\n\
    \        }\n    }\n    cnt", "    let mut count = S.len();\n    let mut flag =\
    \ false;\n\n    for ch in S {\n        match ch {\n            '.' | '?' | '!'\
    \ => flag = true,\n            _ => (),\n        }\n\n        if flag {\n    \
    \        count -= 1;\n        }\n    }\n\n    count", "    let mut boredoms =\
    \ 0; // Boredoms starts at 0\n    let mut first = true; // Set to true while scanning\
    \ for the first 'I', or the first '.'\n    let mut last = 0; // Last character\
    \ of sentence that started the boredom\n    let mut sentence = String::new();\
    \ // Temporary string to scan for the first 'I', or the first '.'\n    \n    S.chars().filter(|c|\
    \ {\n        if first {\n            first = false;\n            return c.is_ascii_letter()\
    \ || c == '.';\n        }\n        if c == '.' {\n            last = c;\n    \
    \        return false;\n        }\n        if c == '?' || c == '!' {\n       \
    \     return false;\n        }\n        if last == 0 {\n            return true;\n\
    \        }\n        if last != 0 && last != c {\n            boredoms += 1; //\
    \ Increase count for current boredom\n            last = 0; // Set last character\
    \ to 0\n            return false;\n        }\n        \n        sentence = sentence.push(c);\n\
    \        return false;\n    }).count();\n    \n    boredoms", '    S.chars().filter(|c|
    is_bored_char(c)).count() as isize', "    if is_bored(S) == 1 {\n        1\n \
    \   } else {\n        0\n    }", "    let mut boredom = 0.0;\n    for (i, word)\
    \ in S.chars().enumerate() {\n        if *word == 'I' {\n            boredom =\
    \ boredom + 1.0;\n        }\n    }\n    return boredom;", "    S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() > 3", "    let mut counter = 0;\n\
    \    let mut words = S.split_whitespace();\n\n    for word in words {\n      \
    \  if word.to_lowercase() == \"i\" {\n            counter += 1;\n        }\n \
    \   }\n    counter", "    let mut count = 0;\n    let mut s = S;\n    loop {\n\
    \        if s.starts_with(\"I\") {\n            break;\n        }\n        if\
    \ let Some(pos) = s.find('.')? {\n            count += 1;\n            s = &s[pos..];\n\
    \        } else {\n            break;\n        }\n    }\n    count", "    let\
    \ mut boredom = 1;\n    let mut i = 0;\n    while i < S.len() {\n        if S[i]\
    \ == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n            boredom++;\n     \
    \   }\n        i += 1;\n    }\n    boredom", "    let mut is_bored = 0;\n    for\
    \ word in S.split('.') {\n        let word = word.to_lowercase();\n        if\
    \ word.starts_with(\"i\") {\n            is_bored += 1;\n        }\n    }\n  \
    \  is_bored"]
stop_tokens:
- "\n}"
