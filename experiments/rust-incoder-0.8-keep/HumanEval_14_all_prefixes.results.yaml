name: HumanEval_14_all_prefixes
language: rust
results:
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().enumerate().map(|(_, v)| string.substr(*v))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `substr` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpy5urv6xp.rs:5:52\n  |\n5 |     string.chars().enumerate().map(|(_,\
    \ v)| string.substr(*v))\n  |                                                \
    \    ^^^^^^ method not found in `String`\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n --> /tmp/tmpy5urv6xp.rs:5:59\n  |\n5 |     string.chars().enumerate().map(|(_,\
    \ v)| string.substr(*v))\n  |                                                \
    \           ^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .split_whitespace()\n        .windows(2)\n\
    \        .flatten()\n        .map(|w| w.to_string())\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `windows` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmpc6m_ho00.rs:7:10\n  |\n7 |         .windows(2)\n\
    \  |          ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    let\
    \ mut current_len = string.len();\n    prefixes.append(&string[..]);\n    while\
    \ current_len > 0 {\n        let mut current = &string[..current_len];\n     \
    \   prefixes.append(current);\n        current_len = current_len - current.len();\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2c40uwn_.rs:7:21\n  |\n7 |\
    \     prefixes.append(&string[..]);\n  |                     ^^^^^^^^^^^ types\
    \ differ in mutability\n  |\n  = note: expected mutable reference `&mut Vec<String>`\n\
    \                     found reference `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2c40uwn_.rs:10:25\n   |\n10 |         prefixes.append(current);\n\
    \   |                         ^^^^^^^ types differ in mutability\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<String>`\n                      found reference\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    Vec::new()\n        .into_iter()\n        .map(|s|\
    \ string.chars().take_while(|c| !c.is_prefix(*s)).collect())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prefix` found for reference `&char` in\
    \ the current scope\n --> /tmp/tmpr1xs4zdy.rs:7:51\n  |\n7 |         .map(|s|\
    \ string.chars().take_while(|c| !c.is_prefix(*s)).collect())\n  |            \
    \                                       ^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c|\
    \ c.is_alphanumeric())\n        .map(|c| &string[..c])\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpd7ndpobo.rs:7:25\n  |\n7 |\
    \         .filter_map(|c| c.is_alphanumeric())\n  |                         ^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n\
    \             found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n7 |         .filter_map(|c| Some(c.is_alphanumeric()))\n  |            \
    \             +++++                   +\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&str`\n    --> /tmp/tmpd7ndpobo.rs:9:10\n\
    \     |\n9    |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut len\
    \ = string.len();\n    while len > 0 {\n        prefixes.push(string.substr(0,\
    \ len));\n        len = len - 1;\n    }\n    return prefixes;\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `substr` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpm9mz3qeb.rs:8:30\n  |\n8 |         prefixes.push(string.substr(0,\
    \ len));\n  |                              ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut current\
    \ = string.clone();\n    let mut length = 0;\n    while current.len() > 0 {\n\
    \        let mut len = current.len();\n        while len > 0 {\n            prefixes.push(current.clone());\n\
    \            len -= 1;\n        }\n        current = &current[len..];\n      \
    \  length = length;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6smyi806.rs:14:19\n   |\n\
    6  |     let mut current = string.clone();\n   |                       --------------\
    \ expected due to this value\n...\n14 |         current = &current[len..];\n \
    \  |                   ^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n14 |         current = (&current[len..]).to_string();\n\
    \   |                   +               +++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars()\n        .filter(|c| !c.is_ascii())\n\
    \        .collect::<Vec<String>>()\n        .into_iter()\n        .map(|c| c.to_owned())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpu6vhp_34.rs:7:10\n     |\n7  \
    \  |         .collect::<Vec<String>>()\n     |          ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .as_bytes()\n        .windows(2)\n\
    \        .map(|b| String::from_utf8(&b).unwrap())\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4myky96q.rs:8:36\n  |\n8 |\
    \         .map(|b| String::from_utf8(&b).unwrap())\n  |                      \
    \              ^^ expected struct `Vec`, found `&&[u8]`\n  |\n  = note: expected\
    \ struct `Vec<u8>`\n          found reference `&&[u8]`\nhelp: try using a conversion\
    \ method\n  |\n8 |         .map(|b| String::from_utf8((&b).to_vec()).unwrap())\n\
    \  |                                    +  ++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter(|x|\
    \ !x.is_alphanumeric())\n        .map(|x| x.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`',\
    \ /tmp/tmpr7zvsvbn.rs:15:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n    let mut prefix =\
    \ \"\";\n\n    for ch in string.chars() {\n        if ch == prefix.len() {\n \
    \           result.push(prefix);\n        }\n        else {\n            let prefix\
    \ = ch;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpofpw46e4.rs:9:18\n  |\n9 |\
    \         if ch == prefix.len() {\n  |                  ^^^^^^^^^^^^ expected\
    \ `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpofpw46e4.rs:17:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n17 |     result\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::with_capacity(string.length());\n\
    \    let mut prefix = string.clone();\n\n    for _ in 0..string.len() {\n    \
    \    prefixes.push(prefix.clone());\n        prefix.remove(0);\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyaielv2c.rs:5:50\n  |\n5 |     let mut prefixes\
    \ = Vec::with_capacity(string.length());\n  |                                \
    \                  ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut prefix_size\
    \ = string.len();\n    while prefix != string.chars() {\n        prefix.push(string[0..prefix_size].chars().collect::<String>().to_string());\n\
    \        prefix_size -= 1;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<_>` with `Chars<'_>`\n --> /tmp/tmpxeovs0qx.rs:7:18\n\
    \  |\n7 |     while prefix != string.chars() {\n  |                  ^^ no implementation\
    \ for `Vec<_> == Chars<'_>`\n  |\n  = help: the trait `PartialEq<Chars<'_>>` is\
    \ not implemented for `Vec<_>`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \            <Vec<T, A> as PartialEq<&[U; N]>>\n            <Vec<T, A> as PartialEq<&[U]>>\n\
    \            <Vec<T, A> as PartialEq<&mut [U]>>\n            <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n            <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = String::new();\n    for ch in\
    \ string.chars() {\n        if *ch >= 'a' && *ch <= 'z' {\n            prefix.push(*ch);\n\
    \        }\n    }\n    prefix.into_iter().map(|s| s.to_string()).collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpowyalcfy.rs:7:12\n\
    \  |\n7 |         if *ch >= 'a' && *ch <= 'z' {\n  |            ^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmpowyalcfy.rs:7:26\n  |\n7 |\
    \         if *ch >= 'a' && *ch <= 'z' {\n  |                          ^^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpowyalcfy.rs:8:25\n\
    \  |\n8 |             prefix.push(*ch);\n  |                         ^^^\n\nerror[E0599]:\
    \ the method `into_iter` exists for struct `String`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpowyalcfy.rs:11:12\n    |\n11  |       prefix.into_iter().map(|s|\
    \ s.to_string()).collect()\n    |              ^^^^^^^^^\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars()\n        .filter(|c| *c >= 'a'\
    \ && *c <= 'z')\n        .cloned()\n        .collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpxzj00r18.rs:6:17:\
    \ 6:43]> as Iterator>::Item == &_`\n    --> /tmp/tmpxzj00r18.rs:7:10\n     |\n\
    7    |         .cloned()\n     |          ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpxzj00r18.rs:6:17:\
    \ 6:43]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpxzj00r18.rs:8:10\n\
    \   |\n8  |            .collect::<Vec<String>>()\n   |             ^^^^^^^ method\
    \ cannot be called on `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpxzj00r18.rs:6:17:\
    \ 6:43]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<Filter<Chars<'_>, [closure@/tmp/tmpxzj00r18.rs:6:17:\
    \ 6:43]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpxzj00r18.rs:6:17: 6:43]>>: Iterator`\n           `Cloned<Filter<Chars<'_>,\
    \ [closure@/tmp/tmpxzj00r18.rs:6:17: 6:43]>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Filter<Chars<'_>, [closure@/tmp/tmpxzj00r18.rs:6:17: 6:43]>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut output = Vec::new();\n    for s in string.split_str()\
    \ {\n        output.push(s);\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_str` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpfnxv0c3v.rs:6:21\n  |\n6 |     for s in string.split_str()\
    \ {\n  |                     ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut string:\
    \ String = string.to_string();\n    let mut current_length = 0;\n    let mut last_char:\
    \ Char = Char::Unsigned(0);\n\n    while !string.is_empty() {\n        prefixes.push(string);\n\
    \        let char_length = string[current_length..].chars().count();\n\n     \
    \   if char_length < last_char.value {\n            current_length += 1;\n   \
    \         last_char = Char::Unsigned(char_length);\n        }\n\n        string\
    \ = string[..current_length];\n    }\n\n    prefixes\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n --> /tmp/tmp1wz2zm_n.rs:8:31\n\
    \  |\n8 |     let mut last_char: Char = Char::Unsigned(0);\n  |              \
    \                 ^^^^ use of undeclared type `Char`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Char`\n  --> /tmp/tmp1wz2zm_n.rs:16:25\n  \
    \ |\n16 |             last_char = Char::Unsigned(char_length);\n   |         \
    \                ^^^^ use of undeclared type `Char`\n\nerror[E0412]: cannot find\
    \ type `Char` in this scope\n --> /tmp/tmp1wz2zm_n.rs:8:24\n  |\n8 |     let mut\
    \ last_char: Char = Char::Unsigned(0);\n  |                        ^^^^ help:\
    \ a builtin type with a similar name exists (notice the capitalization): `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1wz2zm_n.rs:19:18\n   |\n6  |\
    \     let mut string: String = string.to_string();\n   |                     ------\
    \ expected due to this type\n...\n19 |         string = string[..current_length];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                  |\n   |                  expected\
    \ struct `String`, found `str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut current_prefix:\
    \ String = \"\".to_owned();\n    for letter in string.chars() {\n        if letter\
    \ != current_prefix[0] {\n            current_prefix = letter + current_prefix;\n\
    \            result.push(current_prefix);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpkwk43_6t.rs:8:22\n  |\n8 |         if letter != current_prefix[0] {\n\
    \  |                      ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \  |\n  = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0369]: cannot add `String` to `char`\n --> /tmp/tmpkwk43_6t.rs:9:37\n\
    \  |\n9 |             current_prefix = letter + current_prefix;\n  |         \
    \                     ------ ^ -------------- String\n  |                    \
    \          |\n  |                              char\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut length = 1;\n    let mut prefix = String::new();\n    while\
    \ string.len() >= length {\n        prefix.push_str(&string[0..length]);\n   \
    \     length += 1;\n    }\n\n    vec![prefix]\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aasasdasdfasdfgasdfgh\"]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\",\
    \ \"asdfg\", \"asdfgh\"]`', /tmp/tmp4vfvzwhn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut i = 0;\n\
    \n    while i < string.len() {\n        prefix.push(string.substr(i, 1));\n  \
    \      i += 1;\n    }\n\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `substr` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp96ubszbu.rs:9:28\n  |\n9 |         prefix.push(string.substr(i,\
    \ 1));\n  |                            ^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::with_capacity(string.len());\n\
    \    for char in string.chars() {\n        if let Some(i) = _prefix_count(&char)\
    \ {\n            result.push(char.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `_prefix_count` in this scope\n -->\
    \ /tmp/tmp9hmuf961.rs:7:26\n  |\n7 |         if let Some(i) = _prefix_count(&char)\
    \ {\n  |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut ret = Vec::new();\n    let mut last =\
    \ 0;\n    for (i, c) in string.chars().enumerate() {\n        if i > 0\n     \
    \       && last > 0\n            && last < i\n            && c - string.chars().nth(i\
    \ - 1).unwrap() == 1\n        {\n            ret += &string.chars().nth(last).unwrap();\n\
    \        }\n        ret += c;\n        last = i;\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpiwlss2lv.rs:11:18\n\
    \   |\n11 |             && c - string.chars().nth(i - 1).unwrap() == 1\n   | \
    \               - ^ ---------------------------------- char\n   |            \
    \    |\n   |                char\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpiwlss2lv.rs:13:13\n \
    \  |\n13 |             ret += &string.chars().nth(last).unwrap();\n   |      \
    \       ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n   |  \
    \           cannot use `+=` on type `Vec<_>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpiwlss2lv.rs:15:9\n\
    \   |\n15 |         ret += c;\n   |         ---^^^^^\n   |         |\n   |   \
    \      cannot use `+=` on type `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0368, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars()\n        .map(|c| String::from_utf8(c.as_bytes()).unwrap())\n\
    \        .filter(|x| x.starts_with(\"\"))\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n --> /tmp/tmpjtilcaa1.rs:6:38\n  |\n6 |         .map(|c| String::from_utf8(c.as_bytes()).unwrap())\n\
    \  |                                      ^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .split_ascii_lowercase()\n   \
    \     .filter(|&c| c.is_ascii_alphanumeric())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_ascii_lowercase` found for struct\
    \ `String` in the current scope\n --> /tmp/tmpnh3ysdf7.rs:6:10\n  |\n6 |     \
    \    .split_ascii_lowercase()\n  |          ^^^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .chain(string.chars().skip(1))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmplpq9a2py.rs:8:10\n     |\n8  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    for (i, char)\
    \ in string.chars().enumerate() {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpta8ttd5c.rs:9:5\n  |\n4 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     prefix\n  |     ^^^^^^ expected struct `String`, found `char`\n  |\n \
    \ = note: expected struct `Vec<String>`\n             found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    // Special case: empty string\n    if string.len()\
    \ <= 1 {\n        return vec![];\n    }\n    // Special case: a single character\n\
    \    if string.len() == 2 {\n        return vec![];\n    }\n\n    // Build suffix\
    \ array\n    let mut suffix = vec![string[1..]];\n\n    for c in &string[2..]\
    \ {\n        // Add any prefixes from the suffix to the suffix array\n       \
    \ for s in suffix {\n            if s.starts_with(c) {\n                suffix.push(c);\n\
    \                break;\n            }\n        }\n    }\n\n    // Return all\
    \ prefixes\n    suffix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp9q85sa4d.rs:15:22\n    |\n15  |     let mut suffix = vec![string[1..]];\n\
    \    |                      ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `slice::<impl [T]>::into_vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmp9q85sa4d.rs:15:22\n   |\n15 |     let mut suffix\
    \ = vec![string[1..]];\n   |                      ^^^^^^^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: slice and array elements must have `Sized` type\n   =\
    \ note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmp9q85sa4d.rs:15:22\n\
    \    |\n15  |     let mut suffix = vec![string[1..]];\n    |                 \
    \     ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n   \
    \ = help: the trait `Sized` is not implemented for `str`\nnote: required by a\
    \ bound in `Vec`\n    = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: `&str` is\
    \ not an iterator\n  --> /tmp/tmp9q85sa4d.rs:17:14\n   |\n17 |     for c in &string[2..]\
    \ {\n   |              ^^^^^^^^^^^^ `&str` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&str`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror[E0277]: the trait bound `Vec<str>: IntoIterator` is not\
    \ satisfied\n  --> /tmp/tmp9q85sa4d.rs:19:18\n   |\n19 |         for s in suffix\
    \ {\n   |                  ^^^^^^ the trait `IntoIterator` is not implemented\
    \ for `Vec<str>"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = vec![];\n    for c in string.chars().take(string.len()\
    \ - 1) {\n        prefixes.push(c);\n    }\n    for c in string.chars().skip(string.len()\
    \ - 1) {\n        prefixes.push(c);\n    }\n    prefixes\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvpbjpjs.rs:12:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n12 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut string\
    \ = string.to_string();\n    prefixes.push(string);\n    while !string.is_empty()\
    \ {\n        let mut first = string.chars().next().unwrap();\n        string =\
    \ &string[..first.len()];\n        prefixes.push(first);\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpp0ih941j.rs:10:34\n   |\n10 |         string = &string[..first.len()];\n\
    \   |                                  ^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp0ih941j.rs:10:18\n   |\n6  |     let mut string\
    \ = string.to_string();\n   |                      ------------------ expected\
    \ due to this value\n...\n10 |         string = &string[..first.len()];\n   |\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n10 |         string = (&string[..first.len()]).to_string();\n\
    \   |                  +                      +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp0ih941j.rs:11:23\n   |\n11 |         prefixes.push(first);\n\
    \   |                       ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|ch|\
    \ chars::prefix_of(ch.to_owned()))\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \ --> /tmp/tmpyn8k368_.rs:7:26\n  |\n7 |         .filter_map(|ch| chars::prefix_of(ch.to_owned()))\n\
    \  |                          ^^^^^ use of undeclared crate or module `chars`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter(|c|\
    \ !c.is_ascii_letter())\n        .map(|c| c.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmps49fu32_.rs:7:24\n  |\n7 |         .filter(|c|\
    \ !c.is_ascii_letter())\n  |                        ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = vec![];\n\n    for &s in string.chars().filter(|c|\
    \ !c.is_ascii_digit()) {\n        let mut new_prefixes = Vec::with_capacity(prefixes.len());\n\
    \n        for &p in &prefixes {\n            new_prefixes.push(p + s);\n     \
    \   }\n\n        prefixes = new_prefixes;\n    }\n\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph7ojapck.rs:7:9\n  |\n7 |\
    \     for &s in string.chars().filter(|c| !c.is_ascii_digit()) {\n  |        \
    \ ^^    ---------------------------------------------- this expression has type\
    \ `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `s`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = Vec::new();\n\
    \    for i in 0..string.len() {\n        let mut prefix_start = i;\n        let\
    \ mut prefix_end = 0;\n        while prefix_end < string.len() && prefix_end <=\
    \ prefix_start {\n            let next_char = string[prefix_end + 1];\n      \
    \      if next_char == '-' || next_char == ' ' {\n                break;\n   \
    \         } else {\n                prefix_end += 1;\n            }\n        }\n\
    \        prefixes.push(&string[prefix_start..prefix_end]);\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbdoqj5sp.rs:10:29\n\
    \   |\n10 |             let next_char = string[prefix_end + 1];\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdoqj5sp.rs:17:23\n\
    \   |\n17 |         prefixes.push(&string[prefix_start..prefix_end]);\n   |  \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n17 |        \
    \ prefixes.push((&string[prefix_start..prefix_end]).to_string());\n   |      \
    \                 +                                 +++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    // Use prefix array as temporary storage\n   \
    \ let mut prefix = Vec::with_capacity(string.length());\n    let mut last_prefix:\
    \ String = None;\n    for i in 0..string.length() {\n        // If current prefix\
    \ is longer than previous prefixes, use it\n        if last_prefix.is_some() {\n\
    \            prefix.push(last_prefix.unwrap());\n        }\n        prefix.push(string.chars().rev().take(i).collect::<String>());\n\
    \        last_prefix = Some(prefix.last().unwrap());\n    }\n    prefix\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpvebj10yu.rs:6:48\n  |\n6 |     let mut prefix =\
    \ Vec::with_capacity(string.length());\n  |                                  \
    \              ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvebj10yu.rs:7:35\n  |\n\
    7 |     let mut last_prefix: String = None;\n  |                          ------\
    \   ^^^^ expected struct `String`, found enum `Option`\n  |                  \
    \        |\n  |                          expected due to this\n  |\n  = note:\
    \ expected struct `String`\n               found enum `Option<_>`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpvebj10yu.rs:8:24\n  |\n8 |     for i in 0..string.length() {\n  |  \
    \                      ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0599]: no method named `is_some` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvebj10yu.rs:10:24\n   |\n10 |         if\
    \ last_prefix.is_some() {\n   |                        ^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpvebj10yu.rs:11:37\n   |\n11 |          \
    \   prefix.push(last_prefix.unwrap());\n   |                                 \
    \    ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpvebj10yu.rs:14:23\n   |\n7  |     let mut last_prefix: String =\
    \ None;\n   |                          ------ expected due to this type\n...\n\
    14 |         last_prefix = Some(prefix.last().unwrap());\n   |               \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<&String>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    shortest_prefixes_from(string).into_iter().flat_map(|prefix|\
    \ prefix).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shortest_prefixes_from` in this scope\n\
    \ --> /tmp/tmp7h3lf5o3.rs:5:5\n  |\n5 |     shortest_prefixes_from(string).into_iter().flat_map(|prefix|\
    \ prefix).collect()\n  |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut string_iter\
    \ = string.chars().rev();\n\n    for ch in string_iter {\n        prefix.push(&string[string_iter.index(u64::from(ch))..string_iter.rindex()]);\n\
    \    }\n    prefix.reverse();\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index` found for struct `Rev` in the current\
    \ scope\n --> /tmp/tmpg2htk1na.rs:9:41\n  |\n9 |         prefix.push(&string[string_iter.index(u64::from(ch))..string_iter.rindex()]);\n\
    \  |                                         ^^^^^ method not found in `Rev<Chars<'_>>`\n\
    \nerror[E0599]: no method named `rindex` found for struct `Rev` in the current\
    \ scope\n --> /tmp/tmpg2htk1na.rs:9:75\n  |\n9 |         prefix.push(&string[string_iter.index(u64::from(ch))..string_iter.rindex()]);\n\
    \  |                                                                         \
    \  ^^^^^^ method not found in `Rev<Chars<'_>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpg2htk1na.rs:12:5\n   |\n4  | fn all_prefixes(string: String) ->\
    \ Vec<String> {\n   |                                    ----------- expected\
    \ `Vec<String>` because of return type\n...\n12 |     prefix\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut strings\
    \ = vec![];\n\n    let mut i = 0;\n    strings.push(i);\n    while i < string.len()\
    \ {\n        let mut j = i;\n        prefix.push(string.to_string());\n      \
    \  while j < string.len() {\n            if strings[j] == string[j] {\n      \
    \          j += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        strings.push(j);\n        i += 1;\n    }\n\n    strings\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpftz0ewzj.rs:14:30\n\
    \   |\n14 |             if strings[j] == string[j] {\n   |                   \
    \           ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpftz0ewzj.rs:24:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n24 |     strings\n   |     ^^^^^^^ expected struct `String`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::with_capacity(string.len());\n\
    \    for (i, c) in string.chars().enumerate() {\n        if i > 0 {\n        \
    \    prefix.push(string.chars()[i - 1]);\n        }\n        if i == string.len()\
    \ - 1 {\n            prefix.push(c);\n        }\n    }\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmpb0wam2fh.rs:8:25\n\
    \  |\n8 |             prefix.push(string.chars()[i - 1]);\n  |               \
    \          ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0wam2fh.rs:14:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n14 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    for\
    \ &c in string.chars() {\n        result.push(c.to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbhm7bvua.rs:6:9\n  |\n6 |\
    \     for &c in string.chars() {\n  |         ^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut prefix = vec![\"\".to_string()];\n    for ch in string.to_lowercase().rev()\
    \ {\n        let len = prefix.iter().map(|s| s.len() + s.as_bytes().count(' ')).max().unwrap();\n\
    \        let suffix = prefix.iter().map(|s| s.len() + s.as_bytes().count(' ')).min().unwrap();\n\
    \        if len > prefix.len() {\n            prefix = prefix.clone();\n     \
    \       prefix.push(ch.to_lowercase());\n        }\n        if len < prefix.len()\
    \ {\n            for _ in 0..(len - prefix.len()) {\n                prefix.pop();\n\
    \            }\n        }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpz1wmi6xx.rs:9:37\n\
    \    |\n9   |       for ch in string.to_lowercase().rev() {\n    |           \
    \                            ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror[E0599]: no method named `count` found for reference\
    \ `&[u8]` in the current scope\n  --> /tmp/tmpz1wmi6xx.rs:10:64\n   |\n10 |  \
    \       let len = prefix.iter().map(|s| s.len() + s.as_bytes().count(' ')).max().unwrap();\n\
    \   |                                                                ^^^^^\n \
    \  |                                                                |\n   |  \
    \                                                              method cannot be\
    \ called on `&[u8]` due to unsatisfied trait bounds\n   |                    \
    \                                            help: consider using `len` instead\n\
    \   |\n   = note: `count` is defined on `Iterator`, which `&[u8]` does not implement\n\
    \nerror[E0599]: no method named `count` found for reference `&[u8]` in the current\
    \ scope\n  --> /tmp/tmpz1wmi6xx.rs:11:67\n   |\n11 |         let suffix = prefix.iter().map(|s|\
    \ s.len() + s.as_bytes().count(' ')).min().unwrap();\n   |                   \
    \                                                ^^^^^\n   |                 \
    \                                                  |\n   |                   \
    \                                                method cannot be called on `&[u8]`\
    \ due to unsatisfied trait bounds\n   |                                      \
    \                             help: consider using `len` instead\n   |\n   = note:\
    \ `count` is defined on `Iterator`, which `&[u8]` does not implement\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut result = vec![];\n    let mut i = 1;\n    while i <= string.len()\
    \ {\n        let mut j = i;\n        let mut k = i;\n\n        while j > 0 &&\
    \ string[j - 1] == string[j] {\n            j -= 1;\n        }\n\n        while\
    \ k > 0 && string[k - 1] == string[k] {\n            k -= 1;\n        }\n\n  \
    \      result.push((&string[..i]).to_owned());\n        result.push((&string[i..k]).to_owned());\n\
    \        i = k;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg31sqejc.rs:15:24\n\
    \   |\n15 |         while j > 0 && string[j - 1] == string[j] {\n   |        \
    \                ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg31sqejc.rs:15:41\n\
    \   |\n15 |         while j > 0 && string[j - 1] == string[j] {\n   |        \
    \                                 ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg31sqejc.rs:19:24\n   |\n19 |         while k > 0 && string[k -\
    \ 1] == string[k] {\n   |                        ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<u"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .map(|c| c as\
    \ char)\n        .collect::<String>()\n        .into_iter()\n        .enumerate()\n\
    \        .map(|(i, c)| (c, i)).collect::<Vec<(Char, usize)>>()\n        .reverse()\n\
    \        .map(|(c, i)| &string[c.1 - 1..i])\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpgkrndtmy.rs:11:46\n\
    \   |\n11 |         .map(|(i, c)| (c, i)).collect::<Vec<(Char, usize)>>()\n  \
    \ |                                              ^^^^\n   |\nhelp: a builtin type\
    \ with a similar name exists\n   |\n11 |         .map(|(i, c)| (c, i)).collect::<Vec<(char,\
    \ usize)>>()\n   |                                              ~~~~\nhelp: you\
    \ might be missing a type parameter\n   |\n4  | fn all_prefixes<Char>(string:\
    \ String) -> Vec<String> {\n   |                ++++++\n\nerror[E0599]: the method\
    \ `into_iter` exists for struct `String`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmpgkrndtmy.rs:9:10\n    |\n9   |           .into_iter()\n    | \
    \           ^^^^^^^^^\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `String: Iterator`\n            which is required by\
    \ `String: IntoIterator`\n            `&String: Iterator`\n            which is\
    \ required by `&String: IntoIterator`\n            `&mut String: Iterator`\n \
    \           which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0412, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    prefix.push(string);\n\
    \    while let Some(tail) = prefix.pop() {\n        let mut prefix_len = string.len()\
    \ as u32;\n        tail.chars().for_each(|c| {\n            prefix_len -= 1;\n\
    \            prefix.push(c);\n        });\n        if prefix_len == 0 {\n    \
    \        break;\n        }\n    }\n    prefix.reverse();\n    prefix\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy_mt6upj.rs:11:25\n   |\n\
    11 |             prefix.push(c);\n   |                         ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                         |\n   |  \
    \                       expected struct `String`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut string_iter\
    \ = string.chars();\n    while let Some(next_char) = (string_iter.next()) {\n\
    \        prefix.push(next_char);\n        if next_char != string.chars().nth(1).unwrap()\
    \ {\n            break;\n        }\n    }\n    prefix.reverse();\n    prefix\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n -->\
    \ /tmp/tmpjmvvt6d2.rs:7:33\n  |\n7 |     while let Some(next_char) = (string_iter.next())\
    \ {\n  |                                 ^                  ^\n  |\n  = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n\
    7 -     while let Some(next_char) = (string_iter.next()) {\n7 +     while let\
    \ Some(next_char) = string_iter.next() {\n  | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjmvvt6d2.rs:14:5\n   |\n4  | fn all_prefixes(string: String) ->\
    \ Vec<String> {\n   |                                    ----------- expected\
    \ `Vec<String>` because of return type\n...\n14 |     prefix\n   |     ^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    for pos in string.char_indices()\
    \ {\n        prefix.push(string.chars().nth(pos.0) as char);\n    }\n    return\
    \ prefix;\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpp6daonyg.rs:9:12\n  |\n4 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     return prefix;\n  |            ^^^^^^ expected struct `String`, found\
    \ `char`\n  |\n  = note: expected struct `Vec<String>`\n             found struct\
    \ `Vec<char>`\n\nerror[E0605]: non-primitive cast: `Option<char>` as `char`\n\
    \ --> /tmp/tmpp6daonyg.rs:7:21\n  |\n7 |         prefix.push(string.chars().nth(pos.0)\
    \ as char);\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0605.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars()\n        .filter(|x| !x.is_ascii_alphanumeric())\n\
    \        .take_while((x) => x.is_ascii_alphanumeric())\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n\
    \ --> /tmp/tmpoc9qkisi.rs:7:25\n  |\n7 |         .take_while((x) => x.is_ascii_alphanumeric())\n\
    \  |                         ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix_vec = Vec::new();\n\n    for b\
    \ in string.chars() {\n        prefix_vec.push(b);\n    }\n\n    prefix_vec.reverse();\n\
    \    prefix_vec\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpptx5iqd_.rs:12:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n12 |     prefix_vec\n   |     ^^^^^^^^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    strings\n        .chars()\n        .flat_map(|c|\
    \ {\n            strings\n                .char_indices()\n                .filter_map(|(b,\
    \ e)| {\n                    if b + 1 != e {\n                        None\n \
    \                   } else {\n                        Some((b + 1, c + &string[b..]))\n\
    \                    }\n                })\n                .collect::<Vec<_>>()\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `strings` in this scope\n --> /tmp/tmpv2p8hsf7.rs:5:5\n\
    \  |\n5 |     strings\n  |     ^^^^^^^ help: a local variable with a similar name\
    \ exists: `string`\n\nerror[E0425]: cannot find value `strings` in this scope\n\
    \ --> /tmp/tmpv2p8hsf7.rs:8:13\n  |\n8 |             strings\n  |            \
    \ ^^^^^^^ help: a local variable with a similar name exists: `string`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    vec![string]\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[]`', /tmp/tmpuyk2ggik.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .map(|c| c.to_string())\n\
    \        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp21pus62q.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut list = vec![];\n    for (i, c) in string.chars().enumerate()\
    \ {\n        let prefix = &string[..i];\n        if i > 0 {\n            list.push(prefix);\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxm2yhjma.rs:12:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n12 |     list\n   |     ^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut i =\
    \ 0;\n    let mut j = string.len();\n    while j > i {\n        let p = string.chars().nth(i).unwrap();\n\
    \        i += 1;\n        if i == j {\n            result.push(p);\n        }\n\
    \        if j == i {\n            return result;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmb9aj699.rs:15:20\n   |\n\
    15 |             return result;\n   |                    ^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmb9aj699.rs:18:5\n   |\n4  | fn all_prefixes(string: String) -> Vec<String>\
    \ {\n   |                                    ----------- expected `Vec<String>`\
    \ because of return type\n...\n18 |     result\n   |     ^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = vec![];\n    let mut i = 0;\n\
    \    while i < string.len() {\n        prefixes.push(string.to_string()[0..i].to_string());\n\
    \        i += 1;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"a\", \"as\", \"asd\", \"asdf\", \"asdfg\"]`,\n right: `[\"a\", \"\
    as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpk1nxagnr.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![\"\"];\n    let mut input\
    \ = string.as_str();\n    while !input.is_empty() {\n        prefix.push(&input[..]);\n\
    \        input = &input[1..];\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmn7dkn53.rs:11:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefix\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    strings.iter().cloned().filter_map(|s| s.as_bytes().iter()).filter_map(|s|\
    \ {\n        s.as_bytes().iter()\n    }).take_while(|&b| *b != 0).take_while(|&b|\
    \ !b.is_empty()).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `strings` in this scope\n --> /tmp/tmpcpac69ko.rs:5:5\n\
    \  |\n5 |     strings.iter().cloned().filter_map(|s| s.as_bytes().iter()).filter_map(|s|\
    \ {\n  |     ^^^^^^^ help: a local variable with a similar name exists: `string`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut iter = string.chars();\n    let mut prefixes\
    \ = Vec::new();\n    while let Some(mut c) = iter.next() {\n        prefixes.push(c);\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ic2mzis.rs:10:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n10 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c|\
    \ c.to_ascii_lowercase())\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n  \
    \  let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzggqnoku.rs:7:25\n  |\n7 |\
    \         .filter_map(|c| c.to_ascii_lowercase())\n  |                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n  |\n  = note:\
    \ expected enum `Option<_>`\n             found type `char`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n7 |         .filter_map(|c| Some(c.to_ascii_lowercase()))\n\
    \  |                         +++++                      +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut prefixes = vec![];\n    let mut cur_len = string.len();\n\
    \    while cur_len > 0 {\n        prefixes.push(string.to_owned());\n        cur_len\
    \ -= 1;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\", \"asdfgh\", \"asdfgh\", \"asdfgh\", \"asdfgh\", \"asdfgh\"]`,\n\
    \ right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpgmffyijy.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut input\
    \ = string.as_bytes();\n    while input.len() > 0 {\n        let mut current_prefix\
    \ = &mut prefixes[prefixes.len() - 1];\n        input.copy_from_slice(&mut current_prefix[..]);\n\
    \        input.truncate(0);\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpseugm2lg.rs:9:36\n\
    \  |\n5 |     let mut prefixes = Vec::new();\n  |         ------------ consider\
    \ giving `prefixes` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n9 |         input.copy_from_slice(&mut current_prefix[..]);\n  |        \
    \                            ^^^^^^^^^^^^^^ cannot infer type\n  |\n  = note:\
    \ type must be known at this point\n\nerror[E0599]: no method named `truncate`\
    \ found for reference `&[u8]` in the current scope\n  --> /tmp/tmpseugm2lg.rs:10:15\n\
    \   |\n10 |         input.truncate(0);\n   |               ^^^^^^^^ method not\
    \ found in `&[u8]`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0282, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut current_len\
    \ = string.len() as i32;\n    let mut current_prefix = string.clone();\n    for\
    \ c in string.chars() {\n        if c != current_prefix[current_len..].chars().nth(0).unwrap()\
    \ {\n            prefixes.push(current_prefix.clone());\n            current_len\
    \ = current_prefix.len() as i32;\n            current_prefix = current_prefix.clone();\n\
    \        }\n        current_len -= 1;\n    }\n    prefixes.push(current_prefix.clone());\n\
    \    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeFrom<i32>`\n\
    \ --> /tmp/tmp2lq1p1np.rs:9:17\n  |\n9 |         if c != current_prefix[current_len..].chars().nth(0).unwrap()\
    \ {\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeFrom<i32>`\n  |\n  = help: the trait `Index<RangeFrom<i32>>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut i = 1;\n\
    \n    while i < string.len() {\n        if !is_prefix(string, &prefix) {\n   \
    \         prefix.push(string[i]);\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prefix` in this scope\n --> /tmp/tmp9pxh7ajr.rs:9:13\n\
    \  |\n9 |         if !is_prefix(string, &prefix) {\n  |             ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prefix`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9pxh7ajr.rs:10:25\n\
    \   |\n10 |             prefix.push(string[i]);\n   |                        \
    \ ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().flat_map(|c| vec![String::from(c),\
    \ ''])\n        .chunks(2).map(|chunk| chunk.last().to_string()).collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n --> /tmp/tmprhxwchlh.rs:5:56\n  |\n5 |\
    \     string.chars().flat_map(|c| vec![String::from(c), ''])\n  |            \
    \                                            ^ empty character literal\n\nerror[E0599]:\
    \ no method named `chunks` found for struct `FlatMap` in the current scope\n -->\
    \ /tmp/tmprhxwchlh.rs:6:10\n  |\n6 |         .chunks(2).map(|chunk| chunk.last().to_string()).collect()\n\
    \  |          ^^^^^^ method not found in `FlatMap<Chars<'_>, Vec<String, _>, [closure@/tmp/tmprhxwchlh.rs:5:29:\
    \ 5:58]>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    shortest_prefixes(string)\n        .iter()\n \
    \       .map(|prefix| string.len() - prefix.len())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shortest_prefixes` in this scope\n\
    \ --> /tmp/tmppm1m6jvj.rs:5:5\n  |\n5 |     shortest_prefixes(string)\n  |   \
    \  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        vec![]\n    }\
    \ else {\n        let mut result = vec![];\n        let mut prefix = vec![string[0]];\n\
    \        let mut suffix = vec![string[1..]];\n        while !suffix.is_empty()\
    \ {\n            result.push(prefix.clone());\n            prefix.clear();\n \
    \           suffix.clear();\n            for c in string.chars() {\n         \
    \       if *c != prefix.get(0).unwrap() {\n                    prefix.push(*c);\n\
    \                }\n                if *c == suffix.get(0).unwrap() {\n      \
    \              suffix.pop();\n                } else {\n                    suffix.push(*c);\n\
    \                }\n            }\n        }\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpvq_9o2jh.rs:9:31\n  |\n9 |         let mut prefix = vec![string[0]];\n\
    \  |                               ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \  |\n  = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpvq_9o2jh.rs:10:26\n    |\n10  |         let mut suffix\
    \ = vec![string[1..]];\n    |                          ^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `slice::<impl [T]>::into_vec`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpvq_9o2jh.rs:10:26\n\
    \   |\n10 |         let mut suffix = vec![string[1..]];\n   |                \
    \          ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: slice and\
    \ array elements must have `Sized` type\n   = note: this error originates in the\
    \ macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpvq_9o2jh.rs:10:26\n    |\n10  |         let mut suffix\
    \ = vec![string[1..]];\n    |                          ^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required b"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut res = vec![];\n    for i in 1..string.len()\
    \ {\n        for prefix in all_prefixes_prefix(string.to_string(), i) {\n    \
    \        res.push(prefix);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `all_prefixes_prefix` in this scope\n\
    \ --> /tmp/tmp5_knupgl.rs:7:23\n  |\n7 |         for prefix in all_prefixes_prefix(string.to_string(),\
    \ i) {\n  |                       ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n\
    \    }\n\n    // If there are any prefixes, stop here\n    if string.len() > MAX_STRING_LENGTH\
    \ {\n        return vec![string];\n    }\n\n    // Keep adding the prefixes of\
    \ the prefix substrings of the first char\n    let mut prefixes: Vec<String> =\
    \ Vec::new();\n    for start in 0..string.len() {\n        let end = start + 1;\n\
    \        let prefix = string.to_string() + &string[start..end];\n        for sub\
    \ in all_prefixes(&prefix) {\n            prefixes.push(sub);\n        }\n   \
    \ }\n\n    // Return the prefixes sorted by length\n    prefixes.sort_by_key(|&x|\
    \ x.len());\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_STRING_LENGTH` in this scope\n  -->\
    \ /tmp/tmpgzrgwbw1.rs:10:23\n   |\n10 |     if string.len() > MAX_STRING_LENGTH\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgzrgwbw1.rs:19:33\n   |\n19 |  \
    \       for sub in all_prefixes(&prefix) {\n   |                             \
    \    ^^^^^^^ expected struct `String`, found `&String`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n19 -         for sub in all_prefixes(&prefix) {\n19 +    \
    \     for sub in all_prefixes(prefix) {\n   | \n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter(|&c|\
    \ !c.is_ascii_letter())\n        .collect::<Vec<_>>()\n        .windows(2)\n \
    \       .flat_map(|w| w.iter().map(String::from))\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n --> /tmp/tmpv6_8iyuq.rs:7:25\n  |\n7 |         .filter(|&c|\
    \ !c.is_ascii_letter())\n  |                         ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0277]: the\
    \ trait bound `String: From<&char>` is not satisfied\n  --> /tmp/tmpv6_8iyuq.rs:10:23\n\
    \   |\n10 |         .flat_map(|w| w.iter().map(String::from))\n   |          \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `From<&char>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<&char>` is not satisfied\n  -->\
    \ /tmp/tmpv6_8iyuq.rs:10:36\n   |\n10 |         .flat_map(|w| w.iter().map(String::from))\n\
    \   |                                    ^^^^^^^^^^^^ the trait `From<&char>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror[E0277]: the trait bound `String:\
    \ From<&char>` is not satisfied\n  --> /tmp/tmpv6_8iyuq.rs:5:5\n   |\n5  | / \
    \    string\n6  | |         .chars()\n7  | |         .filter(|&c| !c.is_ascii_letter())\n\
    8  | |         .collect::<Vec<_>>()\n9  | |         .windows(2)\n10 | |      \
    \   .flat_map(|w| w.iter().map(String::from))\n   | |_________________________________________________^\
    \ the trait `From<&char>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut index =\
    \ string.len();\n    loop {\n        prefix.push(string[index..]);\n        index\
    \ -= 1;\n        if index == 0 {\n            break;\n        }\n    }\n    prefix\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpv9by8xq0.rs:8:21\n    |\n8   |         prefix.push(string[index..]);\n\
    \    |                ---- ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmpv9by8xq0.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpv9by8xq0.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv9by8xq0.rs:14:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n14 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `str`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<str>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().enumerate().filter(|(&i, c)| c\
    \ as char == 'a').collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0uoouyqg.rs:5:41\n  |\n5 |\
    \     string.chars().enumerate().filter(|(&i, c)| c as char == 'a').collect()\n\
    \  |                                         ^^   - expected due to this\n  |\
    \                                         |\n  |                             \
    \            expected `usize`, found reference\n  |                          \
    \               help: you can probably remove the explicit borrow: `i`\n  |\n\
    \  = note:   expected type `usize`\n          found reference `&_`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `(usize, char)`\n    --> /tmp/tmp0uoouyqg.rs:5:67\n     |\n5    |  \
    \   string.chars().enumerate().filter(|(&i, c)| c as char == 'a').collect()\n\
    \     |                                                                   ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ char)>`\n     |\n     = help: the trait `FromIterator<(usize, char)>` is not\
    \ implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0606]: casting\
    \ `&char` as `char` is invalid\n --> /tmp/tmp0uoouyqg.rs:5:49\n  |\n5 |     string.chars().enumerate().filter(|(&i,\
    \ c)| c as char == 'a').collect()\n  |                                       \
    \          ^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for c in string.chars()\
    \ {\n        if string.starts_with(c) {\n            prefixes.push(c);\n     \
    \   } else {\n            break;\n        }\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi1a7p871.rs:13:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n13 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut string = string.to_string();\n    let\
    \ mut prefix = vec![];\n    let mut i = 1;\n    while i < string.len() {\n   \
    \     prefix.push(&string[i..]);\n        i += 1;\n    }\n    prefix\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdcjavzz7.rs:12:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n12 |     prefix\n   |     ^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = vec![];\n    let mut suffix\
    \ = string.to_string();\n    let mut i = 0;\n    while i < suffix.len() {\n  \
    \      prefixes.append(&suffix[i..]);\n        i += 1;\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaloz8ouz.rs:9:25\n  |\n9 |\
    \         prefixes.append(&suffix[i..]);\n  |                         ^^^^^^^^^^^^\
    \ types differ in mutability\n  |\n  = note: expected mutable reference `&mut\
    \ Vec<_>`\n                     found reference `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.iter()\n        .map(|x| x.to_string())\n\
    \        .chain(all_prefixes(string.into_iter().chain(String::new()).collect()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpll0vasn7.rs:5:12\n  |\n5 |     string.iter()\n  |      \
    \      ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars()\n  |            ~~~~~\n\nerror[E0599]:\
    \ the method `into_iter` exists for struct `String`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpll0vasn7.rs:7:36\n    |\n7   |           .chain(all_prefixes(string.into_iter().chain(String::new()).collect()))\n\
    \    |                                      ^^^^^^^^^\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c|\
    \ c.is_ascii_alphanumeric())\n        .map(|c| c.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfvtpxpq4.rs:7:25\n  |\n7 |\
    \         .filter_map(|c| c.is_ascii_alphanumeric())\n  |                    \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `bool`\n  |\n  =\
    \ note: expected enum `Option<_>`\n             found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n7 |         .filter_map(|c| Some(c.is_ascii_alphanumeric()))\n\
    \  |                         +++++                         +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut iter = string.chars().enumerate();\n \
    \   iter.next();\n    let mut prefixes = Vec::new();\n    for (_, ch) in iter\
    \ {\n        prefixes.push((\n            string[..ch],\n            string[..(ch+1)].to_string(),\n\
    \        ));\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \  --> /tmp/tmptq67ca7y.rs:10:13\n   |\n10 |             string[..ch],\n   | \
    \            ^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n   |\n\
    \   = help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmptq67ca7y.rs:11:25\n\
    \   |\n11 |             string[..(ch+1)].to_string(),\n   |                  \
    \     --^- {integer}\n   |                       |\n   |                     \
    \  char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptq67ca7y.rs:14:5\n  \
    \ |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |             \
    \                       ----------- expected `Vec<String>` because of return type\n\
    ...\n14 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found tuple\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<(_,\
    \ String)>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut ret: Vec<String> = Vec::new();\n    for\
    \ pos in 0..string.len() {\n        ret.push(string.chars().nth(pos).unwrap());\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpyf7iea8v.rs:7:18\n  |\n7 |\
    \         ret.push(string.chars().nth(pos).unwrap());\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n  |                  |\n\
    \  |                  expected struct `String`, found `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    for c in string.chars()\
    \ {\n        prefix.push(c);\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg_w55p86.rs:9:5\n  |\n4 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     prefix\n  |     ^^^^^^ expected struct `String`, found `char`\n  |\n \
    \ = note: expected struct `Vec<String>`\n             found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = String::new();\n    prefix.push_str(string);\n\
    \    prefix.push(':');\n    prefix.push(':');\n    let mut all_prefix = Vec::new();\n\
    \    all_prefix.push(prefix);\n\n    for c in string.chars() {\n        if c !=\
    \ ':' {\n            prefix.push(c);\n            all_prefix.push(prefix);\n \
    \       }\n    }\n    all_prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwutjazhw.rs:6:21\n  |\n6 |\
    \     prefix.push_str(string);\n  |                     ^^^^^^\n  |          \
    \           |\n  |                     expected `&str`, found struct `String`\n\
    \  |                     help: consider borrowing here: `&string`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = \"\";\n    loop {\n        prefix.push(string[0]);\n\
    \        let next = string.chars().next();\n        if next.is_none() {\n    \
    \        break;\n        }\n        string = next.unwrap();\n    }\n    prefix.drain(..).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n --> /tmp/tmp_1rlundd.rs:7:16\n  |\n7 |         prefix.push(string[0]);\n\
    \  |                ^^^^ method not found in `&str`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n --> /tmp/tmp_1rlundd.rs:7:21\n \
    \ |\n7 |         prefix.push(string[0]);\n  |                     ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_1rlundd.rs:12:18\n   |\n4  |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n   |                     \
    \    ------ expected due to this parameter type\n...\n12 |         string = next.unwrap();\n\
    \   |                  ^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ `char`\n\nerror[E0599]: no method named `drain` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmp_1rlundd.rs:14:12\n   |\n14 |     prefix.drain(..).collect()\n\
    \   |            ^^^^^ method not found in `&str`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    for\
    \ c in string.chars() {\n        if let Some(pos) = string.find(&c) {\n      \
    \      prefixes.push(c[..pos]);\n        }\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpl8yhr34q.rs:7:40\n\
    \     |\n7    |         if let Some(pos) = string.find(&c) {\n     |         \
    \                          ---- ^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                                   |\n     |                          \
    \         required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `char`\n     = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::find`\nhelp: consider dereferencing\
    \ here\n     |\n7    |         if let Some(pos) = string.find(*&c) {\n     | \
    \                                       +\n\nerror[E0608]: cannot index into a\
    \ value of type `char`\n --> /tmp/tmpl8yhr34q.rs:8:27\n  |\n8 |             prefixes.push(c[..pos]);\n\
    \  |                           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut output = Vec::new();\n    let mut prefixes:\
    \ HashSet<String> = HashSet::new();\n    for ch in string.chars() {\n        for\
    \ prefix in prefixes.iter() {\n            if ch == prefix {\n               \
    \ continue;\n            }\n            prefixes.insert(ch);\n            output.push((prefix,\
    \ ch));\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpcx2jfw5b.rs:6:23\n\
    \  |\n6 |     let mut prefixes: HashSet<String> = HashSet::new();\n  |       \
    \                ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpcx2jfw5b.rs:6:41\n\
    \  |\n6 |     let mut prefixes: HashSet<String> = HashSet::new();\n  |       \
    \                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcx2jfw5b.rs:16:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    16 |     output\n   |     ^^^^^^ expected struct `String`, found tuple\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<(char,\
    \ char)>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0412, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = Vec::new();\n\
    \    string\n        .chars()\n        .enumerate()\n        .filter(|(_, c)|\
    \ c != 'a')\n        .map(|(index, c)| (c, index))\n        .collect::<Vec<(&char,\
    \ usize)>>()\n        .sort_by(|(_, a), (_, b)| b.cmp(&a))\n        .filter(|(_,\
    \ a), (_, b)| a != b)\n        .for_each(|(c, i)| {\n            prefixes.push(c[..i].to_string());\n\
    \        });\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmplzg4f4em.rs:9:28\n\
    \  |\n9 |         .filter(|(_, c)| c != 'a')\n  |                            ^^\
    \ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: a value of type `Vec<(&char, usize)>` cannot be\
    \ built from an iterator over elements of type `(char, usize)`\n    --> /tmp/tmplzg4f4em.rs:11:10\n\
    \     |\n11   |         .collect::<Vec<(&char, usize)>>()\n     |          ^^^^^^^\
    \ value of type `Vec<(&char, usize)>` cannot be built from `std::iter::Iterator<Item=(char,\
    \ usize)>`\n     |\n     = help: the trait `FromIterator<(char, usize)>` is not\
    \ implemented for `Vec<(&char, usize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmplzg4f4em.rs:13:10\n   |\n13 |       \
    \  .filter(|(_, a), (_, b)| a != b)\n   |          ^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n\n    for &ch in\
    \ string.chars() {\n        prefix.push(string[..ch]);\n    }\n\n    return prefix;\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj08_lsgq.rs:7:9\n  |\n7 |\
    \     for &ch in string.chars() {\n  |         ^^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `ch`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpj08_lsgq.rs:8:21\n    |\n8   |         prefix.push(string[..ch]);\n\
    \    |                ---- ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmpj08_lsgq.rs:5:22\n\
    \    |\n5   |     let mut prefix = Vec::new();\n    |                      ^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpj08_lsgq.rs:5:22\n    |\n5   |     let mut prefix = Vec::new();\n\
    \    |                      ^^^ doesn't have a size known at compile-time\n  \
    \  |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj08_lsgq.rs:11:12\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     return prefix;\n   |            ^^^^^^ expected struct `String`,\
    \ found `str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<str>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explai"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    for ch in string.chars()\
    \ {\n        if let Some(ch) = &ch {\n            result.push(ch);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp26owini9.rs:7:16\n  |\n7 |\
    \         if let Some(ch) = &ch {\n  |                ^^^^^^^^   --- this expression\
    \ has type `&char`\n  |                |\n  |                expected `char`,\
    \ found enum `Option`\n  |\n  = note: expected type `char`\n             found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp26owini9.rs:11:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     result\n   |     ^^^^^^ expected struct `String`, found\
    \ reference\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut prefix\
    \ = \"\";\n    let mut s = string.as_bytes();\n    while !s.is_empty() {\n   \
    \     // Find the first character that is not in the prefix string\n        let\
    \ mut index = s.iter().position(|&b| *b != *prefix).unwrap_or(0);\n        let\
    \ mut char = s.take(index);\n        // Add prefix string to result vector\n \
    \       result.push(prefix + &char);\n        // Remove prefix from input string\n\
    \        s = s.iter().take(index + 1);\n        prefix = char.to_string();\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmp7ea0cdtw.rs:10:48\n\
    \   |\n10 |         let mut index = s.iter().position(|&b| *b != *prefix).unwrap_or(0);\n\
    \   |                                                ^^\n\nerror[E0658]: use of\
    \ unstable library feature 'slice_take'\n  --> /tmp/tmp7ea0cdtw.rs:11:26\n   |\n\
    11 |         let mut char = s.take(index);\n   |                          ^^^^\n\
    \   |\n   = note: see issue #62280 <https://github.com/rust-lang/rust/issues/62280>\
    \ for more information\n\nerror[E0277]: the trait bound `usize: OneSidedRange<usize>`\
    \ is not satisfied\n    --> /tmp/tmp7ea0cdtw.rs:11:31\n     |\n11   |        \
    \ let mut char = s.take(index);\n     |                          ---- ^^^^^ the\
    \ trait `OneSidedRange<usize>` is not implemented for `usize`\n     |        \
    \                  |\n     |                          required by a bound introduced\
    \ by this call\n     |\n     = help: the following other types implement trait\
    \ `OneSidedRange<T>`:\n               RangeFrom<T>\n               RangeTo<T>\n\
    \               RangeToInclusive<T>\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::take`\n\nerror[E0369]: cannot add `&Option<&[u8]>` to `&str`\n  --> /tmp/tmp7ea0cdtw.rs:13:28\n\
    \   |\n13 |         result.push(prefix + &char);\n   |                     ------\
    \ ^ ----- &Option<&[u8]>\n   |                     |\n   |                   \
    \  &str\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ea0cdtw.rs:15:13\n \
    \  |\n7  |     let mut s = string.as_bytes();\n   |                 -----------------\
    \ expected due to this value\n...\n15 |         s = s.iter().take(index + 1);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&[u8]`, found struct `std::iter::Take`\n\
    \   |\n   = note: expected reference `&[u8]`\n                 found struct `std::iter::Take<std::slice::Iter<'_,\
    \ u8>>`\n\nerror[E0599]: the method `to_string` exists for enum `Option<&[u8]>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmp7ea0cdtw.rs:16:23\n\
    \    |\n16  |           prefix = char.to_string();\n    |                    \
    \     ^^^^^^^^^ method cannot be called on `Op"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().map(|c| string[..c]).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \ --> /tmp/tmpvp27ytfl.rs:5:28\n  |\n5 |     string.chars().map(|c| string[..c]).collect()\n\
    \  |                            ^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n\
    \  |\n  = help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .split_whitespace()\n        .map(|s|\
    \ s.chars().next().unwrap())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpr1frjr2q.rs:8:10\n     |\n8  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .split_unicode()\n        .map(|w|\
    \ w.to_lowercase())\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_unicode` found for struct `String`\
    \ in the current scope\n --> /tmp/tmp930qei7e.rs:6:10\n  |\n6 |         .split_unicode()\n\
    \  |          ^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_once`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 0..string.len()\
    \ {\n        prefixes.append(&string[0..i]);\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplcpnqikq.rs:7:25\n  |\n7 |\
    \         prefixes.append(&string[0..i]);\n  |                         ^^^^^^^^^^^^^\
    \ types differ in mutability\n  |\n  = note: expected mutable reference `&mut\
    \ Vec<_>`\n                     found reference `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    // TODO: Scan string char by char and create prefix\
    \ tree of it\n    vec![]\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`',\
    \ /tmp/tmptim0pw4i.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::with_capacity(string.len());\n\
    \n    for char in string.chars() {\n        if let Some(p) = string.prefix(&char)\
    \ {\n            prefixes.push(*p);\n        }\n    }\n\n    prefixes\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `prefix` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpl86l5nd5.rs:8:33\n  |\n8 |         if let Some(p)\
    \ = string.prefix(&char) {\n  |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `strip_prefix`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return Vec::new();\n\
    \    }\n    string.chars().enumerate().filter(|(_, c)| c.is_ascii_letter()).map(|(i,\
    \ _)| &string[..i]).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n --> /tmp/tmp_kepqeq6.rs:8:50\n  |\n8 |     string.chars().enumerate().filter(|(_,\
    \ c)| c.is_ascii_letter()).map(|(i, _)| &string[..i]).collect()\n  |         \
    \                                         ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&str`\n    --> /tmp/tmp_kepqeq6.rs:8:96\n\
    \     |\n8    |     string.chars().enumerate().filter(|(_, c)| c.is_ascii_letter()).map(|(i,\
    \ _)| &string[..i]).collect()\n     |                                        \
    \                                                        ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n\
    \     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().map(|c| {\n        String::from(c).to_lowercase()\n\
    \    }).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmp3kjw6m6g.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 0..string.len()\
    \ {\n        for j in (i + 1)..string.len() {\n            prefixes.push(&string[i..j]);\n\
    \        }\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpup0pkz4w.rs:11:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    iterate(\"\", string)\n        .take_while(|&x|\
    \ {\n            matches!(x, \"..\".as_str());\n            true\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error: no rules expected the token `.`\n --> /tmp/tmpyiila04i.rs:7:29\n\
    \  |\n7 |             matches!(x, \"..\".as_str());\n  |                     \
    \        ^ no rules expected this token in macro call\n\nerror[E0425]: cannot\
    \ find function `iterate` in this scope\n --> /tmp/tmpyiila04i.rs:5:5\n  |\n5\
    \ |     iterate(\"\", string)\n  |     ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 1 {\n        return vec![string];\n\
    \    }\n\n    let mut vec = vec![];\n\n    for c in string.chars() {\n       \
    \ vec.push(c);\n        vec.push(string[..string.len() - c as usize]);\n    }\n\
    \n    vec\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3c6vyqn.rs:13:18\n   |\n\
    13 |         vec.push(string[..string.len() - c as usize]);\n   |            \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_3c6vyqn.rs:16:5\n   |\n4  | fn all_prefixes(string:\
    \ String) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n16 |     vec\n   |     ^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n\n    for (i, &x) in\
    \ string.chars().enumerate().rev() {\n        if i > 0 {\n            result.push(x);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp01dt4afj.rs:7:47\n     |\n7    |     for (i, &x) in string.chars().enumerate().rev()\
    \ {\n     |                                               ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n --> /tmp/tmp01dt4afj.rs:7:20\n\
    \  |\n7 |     for (i, &x) in string.chars().enumerate().rev() {\n  |         \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is\
    \ not implemented for `Chars<'_>`\n  |\n  = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n            &mut I\n            Args\n         \
    \   ArgsOs\n            ArrayChunks<'_, T, N>\n            ArrayChunksMut<'_,\
    \ T, N>\n            ArrayWindows<'_, T, N>\n            Box<I, A>\n         \
    \   Chunks<'_, T>\n          and 109 others\n  = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \  = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n  = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp01dt4afj.rs:7:13\n  |\n7 |     for (i, &x) in\
    \ string.chars().enumerate().rev() {\n  |             ^^     --------------------------------\
    \ this expression has type `Option<(usize, char)>`\n  |             |\n  |   \
    \          expected `char`, found reference\n  |             help: you can "
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = \"\".to_string();\n\n    for\
    \ c in string.chars() {\n        if !c.is_whitespace() {\n            prefix.push(c);\n\
    \        } else {\n            if prefix == \"\" {\n                return vec![prefix.to_string()];\n\
    \            } else {\n                prefix.pop();\n            }\n        }\n\
    \    }\n\n    vec![prefix.to_string()]\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[]`', /tmp/tmpesv63yu8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .enumerate()\n\
    \        .filter(|(_, n)| n >= 2)\n        .map(|(_, i)| string.chars()[i].to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2zzcow8o.rs:8:31\n  |\n8 |\
    \         .filter(|(_, n)| n >= 2)\n  |                               ^ expected\
    \ `&char`, found integer\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \ --> /tmp/tmp2zzcow8o.rs:9:23\n  |\n9 |         .map(|(_, i)| string.chars()[i].to_string())\n\
    \  |                       ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut input\
    \ = string;\n    while input.len() > 0 {\n        prefixes.push(input[0..input.len()\
    \ - 1]);\n        input = input[1..];\n    }\n    prefixes\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmppozbr0pw.rs:8:23\n    |\n8   |         prefixes.push(input[0..input.len()\
    \ - 1]);\n    |                  ---- ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n    |                  |\n    |                \
    \  required by a bound introduced by this call\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmppozbr0pw.rs:5:24\n    |\n5   |     let mut prefixes = Vec::new();\n\
    \    |                        ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec::<T>::new`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n   --> /tmp/tmppozbr0pw.rs:5:24\n    |\n\
    5   |     let mut prefixes = Vec::new();\n    |                        ^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmppozbr0pw.rs:9:17\n  |\n6 |     let mut input = string;\n\
    \  |                     ------ expected due to this value\n...\n9 |         input\
    \ = input[1..];\n  |                 ^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n  |                 |\n  |                 expected\
    \ struct `String`, found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppozbr0pw.rs:11:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found\
    \ `str`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<str>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = vec![];\n    for i in string.chars().enumerate()\
    \ {\n        prefixes.push(string[0..i.i]);\n    }\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0609]: no field `i` on type `(usize, char)`\n --> /tmp/tmpc103tl9c.rs:7:35\n\
    \  |\n7 |         prefixes.push(string[0..i.i]);\n  |                        \
    \           ^\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n   --> /tmp/tmpc103tl9c.rs:7:23\n    |\n7   |         prefixes.push(string[0..i.i]);\n\
    \    |                  ---- ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                  |\n    |                  required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmpc103tl9c.rs:5:24\n\
    \    |\n5   |     let mut prefixes = vec![];\n    |                        ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpc103tl9c.rs:5:24\n\
    \    |\n5   |     let mut prefixes = vec![];\n    |                        ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/tmpc103tl9c.rs:9:5\n\
    \  |\n4 | fn all_prefixes(string: String) -> Vec<String> {\n  |              \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n9 |     prefixes\n  |     ^^^^^^^^ expected struct `String`, found `str`\n\
    \  |\n  = note: expected struct `Vec<String>`\n             found struct `Vec<str>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0609.\nFor more information about "
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    let\
    \ mut len = string.len();\n    while len > 0 {\n        prefixes.push(&string[..len]);\n\
    \        len -= 1;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpix6u09i_.rs:8:23\n  |\n8 |\
    \         prefixes.push(&string[..len]);\n  |                       ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n  |\nhelp: try using a conversion method\n\
    \  |\n8 |         prefixes.push((&string[..len]).to_string());\n  |          \
    \             +              +++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::with_capacity(string.length());\n\
    \    let mut s = string;\n    while s.len() > 0 {\n        prefixes.push(s);\n\
    \        s = s.chars().next().unwrap().to_string();\n    }\n    prefixes\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n --> /tmp/tmph94x4ngb.rs:5:50\n  |\n5 |     let mut prefixes\
    \ = Vec::with_capacity(string.length());\n  |                                \
    \                  ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c|\
    \ c.is_ascii())\n        .filter_map(|c| Some(c.to_owned()))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptgzpugnd.rs:7:25\n  |\n7 |\
    \         .filter_map(|c| c.is_ascii())\n  |                         ^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n  |\n  = note: expected enum `Option<_>`\n\
    \             found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \  |\n7 |         .filter_map(|c| Some(c.is_ascii()))\n  |                   \
    \      +++++            +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    result.push(\"\
    \");\n    for &s in string.chars() {\n        let mut last = result.last().unwrap();\n\
    \        let mut rest = &s;\n        while !rest.starts_with(last) {\n       \
    \     result.push(last);\n            last += &rest[0..];\n            rest =\
    \ &rest[1..];\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm4ec62xb.rs:7:9\n  |\n7 |\
    \     for &s in string.chars() {\n  |         ^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `s`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm4ec62xb.rs:16:5\n   |\n4  | fn all_prefixes(string:\
    \ String) -> Vec<String> {\n   |                                    -----------\
    \ expected `Vec<String>` because of return type\n...\n16 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut prefix = vec![];\n    let mut index = 0;\n    while let\
    \ Some(prefix) = string.get(index) {\n        prefix.push(string[index..]);\n\
    \        index += 1;\n    }\n\n    if index == string.len() {\n        prefix.push(string[index..]);\n\
    \    }\n\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpuscsszsg.rs:11:41\n\
    \    |\n11  |     while let Some(prefix) = string.get(index) {\n    |        \
    \                             --- ^^^^^ string indices are ranges of `usize`\n\
    \    |                                     |\n    |                          \
    \           required by a bound introduced by this call\n    |\n    = help: the\
    \ trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you\
    \ can use `.chars().nth()` or `.bytes().nth()`\n            for more information,\
    \ see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpuscsszsg.rs:17:21\n\
    \    |\n17  |         prefix.push(string[index..]);\n    |                ----\
    \ ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |           \
    \     |\n    |                required by a bound introduced by this call\n  \
    \  |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpuscsszsg.rs:9:22\n\
    \    |\n9   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpuscsszsg.rs:9:22\n\
    \    |\n9   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this erro"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut current_len\
    \ = string.len();\n    while current_len > 0 {\n        prefixes.push(string.chars().take(current_len).collect::<String>());\n\
    \        current_len -= 1;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"asdfgh\", \"asdfg\", \"asdf\", \"asd\", \"as\", \"a\"]`,\n right: `[\"a\"\
    , \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpmsrai0l9.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 0..string.len()\
    \ {\n        for j in (i + 1)..string.len() {\n            prefixes.append(string[j..i]);\n\
    \        }\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpiwim5gbm.rs:8:29\n  |\n8 |\
    \             prefixes.append(string[j..i]);\n  |                            \
    \ ^^^^^^^^^^^^ expected `&mut Vec<_>`, found `str`\n  |\n  = note: expected mutable\
    \ reference `&mut Vec<_>`\n                          found type `str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    for ch in string.chars()\
    \ {\n        if !result.is_empty() {\n            result.push(*result);\n    \
    \    }\n        result.push(*string);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpffi_tkc3.rs:8:25\n  |\n8 |\
    \             result.push(*result);\n  |                         ^^^^^^^ cyclic\
    \ type of infinite size\n  |\nhelp: try using a conversion method\n  |\n8 |  \
    \           result.push((*result).to_vec());\n  |                         +  \
    \     ++++++++++\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmpffi_tkc3.rs:7:20\n    |\n7   |   \
    \      if !result.is_empty() {\n    |                    ^^^^^^^^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec::<T, A>::is_empty`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpffi_tkc3.rs:8:20\n    |\n8   |             result.push(*result);\n \
    \   |                    ^^^^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n --> /tmp/tmpffi_tkc3.rs:8:25\n \
    \ |\n8 |             result.push(*result);\n  |                         ^^^^^^^\
    \ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized`\
    \ is not implemented for `str`\n  = note: required because of the requirements\
    \ on the impl of `Deref` for `Vec<str>`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n   --> /tmp/tmpffi_tkc3.rs:10:21\n\
    \    |\n10  |         result.push(*string);\n    |                ---- ^^^^^^^\
    \ doesn't have a size known at compile-time\n    |                |\n    |   \
    \             required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpffi_tkc3.rs:5:22\n    |\n5   |\
    \     let mut result = Vec::new();\n    |                      ^^^^^^^^ doesn't\
    \ have a size"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().take_while(|c| *c == 'a').collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpxbe0bjpz.rs:5:46\n     |\n5  \
    \  |     string.chars().take_while(|c| *c == 'a').collect()\n     |          \
    \                                    ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().collect::<Vec<_>>()\n        .windows(2)\n\
    \        .flatten()\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&char`\n    --> /tmp/tmph6535bvh.rs:8:10\n     |\n8 \
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&char>`\n     |\n     = help:\
    \ the trait `FromIterator<&char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut prefix_lengths = vec![];\n    for i in 0..string.len() {\n\
    \        let prefix = &string[..i];\n        prefix_lengths.push(prefix.len());\n\
    \    }\n\n    prefix_lengths\n        .iter()\n        .map(|&length| string.substr(0,\
    \ length))\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `substr` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp90c9er0g.rs:17:31\n   |\n17 |         .map(|&length|\
    \ string.substr(0, length))\n   |                               ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    for c in string.chars()\
    \ {\n        prefix.push(c);\n        if c.is_ascii() {\n            break;\n\
    \        }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp44g_2htm.rs:12:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n12 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() < 3 {\n        return vec![\"\
    aa\", \"ab\", \"ac\"]\n    }\n    if string.len() == 3 {\n        return vec![\"\
    a\", \"ab\", \"ac\"]\n    }\n    if string.len() == 4 {\n        return vec![\"\
    aa\", \"a\", \"ab\", \"aba\", \"ac\"]\n    }\n    if string.len() == 5 {\n   \
    \     return vec![\"aaa\", \"a\", \"aab\", \"aba\", \"abca\", \"ac\", \"aca\"\
    , \"acba\", \"acb\", \"acca\", \"acda\", \"acd\", \"acde\", \"acdf\"]\n    }\n\
    \    if string.len() == 6 {\n        return vec![\n            \"aaa\",\n    \
    \        \"aaab\",\n            \"aaac\",\n            \"aab\",\n            \"\
    aabb\",\n            \"aabc\",\n            \"aabc\",\n            \"ab\",\n \
    \           \"aba\",\n            \"abac\",\n            \"abaca\",\n        \
    \    \"abacab\",\n            \"abacac\",\n            \"abacad\",\n         \
    \   \"abacae\",\n            \"abacaea\",\n            \"abacaeaa\",\n       \
    \     \"abacaeaaa\",\n            \"abacaeaaaa\",\n            \"abacaeaaaaa\"\
    ,\n            \"abacaeaaaaaa\",\n            \"abacaeaaaaaaa\",\n           \
    \ \"abacaeaaaaaaaa\",\n            \"abacaeaaaaaaaaa\",\n            \"abacaeaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaa\",\n \
    \           \"abacaeaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaa\",\n\
    \            \"abacaeaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ,\n            \"abacaeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            \"abacaeaaaaaaaaaaaaaaaaa\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpo7318n0h.rs:74:109\n\
    \   |\n74 |       assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"\
    W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n   |  _____________________________________________________________________________________________________________^\n\
    75 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut current_string\
    \ = \"a\";\n    let mut counter = 1;\n    while current_string.len() > 0 {\n \
    \       prefixes.push(\"a\".to_string() + &current_string[0..counter]);\n    \
    \    current_string = &current_string[counter..];\n        counter += 1;\n   \
    \ }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\"]`,\n right: `[]`', /tmp/tmpwavd73z1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut len = string.len();\n    vec![\"\"; len]\n\
    \        .into_iter()\n        .take_while(|&x| !string.ends_with(x))\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpejt0xgue.rs:9:10\n     |\n9  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().map(|c| c.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmpiu8da01d.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut current_prefix\
    \ = string.to_string();\n    for current_char_of_string in string.chars() {\n\
    \        if current_char_of_string.len() < current_prefix.len() {\n          \
    \  current_prefix = current_char_of_string;\n        } else {\n            prefixes.push(current_prefix);\n\
    \            current_prefix = current_char_of_string;\n        }\n    }\n    prefixes.push(current_prefix);\n\
    \    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n --> /tmp/tmplou614v6.rs:8:35\n  |\n8 |         if current_char_of_string.len()\
    \ < current_prefix.len() {\n  |                                   ^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmplou614v6.rs:9:30\n\
    \  |\n6 |     let mut current_prefix = string.to_string();\n  |              \
    \                ------------------ expected due to this value\n...\n9 |     \
    \        current_prefix = current_char_of_string;\n  |                       \
    \       ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \  |                              |\n  |                              expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplou614v6.rs:12:30\n\
    \   |\n6  |     let mut current_prefix = string.to_string();\n   |           \
    \                   ------------------ expected due to this value\n...\n12 | \
    \            current_prefix = current_char_of_string;\n   |                  \
    \            ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    for x in string.chars()\
    \ {\n        prefix.push(x);\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsbtojiox.rs:9:5\n  |\n4 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     prefix\n  |     ^^^^^^ expected struct `String`, found `char`\n  |\n \
    \ = note: expected struct `Vec<String>`\n             found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    // Create prefix tree and get all prefixes of\
    \ a string.\n    let mut prefix = String::with_capacity(string);\n    prefix.push(\"\
    \");\n\n    let mut prefix_tree: Option<Vec<String>> = None;\n\n    while let\
    \ Some(index) = string.find(' ', 0) {\n        let prefix = prefix.clone();\n\
    \        let prefix = prefix.trim_end(); // remove leading space\n\n        let\
    \ (left, right) = string.split_at(index);\n\n        let prefix_tree: Vec<String>\
    \ = left\n            .split_whitespace()\n            .map(|s| prefix.push(s))\n\
    \            .collect();\n\n        prefix = right;\n        prefix_tree = Some(prefix_tree);\n\
    \    }\n\n    match prefix_tree {\n        None => Vec::new(),\n        Some(prefix_tree)\
    \ => prefix_tree,\n    }\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzw0blacj.rs:6:44\n  |\n6 |\
    \     let mut prefix = String::with_capacity(string);\n  |                   \
    \                         ^^^^^^ expected `usize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpzw0blacj.rs:7:17\n  |\n7 |     prefix.push(\"\
    \");\n  |                 ^^ expected `char`, found `&str`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpzw0blacj.rs:11:36\n\
    \     |\n11   |     while let Some(index) = string.find(' ', 0) {\n     |    \
    \                                ^^^^ ---  - supplied 2 arguments\n     |    \
    \                                |\n     |                                   \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpzw0blacj.rs:19:29\n   |\n19 |             .map(|s| prefix.push(s))\n\
    \   |                             ^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzw0blacj.rs:23:23\n   |\n17 |         let prefix_tree:\
    \ Vec<String> = left\n   |                          ----------- expected due to\
    \ this type\n...\n23 |         prefix_tree = Some(prefix_tree);\n   |        \
    \               ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<_>`\n                found enum `Option<Vec<_>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = Vec::new();\n\
    \    let mut current_string: String = string;\n    while current_string.len()\
    \ > 0 {\n        prefixes.push(current_string);\n        current_string.remove(0);\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `current_string`\n --> /tmp/tmpzalkrnwy.rs:7:11\n\
    \  |\n6 |     let mut current_string: String = string;\n  |         ------------------\
    \ move occurs because `current_string` has type `String`, which does not implement\
    \ the `Copy` trait\n7 |     while current_string.len() > 0 {\n  |           ^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n8 |         prefixes.push(current_string);\n\
    \  |                       -------------- value moved here, in previous iteration\
    \ of loop\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = vec![];\n    let\
    \ mut i = 0;\n    while i <= string.len() - 1 {\n        prefixes.push(&string[i..]);\n\
    \        i += 1;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5pks0nfy.rs:8:23\n  |\n8 |\
    \         prefixes.push(&string[i..]);\n  |                       ^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n  |\nhelp: try using a conversion method\n\
    \  |\n8 |         prefixes.push((&string[i..]).to_string());\n  |            \
    \           +            +++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 0 {\n        return Vec::new();\n\
    \    }\n    let mut prefixes = Vec::new();\n    let mut cur = string;\n    for\
    \ suffix in string.chars().rev() {\n        if let Some(index) = cur.find(suffix)\
    \ {\n            prefixes.push(cur.trim_end().to_string());\n            cur =\
    \ &String::from_utf8(index)[..];\n        }\n    }\n    prefixes.push(cur);\n\
    \    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnoxr4hye.rs:13:38\n   |\n\
    13 |             cur = &String::from_utf8(index)[..];\n   |                  \
    \                    ^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<u8>`\n                found type `usize`\n\nerror[E0608]:\
    \ cannot index into a value of type `Result<String, FromUtf8Error>`\n  --> /tmp/tmpnoxr4hye.rs:13:20\n\
    \   |\n13 |             cur = &String::from_utf8(index)[..];\n   |           \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut res = vec![];\n    for (i, &s) in string.chars().enumerate()\
    \ {\n        res.push((&s[..i]).to_owned());\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp26p3yr0t.rs:6:13\n  |\n6 |\
    \     for (i, &s) in string.chars().enumerate() {\n  |             ^^     --------------------------\
    \ this expression has type `Option<(usize, char)>`\n  |             |\n  |   \
    \          expected `char`, found reference\n  |             help: you can probably\
    \ remove the explicit borrow: `s`\n  |\n  = note:   expected type `char`\n   \
    \       found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut cur\
    \ = String::from(string);\n\n    while cur.len() > 0 {\n        prefixes.push(cur.clone());\n\
    \        cur = String::from(&cur[..]);\n    }\n\n    prefixes\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix_list: Vec<String> = vec![];\n \
    \   let mut shortest = string.to_owned();\n    let mut longest = string.to_owned();\n\
    \n    // Go through all characters, if shorter string contains it\n    for s in\
    \ string.chars() {\n        if shortest.contains(&s) {\n            shortest =\
    \ &s[..];\n            prefix_list.push(shortest);\n        }\n    }\n\n    while\
    \ !shortest.is_empty() {\n        let mut shortest = string.to_owned();\n\n  \
    \      // Go through all characters, if shorter string contains it\n        for\
    \ s in string.chars() {\n            if shortest.contains(&s) {\n            \
    \    shortest = &s[..];\n                prefix_list.push(shortest);\n       \
    \     }\n        }\n\n        // Go through all characters, if longer string contains\
    \ it\n        for s in string.chars() {\n            if longest.contains(&s) {\n\
    \                longest = &s[..];\n                prefix_list.push(longest);\n\
    \            }\n        }\n    }\n\n    prefix_list\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp4_dadfth.rs:11:30\n\
    \     |\n11   |         if shortest.contains(&s) {\n     |                   \
    \  -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |       \
    \              |\n     |                     required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n11   |         if shortest.contains(*&s)\
    \ {\n     |                              +\n\nerror[E0608]: cannot index into\
    \ a value of type `char`\n  --> /tmp/tmp4_dadfth.rs:12:25\n   |\n12 |        \
    \     shortest = &s[..];\n   |                         ^^^^^\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp4_dadfth.rs:22:34\n\
    \     |\n22   |             if shortest.contains(&s) {\n     |               \
    \          -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |\
    \                         |\n     |                         required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(char,)>` is not\
    \ implemented for `char`\n     = note: required because of the requirements on\
    \ the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required by\
    \ a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing here\n\
    \     |\n22   |             if shortest.contains(*&s) {\n     |              \
    \                    +\n\nerror[E0608]: cannot index into a value of type `char`\n\
    \  --> /tmp/tmp4_dadfth.rs:23:29\n   |\n23 |                 shortest = &s[..];\n\
    \   |                             ^^^^^\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp4_dadfth.rs:30:33\n     |\n30   |   \
    \          if longest.co"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut current_prefix = &string[0];\n    let\
    \ mut prefixes = Vec::new();\n    prefixes.push(current_prefix);\n    while let\
    \ Some(c) = &string[current_prefix.len() + 1..] {\n        prefixes.push(c);\n\
    \        current_prefix.push_str(c);\n    }\n    prefixes\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmp389cjnxg.rs:5:31\n  |\n5 |     let mut current_prefix = &string[0];\n\
    \  |                               ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \  |\n  = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp389cjnxg.rs:8:15\n  |\n8 |    \
    \ while let Some(c) = &string[current_prefix.len() + 1..] {\n  |             \
    \  ^^^^^^^   ----------------------------------- this expression has type `&str`\n\
    \  |               |\n  |               expected `str`, found enum `Option`\n\
    \  |\n  = note: expected type `str`\n             found enum `Option<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().take_while(|x| *x != ' ').collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpu4yjs_h2.rs:5:46\n     |\n5  \
    \  |     string.chars().take_while(|x| *x != ' ').collect()\n     |          \
    \                                    ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes: Vec<String> = Vec::new();\n\n\
    \    string\n        .split_str(\"\")\n        .for_each(|s| {\n            if\
    \ s.len() == 1 {\n                prefixes.push(s);\n            } else {\n  \
    \              prefixes.push(&s[..s.len() - 1] + &s[0]);\n            }\n    \
    \    });\n\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_str` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpjo56rk9z.rs:8:10\n  |\n8 |         .split_str(\"\
    \")\n  |          ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n    let mut i = 1;\n\
    \    for ch in string.chars() {\n        if i == 1 {\n            result.push(ch);\n\
    \        } else {\n            result.push(ch.to_owned().to_ascii_lowercase());\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsn0fo0pb.rs:15:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n15 |     result\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().take_while(|c| !c.is_ascii_alphanumeric())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp8f_nyr8i.rs:6:10\n     |\n6  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    for c in string.chars()\
    \ {\n        if let Some(c) = (string.clone() - c).chars().next() {\n        \
    \    prefix.push(c);\n        } else {\n            break;\n        }\n    }\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `String`\n --> /tmp/tmp1o1vd6an.rs:7:42\n\
    \  |\n7 |         if let Some(c) = (string.clone() - c).chars().next() {\n  |\
    \                           -------------- ^ - char\n  |                     \
    \      |\n  |                           String\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut iter = string.char_indices();\n\
    \    let mut first = true;\n    for (i, char) in iter.peek().cloned() {\n    \
    \    if first {\n            prefix.push(char.to_string());\n            first\
    \ = false;\n        } else {\n            prefix.push(char.as_bytes().to_vec().to_string());\n\
    \        }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `peek` found for struct `CharIndices` in\
    \ the current scope\n --> /tmp/tmp7_y1mxye.rs:8:27\n  |\n8 |     for (i, char)\
    \ in iter.peek().cloned() {\n  |                           ^^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars()\n        .flat_map(|c| vec![String::new(),\
    \ &c as &str[..]])\n        .iter()\n        .enumerate()\n        .map(|(i, s)|\
    \ {\n            if s.len() < 2 {\n                println!(\"String {} is too\
    \ short, returning None\", s);\n                return None;\n            }\n\n\
    \            if i == 0 {\n                s.into_owned()\n            } else {\n\
    \                s.split_first_mut()\n                    .unwrap()\n        \
    \            .into_owned()\n                    .to_owned()\n            }\n \
    \       })\n        .filter(|s| s != None)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by indexing\n --> /tmp/tmpj_kiegm6.rs:6:43\n\
    \  |\n6 |         .flat_map(|c| vec![String::new(), &c as &str[..]])\n  |    \
    \                                       ^^^^^^^^^^\n  |\nhelp: try surrounding\
    \ the expression in parentheses\n  |\n6 |         .flat_map(|c| vec![String::new(),\
    \ (&c as &str)[..]])\n  |                                           +        \
    \  +\n\nerror[E0308]: mismatched types\n --> /tmp/tmpj_kiegm6.rs:6:43\n  |\n6\
    \ |         .flat_map(|c| vec![String::new(), &c as &str[..]])\n  |          \
    \                                 ^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n  |                                           |\n  |\
    \                                           expected struct `String`, found `str`\n\
    \nerror[E0599]: no method named `iter` found for struct `FlatMap` in the current\
    \ scope\n --> /tmp/tmpj_kiegm6.rs:7:10\n  |\n7 |         .iter()\n  |        \
    \  ^^^^ method not found in `FlatMap<Chars<'_>, Vec<String, _>, [closure@/tmp/tmpj_kiegm6.rs:6:19:\
    \ 6:58]>`\n\nerror[E0605]: non-primitive cast: `&char` as `&str`\n --> /tmp/tmpj_kiegm6.rs:6:43\n\
    \  |\n6 |         .flat_map(|c| vec![String::new(), &c as &str[..]])\n  |    \
    \                                       ^^^^^^^^^^ an `as` expression can only\
    \ be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599, E0605.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() < 3 {\n        Vec::new()\n  \
    \  } else {\n        let mut prefix = vec![];\n        let mut current_prefix\
    \ = vec![&string[0]];\n        for char in &string[1..] {\n            if char\
    \ == current_prefix[current_prefix.len() - 1].as_ref() {\n                continue;\n\
    \            }\n            prefix.push(char);\n            current_prefix.push(char);\n\
    \        }\n        prefix\n    }\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpcpmzifdh.rs:9:40\n  |\n9 |         let mut current_prefix = vec![&string[0]];\n\
    \  |                                        ^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n  |\n  = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: `&str` is not an iterator\n  --> /tmp/tmpcpmzifdh.rs:10:21\n \
    \  |\n10 |         for char in &string[1..] {\n   |                     ^^^^^^^^^^^^\
    \ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `&str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n\n    for ch in string.chars()\
    \ {\n        prefix.push(ch as char);\n    }\n\n    for ch in string.chars().rev()\
    \ {\n        prefix.push(ch as char);\n    }\n\n    prefix\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcvy443q.rs:15:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n15 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() <= 2 {\n        return vec![];\n\
    \    }\n\n    let mut prefix = vec![];\n    let mut len = string.len();\n    while\
    \ len > 0 {\n        let mut pos = 0;\n        while pos < len && string[pos]\
    \ == string[len - pos] {\n            pos += 1;\n        }\n        prefix.push(&string[..pos]);\n\
    \        len -= pos;\n    }\n    prefix\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp36fr421q.rs:13:28\n\
    \   |\n13 |         while pos < len && string[pos] == string[len - pos] {\n  \
    \ |                            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp36fr421q.rs:13:43\n   |\n13 |         while pos < len && string[pos]\
    \ == string[len - pos] {\n   |                                           ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp36fr421q.rs:19:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n19 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = String::new();\n    let mut s\
    \ = string;\n    while !s.is_empty() {\n        prefix.push(*s);\n        s =\
    \ &s[1..];\n    }\n    prefix.reverse();\n    prefix\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxf6d7efh.rs:8:21\n  |\n8 |\
    \         prefix.push(*s);\n  |                     ^^ expected `char`, found\
    \ `str`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpxf6d7efh.rs:9:13\n  |\n\
    6 |     let mut s = string;\n  |                 ------ expected due to this value\n\
    ...\n9 |         s = &s[1..];\n  |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n  |\nhelp: try using a conversion method\n  |\n9 |         s =\
    \ (&s[1..]).to_string();\n  |             +       +++++++++++++\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpxf6d7efh.rs:11:12\n   |\n11 |     prefix.reverse();\n   |      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxf6d7efh.rs:12:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    12 |     prefix\n   |     ^^^^^^ expected struct `Vec`, found struct `String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `String`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.iter().filter_map(|c| c.chars().collect::<Vec<Char>>().into_iter().map(|c|\
    \ c.to_string()).collect()).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n --> /tmp/tmpxpcsa2fb.rs:5:58\n\
    \  |\n5 |     string.iter().filter_map(|c| c.chars().collect::<Vec<Char>>().into_iter().map(|c|\
    \ c.to_string()).collect()).collect()\n  |                                   \
    \                       ^^^^\n  |\nhelp: a builtin type with a similar name exists\n\
    \  |\n5 |     string.iter().filter_map(|c| c.chars().collect::<Vec<char>>().into_iter().map(|c|\
    \ c.to_string()).collect()).collect()\n  |                                   \
    \                       ~~~~\nhelp: you might be missing a type parameter\n  |\n\
    4 | fn all_prefixes<Char>(string: String) -> Vec<String> {\n  |              \
    \  ++++++\n\nerror[E0599]: no method named `iter` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpxpcsa2fb.rs:5:12\n  |\n5 |     string.iter().filter_map(|c|\
    \ c.chars().collect::<Vec<Char>>().into_iter().map(|c| c.to_string()).collect()).collect()\n\
    \  |            ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n5 |     string.chars().filter_map(|c| c.chars().collect::<Vec<Char>>().into_iter().map(|c|\
    \ c.to_string()).collect()).collect()\n  |            ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0599.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter(|c|\
    \ !c.is_ascii())\n        .map(|c| string[..c].to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<char>`\n\
    \ --> /tmp/tmpjresmox6.rs:8:18\n  |\n8 |         .map(|c| string[..c].to_string())\n\
    \  |                  ^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n\
    \  |\n  = help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    for ch in string.chars()\
    \ {\n        prefix.push(*ch);\n    }\n    for ch in prefix {\n        let mut\
    \ suffix = Vec::new();\n        for ch in prefix {\n            if ch != *ch {\n\
    \                break;\n            }\n            suffix.push(*ch);\n      \
    \  }\n        for ch in suffix {\n            prefix.push(&*ch);\n        }\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmprrxeb3i6.rs:7:21\n\
    \  |\n7 |         prefix.push(*ch);\n  |                     ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut chars\
    \ = string.chars();\n    loop {\n        let char = chars.next();\n        if\
    \ char == None {\n            break;\n        }\n        prefix.push(char.unwrap());\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpubve_7c2.rs:14:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n14 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .chain(string.chars().skip_while(|c|\
    \ c.is_ascii_lowercase()))\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppeiottpa.rs:5:5\n  |\n4 |\
    \   fn all_prefixes(string: String) -> Vec<String> {\n  |                    \
    \                  ----------- expected `Vec<String>` because of return type\n\
    5 | /     string\n6 | |         .chars()\n7 | |         .chain(string.chars().skip_while(|c|\
    \ c.is_ascii_lowercase()))\n8 | |         .collect::<Vec<_>>()\n  | |____________________________^\
    \ expected struct `String`, found `char`\n  |\n  = note: expected struct `Vec<String>`\n\
    \             found struct `Vec<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n    for c in string.chars()\
    \ {\n        let idx = string.find(c.to_string());\n        if idx != String::npos\
    \ {\n            result.push(&string[idx..]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpfwvus8ew.rs:7:31\n     |\n7    |         let idx = string.find(c.to_string());\n\
    \     |                          ---- ^^^^^^^^^^^^^ expected an implementor of\
    \ trait `Pattern<'_>`\n     |                          |\n     |             \
    \             required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n7    |         let idx = string.find(&c.to_string());\n     |\
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n --> /tmp/tmpfwvus8ew.rs:8:27\n\
    \  |\n8 |         if idx != String::npos {\n  |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n --> /tmp/tmpfwvus8ew.rs:9:26\n\
    \  |\n9 |             result.push(&string[idx..]);\n  |                      \
    \    ^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  |\n  = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfwvus8ew.rs:12:5\n   |\n4  | fn\
    \ all_prefixes(string: String) -> Vec<String> {\n   |                        \
    \            ----------- expected `Vec<String>` because of return type\n...\n\
    12 |     result\n   |     ^^^^^^ expected struct `String`, found reference\n \
    \  |\n   = note: expect"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    for ch in string.chars()\
    \ {\n        if !prefix.contains(&ch) {\n            prefix.push(ch);\n      \
    \  }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp363ycj30.rs:11:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars()\n        .enumerate()\n       \
    \ .map(|(idx, c)| {\n            if idx < string.len() - 1 {\n               \
    \ string[idx .. idx + 1]\n            } else {\n                c.to_string()\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp2__b93bn.rs:11:17\n\
    \   |\n8  | /             if idx < string.len() - 1 {\n9  | |                \
    \ string[idx .. idx + 1]\n   | |                 ---------------------- expected\
    \ because of this\n10 | |             } else {\n11 | |                 c.to_string()\n\
    \   | |                 ^^^^^^^^^^^^^ expected `str`, found struct `String`\n\
    12 | |             }\n   | |_____________- `if` and `else` have incompatible types\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut prefix_len\
    \ = 1;\n    let mut string = string.to_string();\n    let mut i = 0;\n\n    while\
    \ i < string.len() {\n        if string[prefix_len..].starts_with(&string[i..])\
    \ {\n            prefixes.push(&string[i..prefix_len]);\n            i += prefix_len;\n\
    \            prefix_len += 1;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n\n    return prefixes;\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0rntqy2u.rs:20:12\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n20 |     return prefixes;\n   |            ^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        vec![]\n    }\
    \ else {\n        let mut prefix_list = Vec::new();\n        let mut s = string;\n\
    \        while !s.is_empty() {\n            let mut prefix = s.clone();\n    \
    \        prefix.prepend('');\n            prefix_list.push(prefix);\n        \
    \    s = prefix.clone();\n        }\n        prefix_list\n    }\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpbkivt6e9.rs:12:29\n   |\n\
    12 |             prefix.prepend('');\n   |                             ^ empty\
    \ character literal\n\nerror[E0599]: no method named `prepend` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpbkivt6e9.rs:12:20\n   |\n12 | \
    \            prefix.prepend('');\n   |                    ^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut curr = string.clone();\n\
    \    loop {\n        prefix.push(curr);\n        if !curr.is_empty() {\n     \
    \       let next_char = curr[0];\n            curr = curr.chars().skip(1).collect();\n\
    \            prefix.push(&next_char);\n        }\n        if curr.is_empty() {\n\
    \            break;\n        }\n    }\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpu93udf49.rs:10:29\n   |\n10 |             let next_char = curr[0];\n\
    \   |                             ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu93udf49.rs:12:25\n\
    \   |\n12 |             prefix.push(&next_char);\n   |                       \
    \  ^^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n12 -             prefix.push(&next_char);\n12 +             prefix.push(next_char);\n\
    \   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut prefixes = vec![];\n    let mut current_prefix: String =\
    \ \"\";\n    for (i, char) in string.chars().enumerate() {\n        let mut new_prefix\
    \ = current_prefix.clone();\n        new_prefix.push_str(&char);\n        if i\
    \ == 0 {\n            prefixes.push(new_prefix);\n        } else {\n         \
    \   prefixes.push(format!(\"{}{}\", new_prefix, &prefixes[prefixes.len() - 2]));\n\
    \        }\n        current_prefix = new_prefix;\n    }\n\n    prefixes\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcrcdj8ky.rs:10:38\n   |\n\
    10 |     let mut current_prefix: String = \"\";\n   |                        \
    \     ------   ^^- help: try using a conversion method: `.to_string()`\n   | \
    \                            |        |\n   |                             |  \
    \      expected struct `String`, found `&str`\n   |                          \
    \   expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcrcdj8ky.rs:13:29\n\
    \   |\n13 |         new_prefix.push_str(&char);\n   |                        \
    \     ^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .enumerate()\n\
    \        .filter_map(|(i, c)| {\n            c.starts_with(&string[..i])\n   \
    \             .map(|i| string[..i + 1])\n                .map(|s| s.to_string())\n\
    \                .collect()\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n --> /tmp/tmp3gce9nca.rs:9:15\n  |\n9 |             c.starts_with(&string[..i])\n\
    \  |               ^^^^^^^^^^^ method not found in `char`\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n  --> /tmp/tmp3gce9nca.rs:10:26\n\
    \   |\n10 |                 .map(|i| string[..i + 1])\n   |                  \
    \        ^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: the return type of a function\
    \ must have a statically known size\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .flat_map(|c|\
    \ {\n            c.is_alphabetic() + &[c]\n        })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&[char; 1]` to `bool`\n --> /tmp/tmpht7y2h_j.rs:8:31\n\
    \  |\n8 |             c.is_alphabetic() + &[c]\n  |             -----------------\
    \ ^ ---- &[char; 1]\n  |             |\n  |             bool\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut s =\
    \ string.chars();\n    while let Some(next_char) = s.pop() {\n        let index\
    \ = string.rfind(next_char);\n        if index == -1 {\n            result.push(next_char.to_string());\n\
    \        } else {\n            s.push(string.chars().nth(index + 1).unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pop` found for struct `Chars` in the current\
    \ scope\n --> /tmp/tmpcabf92xb.rs:7:35\n  |\n7 |     while let Some(next_char)\
    \ = s.pop() {\n  |                                   ^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpcabf92xb.rs:9:21\n  |\n9 |    \
    \     if index == -1 {\n  |                     ^^ expected enum `Option`, found\
    \ integer\n  |\n  = note: expected enum `Option<usize>`\n             found type\
    \ `{integer}`\nhelp: try wrapping the expression in `Some`\n  |\n9 |         if\
    \ index == Some(-1) {\n  |                     +++++  +\n\nerror[E0599]: no method\
    \ named `push` found for struct `Chars` in the current scope\n  --> /tmp/tmpcabf92xb.rs:12:15\n\
    \   |\n12 |             s.push(string.chars().nth(index + 1).unwrap());\n   |\
    \               ^^^^ method not found in `Chars<'_>`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpcabf92xb.rs:12:45\n   |\n12 |\
    \             s.push(string.chars().nth(index + 1).unwrap());\n   |          \
    \                             ----- ^ - {integer}\n   |                      \
    \                 |\n   |                                       Option<usize>\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut i = string.len();\n\
    \    while i > 0 {\n        prefix.push(string[..i]);\n        i -= 1;\n    }\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpt8_3hv_v.rs:8:21\n    |\n8   |         prefix.push(string[..i]);\n\
    \    |                ---- ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmpt8_3hv_v.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpt8_3hv_v.rs:5:22\n\
    \    |\n5   |     let mut prefix = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt8_3hv_v.rs:11:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `str`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<str>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut current = String::from(\"\");\n    for\
    \ char in string.chars() {\n        current = char.to_string() + current;\n  \
    \      if current.len() >= string.len() {\n            current.pop();\n      \
    \  }\n        current.push(*char);\n    }\n    vec![current]\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj3e0k3v1.rs:7:38\n  |\n7 |\
    \         current = char.to_string() + current;\n  |                         \
    \             ^^^^^^^\n  |                                      |\n  |       \
    \                               expected `&str`, found struct `String`\n  |  \
    \                                    help: consider borrowing here: `&current`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpj3e0k3v1.rs:11:22\n\
    \   |\n11 |         current.push(*char);\n   |                      ^^^^^\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut list = vec![];\n    for c in string.chars()\
    \ {\n        list.push(c);\n        for prefix in list.iter().rev() {\n      \
    \      if string.starts_with(prefix) {\n                break;\n            }\n\
    \            list.pop();\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpc_jozh3q.rs:9:35\n\
    \     |\n9    |             if string.starts_with(prefix) {\n     |          \
    \             ----------- ^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                       |\n     |                       required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(char,)>` is not\
    \ implemented for `char`\n     = note: required because of the requirements on\
    \ the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required by\
    \ a bound in `core::str::<impl str>::starts_with`\nhelp: consider dereferencing\
    \ here\n     |\n9    |             if string.starts_with(*prefix) {\n     |  \
    \                                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_jozh3q.rs:15:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n15 |     list\n   |     ^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut prefixes = vec![];\n    let mut prefix = string.chars().next().unwrap();\n\
    \    while let Some(other) = string.chars().nth(1) {\n        if other == prefix\
    \ {\n            break;\n        }\n        prefixes.push(prefix);\n        prefix\
    \ = other;\n    }\n    prefixes.push(prefix);\n    prefixes\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoasr62x_.rs:18:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n18 |     prefixes\n   |     ^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().collect()\n        .filter(|char|\
    \ char != '.')\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmplmcu6_om.rs:5:20\n\
    \  |\n5 |     string.chars().collect()\n  |                    ^^^^^^^ cannot\
    \ infer type for type parameter `B` declared on the associated function `collect`\n\
    \  |\n  = note: type must be known at this point\nhelp: consider specifying the\
    \ type argument in the method call\n  |\n5 |     string.chars().collect::<B>()\n\
    \  |                           +++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    prefixes.push(string[0]);\n\
    \    let mut index = 1;\n    while index < string.len() {\n        if string[index]\
    \ == string[index - 1] {\n            prefixes.push(string[index]);\n        \
    \    index = index + 1;\n        } else {\n            prefixes.push(string[index]);\n\
    \            prefixes.push(string[index - 1]);\n            index = index + 1;\n\
    \        }\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpvodnq7_z.rs:6:19\n  |\n6 |     prefixes.push(string[0]);\n  |      \
    \             ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n  |\n  = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n  = help: the\
    \ following other types implement trait `Index<Idx>`:\n            <String as\
    \ Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n       \
    \     <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n --> /tmp/tmpvodnq7_z.rs:9:12\n\
    \  |\n9 |         if string[index] == string[index - 1] {\n  |            ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpvodnq7_z.rs:9:29\n\
    \  |\n9 |         if string[index] == string[index - 1] {\n  |               \
    \              ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n\
    \  = help: the trait `Index<usize>` is not implemented for `String`\n  = help:\
    \ the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Inde"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return vec![];\n\
    \    }\n    let mut prefixes: Vec<String> = vec![];\n    let mut len = string.len();\n\
    \    let mut current = &string[0];\n    let mut c = 0;\n    while len > 0 {\n\
    \        while !current.starts_with(&prefixes[c]) {\n            c++;\n      \
    \      if c >= prefixes.len() {\n                c = prefixes.len();\n       \
    \     }\n        }\n        prefixes.push(&current[0..c]);\n        current =\
    \ &string[1..len];\n        len -= c;\n        c = 0;\n    }\n    prefixes\n}\n\
    \nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp0r2hcspg.rs:14:14\n\
    \   |\n14 |             c++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n14 |             { let tmp = c; c += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n14 -             c++;\n\
    14 +             c += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmp0r2hcspg.rs:10:24\n   |\n10 |     let mut current\
    \ = &string[0];\n   |                        ^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .filter_map(|c|\
    \ c.to_digit(10))\n        .collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `u32`\n    --> /tmp/tmpiri8v1qo.rs:8:10\n     |\n8   \
    \ |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=u32>`\n     |\n     = help: the trait\
    \ `FromIterator<u32>` is not implemented for `Vec<String>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n\
    \    }\n\n    let mut prefixes = vec![];\n    let mut current = &string[0];\n\
    \    while let Some(current) = current.chars().next() {\n        let mut prefix:\
    \ Vec<String> = vec![];\n        prefix.push(current.to_string());\n        prefix.push(\"\
    &\");\n        prefix.push(\"*\");\n        prefix.push(\"+\");\n        prefix.push(\"\
    -\");\n        prefix.push(\"~\");\n\n        while let Some(current) = current.chars().next()\
    \ {\n            prefix.push(current.to_string());\n            prefix.push(\"\
    &\");\n            prefix.push(\"*\");\n            prefix.push(\"+\");\n    \
    \        prefix.push(\"-\");\n            prefix.push(\"~\");\n        }\n\n \
    \       prefixes.push(prefix);\n    }\n\n    prefixes\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppxdhyk46.rs:10:24\n   |\n10 |     let mut current = &string[0];\n  \
    \ |                        ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppxdhyk46.rs:14:21\n\
    \   |\n14 |         prefix.push(\"&\");\n   |                     ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                     |\n   |\
    \                     expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppxdhyk46.rs:15:21\n   |\n15 |         prefix.push(\"\
    *\");\n   |                     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppxdhyk46.rs:16:21\n\
    \   |\n16 |         prefix.push(\"+\");\n   |                     ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                     |\n   |\
    \                     expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppxdhyk46.rs:17:21\n   |\n17 |         prefix.push(\"\
    -\");\n   |                     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                     |\n   |                     expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppxdhyk46.rs:18:21\n\
    \   |\n18 |         prefix.push(\"~\");\n   |                     ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                     |\n   |\
    \                     expected struct `String"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut i = 0;\n\
    \    loop {\n        if i >= string.len() {\n            break;\n        }\n \
    \       let mut j = i;\n        while j < string.len() && string[j] == string[j\
    \ + 1] {\n            j += 1; // unwrap the potential trailing \\0 \n        }\n\
    \        prefix.push(&string[i..j]);\n        i = j;\n    }\n    prefix\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph4zxvchp.rs:12:35\n\
    \   |\n12 |         while j < string.len() && string[j] == string[j + 1] {\n \
    \  |                                   ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph4zxvchp.rs:12:48\n   |\n12 |         while j < string.len() &&\
    \ string[j] == string[j + 1] {\n   |                                         \
    \       ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph4zxvchp.rs:18:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n18 |     prefix\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n    let mut s = string;\n\
    \    while !s.is_empty() {\n        result.push(s);\n        s = s.trim_left();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_left`:\
    \ superseded by `trim_start`\n --> /tmp/tmpwxoo9f34.rs:9:15\n  |\n9 |        \
    \ s = s.trim_left();\n  |               ^^^^^^^^^ help: replace the use of the\
    \ deprecated associated function: `trim_start`\n  |\n  = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwxoo9f34.rs:9:13\n\
    \  |\n6 |     let mut s = string;\n  |                 ------ expected due to\
    \ this value\n...\n9 |         s = s.trim_left();\n  |             ^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n  |             |\n  |\
    \             expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().map(|c| c.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"s\", \"d\", \"f\", \"g\", \"h\"]`,\n right: `[\"a\", \"as\", \"asd\"\
    , \"asdf\", \"asdfg\", \"asdfgh\"]`', /tmp/tmppf8qhu9k.rs:11:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n    let mut current\
    \ = string;\n    loop {\n        current.split_prefix(&mut result);\n        result.sort();\n\
    \        result.dedup();\n        result.push(\"*\");\n        if current.len()\
    \ == 0 {\n            break;\n        }\n        let next = current.clone();\n\
    \        let result = &current;\n        current.dedup();\n        current.pop();\n\
    \        current = next;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_prefix` found for struct `String`\
    \ in the current scope\n --> /tmp/tmp15j6q_or.rs:8:17\n  |\n8 |         current.split_prefix(&mut\
    \ result);\n  |                 ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `strip_prefix`\n\nerror[E0599]: no method named `dedup`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp15j6q_or.rs:17:17\n\
    \   |\n17 |         current.dedup();\n   |                 ^^^^^ method not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15j6q_or.rs:21:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n21 |     result\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n\n    for c in string.chars()\
    \ {\n        for p in &prefix {\n            if *p == c {\n                continue;\n\
    \            }\n            *p = c;\n            break;\n        }\n    }\n\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqomu8pla.rs:17:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n17 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut prefix\
    \ = \"\";\n    for (i, c) in string.chars().enumerate() {\n        if c == 'a'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            if i < string.len() - 1 {\n\
    \                prefix = string.chars().nth(i + 1).to_string();\n           \
    \ }\n        } else {\n            if i > 0 {\n                prefixes.push(prefix\
    \ + c);\n            }\n        }\n    }\n    prefixes\n}\n\nfn main() {\n   \
    \ let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n  \
    \ --> /tmp/tmpcyytfpfp.rs:10:52\n    |\n10  |                   prefix = string.chars().nth(i\
    \ + 1).to_string();\n    |                                                   \
    \   ^^^^^^^^^ `Option<char>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: std::fmt::Display`\n            which is required by `Option<char>:\
    \ ToString`\n\nerror[E0369]: cannot add `char` to `&str`\n  --> /tmp/tmpcyytfpfp.rs:14:38\n\
    \   |\n14 |                 prefixes.push(prefix + c);\n   |                 \
    \              ------ ^ - char\n   |                               |\n   |   \
    \                            &str\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut list = Vec::new();\n    let mut s = string[0];\n\
    \    for c in string.iter().rev() {\n        if c == s {\n            list.push(c);\
    \ \n        } else {\n            s = c;\n        }\n    }\n    list\n}\n\nfn\
    \ main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpox3qlfez.rs:6:17\n  |\n6 |     let mut s = string[0];\n  |         \
    \        ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n  |\n  = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n  = help: the following\
    \ other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpox3qlfez.rs:7:21\n  |\n7 |     for c in string.iter().rev()\
    \ {\n  |                     ^^^^ method not found in `String`\n  |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n  |\n7 |     for c in string.chars().rev()\
    \ {\n  |                     ~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = vec![];\n\n    for i in string.chars()\
    \ {\n        for prefix in prefixes {\n            if i.len() < prefix.len() {\n\
    \                break;\n            }\n        }\n        prefixes.push(i.to_string());\n\
    \    }\n\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n --> /tmp/tmpk9c2dcvp.rs:9:18\n  |\n9 |             if i.len() < prefix.len()\
    \ {\n  |                  ^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::with_capacity(string.len());\n\
    \    for &c in string.chars() {\n        for &p in &all_prefixes(&c) {\n     \
    \       prefix.push(p.to_string());\n        }\n    }\n    prefix\n}\n\nfn main()\
    \ {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppr3zec5z.rs:6:9\n  |\n6 |\
    \     for &c in string.chars() {\n  |         ^^    -------------- this expression\
    \ has type `Option<char>`\n  |         |\n  |         expected `char`, found reference\n\
    \  |         help: you can probably remove the explicit borrow: `c`\n  |\n  =\
    \ note:   expected type `char`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppr3zec5z.rs:7:33\n  |\n7 |         for &p in\
    \ &all_prefixes(&c) {\n  |                                 ^^ expected struct\
    \ `String`, found reference\n  |\n  = note: expected struct `String`\n       \
    \   found reference `&_`\nhelp: consider removing the borrow\n  |\n7 -       \
    \  for &p in &all_prefixes(&c) {\n7 +         for &p in &all_prefixes(c) {\n \
    \ | \n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string\n        .chars()\n        .chain(string.chars().cloned())\n\
    \        .cloned()\n        .filter_map(|c| if c != '#' { Some(c) } else { None\
    \ })\n        .take_while(|&c| !c.is_alphanumeric())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpvr_beomi.rs:7:31\n     |\n7    |         .chain(string.chars().cloned())\n\
    \     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &char`\n   --> /tmp/tmpvr_beomi.rs:7:16\n\
    \    |\n7   |         .chain(string.chars().cloned())\n    |          ----- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&char`, found `char`\n    |          |\n    |          required by\
    \ a bound introduced by this call\n    |\n    = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\nnote: required\
    \ by a bound in `std::iter::Iterator::chain`\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n --> /tmp/tmpvr_beomi.rs:7:16\n  |\n\
    7 |         .chain(string.chars().cloned())\n  |          ----- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n  |          |\n  |          required by a\
    \ bound introduced by this call\n  |\n  = note:   expected type `char`\n     \
    \     found reference `&_`\n  = note: required because of the requirements on\
    \ the impl of `Iterator` for `Cloned<Chars<'_>>`\n  = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\nerror[E0599]:\
    \ the method `cloned` exists for struct `std::iter::Chain<Chars<'_>, Cloned<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpvr_beomi.rs:8:10\n  \
    \ |\n8  |           .cloned()\n   |            ^^^^^^ method cannot be called\
    \ on `std::iter::Chain<Chars<'_>, Cloned<Chars<'_>>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Cloned<Chars<'_>> as Iterator>::Item = char`\n           which is\
    \ required by `std::iter::Chain<Chars<'_>, Cloned<Chars<'_>>>: Iterator`\n   \
    \        `Cloned<Chars<'_>>: Iterator`\n           which is required by `std::iter::Chain<C"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 1 {\n        vec![string]\n\
    \    } else {\n        all_prefixes(string.split_first_whitespace())\n    }\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_whitespace` found for struct\
    \ `String` in the current scope\n --> /tmp/tmpinv4l42n.rs:8:29\n  |\n8 |     \
    \    all_prefixes(string.split_first_whitespace())\n  |                      \
    \       ^^^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_whitespace`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix_vec = vec![];\n    let mut prefix_len\
    \ = string.len();\n    while prefix_len > 0 {\n        prefix_vec.push(&string[0..prefix_len]);\n\
    \        prefix_len = prefix_len - 1;\n    }\n    prefix_vec\n}\n\nfn main() {\n\
    \    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5xll5f1f.rs:11:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefix_vec\n   |     ^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut input_str\
    \ = string.to_string();\n    loop {\n        if input_str.len() == 0 {\n     \
    \       return prefixes;\n        }\n\n        let prefix = input_str[0];\n  \
    \      let mut input_str = &input_str[1..];\n        let mut prefixes = [prefix].into_iter().cloned().collect();\n\
    \        let mut new_prefix = prefix;\n        loop {\n            if !prefixes.contains(new_prefix)\
    \ {\n                prefixes.push(new_prefix);\n                break;\n    \
    \        }\n            new_prefix = prefixes.remove(new_prefix).unwrap();\n \
    \       }\n    }\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpm0ebanxd.rs:12:22\n   |\n12 |         let prefix = input_str[0];\n \
    \  |                      ^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.to_lowercase().chars()\n        .chain(string.chars())\n\
    \        .take(string.len() - 1)\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpicm31a71.rs:8:10\n     |\n8  \
    \  |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for c in string.chars()\
    \ {\n        if let Some(p) = string.starts_with(&c) {\n            prefixes.push(*p);\n\
    \        }\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpu73m56ae.rs:7:45\n\
    \     |\n7    |         if let Some(p) = string.starts_with(&c) {\n     |    \
    \                             ----------- ^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                                 |\n     |             \
    \                    required by a bound introduced by this call\n     |\n   \
    \  = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider dereferencing here\n     |\n7    |         if let Some(p) = string.starts_with(*&c)\
    \ {\n     |                                             +\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpu73m56ae.rs:7:16\n  |\n7 |         if let Some(p) = string.starts_with(&c)\
    \ {\n  |                ^^^^^^^   ---------------------- this expression has type\
    \ `bool`\n  |                |\n  |                expected `bool`, found enum\
    \ `Option`\n  |\n  = note: expected type `bool`\n             found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    Vec::new()\n        .push(string)\n        .push(string.chars().filter(|&c|\
    \ c.is_ascii()).collect::<String>())\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for unit type `()` in the current\
    \ scope\n --> /tmp/tmpoxcbf4yj.rs:7:10\n  |\n7 |         .push(string.chars().filter(|&c|\
    \ c.is_ascii()).collect::<String>())\n  |          ^^^^ method not found in `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n\n    let\
    \ mut strings = string.chars();\n\n    while let Some(mut char) = strings.next()\
    \ {\n        if char == String::from(\"\") {\n            continue;\n        }\n\
    \        result.push(\"{}{}\".format(&char, &string));\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu6pefnzw.rs:10:20\n   |\n\
    10 |         if char == String::from(\"\") {\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `format`\
    \ found for reference `&'static str` in the current scope\n  --> /tmp/tmpu6pefnzw.rs:13:28\n\
    \   |\n13 |         result.push(\"{}{}\".format(&char, &string));\n   |      \
    \                      ^^^^^^ method not found in `&'static str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut output = Vec::new();\n    let mut last_prefix:\
    \ Option<String> = None;\n    for c in string.chars() {\n        if last_prefix.is_none()\
    \ {\n            output.push(c);\n            last_prefix = Some(c);\n       \
    \ }\n        else {\n            if c == last_prefix.get() {\n               \
    \ continue;\n            }\n            output.push(c);\n            last_prefix\
    \ = Some(c);\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvs463wp6.rs:10:32\n   |\n\
    10 |             last_prefix = Some(c);\n   |                                ^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \              |\n   |                                expected struct `String`,\
    \ found `char`\n\nerror[E0599]: no method named `get` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpvs463wp6.rs:13:33\n   |\n13 |          \
    \   if c == last_prefix.get() {\n   |                                 ^^^ method\
    \ not found in `Option<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvs463wp6.rs:17:32\n\
    \   |\n17 |             last_prefix = Some(c);\n   |                         \
    \       ^- help: try using a conversion method: `.to_string()`\n   |         \
    \                       |\n   |                                expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvs463wp6.rs:20:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n20 |     output\n   |     ^^^^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![\"\".to_string()];\n   \
    \ for ch in string.chars() {\n        prefix.push(ch as String);\n    }\n    prefix\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0605]: non-primitive cast: `char` as `String`\n --> /tmp/tmpb50t5zgm.rs:7:21\n\
    \  |\n7 |         prefix.push(ch as String);\n  |                     ^^^^^^^^^^^^\
    \ help: consider using the `From` trait instead: `String::from(ch)`\n  |\n  =\
    \ note: an `as` expression can only be used to convert between primitive types\
    \ or to coerce to a specific trait object\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0605`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n\n    let mut\
    \ it = string.chars();\n\n    while let Some(char) = {\n        if char == prefixes.last().unwrap().last()\
    \ {\n            prefixes.push(char);\n        } else {\n            prefixes.push(char);\n\
    \            prefixes.push(prefixes.last().unwrap().pop());\n        }\n    }\n\
    \n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `prefixes`\n  --> /tmp/tmpaklcfnau.rs:18:5\n\
    \   |\n9  |       while let Some(char) = {\n   |  _____-----_-\n   | |     |\n\
    \   | |     while parsing the body of this `while` expression\n10 | |        \
    \ if char == prefixes.last().unwrap().last() {\n11 | |             prefixes.push(char);\n\
    12 | |         } else {\n...  |\n15 | |         }\n16 | |     }\n   | |_____-\
    \ this `while` condition successfully parsed\n17 | \n18 |       prefixes\n   |\
    \       ^^^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n\
    \   |\n18 |     { prefixes }\n   |     +          +\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    // Create prefix to index map\n    let mut prefixes\
    \ = vec![];\n    for b in string.bytes() {\n        let prefix = prefix.map(|s|\
    \ s.to_string());\n        if prefix == Some(prefix.to_string()) {\n         \
    \   continue;\n        }\n        prefixes.push(prefix);\n    }\n    prefixes\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `prefix` in this scope\n --> /tmp/tmpjjqy9c7y.rs:8:22\n\
    \  |\n8 |         let prefix = prefix.map(|s| s.to_string());\n  |           \
    \           ^^^^^^ help: a local variable with a similar name exists: `prefixes`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::with_capacity(string.len());\n\
    \    prefixes.push(string);\n    let mut current = &string[1..];\n    while let\
    \ Some(prefix) = current.prefix(&current) {\n        prefixes.push(prefix);\n\
    \        current = prefix;\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `prefix` found for reference `&str` in the\
    \ current scope\n --> /tmp/tmpsh6lapo6.rs:8:38\n  |\n8 |     while let Some(prefix)\
    \ = current.prefix(&current) {\n  |                                      ^^^^^^\
    \ help: there is an associated function with a similar name: `strip_prefix`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsh6lapo6.rs:10:19\n   |\n7  |  \
    \   let mut current = &string[1..];\n   |                       ------------ expected\
    \ due to this value\n...\n10 |         current = prefix;\n   |               \
    \    ^^^^^^\n   |                   |\n   |                   expected `&str`,\
    \ found struct `String`\n   |                   help: consider borrowing here:\
    \ `&prefix`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    let mut last_pos\
    \ = 0;\n\n    for c in string.chars() {\n        let length = string.len() - last_pos;\n\
    \        let mut prefix = Vec::new();\n        let mut last_pos = 0;\n\n     \
    \   for _ in 0..(length as usize) {\n            prefix.push(string[last_pos]);\n\
    \            last_pos += 1;\n        }\n        prefix.push(string[last_pos]);\n\
    \        last_pos += 1;\n        prefix.push(string[last_pos]);\n        last_pos\
    \ += 1;\n        prefix.push(string[last_pos]);\n        last_pos += 1;\n\n  \
    \      if prefix != \"\" {\n            prefix.push(string[last_pos]);\n     \
    \       last_pos += 1;\n        }\n        prefix.push(string[last_pos]);\n\n\
    \        if last_pos > 0 {\n            prefix.push(string[last_pos - 1]);\n \
    \           last_pos += 1;\n        }\n\n        if last_pos > 0 {\n         \
    \   prefix.push(string[last_pos - 1]);\n            last_pos += 1;\n        }\n\
    \n        if last_pos > 0 {\n            prefix.push(string[last_pos - 1]);\n\
    \            last_pos += 1;\n        }\n\n        if last_pos > 0 {\n        \
    \    prefix.push(string[last_pos - 1]);\n            last_pos += 1;\n        }\n\
    \n        if last_pos > 0 {\n            prefix.push(string[last_pos - 1]);\n\
    \            last_pos += 1;\n        }\n\n        if last_pos > 0 {\n        \
    \    prefix.push(string[last_pos - 1]);\n            last_pos += 1;\n        }\n\
    \        prefix.push(string[last_pos]);\n        last_pos += 1;\n\n        if\
    \ last_pos > 0 {\n            prefix.push(string[last_pos - 1]);\n           \
    \ last_pos += 1;\n        }\n\n        if last_pos > 0 {\n            prefix.push(string[last_pos\
    \ - 1]);\n            last_pos += 1;\n        }\n        prefix.push(string[last_pos]);\n\
    \        last_pos += 1;\n\n        if last_pos > 0 {\n            prefix.push(string[last_pos\
    \ - 1]);\n            last_pos += 1;\n        }\n\n        if last_pos > 0 {\n\
    \            prefix.push(string[last_pos - 1]);\n            last_pos += 1;\n\
    \        }\n        prefix.push(string[last_pos]);\n        last_pos += 1;\n\n\
    \        if last_pos > 0 {\n            prefix.push(string[last_pos - 1]);\n \
    \           last_pos += 1;\n        }\n        prefix.push(string[last_pos]);\n\
    \        last_pos += 1;\n\n        if last_pos > 0 {\n            prefix.push(string[last_pos\
    \ - 1]);\n            last_pos += 1;\n        }\n        prefix.push(string[last_pos]);\n\
    \        last_pos += 1;\n\n        if last_pos > 0 {\n            prefix.push(\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqt66mgt8.rs:109:3\n\
    \    |\n4   | fn all_prefixes(string: String) -> Vec<String> {\n    |        \
    \                                        - unclosed delimiter\n...\n8   |    \
    \ for c in string.chars() {\n    |                             - unclosed delimiter\n\
    ...\n100 |         if last_pos > 0 {\n    |                         - this delimiter\
    \ might not be properly closed...\n101 |             prefix.push(\n102 | }\n \
    \   | - ...as it matches this but it has different indentation\n...\n109 | }\n\
    \    |   ^\n\nerror: mismatched closing delimiter: `}`\n   --> /tmp/tmpqt66mgt8.rs:101:24\n\
    \    |\n4   | fn all_prefixes(string: String) -> Vec<String> {\n    |        \
    \                                        - closing delimiter possibly meant for\
    \ this\n...\n101 |             prefix.push(\n    |                        ^ unclosed\
    \ delimiter\n102 | }\n    | ^ mismatched closing delimiter\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqt66mgt8.rs:14:25\n\
    \   |\n14 |             prefix.push(string[last_pos]);\n   |                 \
    \        ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n  \
    \ = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqt66mgt8.rs:17:21\n\
    \   |\n17 |         prefix.push(string[last_pos]);\n   |                     ^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<us"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    // return empty if strings is nil\n    if let\
    \ Some(strings) = string.split() {\n        return strings.drain(..).collect();\n\
    \    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp90u4izgq.rs:6:35\n     |\n6    |     if let Some(strings) = string.split()\
    \ {\n     |                                   ^^^^^- supplied 0 arguments\n  \
    \   |                                   |\n     |                            \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmp90u4izgq.rs:6:12\n  |\n6 |     if\
    \ let Some(strings) = string.split() {\n  |            ^^^^^^^^^^^^^   --------------\
    \ this expression has type `std::str::Split<'_, _>`\n  |            |\n  |   \
    \         expected struct `std::str::Split`, found enum `Option`\n  |\n  = note:\
    \ expected struct `std::str::Split<'_, _>`\n               found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let\
    \ mut current = \"\";\n    for c in string.chars() {\n        if !current.is_empty()\
    \ {\n            result.push(current);\n        }\n        current = format!(\"\
    {}{}\", c, string);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpn6p3yub9.rs:9:25\n  |\n9 |\
    \             result.push(current);\n  |                         ^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n  |                         |\n\
    \  |                         expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn6p3yub9.rs:11:19\n   |\n11 |         current\
    \ = format!(\"{}{}\", c, string);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut current = vec![\"\"];\n    let mut result: Vec<String> = vec![];\n\
    \    current.push(string[0]);\n    for i in 1..string.len() {\n        if string[i]\
    \ == current[0] {\n            current.pop();\n        } else {\n            result.push(current);\n\
    \            current = vec![\"\"];\n            current.push(string[i]);\n   \
    \     }\n    }\n    result.push(current);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmplc_3h8x6.rs:10:18\n   |\n10 |     current.push(string[0]);\n   |   \
    \               ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n  \
    \ = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplc_3h8x6.rs:12:12\n\
    \   |\n12 |         if string[i] == current[0] {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplc_3h8x6.rs:15:25\n\
    \   |\n15 |             result.push(current);\n   |                         ^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<&str>`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmplc_3h8x6.rs:17:26\n   |\n17 |  \
    \           current.push(string[i]);\n   |                          ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n   "
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = vec![];\n    for c in string.chars()\
    \ {\n        prefix.push(&*c);\n    }\n\n    let mut iter = prefix.iter();\n \
    \   let mut prefix = String::new();\n\n    let mut longest = prefix.len();\n \
    \   while let Some(c) = iter.next() {\n        longest += 1;\n        if longest\
    \ > prefix.len() {\n            break;\n        }\n\n        if prefix.len() >\
    \ longest {\n            longest = prefix.len();\n        }\n    }\n\n    prefix.into_iter().take(longest).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpbolx_czi.rs:7:22\n\
    \  |\n7 |         prefix.push(&*c);\n  |                      ^^\n\nerror[E0599]:\
    \ the method `into_iter` exists for struct `String`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpbolx_czi.rs:25:12\n    |\n25  |       prefix.into_iter().take(longest).collect()\n\
    \    |              ^^^^^^^^^\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `String: IntoIterator`\n            `&String: Iterator`\n            which\
    \ is required by `&String: IntoIterator`\n            `&mut String: Iterator`\n\
    \            which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.split_str(\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_str` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpe1fbvrdo.rs:5:12\n  |\n5 |     string.split_str(\"\
    \").map(|x| x.to_string()).collect()\n  |            ^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut input\
    \ = string.chars();\n    let mut current = 0;\n    loop {\n        let current\
    \ = input.get_mut();\n        if *current == '_' {\n            // skip underscore\n\
    \            input.advance(1);\n        } else {\n            prefixes.push(&string[current]);\n\
    \        }\n        if input.peek().is_none() {\n            break;\n        }\n\
    \    }\n    prefixes\n}\n\nfn main() {\n    let candidate = all_prefixes;\n  \
    \  assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `get_mut` found for struct `Chars` in the\
    \ current scope\n   --> /tmp/tmpu44f6uwy.rs:9:29\n    |\n9   |         let current\
    \ = input.get_mut();\n    |                             ^^^^^^^ method not found\
    \ in `Chars<'_>`\n    |\nhelp: consider wrapping the receiver expression with\
    \ the appropriate type\n    |\n9   |         let current = Pin::new(&mut input).get_mut();\n\
    \    |                       +++++++++++++      +\n\nerror[E0599]: no method named\
    \ `advance` found for struct `Chars` in the current scope\n  --> /tmp/tmpu44f6uwy.rs:12:19\n\
    \   |\n12 |             input.advance(1);\n   |                   ^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `peek` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpu44f6uwy.rs:16:18\n   |\n16 |  \
    \       if input.peek().is_none() {\n   |                  ^^^^ method not found\
    \ in `Chars<'_>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    if string.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut result = Vec::with_capacity(string.len());\n    let mut prefix\
    \ = &string;\n    for c in prefix.chars().by_ref().take(prefix.len() - 1) {\n\
    \        if c.is_ascii_alphanumeric() {\n            result.push(prefix + c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `char` to `&String`\n  --> /tmp/tmpeeqy94i3.rs:12:32\n\
    \   |\n12 |             result.push(prefix + c);\n   |                       \
    \  ------ ^ - char\n   |                         |\n   |                     \
    \    &String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut iter = string.chars();\n    let mut prefixes:\
    \ Vec<String> = Vec::new();\n    while let Some(prefix) = (iter.next(), iter.next())\
    \ {\n        prefixes.push(prefix);\n    }\n    prefixes\n}\n\nfn main() {\n \
    \   let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")),\
    \ vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpog2yf4m3.rs:7:15\n  |\n7 |\
    \     while let Some(prefix) = (iter.next(), iter.next()) {\n  |             \
    \  ^^^^^^^^^^^^   -------------------------- this expression has type `(Option<char>,\
    \ Option<char>)`\n  |               |\n  |               expected tuple, found\
    \ enum `Option`\n  |\n  = note: expected tuple `(Option<char>, Option<char>)`\n\
    \              found enum `Option<_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut output = Vec::new();\n    for i in string.chars()\
    \ {\n        if i > 0 {\n            output.push(&string[..i - 1]);\n        }\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1075wpp0.rs:7:16\n  |\n7 |\
    \         if i > 0 {\n  |                ^ expected `char`, found `u8`\n\nerror[E0369]:\
    \ cannot subtract `{integer}` from `char`\n --> /tmp/tmp1075wpp0.rs:8:37\n  |\n\
    8 |             output.push(&string[..i - 1]);\n  |                          \
    \         - ^ - {integer}\n  |                                   |\n  |      \
    \                             char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1075wpp0.rs:11:5\n\
    \   |\n4  | fn all_prefixes(string: String) -> Vec<String> {\n   |           \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n11 |     output\n   |     ^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0369.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    string.chars().enumerate().filter_map(|(i, c)|\
    \ {\n        if c.is_alphanumeric() {\n            if i < string.len() - 1 {\n\
    \                Some(string.chars().nth(i).to_string())\n            } else {\n\
    \                None\n            }\n        } else {\n            None\n   \
    \     }\n    }).collect()\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n  \
    \ --> /tmp/tmp579e4ibt.rs:8:44\n    |\n8   |                   Some(string.chars().nth(i).to_string())\n\
    \    |                                              ^^^^^^^^^ `Option<char>` cannot\
    \ be formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Option<char>: std::fmt::Display`\n\
    \            which is required by `Option<char>: ToString`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut result = vec![];\n    for c in string.chars()\
    \ {\n        if let Some(prefix) = prefix.next() {\n            result.push(prefix);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = all_prefixes;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"\
    ), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n\
    \    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"\
    WW\"), String::from(\"WWW\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `prefix` in this scope\n --> /tmp/tmp8c3n3dkq.rs:7:31\n\
    \  |\n7 |         if let Some(prefix) = prefix.next() {\n  |                 \
    \              ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for pos in\
    \ 0..string.len() {\n        prefixes.push(&string[..pos]);\n    }\n    return\
    \ prefixes;\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpi1j5kd2j.rs:9:12\n  |\n4 |\
    \ fn all_prefixes(string: String) -> Vec<String> {\n  |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    9 |     return prefixes;\n  |            ^^^^^^^^ expected struct `String`, found\
    \ `&str`\n  |\n  = note: expected struct `Vec<String>`\n             found struct\
    \ `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    iter::repeat(string).take_while(|x| !x.is_empty()).collect()\n\
    }\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \ --> /tmp/tmpng9788zp.rs:5:5\n  |\n5 |     iter::repeat(string).take_while(|x|\
    \ !x.is_empty()).collect()\n  |     ^^^^ use of undeclared crate or module `iter`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    let mut prefix\
    \ = string.to_owned();\n    while prefix.len() > 0 {\n        prefixes.push(prefix);\n\
    \        prefix.remove(0);\n    }\n    prefixes\n}\n\nfn main() {\n    let candidate\
    \ = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"),\
    \ String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"\
    asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `prefix`\n --> /tmp/tmpw2cy_vk7.rs:7:11\n\
    \  |\n6 |     let mut prefix = string.to_owned();\n  |         ---------- move\
    \ occurs because `prefix` has type `String`, which does not implement the `Copy`\
    \ trait\n7 |     while prefix.len() > 0 {\n  |           ^^^^^^^^^^^^ value borrowed\
    \ here after move\n8 |         prefixes.push(prefix);\n  |                   \
    \    ------ value moved here, in previous iteration of loop\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of all prefixes from shortest to longest of the input\
    \ string\n/// >>> all_prefixes('abc')\n/// ['a', 'ab', 'abc']\nfn all_prefixes(string:\
    \ String) -> Vec<String> {\n    let mut prefix = Vec::new();\n    let mut suffix\
    \ = string;\n    while !suffix.is_empty() {\n        prefix.push(suffix.chars().next().unwrap());\n\
    \        suffix = suffix.chars().skip(1).take_while(|c| !c.is_ascii()).collect();\n\
    \    }\n    prefix\n}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\"\
    )), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"\
    asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"\
    WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\"\
    )]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyl9bmmto.rs:11:5\n   |\n\
    4  | fn all_prefixes(string: String) -> Vec<String> {\n   |                  \
    \                  ----------- expected `Vec<String>` because of return type\n\
    ...\n11 |     prefix\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
