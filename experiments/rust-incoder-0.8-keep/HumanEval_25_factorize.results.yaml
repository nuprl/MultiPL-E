name: HumanEval_25_factorize
language: rust
results:
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut v = Vec::new();\n    let mut primes = Vec::new();\n\
    \    let mut max_prime = 2;\n    let mut i = 2;\n\n    while i < n {\n       \
    \ while n % i == 0 {\n            primes.push(i);\n            n /= i;\n     \
    \   }\n        i += 1;\n    }\n\n    primes.push(i);\n\n    while n != 1 {\n \
    \       for &prime in &primes {\n            for _ in 0..prime {\n           \
    \     v.push(*max_prime);\n            }\n        }\n        max_prime += 1;\n\
    \    }\n\n    v\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp2n9dwtui.rs:29:24\n\
    \   |\n29 |                 v.push(*max_prime);\n   |                        ^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut i = 1;\n\
    \    let mut fact = 1;\n    while n != 1 {\n        if n % i == 0 {\n        \
    \    if fact * i >= n {\n                result.push(fact);\n            } else\
    \ {\n                while n % (fact * i) == 0 {\n                    fact *=\
    \ i;\n                }\n                result.push(i * fact);\n            }\n\
    \            n /= i;\n        } else {\n            i <<= 1;\n        }\n    }\n\
    \    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpws0tvre0.rs:24:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n24 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut product\
    \ = 1;\n    while n > 1 {\n        if n % 2 == 1 {\n            factors.push(2);\n\
    \            n = n / 2;\n        } else {\n            factors.push(1);\n    \
    \        n = n / 2;\n        }\n    }\n\n    let mut n = 1;\n    while n > 1 {\n\
    \        if n % 2 == 1 {\n            factors.push(2);\n            n = n / 2;\n\
    \        } else {\n            factors.push(1);\n            n = n / 2;\n    \
    \    }\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `product`\n  --> /tmp/tmp7sli9sg8.rs:12:13\n\
    \   |\n12 |     let mut product = 1;\n   |             ^^^^^^^ help: if this is\
    \ intentional, prefix it with an underscore: `_product`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp7sli9sg8.rs:12:9\n\
    \   |\n12 |     let mut product = 1;\n   |         ----^^^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `n`\n  -->\
    \ /tmp/tmp7sli9sg8.rs:16:13\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |              - help: consider making this binding mutable: `mut n`\n...\n\
    16 |             n = n / 2;\n   |             ^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp7sli9sg8.rs:19:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n19 |             n = n /\
    \ 2;\n   |             ^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut primes\
    \ = vec![true, false, true, false, true, false, true, false, true];\n    let mut\
    \ x = 1;\n    while x * x <= n {\n        if primes[x] {\n            primes[*x\
    \ * x as usize] = false;\n        }\n        x++;\n    }\n    let mut factor =\
    \ 1;\n    for k in primes {\n        if n % (k as usize) == 0 {\n            result.push(factor\
    \ as isize);\n            n /= k as usize;\n        }\n        factor++;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpd0pn_6sp.rs:18:10\n\
    \   |\n18 |         x++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n18 |         { let tmp = x; x += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n18 -         x++;\n18 +         x +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpd0pn_6sp.rs:26:15\n\
    \   |\n26 |         factor++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n26 |         { let tmp = factor; factor\
    \ += 1; tmp };\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n26 -    \
    \     factor++;\n26 +         factor += 1;\n   | \n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpd0pn_6sp.rs:16:20\n   |\n16 |        \
    \     primes[*x * x as usize] = false;\n   |                    ^^\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpd0pn_6sp.rs:15:12\n\
    \   |\n15 |         if primes[x] {\n   |            ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd0pn_6sp.rs:22:16\n\
    \   |\n22 |         if n % (k as usize) == 0 {\n   |                ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n\
    \  --> /tmp/tmpd0pn_6sp.rs:22:14\n   |\n22 |         if n % (k as usize) == 0\
    \ {\n   |              ^ no implementation for `isize % usize`\n   |\n   = help:\
    \ the trait `Rem<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    factorization(n)\n        .iter()\n        .cloned()\n\
    \        .fold(vec![], |mut vec| vec.push(vec.pop().unwrap()));\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpfghg6dbo.rs:11:5\n   |\n11 |     factorization(n)\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfghg6dbo.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 {\n        return vec![1];\n    }\n\n\
    \    let mut factors: Vec<isize> = vec![n];\n    let mut factor: isize = 0;\n\
    \    let mut new_factor: Vec<isize> = vec![n];\n\n    while factor != 1 {\n  \
    \      new_factor = factors.clone();\n        for &x in &mut new_factor {\n  \
    \          x %= factor;\n            if x == 0 {\n                factors = new_factor;\n\
    \                break;\n            }\n        }\n        factor /= 2;\n    }\n\
    \n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbdch3t02.rs:21:13\n   |\n\
    21 |         for &x in &mut new_factor {\n   |             ^^    ---------------\
    \ this expression has type `Option<&mut isize>`\n   |             |\n   |    \
    \         types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut facs = vec![];\n    if n == 1 {\n      \
    \  facs.push(1);\n        return facs;\n    }\n    if n % 2 == 0 {\n        facs.push(2);\n\
    \        n = n / 2;\n    }\n    for i in 3..(n + 1) {\n        if n % i == 0 {\n\
    \            facs.push(i);\n            n /= i;\n        }\n    }\n    facs\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpivp1953u.rs:18:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |         n = n / 2;\n\
    \   |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmpivp1953u.rs:23:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n23 |             n /= i;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut product\
    \ = 1;\n    let mut max_factor = 1;\n    while product != 0 {\n        let factor\
    \ = product / max_factor;\n        if n % factor == 0 {\n            factors.push(factor);\n\
    \            product /= factor;\n        } else {\n            product *= factor;\n\
    \            max_factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    let mut primes_size\
    \ = Vec::new();\n    let mut m = 1;\n    while n != 1 {\n        for j in 2..m\
    \ {\n            if n % j == 0 {\n                primes.push(j);\n          \
    \      primes_size.push(*primes_size.iter().cloned().skip(primes_size.len()).next()\
    \ + 1);\n                n /= j;\n                break;\n            }\n    \
    \    }\n        m += 1;\n    }\n    primes.sort_by_key(|&i| primes_size[i]);\n\
    \    primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpits62xye.rs:18:34\n\
    \   |\n18 |                 primes_size.push(*primes_size.iter().cloned().skip(primes_size.len()).next()\
    \ + 1);\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpits62xye.rs:25:29\n\
    \   |\n25 |     primes.sort_by_key(|&i| primes_size[i]);\n   |               \
    \              ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut prime_factors\
    \ = Vec::new();\n    let mut known_prime_factors = Vec::new();\n    let mut is_prime:\
    \ Vec<bool> = Vec::new();\n    for prime in prime_factors_upto(n) {\n        let\
    \ mut is_prime_is_prime = true;\n        for known_prime in known_prime_factors.iter()\
    \ {\n            if known_prime % prime == 0 {\n                is_prime_is_prime\
    \ = false;\n                break;\n            }\n        }\n        if is_prime_is_prime\
    \ {\n            factors.push(prime);\n            prime_factors.push(prime);\n\
    \            is_prime.push(true);\n            known_prime_factors.push(prime);\n\
    \        } else {\n            is_prime.push(false);\n        }\n    }\n    factors.push(1);\n\
    \    prime_factors.push(1);\n    is_prime.push(true);\n    known_prime_factors.push(1);\n\
    \    (factors, prime_factors, is_prime, known_prime_factors)\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors_upto` in this scope\n\
    \  --> /tmp/tmp_ezpjoiw.rs:15:18\n   |\n15 |     for prime in prime_factors_upto(n)\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `prime_factors`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ezpjoiw.rs:36:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n36 |    \
    \ (factors, prime_factors, is_prime, known_prime_factors)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found tuple `(Vec<{integer}>, Vec<{integer}>, Vec<bool>, Vec<{integer}>)`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for f in a ->\
    \ (a as isize).gcd() {\n        if n == 1 {\n            return factors;\n   \
    \     }\n        if n % f == 0 {\n            factors.push(f as isize);\n    \
    \        n /= f;\n        }\n    }\n    factors.push(n as isize);\n    return\
    \ factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `->`\n  --> /tmp/tmpc3zs6aps.rs:12:16\n   |\n\
    12 |     for f in a -> (a as isize).gcd() {\n   |                ^^ expected `{`\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut is_prime\
    \ = true;\n\n    for div in 2..=n {\n        if n % div == 0 {\n            if\
    \ is_prime {\n                factors.push(div);\n            }\n            else\
    \ {\n                factors.extend_from_slice(&factors[..factors.len() - 1]);\n\
    \                factors.push(div);\n            }\n        }\n\n        is_prime\
    \ = !is_prime;\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `factors` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpp0krccb9.rs:20:17\n   |\n20 |                 factors.extend_from_slice(&factors[..factors.len()\
    \ - 1]);\n   |                 ^^^^^^^^-----------------^^-------^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |       |                  |\n   |                 |   \
    \    |                  immutable borrow occurs here\n   |                 | \
    \      immutable borrow later used by call\n   |                 mutable borrow\
    \ occurs here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 2..(n +\
    \ 1) {\n        if n % i == 0 {\n            let mut j = 1;\n            while\
    \ i * j < n {\n                j += 1;\n            }\n            res.push(i\
    \ as isize);\n            res.extend(j..n);\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[2]`', /tmp/tmp8pls2mig.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut max_factor = 0;\n    let mut prime_factors = 0;\n    let mut n = n as isize;\n\
    \n    while n > 1 {\n        let mut cur = 1;\n        loop {\n            if\
    \ n % cur == 0 {\n                factors.push(cur);\n                n /= cur;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if n > 1 {\n            cur *= 2;\n        }\n        prime_factors += factors.len()\
    \ - 1;\n        if n > max_factor {\n            max_factor = n;\n        }\n\
    \    }\n\n    for factor in &factors[..] {\n        for _ in 0..factor {\n   \
    \         factors.push(0);\n        }\n    }\n    factors.push(max_factor as isize);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjl1u9gdq.rs:36:21\n   |\n\
    36 |         for _ in 0..factor {\n   |                     ^^^^^^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |  \
    \       for _ in 0..*factor {\n   |                     +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 2..n\
    \ {\n        if n % i == 0 {\n            let mut q = i / 2;\n            loop\
    \ {\n                if n % q == 0 {\n                    result.push(i);\n  \
    \                  break;\n                }\n                q = q / 2;\n   \
    \         }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmp9bnfs34n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    fn factors(mut n: int) -> Vec<isize> {\n       \
    \ let mut factors: Vec<isize> = Vec::new();\n        while n > 1 {\n         \
    \   let mut new_factor = 1;\n            while n % new_factor == 0 {\n       \
    \         factors.push(new_factor);\n                new_factor *= factors.last().unwrap();\n\
    \            }\n            n /= factors.last().unwrap();\n        }\n       \
    \ factors\n    }\n\n    let mut factors = factors(n);\n    let mut factor_iter\
    \ = factors.iter();\n    let mut prime_factors = Vec::new();\n    let mut factor_count\
    \ = 1;\n    loop {\n        prime_factors.push(factor_iter.next().unwrap());\n\
    \        factor_count++;\n        if factor_count == factors.len() {\n       \
    \     break;\n        }\n    }\n\n    prime_factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_oudphtu.rs:30:21\n\
    \   |\n30 |         factor_count++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |         { let tmp = factor_count;\
    \ factor_count += 1; tmp };\n   |         +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    30 -         factor_count++;\n30 +         factor_count += 1;\n   | \n\nerror[E0412]:\
    \ cannot find type `int` in this scope\n  --> /tmp/tmp_oudphtu.rs:11:23\n   |\n\
    11 |     fn factors(mut n: int) -> Vec<isize> {\n   |                       ^^^\n\
    \   |                       |\n   |                       not found in this scope\n\
    \   |                       help: perhaps you intended to use this type: `i32`\n\
    \nwarning: unreachable expression\n  --> /tmp/tmp_oudphtu.rs:36:5\n   |\n28 |\
    \ /     loop {\n29 | |         prime_factors.push(factor_iter.next().unwrap());\n\
    30 | |         factor_count++;\n31 | |         if factor_count == factors.len()\
    \ {\n32 | |             break;\n33 | |         }\n34 | |     }\n   | |_____- any\
    \ code following this expression is unreachable\n35 | \n36 |       prime_factors\n\
    \   |       ^^^^^^^^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_oudphtu.rs:36:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n36 |    \
    \ prime_factors\n   |     ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0308, E0412.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut primes\
    \ = Vec::new();\n\n    let mut limit = (1<<n) - 1;\n    let mut limit = match\
    \ n {\n        64 => limit as u64,\n        32 => limit as u64,\n        16 =>\
    \ limit as u64,\n        8 => limit as u64,\n        4 => limit as u64,\n    \
    \    2 => limit as u64,\n        _ => return factors,\n    };\n\n    while limit\
    \ > 2 {\n        let mut m = limit % 2 == 0 ? limit / 2 : (limit - 2) / 2;\n \
    \       while m >= 2 {\n            if !(m % 2 == 0) {\n                primes.push((m\
    \ as isize));\n                m /= 2;\n            }\n            else {\n  \
    \              if primes.contains(&(m as isize)) {\n                    let index\
    \ = primes.iter().position(|x| x == (m as isize));\n                    factors.push(index\
    \ as isize);\n                }\n                m /= 2;\n            }\n    \
    \    }\n        limit = limit.saturating_sub(1);\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `limit`\n\
    \  --> /tmp/tmpep9e3_fd.rs:26:38\n   |\n26 |         let mut m = limit % 2 ==\
    \ 0 ? limit / 2 : (limit - 2) / 2;\n   |                                     \
    \ ^^^^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = vec![];\n    let mut primes = primes::<isize>().collect::<Vec<_>>();\n\
    \    primes.sort_unstable_by();\n    for i in &primes {\n        if n % i == 0\
    \ {\n            res.push(*i);\n            while n % (i * i) == 0 {\n       \
    \         res.push(*i);\n                n /= *i;\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmp37q7fh0p.rs:12:22\n\
    \   |\n12 |     let mut primes = primes::<isize>().collect::<Vec<_>>();\n   |\
    \                      ^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut prime_numbers\
    \ = Vec::new();\n\n    let mut i = 2;\n    while i * i <= n {\n        for j in\
    \ (i + 1) * i..n {\n            if n % i == 0 {\n                factors.push(i);\n\
    \                n /= i;\n                break;\n            }\n        }\n \
    \       if n == 1 {\n            prime_numbers.push(i);\n        }\n        i\
    \ += 1;\n    }\n\n    factors.sort_unstable();\n    prime_numbers.sort_unstable();\n\
    \n    return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `j`\n  --> /tmp/tmpfphsjv0q.rs:16:13\n   |\n\
    16 |         for j in (i + 1) * i..n {\n   |             ^ help: if this is intentional,\
    \ prefix it with an underscore: `_j`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `n`\n  -->\
    \ /tmp/tmpfphsjv0q.rs:19:17\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |              - help: consider making this binding mutable: `mut n`\n...\n\
    19 |                 n /= i;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut n = n as usize;\n    loop {\n        if n % 2 == 0 {\n            factors.push(2);\n\
    \            n /= 2;\n        }\n        if n % 3 == 0 {\n            factors.push(3);\n\
    \            n /= 3;\n        }\n        if n % 5 == 0 {\n            factors.push(5);\n\
    \            n /= 5;\n        }\n        if n == 1 {\n            break;\n   \
    \     }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n < 2 {\n        return vec![1isize]\n    }\n\
    \n    fn factor(mut n: isize) -> Vec<isize> {\n        if n == 1:\n          \
    \  return vec![1];\n        let mut result = vec![2];\n        for i in 2..(n/2)\
    \ {\n            if n % i == 0 {\n                result.push(i);\n          \
    \      n /= i;\n            }\n        }\n        result\n    }\n\n    let mut\
    \ result = factor(n);\n    for i in 2..(result.len() - 1) {\n        if result.iter().all(|&x|\
    \ x > 1) {\n            n = result.iter().filter(|&x| x > 1).collect::<Vec<_>>()\n\
    \                .iter().fold(n, |acc, x| acc * x).unwrap();\n            result\
    \ = factor(n);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `return`\n  --> /tmp/tmp8ui18kar.rs:17:13\n\
    \   |\n17 |             return vec![1];\n   |             ^^^^^^ expected identifier,\
    \ found keyword\n\nerror: expected type, found keyword `return`\n  --> /tmp/tmp8ui18kar.rs:17:13\n\
    \   |\n16 |         if n == 1:\n   |                  - help: try using a semicolon:\
    \ `;`\n17 |             return vec![1];\n   |             ^^^^^^ expected type\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8ui18kar.rs:31:47\n   |\n31 |\
    \             n = result.iter().filter(|&x| x > 1).collect::<Vec<_>>()\n   | \
    \                                              ^\n   |                       \
    \                        |\n   |                                             \
    \  expected `&isize`, found integer\n   |                                    \
    \           help: consider borrowing here: `&1`\n\nerror[E0277]: cannot multiply\
    \ `isize` by `&&isize`\n  --> /tmp/tmp8ui18kar.rs:32:46\n   |\n32 |          \
    \       .iter().fold(n, |acc, x| acc * x).unwrap();\n   |                    \
    \                          ^ no implementation for `isize * &&isize`\n   |\n \
    \  = help: the trait `Mul<&&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmp8ui18kar.rs:32:51\n\
    \   |\n32 |                 .iter().fold(n, |acc, x| acc * x).unwrap();\n   |\
    \                                                   ^^^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::with_capacity(n % 2);\n  \
    \  for &d in &[2..] {\n        if n / d > 1 {\n            primes.push(d as isize);\n\
    \            n /= d;\n        }\n    }\n    primes.push(n as isize);\n    primes\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp00_2oi.rs:11:41\n   |\n\
    11 |     let mut primes = Vec::with_capacity(n % 2);\n   |                   \
    \                      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut primes = Vec::with_capacity((n % 2).try_into().unwrap());\n\
    \   |                                         +     +++++++++++++++++++++\n\n\
    error[E0277]: cannot divide `isize` by `RangeFrom<{integer}>`\n  --> /tmp/tmpwp00_2oi.rs:13:14\n\
    \   |\n13 |         if n / d > 1 {\n   |              ^ no implementation for\
    \ `isize / RangeFrom<{integer}>`\n   |\n   = help: the trait `Div<RangeFrom<{integer}>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: cannot divide-assign `isize` by `RangeFrom<{integer}>`\n\
    \  --> /tmp/tmpwp00_2oi.rs:15:15\n   |\n15 |             n /= d;\n   |       \
    \        ^^ no implementation for `isize /= RangeFrom<{integer}>`\n   |\n   =\
    \ help: the trait `DivAssign<RangeFrom<{integer}>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `DivAssign<Rhs>`:\n    \
    \         <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n        \
    \     <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n            \
    \ <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n             <i16\
    \ as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and 20 others\n\
    \nerror[E0605]: non-primitive cast: `RangeFrom<{integer}>` as `isize`\n  --> /tmp/tmpwp00_2oi.rs:14:25\n\
    \   |\n14 |             primes.push(d as isize);\n   |                       \
    \  ^^^^^^^^^^ an `as` expression can only be used to convert between primitive\
    \ type"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = vec![n - 1];\n\n    fn next_factor(_factors:\
    \ &mut [isize]) {\n        for i in 0..f.len() {\n            if f[i] % _factors[i]\
    \ == 0 {\n                f.swap(i, i);\n                return;\n           \
    \ }\n        }\n    }\n\n    for i in 0..f.len() {\n        loop {\n         \
    \   match f[i] {\n                0 => next_factor(&mut f),\n                n\
    \ => break,\n            }\n        }\n    }\n\n    f\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpqlyj6yg6.rs:14:21\n\
    \   |\n14 |         for i in 0..f.len() {\n   |                     ^\n   |\n\
    \   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmpqlyj6yg6.rs:15:16\n   |\n15\
    \ |             if f[i] % _factors[i] == 0 {\n   |                ^\n   |\n  \
    \ = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmpqlyj6yg6.rs:16:17\n   |\n16\
    \ |                 f.swap(i, i);\n   |                 ^\n   |\n   = help: use\
    \ the `|| { ... }` closure form instead\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0434`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = Vec::new();\n    for prime in prime_iterator(n)\
    \ {\n        let mut i = 1;\n        while i * prime <= n {\n            if n\
    \ % i == 0 {\n                i += 1;\n                continue;\n           \
    \ }\n            break;\n        }\n        i += 1;\n        f.push(prime);\n\
    \    }\n    f\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_iterator` in this scope\n  -->\
    \ /tmp/tmpe6ky1k_g.rs:12:18\n   |\n12 |     for prime in prime_iterator(n) {\n\
    \   |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![1isize; n];\n\
    \    let mut p: isize = n;\n    while p > 1 {\n        let mut tmp: isize = 1;\n\
    \        let mut i: isize = 1;\n        while i <= p {\n            if tmp * i\
    \ == n {\n                break;\n            }\n            i += 1;\n       \
    \     tmp += 1;\n        }\n        factors[p - i] =\n            tmp * (p - 1)\
    \ / p;\n        p /= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb85f4uh9.rs:11:48\n   |\n\
    11 |     let mut factors: Vec<isize> = vec![1isize; n];\n   |                \
    \                                ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut factors: Vec<isize> = vec![1isize; n.try_into().unwrap()];\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpb85f4uh9.rs:23:9\n\
    \   |\n23 |         factors[p - i] =\n   |         ^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![0; n];\n    let mut i = 1;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            let factor = i as\
    \ isize;\n            i += 1;\n            result[factor] += 1;\n        }\n \
    \       i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkys_du6.rs:11:30\n   |\n\
    11 |     let mut result = vec![0; n];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut result\
    \ = vec![0; n.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmphkys_du6.rs:17:13\n\
    \   |\n17 |             result[factor] += 1;\n   |             ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![];\n    let mut result = Vec::new();\n\
    \    let mut result = Vec::new();\n    loop {\n        let mut curr = n;\n   \
    \     while curr != 1 {\n            if n % curr == 0 {\n                result.push(curr);\n\
    \                curr = n / curr;\n            } else {\n                curr\
    \ *= 2;\n            }\n        }\n        if n == 1 {\n            break;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmphavj4dl1.rs:11:22\n\
    \   |\n11 |     let mut result = vec![];\n   |         ----------   ^^^^^^ cannot\
    \ infer type for type parameter `T`\n   |         |\n   |         consider giving\
    \ `result` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = vec![];\n    for i in 2..n / 2 {\n \
    \       while n % i == 0 {\n            f.push(i);\n            n /= i;\n    \
    \    }\n    }\n    f.push(n);\n    return f;\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2i5mc93s.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut primes =\
    \ Vec::new();\n    let mut factors: Vec<_> = factorize_iter(n);\n\n    for f in\
    \ &factors {\n        if f == 1 {\n            continue;\n        }\n\n      \
    \  for _ in 0..f {\n            res.push(*f);\n        }\n    }\n\n    while primes.len()\
    \ != res.len() {\n        let mut i = 0;\n        while i < primes.len() && primes[i]\
    \ == 0 {\n            i += 1;\n        }\n\n        if i == primes.len() {\n \
    \           break;\n        }\n\n        let mut found = 0;\n        for _prime\
    \ in &primes {\n            found += 1;\n            if found == _prime {\n  \
    \              res.push(i);\n                found = 0;\n            }\n     \
    \   }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n  \
    \  assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize_iter` in this scope\n  -->\
    \ /tmp/tmph1c2wlbh.rs:13:31\n   |\n13 |     let mut factors: Vec<_> = factorize_iter(n);\n\
    \   |                               ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0277]: can't compare `&_` with `{integer}`\n  --> /tmp/tmph1c2wlbh.rs:16:14\n\
    \   |\n16 |         if f == 1 {\n   |              ^^ no implementation for `&_\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph1c2wlbh.rs:20:21\n\
    \   |\n20 |         for _ in 0..f {\n   |                     ^ expected integer,\
    \ found reference\n   |\n   = note:   expected type `{integer}`\n           found\
    \ reference `&_`\nhelp: consider dereferencing the borrow\n   |\n20 |        \
    \ for _ in 0..*f {\n   |                     +\n\nerror[E0277]: can't compare\
    \ `{integer}` with `&_`\n  --> /tmp/tmph1c2wlbh.rs:38:22\n   |\n38 |         \
    \    if found == _prime {\n   |                      ^^ no implementation for\
    \ `{integer} == &_`\n   |\n   = help: the trait `PartialEq<&_>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph1c2wlbh.rs:45:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n45 |    \
    \ res\n   |     ^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = factorization(n);\n    for &c in f.iter().cloned()\
    \ {\n        if c > 1 {\n            f[c - 1] *= c;\n        }\n    }\n    f.cloned()\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmp47b2gwbf.rs:11:17\n   |\n11 |     let mut f = factorization(n);\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    // First of all, find all the prime factors up to\
    \ the given number\n    let mut factors = vec![n];\n    for &factor in factorize(n).iter()\
    \ {\n        if factor > n {\n            break;\n        }\n\n        factors[factor]\
    \ += 1;\n    }\n\n    factors.sort_by_key(|x| x.to_digits().iter().cloned());\n\
    \    return factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2vvk39iq.rs:18:9\n\
    \   |\n18 |         factors[factor] += 1;\n   |         ^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0599]: no method named\
    \ `to_digits` found for reference `&isize` in the current scope\n  --> /tmp/tmp2vvk39iq.rs:21:31\n\
    \   |\n21 |     factors.sort_by_key(|x| x.to_digits().iter().cloned());\n   |\
    \                               ^^^^^^^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factor = Vec::new();\n\n    for i in 2..n\
    \ {\n        if n % i == 0 {\n            factor.push(i);\n            while n\
    \ % i == 0 {\n                n /= i;\n                factor.push(i);\n     \
    \       }\n        }\n    }\n\n    factor\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp51e9r2_8.rs:17:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    let mut factorization\
    \ = factorization::Factorization::new();\n\n    factorization.push(n);\n    let\
    \ mut factorizationsLeft = factorization\n        .factorize()\n        .into_iter()\n\
    \        .take_while(|factor| !factor.is_divisibleby(2));\n    let mut factorizationsLeft\
    \ = factorizationsLeft.into_iter().filter_map(|factor| {\n        factor.into()\n\
    \    });\n\n    for factored_num in factorizationsLeft {\n        if n == factored_num\
    \ {\n            continue;\n        }\n        factors.push(factored_num);\n \
    \       factorizationsLeft = factorization\n            .factorize()\n       \
    \     .into_iter()\n            .take_while(|factor| !factor.is_divisibleby(factored_num));\n\
    \        factorizationsLeft = factorizationsLeft.into_iter().filter_map(|factor|\
    \ {\n            factor.into()\n        });\n    }\n\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factorization`\n\
    \  --> /tmp/tmpir3kgm8b.rs:13:29\n   |\n13 |     let mut factorization = factorization::Factorization::new();\n\
    \   |                             ^^^^^^^^^^^^^ use of undeclared crate or module\
    \ `factorization`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for f in n.trailing_zeros()\
    \ {\n        if n % f == 0 {\n            factors.push(f);\n            n /= f;\n\
    \        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `u32` is not an iterator\n  --> /tmp/tmpdhw8adcq.rs:12:14\n\
    \   |\n12 |     for f in n.trailing_zeros() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ `u32` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `u32`\n   = note: if you want to iterate between `start` until a value `end`,\
    \ use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `u32`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = vec![0; n + 1];\n    let mut ans\
    \ = vec![0; n + 1];\n    let mut f = primes.clone();\n    for i in 1..=n {\n \
    \       let mut c = 0;\n        for j in 1..=i {\n            if f[j] == 0 {\n\
    \                c += 1;\n                f[j] =\n                    c * f[j]\
    \ + i;\n            }\n        }\n        primes[i] = f[i];\n        ans[i] =\
    \ c;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp3reb1j9.rs:11:30\n   |\n\
    11 |     let mut primes = vec![0; n + 1];\n   |                              ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ primes = vec![0; (n + 1).try_into().unwrap()];\n   |                       \
    \       +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3reb1j9.rs:12:27\n\
    \   |\n12 |     let mut ans = vec![0; n + 1];\n   |                          \
    \ ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut ans = vec![0; (n + 1).try_into().unwrap()];\n   |                      \
    \     +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpp3reb1j9.rs:17:16\n   |\n17 |         \
    \    if f[j] == 0 {\n   |                ^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpp3reb1j9.rs:19:17\n   |\n19 |  \
    \               f[j] =\n   |                 ^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpp3reb1j9.rs:20:25\n   |\n20 |  \
    \                   c * f[j] + i;\n   |                         ^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![];\n\n    // First find all\
    \ prime factors of n\n    // This algorithm is based on Euclid's Sieve of Eratosthenes\
    \ algorithm\n    // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Implementation_of_the_algorithm\n\
    \    let mut prime_candidates = Vec::new();\n\n    let mut q = n as isize;\n \
    \   loop {\n        prime_candidates.push(q);\n\n        if q == 2 {\n       \
    \     break;\n        }\n\n        while !prime_candidates.contains(&q) {\n  \
    \          prime_candidates.push(q);\n            q /= 2;\n        }\n    }\n\n\
    \    for &prime in &prime_candidates {\n        if n % prime != 0 {\n        \
    \    continue;\n        }\n\n        if result.contains(&prime) {\n          \
    \  continue;\n        }\n\n        if prime > n {\n            break;\n      \
    \  }\n\n        result.push(prime);\n        n /= prime;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppbobd8ad.rs:46:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n46 |         n /= prime;\n\
    \   |         ^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    factorize_internal(&n,\
    \ &mut factors);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize_internal` in this scope\n\
    \  --> /tmp/tmp0_03lfgi.rs:12:5\n   |\n12 |     factorize_internal(&n, &mut factors);\n\
    \   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    fn factors(n: isize) -> Vec<isize> {\n        if\
    \ n == 1 {\n            return vec![1];\n        }\n\n        let mut factors\
    \ = vec![];\n        if n % 2 == 1 {\n            factors.extend_from_slice(factors(n\
    \ / 2));\n        }\n\n        for i in 2..=n / 2 {\n            if n % i == 0\
    \ {\n                factors.extend_from_slice(vec![i]);\n                if n\
    \ / i == i {\n                    factors.extend_from_slice(factors(n / i));\n\
    \                }\n            }\n        }\n\n        factors\n    }\n\n   \
    \ if n % 2 == 1 {\n        vec![2]\n    } else {\n        factors(n)\n    }\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `Vec<_>`\n  --> /tmp/tmp3wnf6_te.rs:18:39\n\
    \   |\n16 |         let mut factors = vec![];\n   |             ----------- `factors`\
    \ has type `Vec<_>`\n17 |         if n % 2 == 1 {\n18 |             factors.extend_from_slice(factors(n\
    \ / 2));\n   |                                       ^^^^^^^-------\n   |    \
    \                                   |\n   |                                  \
    \     call expression requires function\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3wnf6_te.rs:23:43\n   |\n23 |                 factors.extend_from_slice(vec![i]);\n\
    \   |                                           ^^^^^^^ expected `&[_]`, found\
    \ struct `Vec`\n   |\n   = note: expected reference `&[_]`\n                 found\
    \ struct `Vec<isize>`\n   = note: this error originates in the macro `vec` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0618]:\
    \ expected function, found `Vec<_>`\n  --> /tmp/tmp3wnf6_te.rs:25:47\n   |\n16\
    \ |         let mut factors = vec![];\n   |             ----------- `factors`\
    \ has type `Vec<_>`\n...\n25 |                     factors.extend_from_slice(factors(n\
    \ / i));\n   |                                               ^^^^^^^-------\n\
    \   |                                               |\n   |                  \
    \                             call expression requires function\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0618.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::with_capacity(2);\n    for\
    \ _ in 0..n {\n        let mut a = 2;\n        let mut b = 2;\n        while a\
    \ <= n {\n            if n % a == 0 {\n                a += b;\n            }\
    \ else {\n                b += a;\n            }\n        }\n        factors.push(a\
    \ as isize);\n    }\n    return factors;\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4]`,\n right: `[2]`', /tmp/tmp0chy4wam.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::with_capacity(2);\n    while\
    \ n != 1 {\n        while n % 2 == 0 {\n            factors.push(2);\n       \
    \     n /= 2;\n        }\n        while n % 3 == 0 {\n            factors.push(3);\n\
    \            n /= 3;\n        }\n        while n % 5 == 0 {\n            factors.push(5);\n\
    \            n /= 5;\n        }\n        while n % 7 == 0 {\n            factors.push(7);\n\
    \            n /= 7;\n        }\n        while n % 11 == 0 {\n            factors.push(11);\n\
    \            n /= 11;\n        }\n        while n % 13 == 0 {\n            factors.push(13);\n\
    \            n /= 13;\n        }\n        while n % 17 == 0 {\n            factors.push(17);\n\
    \            n /= 17;\n        }\n        while n % 19 == 0 {\n            factors.push(19);\n\
    \            n /= 19;\n        }\n        while n % 23 == 0 {\n            factors.push(23);\n\
    \            n /= 23;\n        }\n        while n % 29 == 0 {\n            factors.push(29);\n\
    \            n /= 29;\n        }\n        while n % 31 == 0 {\n            factors.push(31);\n\
    \            n /= 31;\n        }\n        while n % 37 == 0 {\n            factors.push(37);\n\
    \            n /= 37;\n        }\n        while n % 41 == 0 {\n            factors.push(41);\n\
    \            n /= 41;\n        }\n        while n % 43 == 0 {\n            factors.push(43);\n\
    \            n /= 43;\n        }\n        while n % 47 == 0 {\n            factors.push(47);\n\
    \            n /= 47;\n        }\n        while n % 53 == 0 {\n            factors.push(53);\n\
    \            n /= 53;\n        }\n        while n % 59 == 0 {\n            factors.push(59);\n\
    \            n /= 59;\n        }\n        while n % 61 == 0 {\n            factors.push(61);\n\
    \            n /= 61;\n        }\n        while n % 67 == 0 {\n            factors.push(67);\n\
    \            n /= 67;\n        }\n        while n % 71 == 0 {\n            factors.push(71);\n\
    \            n /= 71;\n        }\n        while n % 73 == 0 {\n            factors.push(73);\n\
    \            n /= 73;\n        }\n        while n % 79 == 0 {\n            factors.push(79);\n\
    \            n /= 79;\n        }\n        while n % 83 == 0 {\n            factors.push(83);\n\
    \            n /= 83;\n        }\n        while n % 89 == 0 {\n            factors.push(89);\n\
    \            n /= 89;\n        }\n        while n % 97 == 0 {\n            factors.push(97);\n\
    \            n /= 97;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= 2;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:19:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |             n /= 3;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:23:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n23 |             n /= 5;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:27:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n27 |             n /= 7;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:31:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n31 |             n /= 11;\n   | \
    \            ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:35:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n35 |             n /= 13;\n   | \
    \            ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmp99q46clq.rs:39:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n39 |             n /= 17;\n   | \
    \            ^^^^^^^ "
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut i = 2;\n\
    \    while i * i <= n {\n        while n % i == 0 {\n            factors.push(i);\n\
    \            n /= i;\n        }\n        i += 1;\n    }\n    factors.push(n as\
    \ usize);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n   \
    \ assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7jydl9hg.rs:20:18\n   |\n\
    20 |     factors.push(n as usize);\n   |                  ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     factors.push((n\
    \ as usize).try_into().unwrap());\n   |                  +          +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut primes_count\
    \ = Vec::new();\n    for i in 2..=n {\n        if n % i == 0 {\n            let\
    \ mut primes = 2;\n            while i * primes <= n {\n                if n %\
    \ i == 0 {\n                    primes += 1;\n                }\n            \
    \    i += 1;\n            }\n            primes_count.push(primes);\n        }\n\
    \    }\n    for i in 2..=n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \        }\n    }\n    for i in 2..=n {\n        if primes_count[i] < factors.len()\
    \ {\n            factors.push(primes_count[i]);\n        }\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnpmgltwt.rs:31:12\n\
    \   |\n31 |         if primes_count[i] < factors.len() {\n   |            ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnpmgltwt.rs:32:26\n\
    \   |\n32 |             factors.push(primes_count[i]);\n   |                 \
    \         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n < 2 {\n        return vec![n as isize];\n \
    \   }\n\n    // If n is prime and has two divisors, we can easily divide by two\
    \ and get the same result.\n    if n % 2 == 0 {\n        return vec![2 as isize];\n\
    \    }\n\n    // If n is prime and has no divisors below 2, we can divide by any\
    \ one divisor and get the same result.\n    for i in 2..=n / 2 {\n        if n\
    \ % i == 0 {\n            return vec![i as isize];\n        }\n    }\n\n    //\
    \ If n is prime, we can divide by any divisor and get the same result.\n    for\
    \ i in 3..=n / 3 {\n        if n % i == 0 {\n            return vec![i as isize];\n\
    \        }\n    }\n\n    // If n is prime, we can divide by any divisor and get\
    \ the same result.\n    for i in 5..=n / 5 {\n        if n % i == 0 {\n      \
    \      return vec![i as isize];\n        }\n    }\n\n    // If n is prime, we\
    \ can divide by any divisor and get the same result.\n    for i in 7..=n / 7 {\n\
    \        if n % i == 0 {\n            return vec![i as isize];\n        }\n  \
    \  }\n\n    // If n is prime, we can divide by any divisor and get the same result.\n\
    \    for i in 11..=n / 11 {\n        if n % i == 0 {\n            return vec![i\
    \ as isize];\n        }\n    }\n\n    // If n is prime, we can divide by any divisor\
    \ and get the same result.\n    for i in 13..=n / 13 {\n        if n % i == 0\
    \ {\n            return vec![i as isize];\n        }\n    }\n\n    // If n is\
    \ prime, we can divide by any divisor and get the same result.\n    for i in 17..=n\
    \ / 17 {\n        if n % i == 0 {\n            return vec![i as isize];\n    \
    \    }\n    }\n\n    // If n is prime, we can divide by any divisor and get the\
    \ same result.\n    for i in 19..=n / 19 {\n        if n % i == 0 {\n        \
    \    return vec![i as isize];\n        }\n    }\n\n    // If n is prime, we can\
    \ divide by any divisor and get the same result.\n    for i in 23..=n / 23 {\n\
    \        if n % i == 0 {\n            return vec![i as isize];\n        }\n  \
    \  }\n\n    // If n is prime, we can divide by any divisor and get the same result.\n\
    \    for i in 29..=n / 29 {\n        if n % i == 0 {\n            return vec![i\
    \ as isize];\n        }\n    }\n\n    // If n is prime, we can divide by any divisor\
    \ and get the same result.\n    for i in 31\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpw327i0a6.rs:92:1\n   |\n\
    92 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = vec![];\n\n    factorize_primes(&mut\
    \ res, &vec![n]);\n\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize_primes` in this scope\n \
    \ --> /tmp/tmpmt_ku9kv.rs:13:5\n   |\n13 |     factorize_primes(&mut res, &vec![n]);\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    assert!(n != 0, \"Number should be positive\");\n\
    \    fn check(n: isize) -> isize {\n        if n <= 1 {\n            return 1\n\
    \        }\n        for p in 2..n / 2 {\n            if n % p == 0 {\n       \
    \         return p\n            }\n        }\n        0\n    }\n\n    let mut\
    \ primes = Vec::new();\n    let mut factors = Vec::new();\n    let mut f = check(n);\n\
    \    while f != 0 {\n        primes.push(f);\n        factors.push(f);\n     \
    \   f /= 2;\n    }\n    for _ in 0..(primes.len() - 1) {\n        factors.push(check(n));\n\
    \        n /= primes[_];\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpfmmp9y6i.rs:34:21\n   |\n34 |         n /= primes[_];\n\
    \   |                     ^ `_` not allowed here\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = Vec::new();\n    let mut fact = &n;\n\
    \    f.push(1);\n    while *fact > 1 {\n        while !f.contains(&*fact) {\n\
    \            *fact /= *fact;\n            f.push(*fact);\n        }\n        fact\
    \ /= *fact;\n    }\n    f.reverse();\n    f\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `/=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpafaefvt8.rs:19:9\n   |\n19 |         fact /= *fact;\n\
    \   |         ----^^^^^^^^^\n   |         |\n   |         cannot use `/=` on type\
    \ `&isize`\n   |\nhelp: `/=` can be used on `isize`, you can dereference `fact`\n\
    \   |\n19 |         *fact /= *fact;\n   |         +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 {\n        return vec![1];\n    }\n  \
    \  let mut p = 2;\n    let mut f = 0;\n    while n % p == 0 {\n        p += 1;\n\
    \        f += 1;\n    }\n    n /= p;\n    vec![n, f].into_iter().map(|x| x * x).collect()\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmprqnnplwk.rs:20:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n20 |     n /= p;\n   | \
    \    ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![];\n    for i in 2..=n {\n\
    \        if n % i == 0 {\n            for j in 2..i {\n                if i %\
    \ j == 0 {\n                    result.push(i);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmp058ppzdo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for i in 2..(n/2).ceil()\
    \ {\n        if n % i == 0 {\n            factors.push(i);\n            factors.push(n/i);\
    \ //divide n by i\n        }\n    }\n    factors.push(n / 2);\n    factors\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `ceil` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpd5ez1kwi.rs:12:23\n   |\n12 |     for i in 2..(n/2).ceil()\
    \ {\n   |                       ^^^^ help: there is an associated function with\
    \ a similar name: `div_ceil`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = vec![];\n    for i in 2..=n / 2 {\n\
    \        if n % i == 0 {\n            while n % i == 0 {\n                res.push(i);\n\
    \                n /= i;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpogcwc0s9.rs:16:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\n    let mut current\
    \ = 2;\n    let mut next = 1;\n    while current * next <= n {\n        if n %\
    \ current == 0 {\n            next *= current;\n        } else {\n           \
    \ result.push(next);\n        }\n        current *= next;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpbzqa3713.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut factor\
    \ = 1usize;\n    let mut factor_count = 1usize;\n    let mut max_factor = 1usize;\n\
    \    while n != 1 {\n        while n % factor != 0 {\n            max_factor =\
    \ factor;\n            factor += 1;\n            factor_count += 1;\n        }\n\
    \        factors.push(factor);\n        factor *= n;\n        n /= factor;\n \
    \   }\n    max_factor += 1;\n    factors.push(factor);\n    factors.push(max_factor);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl3tjgvbe.rs:16:19\n   |\n\
    16 |         while n % factor != 0 {\n   |                   ^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpl3tjgvbe.rs:16:17\n\
    \   |\n16 |         while n % factor != 0 {\n   |                 ^ no implementation\
    \ for `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl3tjgvbe.rs:22:19\n\
    \   |\n22 |         factor *= n;\n   |                   ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot multiply-assign `usize` by `isize`\n  --> /tmp/tmpl3tjgvbe.rs:22:16\n\
    \   |\n22 |         factor *= n;\n   |                ^^ no implementation for\
    \ `usize *= isize`\n   |\n   = help: the trait `MulAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `MulAssign<Rhs>`:\n\
    \             <f32 as MulAssign<&f32>>\n             <f32 as MulAssign>\n    \
    \         <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n        \
    \     <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n         \
    \    <i16 as MulAssign<&i16>>\n             <i16 as MulAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl3tjgvbe.rs:23:14\n\
    \   |\n23 |         n /= factor;\n   |              ^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmpl3tjgvbe.rs:23:11\n\
    \   |\n23 |         n /= factor;\n   |           ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<R"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![0; n];\n    for\
    \ factor in factors::into_iter() {\n        factors[factor] += 1;\n    }\n\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factors`\n\
    \  --> /tmp/tmptd1ozp3c.rs:12:19\n   |\n12 |     for factor in factors::into_iter()\
    \ {\n   |                   ^^^^^^^ use of undeclared crate or module `factors`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptd1ozp3c.rs:11:43\n   |\n11 |\
    \     let mut factors: Vec<isize> = vec![0; n];\n   |                        \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factors: Vec<isize> = vec![0; n.try_into().unwrap()];\n   | \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = Vec::new();\n    let mut i = 1;\n  \
    \  while i * i <= n {\n        while n % i == 0 {\n            i += 1;\n     \
    \       f.push(i);\n        }\n        i += 1;\n    }\n    f\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3]`,\n right: `[2]`', /tmp/tmpm1z1cmxk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut prime_factors: Vec<isize> = Vec::new();\n\
    \    let mut prime_factors_num: Vec<isize> = Vec::new();\n    let mut is_prime:\
    \ Vec<bool> = Vec::new();\n    let mut divisor: isize = n;\n    while divisor\
    \ > 1 {\n        for _ in 0..(divisor / 2) {\n            if is_prime.iter().any(|&_|\
    \ !divisor % _) {\n                divisor /= 2;\n            } else {\n     \
    \           is_prime.push(true);\n                prime_factors.push(divisor as\
    \ isize);\n                prime_factors_num.push(1);\n                divisor\
    \ = divisor - 1;\n                break;\n            }\n        }\n    }\n  \
    \  for _ in 0..(divisor * 2) {\n        if is_prime.iter().any(|&_| !divisor %\
    \ _) {\n            is_prime.push(false);\n            divisor = divisor + 1;\n\
    \        }\n    }\n    for i in 0..(prime_factors_num.len()) {\n        let mut\
    \ prime_factors_i = prime_factors[prime_factors.len() - prime_factors_num.len()\
    \ - i..prime_factors.len() - i];\n        prime_factors.append(prime_factors_i);\n\
    \    }\n    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpy02_e3n6.rs:17:52\n   |\n17 |             if is_prime.iter().any(|&_|\
    \ !divisor % _) {\n   |                                                    ^ `_`\
    \ not allowed here\n\nerror: in expressions, `_` can only be used on the left-hand\
    \ side of an assignment\n  --> /tmp/tmpy02_e3n6.rs:29:48\n   |\n29 |         if\
    \ is_prime.iter().any(|&_| !divisor % _) {\n   |                             \
    \                   ^ `_` not allowed here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy02_e3n6.rs:17:41\n   |\n17 |             if is_prime.iter().any(|&_|\
    \ !divisor % _) {\n   |                                         ^^^^^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy02_e3n6.rs:29:37\n\
    \   |\n29 |         if is_prime.iter().any(|&_| !divisor % _) {\n   |        \
    \                             ^^^^^^^^^^^^ expected `bool`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy02_e3n6.rs:36:30\n   |\n36 |  \
    \       prime_factors.append(prime_factors_i);\n   |                         \
    \     ^^^^^^^^^^^^^^^ expected `&mut Vec<isize>`, found slice `[isize]`\n   |\n\
    \   = note: expected mutable reference `&mut Vec<isize>`\n                   \
    \       found slice `[isize]`\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpy02_e3n6.rs:35:13\n   |\n\
    35 |         let mut prime_factors_i = prime_factors[prime_factors.len() - prime_factors_num.len()\
    \ - i..prime_factors.len() - i];\n   |             ^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[isize]`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n35 |         let mut prime_factors_i = &prime_factors[prime_factors.len()\
    \ - prime_factors_num.len() - i..prime_factors.len() - i];\n   |             \
    \                      +\n\nerror: aborting due to 6 previous errors\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    debug_assert!(n > 0);\n    let mut factorization:\
    \ Vec<isize> = Vec::new();\n    let mut limit: isize = n;\n    while limit > 1\
    \ {\n        if limit % 2 == 0 {\n            factorization.push(2);\n       \
    \     limit /= 2;\n        } else {\n            let mut i = 2;\n            while\
    \ i <= limit {\n                if limit % i == 0 {\n                    factorization.push(i);\n\
    \                    limit /= i;\n                    break;\n               \
    \ }\n                i += 1;\n            }\n        }\n    }\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut i = 1;\n\
    \    while i * i <= n {\n        while i * i < n && n % i == 0 {\n           \
    \ i += 1;\n        }\n        if i * i > n {\n            break;\n        }\n\
    \        factors.push(i);\n        i += 1;\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpnostxels.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut facs = Vec::new();\n    facs.push(1);\n\
    \    for &f in factors(n) {\n        for &fac in facs {\n            if fac >\
    \ f {\n                continue;\n            }\n            if f % fac != 0 {\n\
    \                facs.push(f);\n                break;\n            }\n      \
    \  }\n    }\n    facs\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpvjjfetjs.rs:13:15\n\
    \   |\n13 |     for &f in factors(n) {\n   |               ^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjjfetjs.rs:14:13\n\
    \   |\n14 |         for &fac in facs {\n   |             ^^^^    ---- this expression\
    \ has type `Option<{integer}>`\n   |             |\n   |             expected\
    \ integer, found reference\n   |             help: you can probably remove the\
    \ explicit borrow: `fac`\n   |\n   = note:   expected type `{integer}`\n     \
    \      found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes: Vec<isize> = Vec::new();\n    let\
    \ mut factors = Vec::new();\n    for factor in &factors::prime_factors(n) {\n\
    \        factors.push(factor);\n    }\n    factors.sort_unstable_by_key(|factor|\
    \ factor);\n    for factor in factors {\n        if factors.contains(&factor -\
    \ 1) {\n            factors.remove(factor);\n        }\n        primes.push(factor);\n\
    \    }\n    primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factors`\n\
    \  --> /tmp/tmppcsc931n.rs:13:20\n   |\n13 |     for factor in &factors::prime_factors(n)\
    \ {\n   |                    ^^^^^^^ use of undeclared crate or module `factors`\n\
    \nerror[E0271]: type mismatch resolving `<&usize as Sub<usize>>::Output == &usize`\n\
    \  --> /tmp/tmppcsc931n.rs:18:37\n   |\n18 |         if factors.contains(&factor\
    \ - 1) {\n   |                                     ^ expected `usize`, found `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppcsc931n.rs:21:21\n   |\n21 |\
    \         primes.push(factor);\n   |                     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         primes.push(factor.try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut current_factor\
    \ = 1;\n    while n > 1 {\n        while n % current_factor == 0 {\n         \
    \   factors.push(current_factor);\n            current_factor *= 2;\n        }\n\
    \        current_factor /= 2;\n        n /= current_factor;\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp13n98fqc.rs:19:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n19 |         n /= current_factor;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut counter: isize = 1;\n    let mut factors:\
    \ Vec<isize> = vec![];\n    for f in factorize_fast(n) {\n        if f % 2 ==\
    \ 0 {\n            counter *= 2;\n        } else {\n            counter *= f;\n\
    \            factors.push(f);\n        }\n        if counter == n {\n        \
    \    break;\n        }\n    }\n    if counter == n {\n        return factors;\n\
    \    }\n    if counter > n {\n        return factors;\n    }\n    factors.append(counter);\n\
    \    let mut f = factorize_fast(counter);\n    let mut c = 0;\n    while f !=\
    \ 1 {\n        if f % 2 == 0 {\n            counter *= 2;\n        } else {\n\
    \            counter *= f;\n        }\n        if counter == n {\n           \
    \ break;\n        }\n        if counter == 1 {\n            factors.push(1);\n\
    \            break;\n        }\n        let mut f = factorize_fast(counter);\n\
    \        if f == 1 {\n            factors.push(1);\n            break;\n     \
    \   }\n        if f % 2 == 0 {\n            c *= 2;\n        } else {\n      \
    \      c *= f;\n        }\n        if counter == n {\n            break;\n   \
    \     }\n    }\n    factors.append(c);\n    return factors;\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize_fast` in this scope\n  -->\
    \ /tmp/tmp5ekvxzak.rs:13:14\n   |\n13 |     for f in factorize_fast(n) {\n   |\
    \              ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `factorize_fast` in this scope\n  --> /tmp/tmp5ekvxzak.rs:31:17\n\
    \   |\n31 |     let mut f = factorize_fast(counter);\n   |                 ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `factorize_fast`\
    \ in this scope\n  --> /tmp/tmp5ekvxzak.rs:46:21\n   |\n46 |         let mut f\
    \ = factorize_fast(counter);\n   |                     ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ekvxzak.rs:30:20\n\
    \   |\n30 |     factors.append(counter);\n   |                    ^^^^^^^ expected\
    \ `&mut Vec<isize>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<isize>`\n                           found type `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5ekvxzak.rs:60:20\n   |\n60 |     factors.append(c);\n\
    \   |                    ^ expected `&mut Vec<isize>`, found integer\n   |\n \
    \  = note: expected mutable reference `&mut Vec<isize>`\n                    \
    \       found type `{integer}`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::with_capacity(1);\n    let mut\
    \ fact = n.clone();\n    while fact > 1 {\n        if fact % 2 == 1 {\n      \
    \      fact = fact / 2;\n        }\n        else {\n            fact = fact /\
    \ 2;\n            let mut i = 0;\n            while fact % 2 == 1 {\n        \
    \        i += 1;\n                fact /= 2;\n            }\n            res.push(i);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmp_ushopcl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut facs = Vec::new();\n    let mut i = 1;\n\
    \n    for f in factors(n) {\n        facs.push(f);\n        while i < f {\n  \
    \          facs.push(i);\n            i += 1;\n        }\n    }\n\n    facs\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpt8irxy47.rs:14:14\n\
    \   |\n14 |     for f in factors(n) {\n   |              ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut ret: Vec<isize> = vec![];\n    for d in\
    \ 2..=(n + 1) {\n        for _ in 0..d / 2 {\n            let mut j = 2;\n   \
    \         while j * j <= n {\n                if n % j == 0 {\n              \
    \      break j;\n                }\n                j += 1;\n            }\n \
    \           if j > d {\n                break;\n            }\n            ret.push(d);\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0571]: `break` with value from a `while` loop\n  --> /tmp/tmp9y6t3zuz.rs:17:21\n\
    \   |\n15 |             while j * j <= n {\n   |             ----------------\
    \ you can't `break` with a value in a `while` loop\n16 |                 if n\
    \ % j == 0 {\n17 |                     break j;\n   |                     ^^^^^^^\
    \ can only break with a value inside `loop` or breakable block\n   |\nhelp: use\
    \ `break` on its own without a value inside this `while` loop\n   |\n17 |    \
    \                 break;\n   |                     ~~~~~\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0571`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut counter\
    \ = 1;\n    let mut dividend = n;\n    let mut i = 1;\n    while dividend % i\
    \ == 0 {\n        factors.push(i);\n        dividend /= i;\n        i += 1;\n\
    \    }\n    while dividend != 1 {\n        factors.push(dividend);\n        dividend\
    \ /= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[2]`', /tmp/tmp4qhdwer7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut counter: usize = 1;\n    let mut factors:\
    \ Vec<isize> = Vec::new();\n\n    while counter <= n {\n        if n % counter\
    \ == 0 {\n            counter += 1;\n            factors.push(counter);\n    \
    \    }\n        else {\n            counter += 1;\n            factors.insert(counter,\
    \ 1);\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7f46hcur.rs:14:22\n   |\n\
    14 |     while counter <= n {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n14 |     while counter <= n.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7f46hcur.rs:15:16\n   |\n15 |         if n % counter ==\
    \ 0 {\n   |                ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot mod `isize` by `usize`\n  --> /tmp/tmp7f46hcur.rs:15:14\n   |\n15 | \
    \        if n % counter == 0 {\n   |              ^ no implementation for `isize\
    \ % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7f46hcur.rs:17:26\n   |\n17 |             factors.push(counter);\n\
    \   |                          ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |             factors.push(counter.try_into().unwrap());\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut i = 1;\n\
    \    while i * i <= n {\n        while n % i == 0 {\n            factors.push(i);\n\
    \            n /= i;\n        }\n        i += 1;\n    }\n    factors.reverse();\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpldwt4euf.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 2..(n\
    \ as usize) {\n        if n % i == 0 {\n            result.push(i);\n        \
    \    n /= i;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8zoyddb8.rs:13:16\n   |\n\
    13 |         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmp8zoyddb8.rs:13:14\n\
    \   |\n13 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8zoyddb8.rs:15:18\n\
    \   |\n15 |             n /= i;\n   |                  ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmp8zoyddb8.rs:15:15\n\
    \   |\n15 |             n /= i;\n   |               ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8zoyddb8.rs:18:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n18 |    \
    \ result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --ex"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut primes = prime_factorization(n);\n    for prime in &primes {\n        factors.push(factors.iter().filter(|&x|\
    \ *x == prime).count());\n    }\n    return factors;\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \  --> /tmp/tmpsd2azn6w.rs:12:22\n   |\n12 |     let mut primes = prime_factorization(n);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsd2azn6w.rs:14:22\n   |\n14 |         factors.push(factors.iter().filter(|&x|\
    \ *x == prime).count());\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |         factors.push(factors.iter().filter(|&x|\
    \ *x == prime).count().try_into().unwrap());\n   |                           \
    \                                          ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    factorize(n,\
    \ &mut factors);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp27mfqe65.rs:12:5\n   |\n12 |     factorize(n, &mut factors);\n\
    \   |     ^^^^^^^^^ -  ------------ supplied 2 arguments\n   |     |\n   |   \
    \  expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp27mfqe65.rs:10:4\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ^^^^^^^^^ --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    for i in\
    \ factorizations.keys().iter() {\n        if n % i == 0 {\n            factorization.push(i);\n\
    \            factorizations[i] = factorizations.get(&i).unwrap() + 1;\n      \
    \  }\n    }\n\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `factorizations` in this scope\n  --> /tmp/tmpl_8mha01.rs:12:14\n\
    \   |\n12 |     for i in factorizations.keys().iter() {\n   |              ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `factorization`\n\nerror[E0425]:\
    \ cannot find value `factorizations` in this scope\n  --> /tmp/tmpl_8mha01.rs:15:13\n\
    \   |\n15 |             factorizations[i] = factorizations.get(&i).unwrap() +\
    \ 1;\n   |             ^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `factorization`\n\nerror[E0425]: cannot find value `factorizations`\
    \ in this scope\n  --> /tmp/tmpl_8mha01.rs:15:33\n   |\n15 |             factorizations[i]\
    \ = factorizations.get(&i).unwrap() + 1;\n   |                               \
    \  ^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `factorization`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut fact = 1;\n    while fact <= n {\n        while n % fact == 0 {\n      \
    \      factors.push(fact);\n            n /= fact;\n        }\n        fact +=\
    \ 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n \
    \   assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnxndvvuk.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= fact;\n\
    \   |             ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut cur = 1;\n\
    \    for i in n.iter().rev() {\n        if i % 2 == 0 {\n            for j in\
    \ cur..i {\n                if n % j == 0 {\n                    res.push(j);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     cur *= i;\n    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmptdf8j7z0.rs:13:16\n   |\n13 |     for i in n.iter().rev()\
    \ {\n   |                ^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fs = Vec::new();\n    let mut x = n;\n \
    \   let mut i = 1; \n    while x * i <= n {\n        if n % i == 0 {\n       \
    \     i += 1;\n            while i * i <= n {\n                if n % i == 0 {\n\
    \                    i += 1;\n                    continue 2;\n              \
    \  }\n                i += 1;\n            }\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    fs.push(x % i);\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            i += 1;\n        } else {\n            break;\n\
    \        }\n    }\n    while i * i > n {\n        fs.push(i);\n        i += 1;\n\
    \    }\n    fs\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `2`\n\
    \  --> /tmp/tmpzzfgo4s3.rs:20:30\n   |\n20 |                     continue 2;\n\
    \   |                              ^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    let mut f = 0;\n\
    \n    // calculate list of prime factors\n    while f <= n {\n        for j in\
    \ 2..(n - f) {\n            if n % j == 0 {\n                primes.push(j);\n\
    \                n /= j;\n                break;\n            }\n        }\n \
    \       f++;\n    }\n\n    // calculate multiplicity of prime factors\n    for\
    \ prime in &primes {\n        for m in 2..(n - prime) {\n            if prime\
    \ * m == n {\n                primes.insert(prime, m);\n                break;\n\
    \            }\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmphbt0gd8t.rs:23:10\n\
    \   |\n23 |         f++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n23 |         { let tmp = f; f += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n23 -         f++;\n23 +         f +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphbt0gd8t.rs:30:31\n\
    \   |\n30 |                 primes.insert(prime, m);\n   |                   \
    \            ^^^^^ expected `usize`, found `&isize`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut counter = 0;\n    let mut primes = vec![];\n\
    \    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ primes.push(i as isize);\n            counter = 1;\n            while i * i\
    \ <= n {\n                if n % i == 0 {\n                    counter = counter\
    \ + 1;\n                    i = i * i;\n                } else {\n           \
    \         break;\n                }\n            }\n        } else {\n       \
    \     i = i * 2;\n        }\n    }\n    primes.reverse();\n    let mut res = vec![];\n\
    \    for i in primes {\n        if counter > 1 {\n            for _ in 0..(counter\
    \ - 1) {\n                res.push(i);\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut limit\
    \ = 1;\n    loop {\n        factors.push(limit);\n        limit *= 2;\n      \
    \  if limit > n {\n            break;\n        }\n        for _ in 0..=limit {\n\
    \            if n % limit == 0 {\n                factors.push(limit);\n     \
    \           break;\n            }\n            limit /= 2;\n        }\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmpak4lf46b.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut max_factor\
    \ = 1;\n\n    let mut num = 1;\n    while num < n {\n        for num in factorize(n)\
    \ {\n            max_factor *= num;\n        }\n        factors.push(num);\n \
    \   }\n\n    while factors.len() > 0 {\n        factors.pop();\n        for num\
    \ in factors.clone() {\n            if num > max_factor {\n                max_factor\
    \ = num;\n            }\n        }\n    }\n    factors\n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut result\
    \ = 1;\n    let mut factor = 1;\n    while n % factor != 0 {\n        factors.push(factor)\n\
    \        result *= factor;\n        factor *= n;\n    }\n    factors.push(result);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `result`\n  --> /tmp/tmp9qk4hztw.rs:15:29\n\
    \   |\n15 |         factors.push(factor)\n   |                             ^ help:\
    \ add `;` here\n16 |         result *= factor;\n   |         ------ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut current_factor\
    \ = n - 1;\n    while current_factor > 1 {\n        let factor = 1;\n        for\
    \ factor in current_factor .. (current_factor * 2) {\n            if n % factor\
    \ == 0 {\n                break;\n            }\n        }\n        if factor\
    \ > 1 {\n            factors.push(factor)\n        }\n        current_factor =\
    \ current_factor / 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmp1nrwbsdp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![];\n    for i in 1..n {\n\
    \        if n % i == 0 {\n            factors.push(i as isize);\n            n\
    \ /= i;\n        }\n    }\n    if n > 1 {\n        factors.push(n as isize);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpen85__d6.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 {\n        return vec![1]\n    }\n\n \
    \   let mut primes = vec![2]; // 1 is not prime but 2 is prime so it is 2\n  \
    \  let mut result = vec![2]; // first two elements are 2\n    let mut m = 2; //\
    \ number of primes smaller than given number\n    let mut n = n as isize;\n\n\
    \    while m != 0 {\n        while n % m == 0 {\n            primes.push(m);\n\
    \            n /= m;\n        }\n        m += 2;\n    }\n    for i in 1..=primes.len()\
    \ {\n        result[primes.iter().position(|&x| *x == i).unwrap()] += i;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp2bex45cz.rs:28:44\n\
    \   |\n28 |         result[primes.iter().position(|&x| *x == i).unwrap()] += i;\n\
    \   |                                            ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2bex45cz.rs:30:5\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut facs = Vec::new();\n    for i in 2..n {\n\
    \        if n % i == 0 {\n            facs.push(i as isize);\n            n /=\
    \ i;\n        }\n    }\n    facs\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpc6n9b0ky.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = vec![0; n];\n    for i in (0..(res.len()\
    \ - 1)).rev() {\n        if n % i == 0 {\n            res[i] = i + 1;\n      \
    \      res -= [n / i];\n        }\n    }\n    if n != 1 {\n        res.insert(0,\
    \ n);\n    }\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz0pci9by.rs:11:27\n   |\n\
    11 |     let mut res = vec![0; n];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut res = vec![0;\
    \ n.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz0pci9by.rs:13:16\n   |\n13 |\
    \         if n % i == 0 {\n   |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpz0pci9by.rs:13:14\n\
    \   |\n13 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz0pci9by.rs:15:25\n\
    \   |\n15 |             res -= [n / i];\n   |                         ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n \
    \ --> /tmp/tmpz0pci9by.rs:15:23\n   |\n15 |             res -= [n / i];\n   |\
    \                       ^ no implementation for `isize / usize`\n   |\n   = help:\
    \ the trait `Div<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0368]: binary\
    \ assignment operation `-=` cannot be applied to type `Vec<usize>`\n  --> /tmp/tmpz0pci9by.rs"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fac = Vec::new();\n    for i in 2..n {\n\
    \        while n % i == 0 {\n            fac.push(i);\n            n /= i;\n \
    \       }\n    }\n    fac\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp6fayc_4v.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![0; n];\n    let mut n = n\
    \ as isize;\n    while n > 1 {\n        for j in 2..n {\n            if n % j\
    \ == 0 {\n                factors[j] += 1;\n                n /= j;\n        \
    \        break;\n            }\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyrson95v.rs:11:31\n   |\n\
    11 |     let mut factors = vec![0; n];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut factors\
    \ = vec![0; n.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpyrson95v.rs:16:17\n\
    \   |\n16 |                 factors[j] += 1;\n   |                 ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    for _ in 0..n\
    \ {\n        let mut prime = true;\n        let mut counter = 0;\n\n        for\
    \ _ in 0..n {\n            if n % _ == 0 {\n                prime = false;\n \
    \               break;\n            }\n            counter += 1;\n        }\n\n\
    \        if prime {\n            factors.push(counter);\n        }\n    }\n\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmp3hcml2kr.rs:18:20\n   |\n18 |             if n % _\
    \ == 0 {\n   |                    ^ `_` not allowed here\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    factorization.push(2);\n\
    \    let mut ffactor = 1;\n\n    for _ in 0..n {\n        if ffactor % 2 == 0\
    \ {\n            let f = ffactor / 2;\n            factorization.push(f);\n  \
    \      }\n\n        if n >= ffactor {\n            factorization.push(n);\n  \
    \          return factorization;\n        }\n\n        ffactor = ffactor * 2;\n\
    \    }\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2]`', /tmp/tmpnv3jg6ex.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut factors\
    \ = Vec::new();\n    let mut factorization = factorize_inner(n);\n\n    while\
    \ !factorization.is_empty() {\n        result.push(factorization.pop());\n   \
    \     factors.push(1);\n        for _ in factorization.clone() {\n           \
    \ let new_factor = factorization.pop();\n            if *factors.last().unwrap()\
    \ != new_factor {\n                factors.push(new_factor);\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize_inner` in this scope\n  -->\
    \ /tmp/tmp1_solfmb.rs:13:29\n   |\n13 |     let mut factorization = factorize_inner(n);\n\
    \   |                             ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for factor in\
    \ prime_factors(n) {\n        factors.push(factor);\n    }\n    factors\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n  -->\
    \ /tmp/tmpjjij4y0b.rs:12:19\n   |\n12 |     for factor in prime_factors(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![];\n\n    for _ in 0..n {\n\
    \        if n % 2 == 0 {\n            result.append(2);\n            n /= 2;\n\
    \        } else {\n            while (n % 3 == 0) n /= 3;\n            while (n\
    \ % 5 == 0) n /= 5;\n            while (n % 7 == 0) n /= 7;\n            result.push(n);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `n`\n  --> /tmp/tmps6v0v0hd.rs:18:32\n   |\n\
    18 |             while (n % 3 == 0) n /= 3;\n   |             ----- ------------\
    \ ^ expected `{`\n   |             |     |\n   |             |     this `while`\
    \ condition successfully parsed\n   |             while parsing the body of this\
    \ `while` expression\n   |\nhelp: try placing this code inside a block\n   |\n\
    18 |             while (n % 3 == 0) { n /= 3 };\n   |                        \
    \        +        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps6v0v0hd.rs:15:27\n\
    \   |\n15 |             result.append(2);\n   |                           ^ expected\
    \ `&mut Vec<_>`, found integer\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                           found type `{integer}`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut a = 1;\n\
    \    let mut b = n;\n    let mut max_factor = 0;\n\n    while a <= b {\n     \
    \   if a % b == 0 {\n            result.push(a);\n            max_factor = std::cmp::max(max_factor,\
    \ a.checked_mul(b.checked_mul(2)).ok().unwrap_or(0));\n        }\n        a +=\
    \ 1;\n        b -= 1;\n    }\n\n    if max_factor > 2 {\n        result\n    }\
    \ else {\n        result.push(1);\n        max_factor = 2;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp92vu4di7.rs:19:66\n   |\n\
    19 |             max_factor = std::cmp::max(max_factor, a.checked_mul(b.checked_mul(2)).ok().unwrap_or(0));\n\
    \   |                                                                  ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0599]: no method named `ok`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp92vu4di7.rs:19:84\n\
    \   |\n19 |             max_factor = std::cmp::max(max_factor, a.checked_mul(b.checked_mul(2)).ok().unwrap_or(0));\n\
    \   |                                                                        \
    \            ^^ help: there is an associated function with a similar name: `or`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp92vu4di7.rs:26:9\n   |\n25 | /\
    \     if max_factor > 2 {\n26 | |         result\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n27 | |     } else {\n28 | |         result.push(1);\n\
    29 | |         max_factor = 2;\n30 | |     }\n   | |_____- expected this to be\
    \ `()`\n   |\n   = note: expected unit type `()`\n                 found struct\
    \ `Vec<isize>`\nhelp: you might have meant to return this value\n   |\n26 |  \
    \       return result;\n   |         ++++++       +\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = vec![];\n    let mut n = n as u64;\n\
    \    while n > 1 {\n        while n % 2 == 0 {\n            f.push(2);\n     \
    \       n /= 2;\n        }\n        while n % 5 == 0 {\n            f.push(5);\n\
    \            n /= 5;\n        }\n        while n % 7 == 0 {\n            f.push(7);\n\
    \            n /= 7;\n        }\n        while n % 11 == 0 {\n            f.push(11);\n\
    \            n /= 11;\n        }\n        while n % 13 == 0 {\n            f.push(13);\n\
    \            n /= 13;\n        }\n        while n % 17 == 0 {\n            f.push(17);\n\
    \            n /= 17;\n        }\n        while n % 19 == 0 {\n            f.push(19);\n\
    \            n /= 19;\n        }\n        while n % 23 == 0 {\n            f.push(23);\n\
    \            n /= 23;\n        }\n        while n % 29 == 0 {\n            f.push(29);\n\
    \            n /= 29;\n        }\n        while n % 31 == 0 {\n            f.push(31);\n\
    \            n /= 31;\n        }\n        while n % 37 == 0 {\n            f.push(37);\n\
    \            n /= 37;\n        }\n        while n % 41 == 0 {\n            f.push(41);\n\
    \            n /= 41;\n        }\n        while n % 43 == 0 {\n            f.push(43);\n\
    \            n /= 43;\n        }\n        while n % 47 == 0 {\n            f.push(47);\n\
    \            n /= 47;\n        }\n        while n % 53 == 0 {\n            f.push(53);\n\
    \            n /= 53;\n        }\n        while n % 59 == 0 {\n            f.push(59);\n\
    \            n /= 59;\n        }\n        while n % 61 == 0 {\n            f.push(61);\n\
    \            n /= 61;\n        }\n        while n % 67 == 0 {\n            f.push(67);\n\
    \            n /= 67;\n        }\n        while n % 71 == 0 {\n            f.push(71);\n\
    \            n /= 71;\n        }\n        while n % 73 == 0 {\n            f.push(73);\n\
    \            n /= 73;\n        }\n        while n % 79 == 0 {\n            f.push(79);\n\
    \            n /= 79;\n        }\n        while n % 83 == 0 {\n            f.push(83);\n\
    \            n /= 83;\n        }\n        while n % 89 == 0 {\n            f.push(89);\n\
    \            n /= 89;\n        }\n        while n % 97 == 0 {\n            f.push(97);\n\
    \            n /= 97;\n        }\n        while n % 101 == 0 {\n            f.push(101);\n\
    \            n /= 101;\n        }\n        while n % 103 == 0 {\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3o7kpkke.rs:127:3\n\
    \    |\n10  | fn factorize(n: isize) -> Vec<isize> {\n    |                  \
    \                    - unclosed delimiter\n...\n13  |     while n > 1 {\n    |\
    \                 - unclosed delimiter\n...\n114 |         while n % 103 == 0\
    \ {\n    |                            - this delimiter might not be properly closed...\n\
    115 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    127 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp3o7kpkke.rs:13:5\n\
    \    |\n10  |   fn factorize(n: isize) -> Vec<isize> {\n    |                \
    \             ---------- expected `Vec<isize>` because of return type\n...\n13\
    \  | /     while n > 1 {\n14  | |         while n % 2 == 0 {\n15  | |        \
    \     f.push(2);\n16  | |             n /= 2;\n...   |\n126 | |     assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n127 | | }\n    | |__^ expected struct `Vec`, found `()`\n \
    \   |\n    = note: expected struct `Vec<isize>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    assert!(n % 2 == 0, \"n should be an even number\"\
    );\n    let mut factors = Vec::new();\n    let mut i = 2;\n    while i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            factors.push(n)\
    \ / i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot divide `()` by `isize`\n  --> /tmp/tmp3sjbg7b5.rs:17:29\n\
    \   |\n17 |             factors.push(n) / i;\n   |             ---------------\
    \ ^ - isize\n   |             |\n   |             ()\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fs = vec![];\n    for (i, _) in factorization(n)\
    \ {\n        fs.push(i as isize);\n    }\n    fs\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpp0w31wuy.rs:12:19\n   |\n12 |     for (i, _) in factorization(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    if n <= 1 {\n\
    \        return factors\n    }\n    for i in 2..=n {\n        if n % i == 0 {\n\
    \            if !factors.contains(&i) {\n                factors.push(i);\n  \
    \          }\n            factors.extend(factorize(n).clone());\n        }\n \
    \   }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    let mut primes\
    \ = HashSet::new();\n    let mut primes_count = Vec::new();\n    let mut counter\
    \ = 1;\n    primes_count.push(1);\n    primes.insert(2);\n    while counter <=\
    \ n {\n        for prime in primes {\n            if n % prime == 0 {\n      \
    \          factors.push(prime);\n                n /= prime;\n               \
    \ break;\n            }\n        }\n        if n != 1 {\n            factors.push(1);\n\
    \        }\n        counter += 1;\n        for _ in 0..(primes.len() - 1) {\n\
    \            primes_count.push(counter);\n        }\n        primes.clear();\n\
    \    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp54m1o70p.rs:13:22\n   |\n13 |     let mut primes = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![];\n    for &d in prime_factors(n)\
    \ {\n        factors.push(d * n);\n    }\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n  -->\
    \ /tmp/tmp7k56wb_v.rs:12:15\n   |\n12 |     for &d in prime_factors(n) {\n   |\
    \               ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    primes.push(2);\
    \ // First prime is always 2\n    let mut nprime = 1;\n    while nprime < n {\n\
    \        // While we still have not met all factors\n        while nprime < n\
    \ {\n            // Check if nprime is a factor\n            if n % nprime ==\
    \ 0 {\n                break;\n            }\n            nprime += 1;\n     \
    \   }\n        // Check if nprime is now equal to n.\n        if nprime == n {\n\
    \            primes.push(nprime);\n        }\n        nprime += 1;\n    }\n  \
    \  primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[2, 2]`', /tmp/tmpijkv5vdj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = vec![0; n]; // f should be initialized\
    \ with 0 as all primes except 1\n    let mut n = n;\n    let mut i = 0;\n    loop\
    \ {\n        if n % f == 0 {\n            f.pop();\n            n /= f;\n    \
    \    } else {\n            i += 1;\n            f.push(i);\n        }\n      \
    \  if n == 1 {\n            break;\n        }\n    }\n    f\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplguv7acs.rs:11:25\n   |\n\
    11 |     let mut f = vec![0; n]; // f should be initialized with 0 as all primes\
    \ except 1\n   |                         ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut f = vec![0; n.try_into().unwrap()];\
    \ // f should be initialized with 0 as all primes except 1\n   |             \
    \             ++++++++++++++++++++\n\nerror[E0277]: cannot mod `isize` by `Vec<{integer}>`\n\
    \  --> /tmp/tmplguv7acs.rs:15:14\n   |\n15 |         if n % f == 0 {\n   |   \
    \           ^ no implementation for `isize % Vec<{integer}>`\n   |\n   = help:\
    \ the trait `Rem<Vec<{integer}>>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Rem<Rhs>`:\n             <&'a f32 as\
    \ Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n\
    \             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n    \
    \         <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n          \
    \   <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]: cannot\
    \ divide-assign `isize` by `Vec<{integer}>`\n  --> /tmp/tmplguv7acs.rs:17:15\n\
    \   |\n17 |             n /= f;\n   |               ^^ no implementation for `isize\
    \ /= Vec<{integer}>`\n   |\n   = help: the trait `DivAssign<Vec<{integer}>>` is\
    \ not implemented for `isize`\n   = help: the following other types implement\
    \ trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n           \
    \  <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n             <f64\
    \ as DivAssign>\n             <i128 as DivAssign<&i128>>\n             <i128 as\
    \ DivAssign>\n             <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut factor\
    \ = 1;\n    while n > 0 {\n        if n % factor == 0 {\n            factors.push(factor);\n\
    \            n /= factor;\n        } else {\n            factor *= factor;\n \
    \       }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgphhehpv.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fs = Vec::new();\n\n    for i in 2..=n /\
    \ 2 {\n        if n % i == 0 {\n            fs.push(i);\n            n /= i;\n\
    \        }\n    }\n\n    fs.push(n as usize);\n    fs\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyz_zaulf.rs:20:13\n   |\n\
    20 |     fs.push(n as usize);\n   |             ^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     fs.push((n as usize).try_into().unwrap());\n\
    \   |             +          +++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for (i, num)\
    \ in factorize::factorize(n).iter().enumerate() {\n        factors.push(num);\n\
    \        for _ in 0..num {\n            factors.push(i);\n        }\n    }\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `factorize`\n\
    \  --> /tmp/tmp0yrsze_f.rs:12:21\n   |\n12 |     for (i, num) in factorize::factorize(n).iter().enumerate()\
    \ {\n   |                     ^^^^^^^^^ use of undeclared crate or module `factorize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut current = 2;\n    while current <= n {\n        if n % current == 0 {\n\
    \            factors.push(current);\n            n /= current;\n        }\n  \
    \      current += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmplu7ialon.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= current;\n\
    \   |             ^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 {\n        return vec![1];\n    }\n  \
    \  let mut f = factorize(n * 2);\n    f.pop();\n    f.push(1);\n    vec!f\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `(`, `[`, or `{`, found `f`\n  --> /tmp/tmpvjudy5bo.rs:17:9\n\
    \   |\n17 |     vec!f\n   |         ^ expected one of `(`, `[`, or `{`\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current\
    \ = 1;\n    while current <= n {\n        if n % current == 0 {\n            result.push(n);\n\
    \            current *= 2;\n        }\n        current += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4]`,\n right: `[2, 2]`', /tmp/tmpzker3oy6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![0;]; // init\
    \ with 0\n    // Sieve of Eratosthenes\n    let mut sieve = vec![true;]; // init\
    \ with true\n    for i in 2..=n+1 {\n        if sieve[i] {\n            for j\
    \ in 2..=i {\n                sieve[j] = false;\n            }\n            factors.push(i);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: unexpected end of macro invocation\n  --> /tmp/tmpixf6p22b.rs:11:42\n\
    \   |\n11 |     let mut factors: Vec<isize> = vec![0;]; // init with 0\n   | \
    \                                         ^ missing tokens in macro arguments\n\
    \nerror: unexpected end of macro invocation\n  --> /tmp/tmpixf6p22b.rs:13:31\n\
    \   |\n13 |     let mut sieve = vec![true;]; // init with true\n   |         \
    \                      ^ missing tokens in macro arguments\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![];\n    let mut\
    \ i = 1;\n    factors.push(1);\n    factors.push(2);\n    while i < n {\n    \
    \    while n % i == 0 {\n            factors.push(i);\n            n /= i;\n \
    \       }\n        i += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpmn7sn01y.rs:18:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut factor\
    \ = 1;\n\n    while n != 1 {\n        if n % factor == 0 {\n            factors.push(*factor);\n\
    \            n /= factor;\n        } else {\n            factor *= factor;\n \
    \       }\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpjbws0han.rs:16:26\n\
    \   |\n16 |             factors.push(*factor);\n   |                         \
    \ ^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    factorization_impl(n)\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization_impl` in this scope\n\
    \  --> /tmp/tmp68_4ynn_.rs:11:5\n   |\n11 |     factorization_impl(n)\n   |  \
    \   ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n\n  \
    \  let mut product: isize = n;\n\n    for factor in 2..(product as isize / 2)\
    \ {\n        while product % factor == 0 {\n            factors.push(factor);\n\
    \            product /= factor;\n        }\n    }\n\n    factors.push(product\
    \ as isize);\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4]`,\n right: `[2, 2]`', /tmp/tmpg4kg2sk7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    use std::cmp::Ordering;\n\n    let mut factors =\
    \ Vec::new();\n    for i in n.step_by(2) {\n        for mut factor = 1; *factor\
    \ < i; ++factors.push_back(factor));\n    }\n    factors\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpidzk6f7v.rs:18:1\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \                 - this opening brace...\n...\n16 |     }\n   |     - ...matches\
    \ this closing brace\n17 |     factors\n18 | }\n   | ^ unexpected closing delimiter\n\
    \nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpidzk6f7v.rs:14:27\n\
    \   |\n14 |     for i in n.step_by(2) {\n   |                           ^ unclosed\
    \ delimiter\n15 |         for mut factor = 1; *factor < i; ++factors.push_back(factor));\n\
    \   |                                                                     ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    // if n is prime then return one element\n    if\
    \ n % 2 == 1 {\n        return vec![1];\n    }\n\n    // get factors of n\n  \
    \  let mut factors = Vec::new();\n    for i in 2..n / 2 {\n        if n % i ==\
    \ 0 {\n            let count = i as isize;\n            for _ in 0..count {\n\
    \                factors.push(i);\n                factors.push(n / i);\n    \
    \        }\n        }\n    }\n\n    // if n is not prime, then remove prime factors\
    \ from returned factors\n    if n % 2 == 1 {\n        factors.remove(&2);\n  \
    \  }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6f9x5wi9.rs:30:24\n   |\n\
    30 |         factors.remove(&2);\n   |                        ^^ expected `usize`,\
    \ found `&{integer}`\n   |\nhelp: consider removing the borrow\n   |\n30 -   \
    \      factors.remove(&2);\n30 +         factors.remove(2);\n   | \n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 {\n        return vec![1];\n    }\n\n\
    \    let mut ret = vec![];\n    let mut prime_map = HashMap::new();\n\n    //\
    \ prime_factorization of number n - 1\n    // let mut prime_factorization = factorize(n-1);\n\
    \    // for &f in &prime_factorization {\n    //     let num: isize = f * n;\n\
    \    //     ret.push(num);\n    //     prime_map.insert(num, true);\n    // }\n\
    \n    // factorization of number n\n    let mut factorization = factorize(n);\n\
    \    for &f in &factorization {\n        let num: isize = f;\n        ret.push(num);\n\
    \        prime_map.insert(num, true);\n    }\n\n    let mut i = 0;\n    for &(k,\
    \ v) in &prime_map {\n        if k > n {\n            break;\n        }\n\n  \
    \      // set all factors less than n to one\n        while factorization[i] ==\
    \ k {\n            ret[k] += 1;\n            i += 1;\n        }\n\n        //\
    \ set all factors equal to n to one\n        if v {\n            while factorization[i]\
    \ == n {\n                ret[k] += 1;\n                i += 1;\n            }\n\
    \        }\n    }\n    ret.reverse();\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpznwd_rx8.rs:16:25\n   |\n16 |     let mut prime_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpznwd_rx8.rs:42:13\n\
    \   |\n42 |             ret[k] += 1;\n   |             ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpznwd_rx8.rs:49:17\n   |\n49 |            \
    \     ret[k] += 1;\n   |                 ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = Vec::new();\n    let mut s = Vec::new();\n\
    \    let mut m = 1;\n\n    while m <= n {\n        if n % m == 0 {\n         \
    \   f.push(m);\n            s.push_back(m);\n            while n / m > m {\n \
    \               n /= m;\n                s.push(n);\n            }\n        }\
    \ else {\n            m += 1;\n        }\n    }\n    while n > 1 {\n        if\
    \ n % 2 == 0 {\n            n /= 2;\n            s.push(n);\n        } else {\n\
    \            s.push(2);\n            n -= 1;\n        }\n    }\n    let mut g\
    \ = Vec::new();\n    let mut m = 1;\n    for &n in s {\n        g.push(n);\n \
    \       while n / m > m {\n            n /= m;\n            g.push(n);\n     \
    \   }\n    }\n    return g;\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmp8m5ubiwu.rs:18:15\n   |\n18 |             s.push_back(m);\n\
    \   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8m5ubiwu.rs:38:9\n   |\n38 |     for &n in s {\n   |  \
    \       ^^    - this expression has type `Option<isize>`\n   |         |\n   |\
    \         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n\n  \
    \  for i in 2..n {\n        if n % i == 0 {\n            let mut iter = factors.iter();\n\
    \            iter.skip(i);\n            factors.push(*iter.rev());\n        }\n\
    \    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo5uttx5p.rs:16:23\n   |\n\
    16 |             iter.skip(i);\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |             iter.skip(i.try_into().unwrap());\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0614]: type `Rev<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmpo5uttx5p.rs:17:26\n   |\n17 |\
    \             factors.push(*iter.rev());\n   |                          ^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut product\
    \ = n;\n    let mut i = 0;\n    while i < product.abs() {\n        if product\
    \ % i == 0 {\n            factors.push(i);\n            product /= i;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmpl9w3fpr_.rs:15:12\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    if n % 2 == 0\
    \ {\n        factors.push(2);\n    }\n\n    loop {\n        let i = 2;\n     \
    \   while i * i <= n {\n            if n % i == 0 {\n                factors.push(i);\n\
    \                n /= i;\n                break;\n            }\n            i\
    \ += 1;\n        }\n        if n == 1 {\n            factors.push(1);\n      \
    \      break;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpre647_yt.rs:21:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n21 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmpre647_yt.rs:24:13\n\
    \   |\n17 |         let i = 2;\n   |             -\n   |             |\n   | \
    \            first assignment to `i`\n   |             help: consider making this\
    \ binding mutable: `mut i`\n...\n24 |             i += 1;\n   |             ^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![n];\n    let mut i = 2;\n\
    \    while factors[factors.len() - i] <= n {\n        i += 1;\n    }\n    for\
    \ i in 2..(factors.len() - 1) {\n        for j in 0..i {\n            factors[factors.len()\
    \ - i - j] = j;\n        }\n    }\n    return factors.clone();\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp65xqcmsq.rs:18:46\n   |\n\
    18 |             factors[factors.len() - i - j] = j;\n   |             ------------------------------\
    \   ^ expected `isize`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let mut f = 1;\n\
    \    let mut x = 1;\n    while x * x <= n {\n        if n % x == 0 {\n       \
    \     factors.push(x);\n            n = n / x;\n        } else {\n           \
    \ f *= x;\n            x *= x;\n        }\n    }\n    if n > 1 {\n        factors.push(f);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpuhtwx0ll.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n = n /\
    \ x;\n   |             ^^^^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    for i in 2..=n\
    \ {\n        for j in 2..i {\n            if i % j == 0 {\n                break;\n\
    \            }\n        }\n        if j == i {\n            primes.push(i);\n\
    \        }\n    }\n    primes\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmprfi1pmp0.rs:18:12\n\
    \   |\n18 |         if j == i {\n   |            ^ help: a local variable with\
    \ a similar name exists: `i`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    let mut\
    \ cur = n;\n    while cur > 1 {\n        let mut pos = 0;\n        while pos <\
    \ factorization.len() && factorization[pos] == cur {\n            pos += 1;\n\
    \        }\n        if pos == 0 {\n            factorization.push(cur);\n    \
    \    } else {\n            factorization[pos] += 1;\n        }\n        cur /=\
    \ cur;\n    }\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4]`,\n right: `[2, 2]`', /tmp/tmp_aig8bem.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fs = Vec::new();\n    let mut num_facs =\
    \ 1;\n    let mut num: isize = n;\n    while num_facs < num {\n        let mut\
    \ fact = num;\n        while fact % num_facs == 0 {\n            fact /= num_facs;\n\
    \            num_facs++;\n        }\n        fs.push(num_facs);\n        num =\
    \ fact;\n    }\n    debugln!(\"{:?} -> {:?}\", n, fs);\n    fs\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp1z4p7tzh.rs:18:21\n\
    \   |\n18 |             num_facs++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp =\
    \ num_facs; num_facs += 1; tmp };\n   |             +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n\
    18 -             num_facs++;\n18 +             num_facs += 1;\n   | \n\nerror:\
    \ cannot find macro `debugln` in this scope\n  --> /tmp/tmp1z4p7tzh.rs:23:5\n\
    \   |\n23 |     debugln!(\"{:?} -> {:?}\", n, fs);\n   |     ^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n < 2 {\n        return vec![2]; // 2 is the\
    \ first factor\n    }\n\n    let mut prime_factors = vec![2]; // prime factors\
    \ of number n\n\n    loop {\n        if n % prime_factors.last() == 0 {\n    \
    \        prime_factors.push(n % prime_factors.last().clone());\n        }\n  \
    \      if prime_factors.len() == 2 {\n            break;\n        }\n        //\
    \ remove one from prime factors\n        let mut last = prime_factors.last().unwrap();\n\
    \        let mut rest = n / last;\n        for factor in prime_factors.iter().cloned()\
    \ {\n            rest = rest % factor;\n            if rest == 0 {\n         \
    \       prime_factors.pop();\n                break;\n            }\n        }\n\
    \    }\n\n    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `Option<&{integer}>`\n  --> /tmp/tmpo1bf1y1d.rs:18:14\n\
    \   |\n18 |         if n % prime_factors.last() == 0 {\n   |              ^ no\
    \ implementation for `isize % Option<&{integer}>`\n   |\n   = help: the trait\
    \ `Rem<Option<&{integer}>>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]: cannot\
    \ mod `isize` by `Option<&{integer}>`\n  --> /tmp/tmpo1bf1y1d.rs:19:34\n   |\n\
    19 |             prime_factors.push(n % prime_factors.last().clone());\n   | \
    \                                 ^ no implementation for `isize % Option<&{integer}>`\n\
    \   |\n   = help: the trait `Rem<Option<&{integer}>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut i = 1;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            while n % i == 0\
    \ {\n                factors.push(i / i);\n                n /= i;\n         \
    \   }\n            factors.push(i as isize);\n            i /= i;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    factors.push(n as\
    \ isize);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n   \
    \ assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp3ds37v5f.rs:17:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    for factor\
    \ in factorization(n) {\n        let count = factors.iter().position(|&x| x ==\
    \ factor).unwrap_or(0);\n        factors.push(count + 1);\n    }\n\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpj7cyjc_d.rs:13:19\n   |\n13 |     for factor in factorization(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj7cyjc_d.rs:18:5\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n18 |     factors\n   |     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut product =\
    \ 1;\n\n    for i in 1..=n / 2 {\n        let j = (n + i) / i;\n        if j ==\
    \ 1 {\n            res.push(i);\n        } else {\n            let mut j = j;\n\
    \            while (j > 1) {\n                if product % j == 0 {\n        \
    \            res.push(j);\n                    break;\n                }\n   \
    \             product *= j;\n                j -= 1;\n            }\n        }\n\
    \    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmp0gzh_f3n.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n\n  \
    \  for i in 2..n {\n        if n % i == 0 {\n            factors.push(i);\n  \
    \          factors.push(n/i).into();\n            factors.push(i).into();\n  \
    \      }\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpsvq72sjn.rs:16:31\n\
    \   |\n16 |             factors.push(n/i).into();\n   |             ------------------^^^^--\n\
    \   |             |                 |\n   |             |                 cannot\
    \ infer type for type parameter `T` declared on the trait `Into`\n   |       \
    \      this method call resolves to `T`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    let mut factors\
    \ = Vec::new();\n\n    let mut f = 2;\n    while f * f <= n {\n        while n\
    \ % f == 0 {\n            primes.push(f);\n            n /= f;\n        }\n  \
    \      factors.push(f);\n        f += 1;\n    }\n    factors.push(n / f);\n  \
    \  factors.push(2);\n    primes.push(2);\n    primes.push(1);\n    for f in factors\
    \ {\n        primes.push(f as isize);\n    }\n    primes\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpplszzbpo.rs:18:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= f;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut factor\
    \ = 1;\n\n    while n > 0 {\n        while n % factor == 0 {\n            factors.push(factor);\n\
    \            n /= factor;\n        }\n        factors.push(factor);\n        factor\
    \ *= factor;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpi4ao_rtn.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    // calculate\
    \ prime factors of n\n    let mut i = 2;\n    while i <= n {\n        if n % i\
    \ == 0 {\n            factors.push(i);\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n\n    if n != 1 {\n        factors.push(n);\n\
    \    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsaboh0fm.rs:18:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n18 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    let mut\
    \ primes = Vec::new();\n\n    // Generating all primes up to sqrt(n)\n    for\
    \ i in 2..n {\n        if n % i == 0 {\n            factorization.push(i);\n \
    \           primes.push(i);\n        }\n    }\n\n    // Checking whether any factor\
    \ of n has already been found\n    // If it has, we remove it from primes vector\n\
    \    if factorization.len() == n {\n        for i in 2..n {\n            if factorization.contains(i)\
    \ {\n                primes.remove(i);\n            }\n        }\n    }\n\n  \
    \  primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4l0469rv.rs:24:31\n   |\n\
    24 |     if factorization.len() == n {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |     if factorization.len()\
    \ == n.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4l0469rv.rs:26:39\n   |\n26 |\
    \             if factorization.contains(i) {\n   |                           \
    \            ^\n   |                                       |\n   |           \
    \                            expected `&isize`, found `isize`\n   |          \
    \                             help: consider borrowing here: `&i`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4l0469rv.rs:27:31\n   |\n27 |              \
    \   primes.remove(i);\n   |                               ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |                 primes.remove(i.try_into().unwrap());\n\
    \   |                                ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut m = 1;\n\
    \    while m <= n {\n        while n % m == 0 {\n            factors.push(m);\n\
    \            n /= m;\n        }\n        m += 1;\n    }\n    factors.push(1);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmposjrvymk.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= m;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    // Use vector to save factorization\n    let mut\
    \ factorization: Vec<isize> = vec![1isize];\n    let mut max_factor: isize = n;\n\
    \n    // Calculate prime factorization of n and calculate prime factors of n\n\
    \    // Note: when calculating prime factorization of number greater than 1, we\
    \ consider only prime factors\n    // that divide n evenly (no composite factors)\n\
    \    for i in 2..n/2 {\n        if n % i == 0 {\n            factorization.push(i);\n\
    \            max_factor = n as isize;\n        }\n    }\n\n    // If factorization\
    \ is empty, return 1\n    if factorization.is_empty() {\n        return vec![1];\n\
    \    }\n\n    // Calculate prime factorization of max_factor\n    for i in 2..max_factor\
    \ {\n        if n % i == 0 {\n            factorization.push(i);\n        }\n\
    \    }\n\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpi5qrf72f.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![0; n / 2 + 1];\n    for factor\
    \ in &mut factors[..] {\n        if n % factor == 0 {\n            *factor = factor;\n\
    \            for _ in 0..n / factor {\n                factors[factor] += 1;\n\
    \            }\n            return factors;\n        }\n    }\n    factors\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3b0bxqac.rs:11:31\n   |\n\
    11 |     let mut factors = vec![0; n / 2 + 1];\n   |                         \
    \      ^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factors = vec![0; (n / 2 + 1).try_into().unwrap()];\n   |   \
    \                            +         +++++++++++++++++++++\n\nerror[E0277]:\
    \ cannot mod `isize` by `&mut {integer}`\n  --> /tmp/tmp3b0bxqac.rs:13:14\n  \
    \ |\n13 |         if n % factor == 0 {\n   |              ^ no implementation\
    \ for `isize % &mut {integer}`\n   |\n   = help: the trait `Rem<&mut {integer}>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3b0bxqac.rs:14:23\n\
    \   |\n14 |             *factor = factor;\n   |             -------   ^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n14 |             *factor = *factor;\n   |                       +\n\nerror[E0277]:\
    \ cannot divide `isize` by `&mut {integer}`\n  --> /tmp/tmp3b0bxqac.rs:15:27\n\
    \   |\n15 |             for _ in 0..n / factor {\n   |                       \
    \    ^ no implementation for `isize / &mut {integer}`\n   |\n   = help: the trait\
    \ `Div<&mut {integer}>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = vec![Vec::new(); n];\n \
    \   for factor in factorization(&n) {\n        factorization.push(factor);\n \
    \   }\n    factorization\n}\n\nfn main() {\n    let candidate = factorize;\n \
    \   assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp376sh_qb.rs:11:46\n   |\n\
    11 |     let mut factorization = vec![Vec::new(); n];\n   |                  \
    \                            ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut factorization = vec![Vec::new(); n.try_into().unwrap()];\n\
    \   |                                               ++++++++++++++++++++\n\nerror[E0618]:\
    \ expected function, found `Vec<Vec<_>>`\n  --> /tmp/tmp376sh_qb.rs:12:19\n  \
    \ |\n11 |     let mut factorization = vec![Vec::new(); n];\n   |         -----------------\
    \ `factorization` has type `Vec<Vec<_>>`\n12 |     for factor in factorization(&n)\
    \ {\n   |                   ^^^^^^^^^^^^^----\n   |                   |\n   |\
    \                   call expression requires function\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp376sh_qb.rs:15:5\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n15 |     factorization\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<_>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0618.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut product\
    \ = n;\n    let mut is_prime = true;\n    while product != 1 {\n        for factor\
    \ in factors {\n            if product % factor == 0 {\n                factors.push(factor);\n\
    \                is_prime = false;\n            }\n        }\n        if is_prime\
    \ {\n            factors.push(1);\n        }\n        product /= factors[0];\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `factors`\n   --> /tmp/tmp4t3fw6u9.rs:15:23\n\
    \    |\n11  |     let mut factors = Vec::new();\n    |         ----------- move\
    \ occurs because `factors` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n15  |         for factor in factors {\n    |            \
    \           ^^^^^^^ `factors` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `factors`\nhelp: consider iterating over a\
    \ slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n  \
    \  |\n15  |         for factor in &factors {\n    |                       +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut a = Vec::with_capacity(n as usize);\n  \
    \  let mut a = n.clone() as usize;\n    for i in 2..=a {\n        if a % i ==\
    \ 0 {\n            let mut counter = 1;\n            while a % i == 0 {\n    \
    \            a /= i;\n                counter += 1;\n            }\n         \
    \   a.push(counter);\n        }\n    }\n    a\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpyqcyx3cg.rs:20:15\n   |\n20 |             a.push(counter);\n\
    \   |               ^^^^ method not found in `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyqcyx3cg.rs:23:5\n   |\n10 | fn factorize(n: isize) ->\
    \ Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n23 |     a\n   |     ^ expected struct `Vec`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    for i in 2..=n\
    \ / 2 {\n        if n % i == 0 {\n            factors.push(i);\n\n           \
    \ for j in i * 2..=n / i {\n                if j % i == 0 {\n                \
    \    factors.push(j);\n                }\n            }\n        }\n    }\n\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmpntd_o8p0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![];\n    for i in 2..=n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            for j in i*2..=n\
    \ {\n                if j % i == 0 {\n                    factors.push(j);\n \
    \               }\n            }\n        }\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 4]`,\n right: `[2, 2]`', /tmp/tmpj5c0ntf2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![n];\n    let mut factor =\
    \ 2;\n\n    while n != 1 {\n        while n % factor != 0 {\n            factor\
    \ *= 2;\n        }\n        factors.push(factor);\n        n /= factor;\n    \
    \    factor *= 2;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpv8wop34y.rs:19:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n19 |         n /= factor;\n\
    \   |         ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    let mut\
    \ prime_factorization = Vec::new();\n    factorization.push(n);\n\n    while factorization.len()\
    \ > 0 {\n        let mut index = factorization.len();\n        while index > 0\
    \ {\n            let mut candidate = factorization.last();\n            while\
    \ factorization[index] % candidate == 0 {\n                candidate = factorization[index]\
    \ % candidate;\n                index -= 1;\n            }\n            factorization.push(candidate);\n\
    \        }\n        factorization.pop();\n\n        if factorization.len() ==\
    \ 0 {\n            prime_factorization.push(1);\n        } else {\n          \
    \  let mut factor = 1;\n            let mut prime_factor = 1;\n            for\
    \ i in factorization.iter() {\n                factor += 1;\n                while\
    \ factor * prime_factor < i {\n                    prime_factor += 1;\n      \
    \          }\n            }\n            prime_factorization.push(prime_factor);\n\
    \        }\n    }\n    prime_factorization\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `Option<&isize>`\n  --> /tmp/tmpiqab_qbp.rs:19:40\n\
    \   |\n19 |             while factorization[index] % candidate == 0 {\n   |  \
    \                                      ^ no implementation for `isize % Option<&isize>`\n\
    \   |\n   = help: the trait `Rem<Option<&isize>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]:\
    \ cannot mod `isize` by `Option<&isize>`\n  --> /tmp/tmpiqab_qbp.rs:20:50\n  \
    \ |\n20 |                 candidate = factorization[index] % candidate;\n   |\
    \                                                  ^ no implementation for `isize\
    \ % Option<&isize>`\n   |\n   = help: the trait `Rem<Option<&isize>>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiqab_qbp.rs:23:32\n\
    \   |\n23 |             factorization.push(candidate);\n   |                 \
    \               ^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0277]:\
    \ can't compare `isize` with `&isize`\n  --> /tmp/tmpiqab_qbp.rs:34:45\n   |\n\
    34 |                 while factor * prime_factor < i {\n   |                 \
    \                            ^ no implementation for `isize < &isize` and `isize\
    \ > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not implemented\
    \ for `isize`\n   = help: the followi"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![0; n];\n    for\
    \ i in (0..n as usize).rev() {\n        let p = i / n;\n        if p < n % i {\n\
    \            *factors = p;\n            break;\n        }\n    }\n\n    if *factors\
    \ == 0 {\n        vec![n]\n    } else {\n        factors\n    }\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwonfh7ur.rs:11:43\n   |\n\
    11 |     let mut factors: Vec<isize> = vec![0; n];\n   |                     \
    \                      ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n11 |     let mut factors: Vec<isize> = vec![0; n.try_into().unwrap()];\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwonfh7ur.rs:13:21\n   |\n13 |         let p\
    \ = i / n;\n   |                     ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot divide `usize` by `isize`\n  --> /tmp/tmpwonfh7ur.rs:13:19\n   |\n13\
    \ |         let p = i / n;\n   |                   ^ no implementation for `usize\
    \ / isize`\n   |\n   = help: the trait `Div<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Div<Rhs>`:\n          \
    \   <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwonfh7ur.rs:14:20\n   |\n14 |         if p <\
    \ n % i {\n   |                    ^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwonfh7ur.rs:14:16\n   |\n14 |         if p <\
    \ n % i {\n   |                ^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n14 |         if p < (n % i).try_into().unwrap() {\n   |         \
    \       +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwonfh7ur.rs:15:24\n\
    \   |\n15 |             *factors = p;\n   |             --------   ^ expected\
    \ slice `[isize]`, found `usize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n\nerror[E0277]: cannot mod `isize` by `usize`\n\
    \  --> /tmp/tmpwonfh7ur.rs:14:1"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for factor in\
    \ factorization(n) {\n        factors.push((factor, 1));\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpp7jo_igg.rs:12:19\n   |\n12 |     for factor in factorization(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp7jo_igg.rs:15:5\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |                           ---------- expected `Vec<isize>`\
    \ because of return type\n...\n15 |     factors\n   |     ^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<(_, {integer})>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for i in 1..=n\
    \ {\n        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp9qpqemog.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fr = Vec::new();\n    let mut fp = 1;\n\
    \    for i in 2..n {\n        while fp % i == 0 {\n            fp.inc();\n   \
    \     }\n        if fp > i {\n            fr.push(i);\n        }\n    }\n    fr\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `inc` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpdou42apr.rs:15:16\n   |\n15 |             fp.inc();\n \
    \  |                ^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<_> = Vec::new();\n    factors.reserve(n);\n\
    \    factors.push(2);\n    let mut f1 = n; // First number with smallest factor\n\
    \    let mut f2 = n; // Second number with smallest factor\n    while f1 > 0 {\n\
    \        if f1 % f1 == 0 {\n            // If the current number is the smallest\
    \ factor, add it\n            factors.push(f1);\n            f1 /= f1;\n     \
    \   } else {\n            // If the current number is not the smallest factor,\
    \ find smallest number with smaller factor\n            f2 = f1;\n           \
    \ f1 /= f2;\n        }\n    }\n    // Add the remaining factor to the end\n  \
    \  factors.push(f1);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnx59lavb.rs:12:21\n   |\n\
    12 |     factors.reserve(n);\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n12 |     factors.reserve(n.try_into().unwrap());\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut factors =\
    \ Vec::new();\n    let mut m = n;\n    let mut m = m / 2;\n\n    while m > 0 {\n\
    \        if n % m == 0 {\n            factors.push(m);\n            m /= 2;\n\
    \        }\n        else {\n            m = m / 2;\n        }\n    }\n\n    for\
    \ i in 0..factors.len() {\n        res.push(factors[i]);\n    }\n\n    return\
    \ res;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpz6h9w2yp.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![];\n    factorize_recursive(n,\
    \ &mut factors);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize_recursive` in this scope\n\
    \  --> /tmp/tmpo99cw904.rs:12:5\n   |\n12 |     factorize_recursive(n, &mut factors);\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    for i in\
    \ 2..n {\n        if n % i == 0 {\n            factorization.push(i);\n      \
    \      while n % i == 0 {\n                n /= i;\n            }\n        }\n\
    \    }\n    if n != 1 {\n        factorization.push(n);\n    }\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpg7892zqi.rs:16:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = Vec::new();\n\n    if n == 1 {\n   \
    \     vec![1]\n    } else if n % 2 == 1 {\n        f.push(n/2);\n        f.push(2)\n\
    \    } else {\n        for d in 3..n-1 {\n            if n % d == 0 {\n      \
    \          f.push(d + (n / d));\n                break;\n            }\n     \
    \   }\n    }\n    f\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1d4m75wu.rs:14:9\n   |\n\
    13 | /     if n == 1 {\n14 | |         vec![1]\n   | |         ^^^^^^^ expected\
    \ `()`, found struct `Vec`\n15 | |     } else if n % 2 == 1 {\n16 | |        \
    \ f.push(n/2);\n...  |\n24 | |         }\n25 | |     }\n   | |_____- expected\
    \ this to be `()`\n   |\n   = note: expected unit type `()`\n                \
    \ found struct `Vec<{integer}>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp:\
    \ consider using a semicolon here\n   |\n25 |     };\n   |      +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization: Vec<isize> = Vec::new();\n\
    \    for i in 2..=n/2 {\n        if n % i == 0 {\n            for _ in 1..=factorization\n\
    \                .iter_mut()\n                .find(|&v| v == i)\n           \
    \ {\n                *v += 1;\n            }\n        }\n    }\n    factorization\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `v` in this scope\n  --> /tmp/tmplmypg34o.rs:18:18\n\
    \   |\n18 |                 *v += 1;\n   |                  ^ help: a local variable\
    \ with a similar name exists: `i`\n\nerror[E0277]: can't compare `&mut isize`\
    \ with `isize`\n  --> /tmp/tmplmypg34o.rs:16:30\n   |\n16 |                 .find(|&v|\
    \ v == i)\n   |                              ^^ no implementation for `&mut isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&mut isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplmypg34o.rs:14:26\n\
    \   |\n14 |               for _ in 1..=factorization\n   |  __________________________^\n\
    15 | |                 .iter_mut()\n16 | |                 .find(|&v| v == i)\n\
    \   | |__________________________________^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<&mut\
    \ isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f: Vec<isize> = Vec::new();\n    let mut\
    \ counter = 0;\n    let mut f2 = &n;\n\n    while f2.is_prime() {\n        let\
    \ mut f3: isize = f2.next_factor();\n        while !f3.is_prime() {\n        \
    \    counter++;\n            f3 += 1;\n        }\n        counter;\n        f.push(counter);\n\
    \        counter += 1;\n        f2 = &f3;\n    }\n    f\n}\n\nfn main() {\n  \
    \  let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpp82du6tr.rs:18:20\n\
    \   |\n18 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    18 -             counter++;\n18 +             counter += 1;\n   | \n\nerror[E0599]:\
    \ no method named `is_prime` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpp82du6tr.rs:15:14\n   |\n15 |     while f2.is_prime() {\n   | \
    \             ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method\
    \ named `next_factor` found for reference `&isize` in the current scope\n  -->\
    \ /tmp/tmpp82du6tr.rs:16:32\n   |\n16 |         let mut f3: isize = f2.next_factor();\n\
    \   |                                ^^^^^^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `is_prime` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpp82du6tr.rs:17:19\n   |\n17 |         while !f3.is_prime()\
    \ {\n   |                   ^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![0; factorization(n)];\n  \
    \  for factor in factorization(n) {\n        if n % factor == 0 {\n          \
    \  result[factor] += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmpqpffbqli.rs:11:30\n   |\n11 |     let mut result = vec![0; factorization(n)];\n\
    \   |                              ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `factorization` in this scope\n  --> /tmp/tmpqpffbqli.rs:12:19\n\
    \   |\n12 |     for factor in factorization(n) {\n   |                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut ans = Vec::new();\n    let mut fr = 1;\n\
    \    for &r in factors(n) {\n        if r != n / fr {\n            ans.push(r);\n\
    \            fr = r + 1;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpomo6wg9w.rs:13:15\n\
    \   |\n13 |     for &r in factors(n) {\n   |               ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut f = Vec::with_capacity(2);\n    for i in\
    \ 2..=n / 2 {\n        if n % i == 0 {\n            f.push(i);\n        }\n  \
    \  }\n    f\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2]`', /tmp/tmph4dh4r08.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    let mut factors\
    \ = Vec::new();\n    fn check_factor(\n        factors: &mut Vec<isize>,\n   \
    \     factor: isize,\n        mut i: isize,\n    ) {\n        if i > n {\n   \
    \         return;\n        }\n        if factors.len() == i {\n            factors.push(factor);\n\
    \            return;\n        }\n        for j in factors.iter_mut() {\n     \
    \       if j == factor {\n                *j += 1;\n                return;\n\
    \            }\n        }\n        factors.push(factor);\n    }\n\n    for i in\
    \ 2..=n / 2 {\n        if n % i == 0 {\n            let mut factor = 2;\n    \
    \        while i * factor <= n {\n                check_factor(&mut factors, factor,\
    \ i);\n                factor *= 2;\n            }\n        }\n    }\n    for\
    \ i in 2..=n / 2 {\n        if n % i == 0 {\n            let mut factor = 3;\n\
    \            while i * factor <= n {\n                check_factor(&mut factors,\
    \ factor, i);\n                factor *= 3;\n            }\n        }\n    }\n\
    \    for i in 2..=n / 2 {\n        if n % i == 0 {\n            let mut factor\
    \ = 5;\n            while i * factor <= n {\n                check_factor(&mut\
    \ factors, factor, i);\n                factor *= 5;\n            }\n        }\n\
    \    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            let mut\
    \ factor = 7;\n            while i * factor <= n {\n                check_factor(&mut\
    \ factors, factor, i);\n                factor *= 7;\n            }\n        }\n\
    \    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            let mut\
    \ factor = 11;\n            while i * factor <= n {\n                check_factor(&mut\
    \ factors, factor, i);\n                factor *= 11;\n            }\n       \
    \ }\n    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            let\
    \ mut factor = 13;\n            while i * factor <= n {\n                check_factor(&mut\
    \ factors, factor, i);\n                factor *= 13;\n            }\n       \
    \ }\n    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            let\
    \ mut factor = 17;\n            while i * factor <= n {\n                check_factor(&mut\
    \ factors, factor, i);\n                factor *= 17;\n            }\n       \
    \ }\n    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            let\
    \ mut factor = 31;\n            while i * factor <= n {\n                check_factor(&mut\
    \ factors, factor, i);\n                factor *= 31;\n            }\n       \
    \ }\n    }\n    for i in 2..=n / 2 {\n        if n % \n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpeozyskfs.rs:120:3\n\
    \    |\n10  | fn factorize(n: isize) -> Vec<isize> {\n    |                  \
    \                    - unclosed delimiter\n...\n106 |     for i in 2..=n / 2 {\n\
    \    |                        - this delimiter might not be properly closed...\n\
    107 |         if n % \n108 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n120 | }\n    |   ^\n\nerror: expected expression, found `}`\n\
    \   --> /tmp/tmpeozyskfs.rs:108:1\n    |\n108 | }\n    | ^ expected expression\n\
    \nerror[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpeozyskfs.rs:18:16\n\
    \   |\n18 |         if i > n {\n   |                ^\n   |\n   = help: use the\
    \ `|| { ... }` closure form instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeozyskfs.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeozyskfs.rs:21:29\n   |\n21 |         if factors.len()\
    \ == i {\n   |                             ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if factors.len() == i.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0277]: can't\
    \ compare `&mut isize` with `isize`\n  --> /tmp/tmpeozyskfs.rs:26:18\n   |\n26\
    \ |             if j == factor {\n   |                  ^^ no implementation for\
    \ `&mut isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&mut isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors ha"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut product_of_all_factors\
    \ = 1;\n    loop {\n        let factor = 1;\n        while n % factor == 0 {\n\
    \            factor *= factor;\n            n /= factor;\n        }\n        factors.push(factor);\n\
    \        product_of_all_factors *= factor;\n        if n == 1 {\n            break;\n\
    \        }\n    }\n    factors.push(product_of_all_factors);\n    factors\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `factor`\n  -->\
    \ /tmp/tmpfwcz0jqe.rs:16:13\n   |\n14 |         let factor = 1;\n   |        \
    \     ------\n   |             |\n   |             first assignment to `factor`\n\
    \   |             help: consider making this binding mutable: `mut factor`\n15\
    \ |         while n % factor == 0 {\n16 |             factor *= factor;\n   |\
    \             ^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpfwcz0jqe.rs:17:13\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n /= factor;\n \
    \  |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![1isize];\n    fn next() ->\
    \ Vec<isize> {\n        let mut res = result;\n        for i in res {\n      \
    \      if n % i == 0 {\n                res.push(i as isize);\n            }\n\
    \        }\n        res\n    }\n    while result.len() > 1 {\n        for i in\
    \ 1..=result.len() {\n            if result[i] > 1 {\n                break;\n\
    \            }\n        }\n        result = result[i..].clone();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpjcxj_v3h.rs:13:23\n\
    \   |\n13 |         let mut res = result;\n   |                       ^^^^^^\n\
    \   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't\
    \ capture dynamic environment in a fn item\n  --> /tmp/tmpjcxj_v3h.rs:15:16\n\
    \   |\n15 |             if n % i == 0 {\n   |                ^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpjcxj_v3h.rs:27:25\n   |\n27 |         result\
    \ = result[i..].clone();\n   |                         ^ help: a local variable\
    \ with a similar name exists: `n`\n\nerror[E0599]: no method named `clone` found\
    \ for slice `[isize]` in the current scope\n  --> /tmp/tmpjcxj_v3h.rs:27:30\n\
    \   |\n27 |         result = result[i..].clone();\n   |                      \
    \        ^^^^^ method not found in `[isize]`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0434, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    use std::cmp::Ordering::*;\n    let mut primes =\
    \ vec![];\n    for i in 2..n {\n        if n % i == 0 {\n            primes.push(i);\n\
    \            if n / i > i {\n                primes.push(n/i);\n            }\n\
    \        }\n    }\n    let mut factors = vec![];\n    for i in primes.iter() {\n\
    \        while n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        }\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n    let\
    \ candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering::*`\n  --> /tmp/tmpp3_zcgig.rs:11:9\n\
    \   |\n11 |     use std::cmp::Ordering::*;\n   |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp3_zcgig.rs:28:18\n   |\n28 |     factors.push(1);\n  \
    \ |                  ^\n   |                  |\n   |                  expected\
    \ `&isize`, found integer\n   |                  help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3_zcgig.rs:29:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n29 |     factors\n   |  \
    \   ^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for i in 2..=n\
    \ {\n        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        }\n    }\n    if n != 1 {\n        factors.push(n as isize);\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp94un18hu.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut prime_numbers_vec = vec![0; n];\n    for\
    \ i in 1..n {\n        prime_numbers_vec[i] = 1;\n    }\n    let mut prime_numbers_vec2\
    \ = vec![0; n];\n    let mut i = 2;\n    let mut j = 2;\n    while i < n {\n \
    \       while j < n && prime_numbers_vec[i] == j {\n            prime_numbers_vec2[i]\
    \ += 1;\n            j += 1;\n        }\n        i += 1;\n    }\n    prime_numbers_vec2.iter().map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbwf4rb1k.rs:11:41\n   |\n\
    11 |     let mut prime_numbers_vec = vec![0; n];\n   |                       \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut prime_numbers_vec = vec![0; n.try_into().unwrap()];\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpbwf4rb1k.rs:13:9\n\
    \   |\n13 |         prime_numbers_vec[i] = 1;\n   |         ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbwf4rb1k.rs:15:42\n   |\n15 |     let mut prime_numbers_vec2\
    \ = vec![0; n];\n   |                                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |     let mut prime_numbers_vec2\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \       ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpbwf4rb1k.rs:19:24\n   |\n19 |         while\
    \ j < n && prime_numbers_vec[i] == j {\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpbwf4rb1k.rs:20:13\n\
    \   |\n20 |             prime_numbers_vec2[i] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    if n == 1 {\n\
    \        return factors;\n    }\n    if n % 2 == 0 {\n        factors.push(2);\n\
    \        n = n / 2;\n    }\n    for i in 2..=n / 2 {\n        while n % i == 0\
    \ {\n            factors.push(i);\n            n /= i;\n        }\n    }\n   \
    \ factors.push(1);\n    return factors;\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd286y4cw.rs:17:9\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |         n = n / 2;\n\
    \   |         ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmpd286y4cw.rs:22:13\n   |\n10\
    \ | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider\
    \ making this binding mutable: `mut n`\n...\n22 |             n /= i;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut f1 =\
    \ 1;\n    let mut f2 = 2;\n    while f2 <= n {\n        if n % f2 == 0 {\n   \
    \         factors.push(f2);\n            while f1 * f2 <= n {\n              \
    \  f1 += 1;\n                f2 += 1;\n            }\n        }\n        f2 +=\
    \ 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n \
    \   assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[2, 2]`', /tmp/tmp40_ngvnw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n\n    for i in 2..n {\n\
    \        while n % i == 0 {\n            ret.push(i);\n            n /= i;\n \
    \       }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2l8qp9jw.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![];\n    let mut\
    \ max_factor = 0;\n\n    for i in 2..n {\n        while n % i == 0 {\n       \
    \     factors.push(i);\n            n /= i;\n        }\n        max_factor = if\
    \ n > max_factor { n } else { max_factor };\n    }\n\n    if n > 1 {\n       \
    \ factors.push(max_factor);\n    }\n\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpx1f_885i.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n\n    for i in 2..n\
    \ {\n        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        }\n    }\n\n    factors.push(n as usize);\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuznrsefa.rs:20:18\n   |\n\
    20 |     factors.push(n as usize);\n   |                  ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     factors.push((n\
    \ as usize).try_into().unwrap());\n   |                  +          +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = vec![1usize; n];\n\n    for i in 2..n+1\
    \ {\n        if res[i] == 0 {\n            for j in 2..i {\n                res[i]\
    \ *= j;\n                if res[i] > n {\n                    return vec![];\n\
    \                }\n            }\n        }\n    }\n\n    return res.iter().cloned().collect();\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpusxxiwya.rs:11:32\n   |\n\
    11 |     let mut res = vec![1usize; n];\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ res = vec![1usize; n.try_into().unwrap()];\n   |                           \
    \      ++++++++++++++++++++\n\nerror[E0277]: the type `[usize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpusxxiwya.rs:14:12\n   |\n14 |         if res[i] ==\
    \ 0 {\n   |            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[usize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<usize>`\n\
    \nerror[E0277]: the type `[usize]` cannot be indexed by `isize`\n  --> /tmp/tmpusxxiwya.rs:16:17\n\
    \   |\n16 |                 res[i] *= j;\n   |                 ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<usize>`\n\nerror[E0277]: the type `[usize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpusxxiwya.rs:17:20\n   |\n17 |            \
    \     if res[i] > n {\n   |                    ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<usize>`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `usize`\n    --> /tmp/tmpusxxiwya.rs:24:32\n\
    \     |\n24   |     return res.iter().cloned().collect();\n     |            \
    \                    ^^^^^^^ value of type `Vec<isize>` cannot be bui"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n < 2 {\n        return vec![];\n    }\n\n  \
    \  // Step 1: Find all prime factors\n    let mut factors = vec![];\n    let mut\
    \ limit = n;\n    while limit != 1 {\n        if n % limit == 0 {\n          \
    \  factors.push(limit);\n            n /= limit;\n        } else {\n         \
    \   limit /= 2;\n        }\n    }\n\n    if n != 1 {\n        factors.push(n);\n\
    \    }\n\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppefuh2ex.rs:21:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n21 |             n /= limit;\n\
    \   |             ^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    let mut factors\
    \ = HashSet::new();\n    primes.push(n);\n    factors.insert(n);\n    while primes.len()\
    \ > 0 {\n        let n = primes.iter().next();\n        for f in 2..(n * n) {\n\
    \            if factors.contains(f) {\n                primes.push(f);\n     \
    \           factors.insert(f);\n            }\n        }\n    }\n    factors\n\
    \        .iter()\n        .filter(|&x| x.is_prime())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp73ov5n41.rs:12:23\n   |\n12 |     let mut factors = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0369]:\
    \ cannot multiply `Option<&isize>` by `Option<&isize>`\n  --> /tmp/tmp73ov5n41.rs:17:24\n\
    \   |\n17 |         for f in 2..(n * n) {\n   |                      - ^ - Option<&isize>\n\
    \   |                      |\n   |                      Option<&isize>\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0433.\nFor more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes = vec![2i32];\n    let mut factors\
    \ = vec![1i32];\n    let mut prime_factor_cache: Vec<Vec<isize>> = vec![vec![2i32]];\n\
    \n    while n >= 1 {\n        if prime_cache[n]\n            .iter()\n       \
    \     .any(|&prime| n % prime == 0)\n        {\n            primes[n] *= n;\n\
    \            factors[n] = 1;\n        } else {\n            let mut prime_factors\
    \ = prime_factor_cache[n].clone();\n            prime_factor_cache[n] = factors;\n\
    \            factors.clear();\n            for prime in primes.iter() {\n    \
    \            while n % prime == 0 {\n                    prime_factors.push(prime);\n\
    \                    factors.push(factors.len());\n                    n /= prime;\n\
    \                }\n            }\n            factors.extend(prime_factors);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `prime_cache` in this scope\n  --> /tmp/tmpfmjni926.rs:16:12\n\
    \   |\n16 |         if prime_cache[n]\n   |            ^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmjni926.rs:13:61\n\
    \   |\n13 |     let mut prime_factor_cache: Vec<Vec<isize>> = vec![vec![2i32]];\n\
    \   |                                                             ^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: change the type of the numeric literal from\
    \ `i32` to `isize`\n   |\n13 |     let mut prime_factor_cache: Vec<Vec<isize>>\
    \ = vec![vec![2isize]];\n   |                                                \
    \              ~~~~~\n\nerror[E0277]: the type `[i32]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpfmjni926.rs:20:13\n   |\n20 |             primes[n] *= n;\n   |\
    \             ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[i32]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<i32>`\n\
    \nerror[E0277]: the type `[i32]` cannot be indexed by `isize`\n  --> /tmp/tmpfmjni926.rs:21:13\n\
    \   |\n21 |             factors[n] = 1;\n   |             ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<i32>`\n\nerror[E0277]: the type `[Vec<isize>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpfmjni926.rs:23:37\n   |\n23 |         \
    \    let mut prime_factors = prime_factor_cache[n].clone();\n   |            \
    \                         ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<isize>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the imp"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut max_factor\
    \ = n;\n    for i in 2..=max_factor {\n        if n % i == 0 {\n            while\
    \ n % i == 0 {\n                factors.push(i);\n                n /= i;\n  \
    \          }\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n   \
    \ }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmps4rgdo3u.rs:12:9\n\
    \   |\n12 |     let mut max_factor = n;\n   |         ----^^^^^^^^^^\n   |   \
    \      |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `n`\n  -->\
    \ /tmp/tmps4rgdo3u.rs:17:17\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |              - help: consider making this binding mutable: `mut n`\n...\n\
    17 |                 n /= i;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut p = n;\n\
    \    while p.is_prime() {\n        factors.push(p);\n        p /= 2;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp4axbhj_i.rs:13:13\n   |\n13 |     while p.is_prime()\
    \ {\n   |             ^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![];\n    for factor\
    \ in 1..=n {\n        if n % factor == 0 {\n            factors.push(factor);\n\
    \            n /= factor;\n        } else {\n            factors.push(1);\n  \
    \      }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpflt7gi2c.rs:15:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n15 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut p = 2i32 + 1;\n    let mut factors: Vec<isize>\
    \ = Vec::new();\n    while n > p {\n        if n % p == 0 {\n            factors.push(p\
    \ as isize);\n            n /= p;\n        } else {\n            p *= 2;\n   \
    \     }\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc3thjtm.rs:13:15\n   |\n\
    13 |     while n > p {\n   |               ^ expected `isize`, found `i32`\n \
    \  |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |     while n > p.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplc3thjtm.rs:14:16\n\
    \   |\n14 |         if n % p == 0 {\n   |                ^ expected `isize`, found\
    \ `i32`\n\nerror[E0277]: cannot mod `isize` by `i32`\n  --> /tmp/tmplc3thjtm.rs:14:14\n\
    \   |\n14 |         if n % p == 0 {\n   |              ^ no implementation for\
    \ `isize % i32`\n   |\n   = help: the trait `Rem<i32>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplc3thjtm.rs:16:18\n\
    \   |\n16 |             n /= p;\n   |                  ^ expected `isize`, found\
    \ `i32`\n\nerror[E0277]: cannot divide-assign `isize` by `i32`\n  --> /tmp/tmplc3thjtm.rs:16:15\n\
    \   |\n16 |             n /= p;\n   |               ^^ no implementation for `isize\
    \ /= i32`\n   |\n   = help: the trait `DivAssign<i32>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n%2 == 0 { vec![2]*n}\n    else {\n        let\
    \ mut factors = Vec::new();\n        for factor in 2..n/2 {\n            if n\
    \ % factor == 0 {\n                factors.push(factor);\n                n /=\
    \ factor;\n            } else {\n                break;\n            }\n     \
    \   }\n        factors.push(n);\n        factors\n    }\n}\n\nfn main() {\n  \
    \  let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot multiply `Vec<{integer}>` by `isize`\n  --> /tmp/tmpjamv77rw.rs:11:26\n\
    \   |\n11 |     if n%2 == 0 { vec![2]*n}\n   |                   -------^- isize\n\
    \   |                   |\n   |                   Vec<{integer}>\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    for _ in 0..n\
    \ {\n        let mut i = 1;\n        while i * i < n {\n            i += 1;\n\
    \        }\n        factors.push(i);\n    }\n    factors\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2]`', /tmp/tmprnipdss5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 2..=n\
    \ {\n        if n % i == 0 {\n            while n % i == 0 {\n               \
    \ result.push(i);\n                n /= i;\n            }\n        }\n    }\n\
    \    if n > 1 {\n        result.push(n);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpldckdkc2.rs:16:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |                 n /=\
    \ i;\n   |                 ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut primes_found: Vec<isize> = Vec::new();\n    let mut p = 26;\n\n    while\
    \ p < n {\n        primes_found.push(p);\n        let mut is_prime = true;\n \
    \       let mut m = p * p;\n        while m <= n {\n            if n % m == 0\
    \ {\n                is_prime = false;\n                break;\n            }\n\
    \            m += p;\n        }\n        if is_prime {\n            factors.push(p);\n\
    \        }\n        p += 1;\n    }\n\n    for prime in primes_found {\n      \
    \  for factor in factors {\n            if factor == prime {\n               \
    \ factors.remove(factor);\n            }\n        }\n    }\n\n    factors\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0n9ru97z.rs:35:32\n   |\n\
    35 |                 factors.remove(factor);\n   |                           \
    \     ^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n35 |      \
    \           factors.remove(factor.try_into().unwrap());\n   |                \
    \                      ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    assert!(n != 0, \"Given number is zero, can't find\
    \ prime factors\");\n    let mut factors = Vec::new();\n    let mut prime_factors\
    \ = Vec::new();\n    let mut divisor = &n;\n    let mut factor = 1;\n    for _\
    \ in 0..n * 2 {\n        if divisor == 0 {\n            break;\n        }\n  \
    \      if divisor % 2 == 0 {\n            divisor /= 2;\n            factor =\
    \ 2;\n        } else {\n            divisor /= 2;\n            factor = 3;\n \
    \       }\n    }\n\n    while divisor != 1 {\n        factors.push(factor);\n\
    \        for prime in prime_factors.iter() {\n            if prime > factor {\n\
    \                break;\n            }\n            if prime == factor {\n   \
    \             factors.push(1);\n                break;\n            }\n      \
    \      if prime * factor == divisor {\n                factors.push(prime);\n\
    \                divisor = &n / &prime;\n                break;\n            }\n\
    \        }\n    }\n    factors.push(factor);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp3ah48rx1.rs:17:20\n\
    \   |\n17 |         if divisor == 0 {\n   |                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&isize`\n  --> /tmp/tmp3ah48rx1.rs:21:13\n \
    \  |\n21 |             divisor /= 2;\n   |             -------^^^^^\n   |    \
    \         |\n   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=`\
    \ can be used on `isize`, you can dereference `divisor`\n   |\n21 |          \
    \   *divisor /= 2;\n   |             +\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `&isize`\n  --> /tmp/tmp3ah48rx1.rs:24:13\n \
    \  |\n24 |             divisor /= 2;\n   |             -------^^^^^\n   |    \
    \         |\n   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=`\
    \ can be used on `isize`, you can dereference `divisor`\n   |\n24 |          \
    \   *divisor /= 2;\n   |             +\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmp3ah48rx1.rs:29:19\n   |\n29 |     while divisor\
    \ != 1 {\n   |                   ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&_` with `{integer}`\n  --> /tmp/tmp3ah48rx1.rs:32:22\n\
    \   |\n32 |             if prime > factor {\n   |                      ^ no implementation\
    \ for `&_ < {integer}` and `&_ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented f"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    debug_assert!(n % 2 == 0);\n    let mut factors:\
    \ Vec<isize> = Vec::new();\n\n    for d in &[i2::INT_MAX..=isize::INT_MAX] {\n\
    \        if n % d == 0 {\n            let mut tmp: isize = 1;\n            while\
    \ n % d == 0 {\n                n /= d;\n                tmp.push(tmp.clone());\n\
    \            }\n            factors.push(tmp);\n        }\n    }\n\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `i2`\n\
    \  --> /tmp/tmp9f9xlg4y.rs:14:16\n   |\n14 |     for d in &[i2::INT_MAX..=isize::INT_MAX]\
    \ {\n   |                ^^ use of undeclared crate or module `i2`\n\nerror[E0599]:\
    \ no associated item named `INT_MAX` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp9f9xlg4y.rs:14:37\n   |\n14 |     for d in &[i2::INT_MAX..=isize::INT_MAX]\
    \ {\n   |                                     ^^^^^^^ associated item not found\
    \ in `isize`\n\nerror[E0277]: cannot mod `isize` by `&RangeInclusive<_>`\n  -->\
    \ /tmp/tmp9f9xlg4y.rs:15:14\n   |\n15 |         if n % d == 0 {\n   |        \
    \      ^ no implementation for `isize % &RangeInclusive<_>`\n   |\n   = help:\
    \ the trait `Rem<&RangeInclusive<_>>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]: cannot\
    \ mod `isize` by `&RangeInclusive<_>`\n  --> /tmp/tmp9f9xlg4y.rs:17:21\n   |\n\
    17 |             while n % d == 0 {\n   |                     ^ no implementation\
    \ for `isize % &RangeInclusive<_>`\n   |\n   = help: the trait `Rem<&RangeInclusive<_>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: cannot divide-assign `isize` by `&RangeInclusive<_>`\n\
    \  --> /tmp/tmp9f9xlg4y.rs:18:19\n   |\n18 |                 n /= d;\n   |   \
    \                ^^ no implementation for `isize /= &RangeInclusive<_>`\n   |\n\
    \   = help: the trait "
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 { return vec![n] }\n    if n % 2 == 0\
    \ { return factorize(n/2).push(2); }\n    let mut factors = Vec::new();\n    for\
    \ i in (1..=n).rev() {\n        if n % i == 0 { factors.append(i); }\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0t1gd4q.rs:12:28\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n11 |     if n == 1 { return vec![n]\
    \ }\n12 |     if n % 2 == 0 { return factorize(n/2).push(2); }\n   |         \
    \                   ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    note: method `push` modifies its receiver in-place\n  --> /tmp/tmp_0t1gd4q.rs:12:43\n\
    \   |\n12 |     if n % 2 == 0 { return factorize(n/2).push(2); }\n   |       \
    \                     -------------- ^^^^ this call modifies its receiver in-place\n\
    \   |                            |\n   |                            you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0t1gd4q.rs:15:40\n\
    \   |\n15 |         if n % i == 0 { factors.append(i); }\n   |               \
    \                         ^ expected `&mut Vec<_>`, found `isize`\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<_>`\n                           found\
    \ type `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n<=1. { vec![1]; }\n    let mut factors = vec![1];\n\
    \    if n == 1 {\n        factors.push(1);\n        return factors;\n    }\n \
    \   for factor in factorize(n/2) {\n        if n%factor == 0 {\n            factors.push(factor);\n\
    \            factors.push(n/factor);\n            factors.push(n%factor);\n  \
    \      }\n    }\n    return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz4a6rthu.rs:11:11\n   |\n\
    11 |     if n<=1. { vec![1]; }\n   |           ^^ expected `isize`, found floating-point\
    \ number\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut fac = vec![0; n];\n    let mut factors =\
    \ vec![n + 1];\n    let mut i = 0;\n    while i < n {\n        let p = i * i;\n\
    \        let q = p / i;\n        fac[i] = p;\n        factors[q] += 1;\n     \
    \   i += 1;\n    }\n    for i in 1..n {\n        fac[i] -= 1;\n    }\n    for\
    \ i in 1..n {\n        fac[i] /= i;\n    }\n    for i in fac[0..n] {\n       \
    \ factors[i] -= 1;\n    }\n    for i in fac[0..n] {\n        factors[i] += 1;\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7rv5jly1.rs:11:27\n   |\n\
    11 |     let mut fac = vec![0; n];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut fac = vec![0;\
    \ n.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp7rv5jly1.rs:17:9\n\
    \   |\n17 |         fac[i] = p;\n   |         ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp7rv5jly1.rs:18:9\n   |\n18 |         factors[q]\
    \ += 1;\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp7rv5jly1.rs:22:9\n   |\n22 |         fac[i] -= 1;\n \
    \  |         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp7rv5jly1.rs:25:9\n\
    \   |\n25 |         fac[i] /= i;\n   |         ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut max_i = n;\n    let mut max_k = n;\n    while max_k > 1 {\n        max_i\
    \ /= 2;\n        max_k -= 1;\n    }\n    for i in 1..=max_k {\n        factors.push(i);\n\
    \        while i && n % i == 0 {\n            factors.push(i);\n            n\
    \ /= i;\n        }\n    }\n    factors.push(n / max_k);\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp01wbnkof.rs:20:15\n   |\n\
    20 |         while i && n % i == 0 {\n   |               ^ expected `bool`, found\
    \ `isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n == 1 {\n        return vec![1]\n    }\n   \
    \ let mut factors = vec![n];\n    let mut num = 1;\n    let mut p = 1;\n    while\
    \ num > 1 {\n        if n % p == 0 {\n            factors[num] = p;\n        \
    \    n /= p;\n            num += 1;\n        }\n        else {\n            p\
    \ += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2vxpx3qi.rs:20:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n20 |             n /= p;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::with_capacity(n);\n    let\
    \ mut counter = 1;\n    while n != 1 {\n        while n % counter == 0 {\n   \
    \         factors.push(counter);\n            n /= counter;\n        }\n     \
    \   counter += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5rhqhzui.rs:11:42\n   |\n\
    11 |     let mut factors = Vec::with_capacity(n);\n   |                      \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut factors = Vec::with_capacity(n.try_into().unwrap());\n   |  \
    \                                         ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = vec![];\n    for &n\
    \ in factorize2(n) {\n        if n % 2 == 0 {\n            factors.push(n / 2);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `factorize2` in this scope\n  --> /tmp/tmpg5ip0gev.rs:12:15\n\
    \   |\n12 |     for &n in factorize2(n) {\n   |               ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut primes: Vec<isize> = Vec::new();\n    let\
    \ mut num: isize = 1;\n    let mut i = 1;\n    loop {\n        while i * num <\
    \ n {\n            if n % i == 0 {\n                num += 1;\n            } else\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == 2 {\n            primes.push(num);\n            num = 1;\n   \
    \     }\n        i += 1;\n    }\n    primes\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut i = 1;\n\
    \    while i * i <= n {\n        while n % i == 0 {\n            res.push(i);\n\
    \            n /= i;\n        }\n        i += 1;\n    }\n    res.reverse();\n\
    \    res\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf566emm0.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factorization = Vec::new();\n    let mut\
    \ factors_found = 0;\n    let mut factor_of_num = 1;\n    loop {\n        factors_found++;\n\
    \        if n / factor_of_num != 0 {\n            factorization.push(factor_of_num);\n\
    \            factor_of_num *= factor_of_num;\n        } else {\n            break;\n\
    \        }\n    }\n    factorization.push(factor_of_num);\n    return factorization;\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp0fv8cp51.rs:15:22\n\
    \   |\n15 |         factors_found++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n15 |         { let tmp\
    \ = factors_found; factors_found += 1; tmp };\n   |         +++++++++++      \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n15 -         factors_found++;\n15 +    \
    \     factors_found += 1;\n   | \n\nwarning: unreachable statement\n  --> /tmp/tmp0fv8cp51.rs:23:5\n\
    \   |\n14 | /     loop {\n15 | |         factors_found++;\n16 | |         if n\
    \ / factor_of_num != 0 {\n17 | |             factorization.push(factor_of_num);\n\
    ...  |\n21 | |         }\n22 | |     }\n   | |_____- any code following this expression\
    \ is unreachable\n23 |       factorization.push(factor_of_num);\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ unreachable statement\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut num =\
    \ 2; //start from 2 because every factor of 2 appears 2 times\n    while num *\
    \ num < n {\n        if n % num == 0 {\n            factors.push(num);\n     \
    \       n /= num;\n        }\n        num +=1;\n    }\n    factors.push(n);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpogwletxv.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= num;\n\
    \   |             ^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut n = n as u64;\n    let mut factors = Vec::new();\n\
    \    let mut f = 1;\n    while n > 1 {\n        if n % f == 0 {\n            factors.push(f\
    \ as isize);\n            n /= f;\n        } else {\n            f++;\n      \
    \  }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7pyx1mus.rs:19:14\n\
    \   |\n19 |             f++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n19 |             { let tmp = f; f += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n19 -             f++;\n\
    19 +             f += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7pyx1mus.rs:22:18\n\
    \   |\n22 |     factors.push(n);\n   |                  ^ expected `isize`, found\
    \ `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     factors.push(n.try_into().unwrap());\n   |\
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![2];\n    let mut cur_factor\
    \ = 1;\n    while cur_factor < n {\n        let mut found = false;\n        for\
    \ factor in factors {\n            if n % factor == 0 {\n                found\
    \ = true;\n                break;\n            }\n        }\n        if found\
    \ {\n            cur_factor *= factor;\n        } else {\n            factors.push(cur_factor);\n\
    \            cur_factor = 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `factor` in this scope\n  --> /tmp/tmptyca8m8j.rs:22:27\n\
    \   |\n22 |             cur_factor *= factor;\n   |                          \
    \ ^^^^^^ help: a local variable with a similar name exists: `factors`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors: Vec<isize> = Vec::new();\n    let\
    \ mut factor = 1;\n    while n % factor == 0 {\n        factors.push(factor);\n\
    \        n /= factor;\n        factor++;\n    }\n    if n > 1 {\n        factors.push(n);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpkeoh7g7u.rs:16:15\n\
    \   |\n16 |         factor++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n16 |         { let tmp = factor; factor\
    \ += 1; tmp };\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n16 -    \
    \     factor++;\n16 +         factor += 1;\n   | \n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    // https://oeis.org/A006873\n    let mut f: Vec<isize>\
    \ = vec![];\n    for i in 1..n {\n        for j in 2..i {\n            if i %\
    \ j == 0 {\n                f.push(j);\n                i /= j;\n            \
    \    break;\n            }\n        }\n    }\n    f.reverse();\n    f\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmp3bhmd4vu.rs:17:17\n\
    \   |\n17 |                 i /= j;\n   |                 ^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `i`\n  --> /tmp/tmp3bhmd4vu.rs:17:17\n   |\n13 |     for i in 1..n {\n   | \
    \        -\n   |         |\n   |         first assignment to `i`\n   |       \
    \  help: consider making this binding mutable: `mut i`\n...\n17 |            \
    \     i /= j;\n   |                 ^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    if n < 2 {\n        return vec![];\n    }\n    loop\
    \ {\n        if n % 2 == 0 {\n            return vec![2..n]\n        }\n     \
    \   let mut s = 3;\n        let mut t = n / 2;\n        while t > 2 {\n      \
    \      if t % 2 == 0 {\n                s *= 2;\n            }\n            t\
    \ /= 2;\n        }\n        return vec![2..s] +\n            (2..n / s).filter(|n|\
    \ n % 2 == 0).map(|n| 2 * n);\n    }\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp89ri4a3y.rs:16:25\n   |\n\
    16 |             return vec![2..n]\n   |                         ^^^^ expected\
    \ `isize`, found struct `std::ops::Range`\n   |\n   = note: expected type `isize`\n\
    \            found struct `std::ops::Range<isize>`\n\nerror[E0369]: cannot add\
    \ `Map<Filter<std::ops::Range<isize>, [closure@/tmp/tmp89ri4a3y.rs:27:31: 27:45]>,\
    \ [closure@/tmp/tmp89ri4a3y.rs:27:51: 27:60]>` to `Vec<std::ops::Range<{integer}>>`\n\
    \  --> /tmp/tmp89ri4a3y.rs:26:27\n   |\n26 |         return vec![2..s] +\n   |\
    \                ---------- ^\n   |                |\n   |                Vec<std::ops::Range<{integer}>>\n\
    27 |             (2..n / s).filter(|n| n % 2 == 0).map(|n| 2 * n);\n   |     \
    \        ------------------------------------------------ Map<Filter<std::ops::Range<isize>,\
    \ [closure@/tmp/tmp89ri4a3y.rs:27:31: 27:45]>, [closure@/tmp/tmp89ri4a3y.rs:27:51:\
    \ 27:60]>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = vec![0i32; n];\n    let mut n =\
    \ n as isize;\n    let mut i: usize = 0;\n    while n > 1 {\n        while n %\
    \ 2 == 0 {\n            result.push(2);\n            n /= 2;\n        }\n    \
    \    while n % 3 == 0 {\n            result.push(3);\n            n /= 3;\n  \
    \      }\n        while n % 5 == 0 {\n            result.push(5);\n          \
    \  n /= 5;\n        }\n        while n % 7 == 0 {\n            result.push(7);\n\
    \            n /= 7;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxa57cf75.rs:11:33\n   |\n\
    11 |     let mut result = vec![0i32; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ result = vec![0i32; n.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxa57cf75.rs:33:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n33 |    \
    \ result\n   |     ^^^^^^ expected `isize`, found `i32`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<i32>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut factors = vec![1];\n    let mut factor =\
    \ 1;\n    while n > 1 {\n        while n % factor == 0 {\n            factors.push(*factor);\n\
    \            n /= *factor;\n        }\n        *factor *= factor;\n        factor++;\n\
    \    }\n    factors.reverse()\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpdbg00a_p.rs:19:15\n\
    \   |\n19 |         factor++;\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n19 |         { let tmp = factor; factor\
    \ += 1; tmp };\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n19 -    \
    \     factor++;\n19 +         factor += 1;\n   | \n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpdbg00a_p.rs:15:26\n   |\n15 |        \
    \     factors.push(*factor);\n   |                          ^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpdbg00a_p.rs:16:18\n   |\n\
    16 |             n /= *factor;\n   |                  ^^^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpdbg00a_p.rs:18:9\n   |\n\
    18 |         *factor *= factor;\n   |         ^^^^^^^\n   |\nhelp: parentheses\
    \ are required to parse this as an expression\n   |\n14 ~         (while n % factor\
    \ == 0 {\n15 |             factors.push(*factor);\n16 |             n /= *factor;\n\
    17 ~         })\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbg00a_p.rs:21:5\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \      ---------- expected `Vec<isize>` because of return type\n...\n21 |    \
    \ factors.reverse()\n   |     ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// [2, 2, 2]\n///\
    \ >>> factorize(25)\n/// [5, 5]\n/// >>> factorize(70)\n/// [2, 5, 7]\nfn factorize(n:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 1..=n\
    \ {\n        if n % i == 0 {\n            result.push(i);\n            if n /\
    \ i >= i {\n                result.push(n/i);\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[2]`', /tmp/tmprsp2ngkb.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
