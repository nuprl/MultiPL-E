name: HumanEval_2_truncate_number
language: rust
results:
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpj0ov0zcg.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return 0.0;\n    }\n    number as f64\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp2ro4ve3x.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let rem = f64::from(number) % f64::from(1.0); // remainder\n \
    \   let mantissa = f64::from(number) / f64::from(1.0); // mantissa\n    f64::from(number)\
    \ + (f64::from(rem) * f64::from(10.0)).powf(-1.0) // decimal part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.7`,\n right: `0.5`', /tmp/tmpwg8p5zqv.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = 0.0;\n    let mut fraction = f64::min(1.0, number\
    \ - integer);\n\n    while fraction >= 10.0 {\n        integer += 1.0;\n     \
    \   fraction -= 10.0;\n    }\n\n    fraction\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmpa7ky5lcf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (int_part, mut fraction) = number.floor_f64();\n    let mut\
    \ decimal_part = 0;\n    while fraction > 1.0 {\n        decimal_part += 1;\n\
    \        fraction = fraction - 1.0;\n    }\n    decimal_part += fraction;\n  \
    \  decimal_part * 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpb6057cw7.rs:8:43\n  |\n8 |     let (int_part, mut fraction)\
    \ = number.floor_f64();\n  |                                           ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `floor`\n\nerror[E0277]:\
    \ cannot multiply `{integer}` by `{float}`\n  --> /tmp/tmpb6057cw7.rs:15:18\n\
    \   |\n15 |     decimal_part * 1.0\n   |                  ^ no implementation\
    \ for `{integer} * {float}`\n   |\n   = help: the trait `Mul<{float}>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let n = number.floor();\n    (number - n) as f64 / 100\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n --> /tmp/tmp70spg9p1.rs:9:25\n\
    \  |\n9 |     (number - n) as f64 / 100\n  |                         ^ no implementation\
    \ for `f64 / {integer}`\n  |\n  = help: the trait `Div<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Div<Rhs>`:\n\
    \            <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n      \
    \      <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n          \
    \  <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n            <&'a\
    \ i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n9\
    \ |     (number - n) as f64 / 100.0\n  |                              ++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.;\n    let mut largest_integer = number;\n\
    \    let mut leftover_part = 0.;\n\n    if number < 0.0 {\n        // negative\
    \ number\n        leftover_part = -number;\n        largest_integer = -number;\n\
    \    } else {\n        // positive number\n        let mut temp = number.to_f64();\n\
    \        while temp > 0.0 {\n            decimal_part += temp % 1.;\n        \
    \    temp -= temp % 1.0;\n            largest_integer -= temp;\n        }\n  \
    \  }\n\n    let result = decimal_part + largest_integer + leftover_part;\n\n \
    \   if result < 0.0 {\n        result\n    } else {\n        result - 1.0\n  \
    \  }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpdg1ptldv.rs:18:31\n   |\n18 |         let mut temp = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmprruze9u5.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut num = number.trunc();\n    if num < 1.0 {\n        let\
    \ mut digits = String::new();\n        let mut places = 0.0;\n        loop {\n\
    \            let mut digit = num % 10.0;\n            digits += &format!(\"{}\"\
    , digit).to_string();\n            num /= 10.0;\n            if num == 0.0 {\n\
    \                break;\n            }\n            places += digit;\n       \
    \ }\n        digits = digits.trim().to_string();\n        num = (num + places).round();\n\
    \    }\n    num\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp1ujr6vi6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = 0;\n    let mut decimals: u64 = 0;\n\n   \
    \ let (mut lower, mut upper) = number.trunc().floor();\n    while low + 1 < upper\
    \ {\n        let mut m = ((upper - low) + 1) as u64;\n        let mut tmp: f64\
    \ = 1.0;\n        let mut factor = 1.0;\n\n        while m > 0 {\n           \
    \ tmp *= m;\n            factor /= m;\n            m -= 1;\n        }\n      \
    \  remainder += tmp;\n        decimals += factor;\n        lower = (upper - factor).saturating_add(1,\
    \ 1);\n        upper = upper.saturating_add(1, 1);\n    }\n\n    if remainder\
    \ < 0.5 {\n        remainder *= 2.0;\n    } else {\n        remainder *= 2.0;\n\
    \        decimals -= 1;\n    }\n\n    number\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `low` in this scope\n  --> /tmp/tmp4bjzj9q6.rs:12:11\n\
    \   |\n12 |     while low + 1 < upper {\n   |           ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `low` in this scope\n  --> /tmp/tmp4bjzj9q6.rs:13:31\n\
    \   |\n13 |         let mut m = ((upper - low) + 1) as u64;\n   |            \
    \                   ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4bjzj9q6.rs:11:9\n   |\n11 |     let (mut lower, mut upper) = number.trunc().floor();\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^   ---------------------- this expression\
    \ has type `f64`\n   |         |\n   |         expected `f64`, found tuple\n \
    \  |\n   = note: expected type `f64`\n             found tuple `(_, _)`\n\nerror[E0277]:\
    \ cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmp4bjzj9q6.rs:22:19\n  \
    \ |\n22 |         remainder += tmp;\n   |                   ^^ no implementation\
    \ for `{integer} += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot add-assign `{float}` to `u64`\n  --> /tmp/tmp4bjzj9q6.rs:23:18\n\
    \   |\n23 |         decimals += factor;\n   |                  ^^ no implementation\
    \ for `u64 += {float}`\n   |\n   = help: the trait `AddAssign<{float}>` is not\
    \ implemented for `u64`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \            <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n     \
    \      and 20 others\n\nerror[E0277]: can't compare `{integer}` w"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.truncate() {\n        Ok(x) => x,\n        Err(x)\
    \ => {\n            if x == number.floor() as f64 {\n                number\n\
    \            } else {\n                let mut number = number.floor() as f64;\n\
    \                let x = number - number;\n                number = x;\n     \
    \           number\n            }\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp04onq6xn.rs:8:18\n  |\n8 |     match number.truncate() {\n\
    \  |                  ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number\n    }\n    let exponent\
    \ = number.exponent();\n    if exponent < -2 {\n        return number\n    }\n\
    \    number.trunc().unwrap() / significand(number).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `significand` in this scope\n  --> /tmp/tmpl474qex_.rs:15:31\n\
    \   |\n15 |     number.trunc().unwrap() / significand(number).unwrap()\n   | \
    \                              ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `exponent` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpl474qex_.rs:11:27\n   |\n11 |     let exponent = number.exponent();\n\
    \   |                           ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmpl474qex_.rs:15:20\n\
    \   |\n15 |     number.trunc().unwrap() / significand(number).unwrap()\n   | \
    \                   ^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    if integer < 1.0 {\n  \
    \      integer -= 1.0;\n    }\n    integer\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp_8v287er.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fraction = number;\n    let digits = fraction.abs().floor();\n\
    \    if digits < 1 {\n        fraction += 1.0; // never happens unless number\
    \ is zero\n        digits++\n    }\n    let decimal_place = digits - truncate_digits(fraction);\n\
    \    fraction -= fraction.trunc().mul(pow(10.0, decimal_place));\n    fraction\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpc8j9g0z6.rs:12:15\n\
    \   |\n12 |         digits++\n   |               ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n12 |         { let tmp = digits; digits\
    \ += 1; tmp }\n   |         +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n12 -     \
    \    digits++\n12 +         digits += 1\n   | \n\nerror[E0425]: cannot find function\
    \ `truncate_digits` in this scope\n  --> /tmp/tmpc8j9g0z6.rs:14:34\n   |\n14 |\
    \     let decimal_place = digits - truncate_digits(fraction);\n   |          \
    \                        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `pow` in this scope\n  --> /tmp/tmpc8j9g0z6.rs:15:38\n\
    \   |\n15 |     fraction -= fraction.trunc().mul(pow(10.0, decimal_place));\n\
    \   |                                      ^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc8j9g0z6.rs:10:17\n   |\n10 |     if digits\
    \ < 1 {\n   |                 ^\n   |                 |\n   |                \
    \ expected `f64`, found integer\n   |                 help: use a float literal:\
    \ `1.0`\n\nerror[E0599]: no method named `mul` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpc8j9g0z6.rs:15:34\n    |\n15  |     fraction -= fraction.trunc().mul(pow(10.0,\
    \ decimal_place));\n    |                                  ^^^ method not found\
    \ in `f64`\n    |\n    = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n    |\n1   | use std::ops::Mul;\n    |\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.floor() {\n        Some(number) => number,\n    \
    \    None => number.ceil(),\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_t6noyrv.rs:9:9\n  |\n8 |\
    \     match number.floor() {\n  |           -------------- this expression has\
    \ type `f64`\n9 |         Some(number) => number,\n  |         ^^^^^^^^^^^^ expected\
    \ `f64`, found enum `Option`\n  |\n  = note: expected type `f64`\n           \
    \  found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_t6noyrv.rs:10:9\n\
    \   |\n8  |     match number.floor() {\n   |           -------------- this expression\
    \ has type `f64`\n9  |         Some(number) => number,\n10 |         None => number.ceil(),\n\
    \   |         ^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected\
    \ type `f64`\n              found enum `Option<_>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut power = 1;\n    let mut result = 0;\n    let mut mantissa\
    \ = number;\n\n    while mantissa > power {\n        result += (power << 1) -\
    \ 1;\n        power *= 2;\n    }\n\n    result + (mantissa / power)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvhkfftk9.rs:12:22\n   |\n\
    12 |     while mantissa > power {\n   |                      ^^^^^ expected `f64`,\
    \ found integer\n\nerror[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmpvhkfftk9.rs:17:24\n\
    \   |\n17 |     result + (mantissa / power)\n   |                        ^ no\
    \ implementation for `f64 / {integer}`\n   |\n   = help: the trait `Div<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        number\n    } else {\n        number.truncate()\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpokadxi0t.rs:11:16\n   |\n11 |         number.truncate()\n\
    \   |                ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let x = number.floor() as f64;\n    if x % 1 == 0.0 {\n      \
    \  x\n    } else {\n        x - 1.0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmp0jvgqt89.rs:9:10\n\
    \  |\n9 |     if x % 1 == 0.0 {\n  |          ^ no implementation for `f64 % {integer}`\n\
    \  |\n  = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n            <&'a f32\
    \ as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n\
    \            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n      \
    \      <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a\
    \ isize as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |     if x % 1.0 == 0.0 {\n  |     \
    \        ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, _) = number.trunc_f64();\n    integer\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpn2w9y9s_.rs:8:31\n  |\n8 |     let (integer, _) = number.trunc_f64();\n\
    \  |                               ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `trunc`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpmsrz72c_.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let n = number.abs();\n    let sign = if n.is_negative() { -1.0\
    \ } else { 1.0 };\n    let mut exp = n.bits() as u16;\n    let mut rem: f64 =\
    \ number; // starting with number\n    let mut ndigits = 8; // number of digits\
    \ in the decimal\n    loop {\n        let mut frac = rem;\n        rem /= 10.0;\n\
    \        if rem < 1.0 {\n            exp -= 1;\n            if exp == 0 {\n  \
    \              frac = 0.0;\n                exp = 1;\n                rem *= 10.0;\n\
    \            } else {\n                ndigits = 1;\n            }\n        }\
    \ else {\n            ndigits -= 1;\n            if ndigits == 0 {\n         \
    \       break;\n            }\n        }\n    }\n    sign * frac + f64::from_f32(0.1\
    \ * (10 ** (exp - 10.0))).unwrap()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `frac` in this scope\n  --> /tmp/tmpsf9_99kz.rs:32:12\n\
    \   |\n32 |     sign * frac + f64::from_f32(0.1 * (10 ** (exp - 10.0))).unwrap()\n\
    \   |            ^^^^ not found in this scope\n\nwarning: use of deprecated associated\
    \ function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \ --> /tmp/tmpsf9_99kz.rs:9:21\n  |\n9 |     let sign = if n.is_negative() { -1.0\
    \ } else { 1.0 };\n  |                     ^^^^^^^^^^^\n  |\n  = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0599]: no method named `bits` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpsf9_99kz.rs:10:21\n   |\n10 |     let mut exp\
    \ = n.bits() as u16;\n   |                     ^^^^ help: there is an associated\
    \ function with a similar name: `to_bits`\n\nerror[E0599]: no function or associated\
    \ item named `from_f32` found for type `f64` in the current scope\n  --> /tmp/tmpsf9_99kz.rs:32:24\n\
    \   |\n32 |     sign * frac + f64::from_f32(0.1 * (10 ** (exp - 10.0))).unwrap()\n\
    \   |                        ^^^^^^^^ function or associated item not found in\
    \ `f64`\n\nerror[E0277]: cannot subtract `{float}` from `{integer}`\n  --> /tmp/tmpsf9_99kz.rs:32:51\n\
    \   |\n32 |     sign * frac + f64::from_f32(0.1 * (10 ** (exp - 10.0))).unwrap()\n\
    \   |                                                   ^ no implementation for\
    \ `{integer} - {float}`\n   |\n   = help: the trait `Sub<{float}>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: cannot multiply `{float}` by `{integer}`\n  --> /tmp/tmpsf9_99kz.rs:32:37\n\
    \   |\n32 |     sign * frac + f64::from_f32(0.1 * (10 ** (exp - 10.0))).unwrap()\n\
    \   |                                     ^ no implementation for `{float} * {integer}`\n\
    \   |\n   = help"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integral = f64::from(number.floor());\n    let mut decimal\
    \ = f64::from(number.fract());\n    if integral < 0 {\n        integral = integral\
    \ + f64::from(0.5);\n        decimal = f64::from(0.0);\n    }\n    integral +\
    \ decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqo3hnygr.rs:10:19\n   |\n\
    10 |     if integral < 0 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `f64`, found integer\n   |                  \
    \ help: use a float literal: `0.0`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO(vaughan): implement this!\n    (number as i64).trunc()\
    \ / (i64::max_value() as f64)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc` found for type `i64` in the current\
    \ scope\n --> /tmp/tmp7v5ky58z.rs:9:21\n  |\n9 |     (number as i64).trunc() /\
    \ (i64::max_value() as f64)\n  |                     ^^^^^ method not found in\
    \ `i64`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut mantissa = number.to_f64().trunc();\n    if mantissa <\
    \ number {\n        mantissa += 1.0;\n    }\n    mantissa\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmplp6x6fvf.rs:8:31\n  |\n8 |     let mut mantissa = number.to_f64().trunc();\n\
    \  |                               ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder -= 1.0;\n   \
    \     decimal_part += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpl9gmbpst.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decs = 0;\n    let mut neg = false;\n\n    if number <\
    \ 0.0 {\n        neg = true;\n        number = -number;\n    }\n\n    while number\
    \ > 0.0 {\n        decs += 1;\n        number -= number / 10.0;\n    }\n\n   \
    \ decs as f64 + number as f64 / 10.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: variable `neg` is assigned to, but never used\n --> /tmp/tmpr_mfw8wi.rs:9:13\n\
    \  |\n9 |     let mut neg = false;\n  |             ^^^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_neg` instead\n\nwarning: value assigned\
    \ to `neg` is never read\n  --> /tmp/tmpr_mfw8wi.rs:12:9\n   |\n12 |         neg\
    \ = true;\n   |         ^^^\n   |\n   = note: `#[warn(unused_assignments)]` on\
    \ by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpr_mfw8wi.rs:13:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n13 | \
    \        number = -number;\n   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `number`\n  -->\
    \ /tmp/tmpr_mfw8wi.rs:18:9\n   |\n7  | fn truncate_number(number: f64) -> f64\
    \ {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n18 |         number -= number / 10.0;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n\n    // Round the decimal part and get the integer part as remainder\
    \ of the\n    // decimal part. The floor and ceil functions return the integer\
    \ part of\n    // a floating point number.\n    decimal = decimal.ceil();\n  \
    \  integer = integer.floor();\n\n    decimal + integer\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp1w1zkmwn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc() / 1\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n --> /tmp/tmpmyyqikwo.rs:8:20\n\
    \  |\n8 |     number.trunc() / 1\n  |                    ^ no implementation for\
    \ `f64 / {integer}`\n  |\n  = help: the trait `Div<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Div<Rhs>`:\n\
    \            <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n      \
    \      <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n          \
    \  <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n            <&'a\
    \ i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     number.trunc() / 1.0\n  |                       ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // the smallest number representable by f64 is 2^-54\n    // f64\
    \ has 15 decimal places, after which we loose precision and can only represent\
    \ 2^-53\n    let f = number.to_f64();\n    let mut result = 0.0;\n    // keep\
    \ adding f until it is close enough to 2^-53\n    while f != 0.0 {\n        //\
    \ multiply by 10 until we get to 2^-54\n        f *= 10.0;\n        // multiply\
    \ by 2 until we get to 2^-52\n        f *= 2.0;\n        // add result to it\n\
    \        result += f;\n    }\n    // return the remaining part as long as it's\
    \ not below 1\n    while result < 1.0 {\n        result *= 10.0;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp0rtb0vqq.rs:10:20\n   |\n10 |     let f = number.to_f64();\n\
    \   |                    ^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut int_part = 0.0;\n    number.abs()\
    \ as i64.pow(10.0)\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n        .try_into()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpze17vaqp.rs:10:5\n\
    \   |\n10 |     number.abs() as i64.pow(10.0)\n   |     ^^^^^^^^^^^^^^^^^^^\n\
    \   |\nhelp: try surrounding the expression in parentheses\n   |\n10 |     (number.abs()\
    \ as i64).pow(10.0)\n   |     +                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpze17vaqp.rs:10:29\n   |\n10 |     number.abs() as i64.pow(10.0)\n\
    \   |                             ^^^^ expected `u32`, found floating-point number\n\
    \nerror[E0599]: no method named `try_into` found for type `i64` in the current\
    \ scope\n   --> /tmp/tmpze17vaqp.rs:11:10\n    |\n11  |         .try_into()\n\
    \    |          ^^^^^^^^ method not found in `i64`\n    |\n    = help: items from\
    \ traits can only be used if the trait is in scope\n    = note: 'std::convert::TryInto'\
    \ is included in the prelude starting in Edition 2021\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n    |\n1   | use\
    \ std::convert::TryInto;\n    |\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.5 {\n        return 0.0;\n    }\n\n    let remainder\
    \ = if number - 0.5 < 1.0 {\n        1.0 - number\n    } else {\n        number\
    \ - 0.5\n    };\n\n    if number < 1.0 {\n        return number * 10.0;\n    }\n\
    \n    if remainder < 10.0 {\n        return number / 10.0;\n    }\n\n    return\
    \ number / 10.0 - remainder;\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.35`,\n right: `0.5`', /tmp/tmp53nchb76.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Return NaN if the number is NaN.\n    if number.is_nan() {\n\
    \        return NAN;\n    }\n\n    // Truncate to zero. NaN's are treated like\
    \ positive zeros, but the code\n    // below doesn't take that into account.\n\
    \    let result = number % 1;\n\n    if result == 0.0 {\n        return NAN;\n\
    \    }\n\n    result.trunc_div(1.0)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `NAN` in this scope\n  --> /tmp/tmpb6eynvwf.rs:10:16\n\
    \   |\n10 |         return NAN;\n   |                ^^^ not found in this scope\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::f32::NAN;\n\
    \   |\n1  | use std::f64::NAN;\n   |\n\nerror[E0425]: cannot find value `NAN`\
    \ in this scope\n  --> /tmp/tmpb6eynvwf.rs:18:16\n   |\n18 |         return NAN;\n\
    \   |                ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ one of these items\n   |\n1  | use std::f32::NAN;\n   |\n1  | use std::f64::NAN;\n\
    \   |\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpb6eynvwf.rs:15:25\n\
    \   |\n15 |     let result = number % 1;\n   |                         ^ no implementation\
    \ for `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n15 |     let result = number % 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number % 1)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpsk2c2_8p.rs:8:22\n\
    \  |\n8 |     number - (number % 1)\n  |                      ^ no implementation\
    \ for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     number - (number % 1.0)\n  |                         ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 0.0 {\n        number\n    } else {\n        let\
    \ (int_part, mut frac_part) = number.divmod(1);\n        while frac_part.is_zero()\
    \ {\n            (int_part + 1, frac_part) = (int_part + 1, 1);\n        }\n \
    \       frac_part\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `divmod` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmptejf6nbw.rs:11:48\n   |\n11 |         let (int_part, mut\
    \ frac_part) = number.divmod(1);\n   |                                       \
    \         ^^^^^^ method not found in `f64`\n\nerror[E0070]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmptejf6nbw.rs:13:39\n   |\n13 |            \
    \ (int_part + 1, frac_part) = (int_part + 1, 1);\n   |              ------------\
    \             ^\n   |              |\n   |              cannot assign to this\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0070, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        return number\n    }\n    math.trunc(number)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpxyql8ix2.rs:11:5\n\
    \   |\n11 |     math.trunc(number)\n   |     ^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - trunc(number)).trunc().unwrap_or(number.abs()) as f64\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `trunc` in this scope\n --> /tmp/tmpfttzrlyn.rs:8:15\n\
    \  |\n8 |     (number - trunc(number)).trunc().unwrap_or(number.abs()) as f64\n\
    \  |               ^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `unwrap_or` found for type `f64` in the current scope\n --> /tmp/tmpfttzrlyn.rs:8:38\n\
    \  |\n8 |     (number - trunc(number)).trunc().unwrap_or(number.abs()) as f64\n\
    \  |                                      ^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number % 1f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut int_part = number.trunc();\n    let mut decimals = number.remainder(f64::EPSILON);\n\
    \    decimals = if decimals < f64::EPSILON { 0 } else { decimals.abs() };\n  \
    \  int_part + (decimals / f64::EPSILON)\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `remainder` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpays7srn0.rs:9:31\n  |\n9 |     let mut decimals = number.remainder(f64::EPSILON);\n\
    \  |                               ^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = number.trunc();\n\n    if decimal_part\
    \ > number.floor() {\n        decimal_part -= 1;\n    }\n\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract-assign `{integer}` from `f64`\n  --> /tmp/tmp8xvw0k63.rs:11:22\n\
    \   |\n11 |         decimal_part -= 1;\n   |                      ^^ no implementation\
    \ for `f64 -= {integer}`\n   |\n   = help: the trait `SubAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n             <f32\
    \ as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n\
    \             <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n \
    \            <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         decimal_part -= 1.0;\n   |                \
    \          ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp7ifz8ncu.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() / number.floor() as f64\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmp5mv61n2r.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpnfx2hmsh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number\n    }\n    let mantissa\
    \ = (number - 1.0).abs();\n    let exp_value = mantissa.ceil() as f64;\n    let\
    \ (whole_part,\n         decimal_part) = std::mem::split::<f64>(mantissa);\n \
    \   return whole_part + decimal_part as f64 / 10.0\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `split` in module `std::mem`\n  -->\
    \ /tmp/tmpdumzt0cx.rs:14:36\n   |\n14 |          decimal_part) = std::mem::split::<f64>(mantissa);\n\
    \   |                                    ^^^^^ not found in `std::mem`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut whole_part: u32;\n    let mut decimal_part: u32 = 0;\n\
    \    let mut fraction_part: u32 = 0;\n\n    if number >= 0.0 {\n        // Truncate\
    \ the number.\n        let mut int_part = number;\n        while int_part >= 1.0\
    \ {\n            int_part = int_part - 1.0;\n            decimal_part += 1;\n\
    \        }\n\n        // Take the floor of the truncated\n        // int_part.\n\
    \        whole_part = int_part as u32;\n\n        // The fractional part can be\n\
    \        // truncated by multiplying the\n        // whole part with 10 to the\
    \ power\n        // of the decimal part length.\n        if decimal_part > 0 {\n\
    \            fraction_part = whole_part * 10.0 as u32;\n            fraction_part\
    \ += decimal_part as u32;\n        }\n    } else {\n        // Truncate negative\
    \ numbers.\n        let mut int_part = number;\n        while int_part < -1.0\
    \ {\n            int_part = int_part + 1.0;\n            decimal_part += 1;\n\
    \        }\n\n        // Take the ceil of the truncated\n        // int_part.\n\
    \        whole_part = int_part as u32;\n\n        // The fractional part can be\n\
    \        // truncated by multiplying the\n        // whole part with 10 to the\
    \ power\n        // of the decimal part length.\n        if decimal_part > 0 {\n\
    \            fraction_part = whole_part * 10.0 as u32;\n            fraction_part\
    \ += decimal_part as u32;\n        }\n    }\n\n    let number = whole_part + fraction_part\
    \ / 10.0 as f64;\n    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `u32` by `f64`\n  --> /tmp/tmp05mv97ru.rs:54:45\n\
    \   |\n54 |     let number = whole_part + fraction_part / 10.0 as f64;\n   | \
    \                                            ^ no implementation for `u32 / f64`\n\
    \   |\n   = help: the trait `Div<f64>` is not implemented for `u32`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut int_part: i32 = 0;\n\
    \    let mut remainder: f64 = number;\n    let mut i = 0;\n\n    while remainder\
    \ >= 1.0 {\n        remainder -= 1.0;\n        i += 1;\n    }\n\n    while remainder\
    \ > 0.0 {\n        remainder -= 1.0;\n        i += 1;\n    }\n\n    if i == 0\
    \ {\n        int_part = i;\n        decimal_part = remainder;\n    } else {\n\
    \        int_part = i;\n        decimal_part = remainder;\n    }\n\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-0.5`,\n right: `0.5`', /tmp/tmplw13p9ew.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number {\n        number.is_nan() => f64::NAN,\n       \
    \ number.is_infinite() => number.abs(),\n        number.is_positive() => number.floor(),\n\
    \        number.is_negative() => number.ceil(),\n        _ => {\n            let\
    \ sign = number.sign();\n            let digits: Vec<_> = number.abs().to_digits().collect();\n\
    \n            if sign == 0 {\n                let n = digits.len() - 1;\n    \
    \            digits.insert(n, 0).collect();\n            }\n\n            let\
    \ mut decimals: Vec<_> = Vec::new();\n            let mut decimals_size: usize\
    \ = 0;\n            for d in digits {\n                if d < 10 {\n         \
    \           decimals.push(0);\n                    decimals_size += 1;\n     \
    \           } else {\n                    decimals.push(d - 10);\n           \
    \         decimals_size += 1;\n                }\n            }\n            if\
    \ decimals_size != 0 {\n                let mut pow: usize = 1;\n            \
    \    while decimals_size < decimals.len() {\n                    decimals.insert(0,\
    \ 0);\n                    decimals_size += 1;\n                    pow *= 10;\n\
    \                }\n                if sign >= 0 {\n                    decimals.push(0);\n\
    \                    decimals_size += 1;\n                }\n                if\
    \ sign < 0 {\n                    decimals = -decimals;\n                }\n \
    \               let mut result = 0;\n                for i in 0..decimals_size\
    \ {\n                    result += decimals[i] * pow;\n                }\n   \
    \             return result\n            }\n            number\n        }\n  \
    \  }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `.`\n --> /tmp/tmpf88yynvn.rs:9:15\n\
    \  |\n9 |         number.is_nan() => f64::NAN,\n  |               ^ expected one\
    \ of `=>`, `@`, `if`, or `|`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        return 0.0;\n    }\n    let mut truncated\
    \ = number;\n    let mut remaining = number.fract() - 1.0;\n    if number > 0.0\
    \ {\n        while remaining > 0.0 && remaining < 1.0 {\n            truncated\
    \ += 1.0;\n            remaining -= 1.0;\n        }\n    }\n    truncated\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmppliido3c.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.1 {\n        return 0.0;\n    }\n    if number >=\
    \ 1.0 {\n        return 1.0;\n    }\n    number.floor() as f64\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmp36f4y4dp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    number.floor_f64(&mut result);\n  \
    \  result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `floor_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3qsm1f9t.rs:9:12\n  |\n9 |     number.floor_f64(&mut result);\n\
    \  |            ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `floor`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    let fraction = number - int_part;\n\
    \    int_part + (fraction / f64::from(10.0))\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.05`,\n right: `0.5`', /tmp/tmp_qqejz7w.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = 0;\n    let mut truncated: f64 = 0;\n\
    \    for n in number.iter().cloned().rev() {\n        let d = n.abs();\n     \
    \   if d > remainder {\n            remainder = d\n        }\n        if d < truncated\
    \ {\n            truncated = d\n        }\n    }\n    truncated + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpryn3q7i6.rs:8:30\n  |\n8 |\
    \     let mut remainder: f64 = 0;\n  |                        ---   ^\n  |   \
    \                     |     |\n  |                        |     expected `f64`,\
    \ found integer\n  |                        |     help: use a float literal: `0.0`\n\
    \  |                        expected due to this\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpryn3q7i6.rs:9:30\n  |\n9 |     let mut truncated: f64 = 0;\n  |\
    \                        ---   ^\n  |                        |     |\n  |    \
    \                    |     expected `f64`, found integer\n  |                \
    \        |     help: use a float literal: `0.0`\n  |                        expected\
    \ due to this\n\nerror[E0599]: no method named `iter` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpryn3q7i6.rs:10:21\n   |\n10 |     for n in\
    \ number.iter().cloned().rev() {\n   |                     ^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpqlx_j_54.rs:8:12\n  |\n8 |     number.trunc_f64()\n  | \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut decimal_point = 0.0;\n \
    \   let mut exponent = MAX_EXPONENT;\n    let mut mantissa = number.to_f64();\n\
    \    while mantissa >= 1.0 {\n        exponent++;\n        mantissa = mantissa\
    \ / 10.0;\n    }\n    while mantissa < 1.0 {\n        exponent--;\n        mantissa\
    \ = mantissa * 10.0;\n    }\n    if exponent <= MAX_EXPONENT {\n        truncated\
    \ = number;\n        while exponent > 0 {\n            if exponent & 1 == 1 {\n\
    \                truncated = truncated.fract();\n            }\n            exponent\
    \ >>= 1;\n        }\n    }\n    return truncated;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp46adat3o.rs:13:17\n\
    \   |\n13 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n13 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n13 -\
    \         exponent++;\n13 +         exponent += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmp46adat3o.rs:17:19\n   |\n17 |         exponent--;\n\
    \   |                   ^ expected expression\n\nerror[E0425]: cannot find value\
    \ `MAX_EXPONENT` in this scope\n  --> /tmp/tmp46adat3o.rs:10:24\n   |\n10 |  \
    \   let mut exponent = MAX_EXPONENT;\n   |                        ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_EXPONENT` in\
    \ this scope\n  --> /tmp/tmp46adat3o.rs:20:20\n   |\n20 |     if exponent <= MAX_EXPONENT\
    \ {\n   |                    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmp46adat3o.rs:11:31\n\
    \   |\n11 |     let mut mantissa = number.to_f64();\n   |                    \
    \           ^^^^^^ method not found in `f64`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = number.abs().floor().unwrap();\n    decimal\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpiquhdl_d.rs:8:51\n  |\n8 |     let (integer, decimal) =\
    \ number.abs().floor().unwrap();\n  |                                        \
    \           ^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - f64::from(number).floor() as f64) / f64::from(number).sqrt()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.2672612419124244`,\n right: `0.5`', /tmp/tmp61vng6jw.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.trunc() {\n        Some(n) => n,\n        None =>\
    \ number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvadcsfiy.rs:9:9\n  |\n8 |\
    \     match number.trunc() {\n  |           -------------- this expression has\
    \ type `f64`\n9 |         Some(n) => n,\n  |         ^^^^^^^ expected `f64`, found\
    \ enum `Option`\n  |\n  = note: expected type `f64`\n             found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvadcsfiy.rs:10:9\n   |\n8  | \
    \    match number.trunc() {\n   |           -------------- this expression has\
    \ type `f64`\n9  |         Some(n) => n,\n10 |         None => number\n   |  \
    \       ^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected type\
    \ `f64`\n              found enum `Option<_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let n = number.trunc();\n    let mut s = number.abs();\n    if\
    \ s.is_nan() {\n        0.0\n    } else {\n        s /= 10.0;\n    }\n    n +\
    \ s\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphocuaxdj.rs:11:9\n   |\n\
    10 | /     if s.is_nan() {\n11 | |         0.0\n   | |         ^^^ expected `()`,\
    \ found floating-point number\n12 | |     } else {\n13 | |         s /= 10.0;\n\
    14 | |     }\n   | |_____- expected this to be `()`\n   |\nhelp: you might have\
    \ meant to return this value\n   |\n11 |         return 0.0;\n   |         ++++++\
    \    +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO: this can be improved\n    let number = number.floor()\
    \ as f64;\n    let number = if number < 1.0 {\n        // number < 1.0\n     \
    \   number\n    } else {\n        // number > 1.0\n        number - 1.0\n    };\n\
    \    let mut decimal: f64 = 0.0;\n    let mut power: i32 = 0;\n    while number\
    \ >= 1.0 {\n        number -= 1.0;\n        decimal += 1.0;\n        power++;\n\
    \    }\n    (decimal, power)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxd2ozckg.rs:22:14\n\
    \   |\n22 |         power++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n22 |         { let tmp = power; power +=\
    \ 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n22 -         power++;\n\
    22 +         power += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxd2ozckg.rs:24:5\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n24 |     (decimal,\
    \ power)\n   |     ^^^^^^^^^^^^^^^^ expected `f64`, found tuple\n   |\n   = note:\
    \ expected type `f64`\n             found tuple `(f64, i32)`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - f64::floorf(number)).round() as f64\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `floorf` found for type\
    \ `f64` in the current scope\n --> /tmp/tmpnvxf9nqu.rs:8:20\n  |\n8 |     (number\
    \ - f64::floorf(number)).round() as f64\n  |                    ^^^^^^\n  |  \
    \                  |\n  |                    function or associated item not found\
    \ in `f64`\n  |                    help: there is an associated function with\
    \ a similar name: `floor`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exponent = number.abs();\n    let (integer, decimals)\
    \ = number.canonical_exp();\n    exponent -= decimals as i64;\n    if exponent\
    \ >= 0 {\n        return number / (f64::from(1i64) as f64);\n    }\n    // Number\
    \ has too many digits for float to represent it exactly.\n    number.powf(exponent\
    \ as f64);\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `canonical_exp` found for type `f64` in the\
    \ current scope\n --> /tmp/tmphfzdpj6b.rs:9:38\n  |\n9 |     let (integer, decimals)\
    \ = number.canonical_exp();\n  |                                      ^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0277]: cannot subtract-assign `i64` from\
    \ `f64`\n  --> /tmp/tmphfzdpj6b.rs:10:14\n   |\n10 |     exponent -= decimals\
    \ as i64;\n   |              ^^ no implementation for `f64 -= i64`\n   |\n   =\
    \ help: the trait `SubAssign<i64>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `SubAssign<Rhs>`:\n             <f32 as\
    \ SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i16 as SubAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphfzdpj6b.rs:11:20\n   |\n11 |     if exponent >= 0 {\n\
    \   |                    ^\n   |                    |\n   |                  \
    \  expected `f64`, found integer\n   |                    help: use a float literal:\
    \ `0.0`\n\nerror[E0277]: the trait bound `f64: From<i64>` is not satisfied\n \
    \ --> /tmp/tmphfzdpj6b.rs:12:26\n   |\n12 |         return number / (f64::from(1i64)\
    \ as f64);\n   |                          ^^^^^^^^^ the trait `From<i64>` is not\
    \ implemented for `f64`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <f32 as From<i16>>\n             <f32 as From<i8>>\n\
    \             <f32 as From<u16>>\n             <f32 as From<u8>>\n           \
    \  <f64 as From<f32>>\n             <f64 as From<i16>>\n             <f64 as From<i32>>\n\
    \             <f64 as From<i8>>\n           and 67 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphfzdpj6b.rs:7:36\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n...\n15 |     number.p"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number % 1\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmp8gx0lcp1.rs:8:12\n\
    \  |\n8 |     number % 1\n  |            ^ no implementation for `f64 % {integer}`\n\
    \  |\n  = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n            <&'a f32\
    \ as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n\
    \            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n      \
    \      <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a\
    \ isize as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     number % 1.0\n  |            \
    \   ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal = f64::from(number);\n    // `trunc` is rounding\
    \ towards zero.\n    if decimal > 0.99999999999 {\n        // Rounding towards\
    \ zero\n        decimal = decimal.trunc();\n    }\n    decimal\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpfsmklnyw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        number\n    } else {\n        let\
    \ mut digits = number.log10();\n        let remainder = number % 10;\n\n     \
    \   match remainder {\n            0 => number,\n            _ => digits + 1,\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpfi7f9uf8.rs:12:32\n\
    \   |\n12 |         let remainder = number % 10;\n   |                       \
    \         ^ no implementation for `f64 % {integer}`\n   |\n   = help: the trait\
    \ `Rem<{integer}>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         let remainder = number %\
    \ 10.0;\n   |                                    ++\n\nerror[E0277]: cannot add\
    \ `{integer}` to `f64`\n  --> /tmp/tmpfi7f9uf8.rs:16:25\n   |\n16 |          \
    \   _ => digits + 1,\n   |                         ^ no implementation for `f64\
    \ + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n16 |             _ => digits + 1.0,\n   |                      \
    \      ++\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.;\n    let mut fraction = number.truncate();\n\
    \    // First we need to check if the given number is too small\n    while fraction\
    \ >= 1.0 {\n        truncated += 1.0;\n        fraction -= 1.0;\n    }\n    //\
    \ Now we need to check if the given number is too big\n    while fraction > 0.0\
    \ {\n        truncated += 0.5;\n        fraction -= 0.5;\n    }\n    truncated\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp1ji9mf19.rs:9:31\n  |\n9 |     let mut fraction = number.truncate();\n\
    \  |                               ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `trunc`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - std::f64::consts::FRAC_1) as f64\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `FRAC_1` in module `std::f64::consts`\n\
    \ --> /tmp/tmp9ju4xff_.rs:8:33\n  |\n8 |     (number - std::f64::consts::FRAC_1)\
    \ as f64\n  |                                 ^^^^^^ not found in `std::f64::consts`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated: f64 = number;\n    // If number is too big,\
    \ truncate it to next lower integer.\n    if truncated > f64::from((1.0 + EPSILON).sqrt())\
    \ {\n        truncated -= f64::from(1.0)\n    }\n    // Return only the decimal\
    \ part of the number.\n    truncated.trunc()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `EPSILON` in this scope\n  --> /tmp/tmpgnos2ptg.rs:10:37\n\
    \   |\n10 |     if truncated > f64::from((1.0 + EPSILON).sqrt()) {\n   |     \
    \                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::f32::EPSILON;\n \
    \  |\n1  | use std::f64::EPSILON;\n   |\n\nerror[E0689]: can't call method `sqrt`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpgnos2ptg.rs:10:46\n   |\n\
    10 |     if truncated > f64::from((1.0 + EPSILON).sqrt()) {\n   |            \
    \                                  ^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= f64::floor(f64::from(1.0) + f64::from(0.5)) {\n \
    \       return number - f64::floor(f64::from(1.0) + f64::from(0.5));\n    }\n\
    \    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpx_afe8cl.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number / std::f64::from(10.0) * std::f64::from(10.0) as f64\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `from` in module `std::f64`\n --> /tmp/tmpt3v8mt4i.rs:8:24\n\
    \  |\n8 |     number / std::f64::from(10.0) * std::f64::from(10.0) as f64\n  |\
    \                        ^^^^ not found in `std::f64`\n\nerror[E0425]: cannot\
    \ find function `from` in module `std::f64`\n --> /tmp/tmpt3v8mt4i.rs:8:47\n \
    \ |\n8 |     number / std::f64::from(10.0) * std::f64::from(10.0) as f64\n  |\
    \                                               ^^^^ not found in `std::f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number % 1\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpm4b6wo5l.rs:8:12\n\
    \  |\n8 |     number % 1\n  |            ^ no implementation for `f64 % {integer}`\n\
    \  |\n  = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n            <&'a f32\
    \ as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n\
    \            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n      \
    \      <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a\
    \ isize as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     number % 1.0\n  |            \
    \   ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.5 {\n        let mut num: f64 = number;\n      \
    \  while num > 0.5 {\n            num -= 1;\n        }\n        num\n    } else\
    \ {\n        number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract-assign `{integer}` from `f64`\n  --> /tmp/tmp90ojnnrp.rs:11:17\n\
    \   |\n11 |             num -= 1;\n   |                 ^^ no implementation for\
    \ `f64 -= {integer}`\n   |\n   = help: the trait `SubAssign<{integer}>` is not\
    \ implemented for `f64`\n   = help: the following other types implement trait\
    \ `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n             <f32\
    \ as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n\
    \             <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n \
    \            <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |             num -= 1.0;\n   |                     ++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut whole_part = 0;\n    let mut decimal_part = number - whole_part;\n\
    \    while decimal_part < 1.0 {\n        whole_part += 1;\n        decimal_part\
    \ *= 10.0;\n    }\n    whole_part - 1\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n --> /tmp/tmpvdwuut6x.rs:9:35\n\
    \  |\n9 |     let mut decimal_part = number - whole_part;\n  |               \
    \                    ^ no implementation for `f64 - {integer}`\n  |\n  = help:\
    \ the trait `Sub<{integer}>` is not implemented for `f64`\n  = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n            <&'a f32 as Sub<f32>>\n\
    \            <&'a f64 as Sub<f64>>\n            <&'a i128 as Sub<i128>>\n    \
    \        <&'a i16 as Sub<i16>>\n            <&'a i32 as Sub<i32>>\n          \
    \  <&'a i64 as Sub<i64>>\n            <&'a i8 as Sub<i8>>\n            <&'a isize\
    \ as Sub<isize>>\n          and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvdwuut6x.rs:14:5\n   |\n7  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                                    --- expected `f64` because of\
    \ return type\n...\n14 |     whole_part - 1\n   |     ^^^^^^^^^^^^^^ expected\
    \ `f64`, found integer\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let decimals = number.floor();\n    if decimals % 1 == 0 {\n \
    \       // We have an integer part (greater than zero)\n        let integer_part\
    \ = number - decimals;\n        // If the integer part is larger than one - then\
    \ we have decimals\n        // and need to multiply by 10 to get the correct number\
    \ of\n        // digits.\n        let multiplier = if integer_part > 1.0 {\n \
    \           10.0 / integer_part\n        } else {\n            1.0\n        };\n\
    \        let truncated = integer_part * multiplier;\n        truncated\n    }\
    \ else {\n        // We have no decimal part\n        number\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpr8iajc21.rs:9:17\n\
    \  |\n9 |     if decimals % 1 == 0 {\n  |                 ^ no implementation\
    \ for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n9\
    \ |     if decimals % 1.0 == 0 {\n  |                    ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result > 0 {\n      \
    \  result = result.fract();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpokiwqlka.rs:9:17\n  |\n9 |\
    \     if result > 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - std::f64::consts::FRAC_1\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `FRAC_1` in module `std::f64::consts`\n\
    \ --> /tmp/tmpmur8hknb.rs:8:32\n  |\n8 |     number - std::f64::consts::FRAC_1\n\
    \  |                                ^^^^^^ not found in `std::f64::consts`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpbkbl16dl.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmphie8av2a.rs:8:12\n  |\n8 |     number.trunc_f64()\n  | \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let decimal = number % 1;\n    if decimal < 0.5 {\n        number\n\
    \    } else {\n        number - decimal\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpe24dcy73.rs:8:26\n\
    \  |\n8 |     let decimal = number % 1;\n  |                          ^ no implementation\
    \ for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     let decimal = number % 1.0;\n  |                             ++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > f64::from::EPSILON {\n        // number is already\
    \ truncated\n        return number;\n    }\n    let mut n = f64::from::from(number);\n\
    \    n -= n.truncate() / f64::from::from(10);\n    n\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0223]: ambiguous associated type\n --> /tmp/tmp4aaj9rnz.rs:8:17\n\
    \  |\n8 |     if number > f64::from::EPSILON {\n  |                 ^^^^^^^^^\
    \ help: use fully-qualified syntax: `<f64 as Trait>::from`\n\nerror[E0223]: ambiguous\
    \ associated type\n  --> /tmp/tmp4aaj9rnz.rs:12:17\n   |\n12 |     let mut n =\
    \ f64::from::from(number);\n   |                 ^^^^^^^^^ help: use fully-qualified\
    \ syntax: `<f64 as Trait>::from`\n\nerror[E0223]: ambiguous associated type\n\
    \  --> /tmp/tmp4aaj9rnz.rs:13:25\n   |\n13 |     n -= n.truncate() / f64::from::from(10);\n\
    \   |                         ^^^^^^^^^ help: use fully-qualified syntax: `<f64\
    \ as Trait>::from`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0223`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer = number.trunc().unwrap_or(0);\n    (number - integer).div(10.0)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap_or` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp1bja6zbl.rs:8:34\n  |\n8 |     let integer = number.trunc().unwrap_or(0);\n\
    \  |                                  ^^^^^^^^^ method not found in `f64`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let remainder = number.trunc();\n\n    if number < remainder {\n\
    \        remainder\n    } else {\n        remainder - 1.0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.0`,\n right: `0.5`', /tmp/tmp4g8xofdb.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let num = number.floor() as f64;\n    let decimal = number.fract();\n\
    \    if decimal < 1 {\n        num\n    } else {\n        num + decimal\n    }\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4972t6i6.rs:10:18\n   |\n\
    10 |     if decimal < 1 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `f64`, found integer\n   |                  help:\
    \ use a float literal: `1.0`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number {\n        0.0 => 0.0,\n        1.0 => 1.0,\n   \
    \     x if x >= 1.0 => x,\n        x if x < 1.0 => 1.0,\n        x if x < 1.5\
    \ => x.floor(),\n        x if x < 2.0 => 1.0,\n        x if x < 2.5 => 1.5,\n\
    \        x if x < 3.0 => x,\n        x if x < 3.5 => x.floor(),\n        x if\
    \ x < 4.0 => 1.5,\n        x if x < 4.5 => 2.0,\n        x if x < 5.0 => 2.5,\n\
    \        x if x < 5.5 => 3.0,\n        x if x < 6.0 => 3.5,\n        x if x <\
    \ 6.5 => 4.0,\n        x if x < 7.0 => 4.5,\n        x if x < 7.5 => 5.0,\n  \
    \      x if x < 8.0 => 5.5,\n        x if x < 8.5 => 6.0,\n        x if x < 9.0\
    \ => 6.5,\n        x if x < 9.5 => 7.0,\n        x if x < 10.0 => 7.5,\n     \
    \   x if x < 10.5 => 8.0,\n        x if x < 11.0 => 8.5,\n        x if x < 11.5\
    \ => 9.0,\n        x if x < 12.0 => 9.5,\n        x if x < 12.5 => 10.0,\n   \
    \     x if x < 13.0 => 10.5,\n        x if x < 13.5 => 11.0,\n        x if x <\
    \ 14.0 => 11.5,\n        x if x < 14.5 => 12.0,\n        x if x < 15.0 => 12.5,\n\
    \        x if x < 15.5 => 13.0,\n        x if x < 16.0 => 13.5,\n        x if\
    \ x < 16.5 => 14.0,\n        x if x < 17.0 => 14.5,\n        x if x < 17.5 =>\
    \ 15.0,\n        x if x < 18.0 => 15.5,\n        x if x < 18.5 => 16.0,\n    \
    \    x if x < 19.0 => 16.5,\n        x if x < 19.5 => 17.0,\n        x if x <\
    \ 20.0 => 17.5,\n        x if x < 20.5 => 18.0,\n        x if x < 21.0 => 18.5,\n\
    \        x if x < 21.0 => 19.0,\n        x if x < 21.5 => 19.5,\n        x if\
    \ x < 22.0 => 20.0,\n        x if x < 22.5 => 20.5,\n        x if x < 23.0 =>\
    \ 21.0,\n        x if x < 23.5 => 21.5,\n        x if x < 24.0 => 22.0,\n    \
    \    x if x < 24.5 => 22.5,\n        x \n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbqq_bufk.rs:69:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n8  |     match number {\n   |    \
    \              - this delimiter might not be properly closed...\n...\n62 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n69 | }\n\
    \   |   ^\n\nerror: expected one of `=>`, `@`, `if`, or `|`, found `}`\n  -->\
    \ /tmp/tmpbqq_bufk.rs:62:1\n   |\n61 |         x \n   |          - expected one\
    \ of `=>`, `@`, `if`, or `|`\n62 | }\n   | ^ unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbqq_bufk.rs:8:5\n   |\n8  | /     match number\
    \ {\n9  | |         0.0 => 0.0,\n10 | |         1.0 => 1.0,\n11 | |         x\
    \ if x >= 1.0 => x,\n...  |\n61 | |         x \n62 | | }\n   | | ^- help: consider\
    \ using a semicolon here\n   | |_|\n   |   expected `()`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpbqq_bufk.rs:7:36\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number % 1.0)\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpvxqt6ge6.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number % 1 == 0 {\n        return number as f64;\n    }\n \
    \   let mut f = number;\n    f /= 1;\n    f - 0.5\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpz9inwdkx.rs:8:15\n\
    \  |\n8 |     if number % 1 == 0 {\n  |               ^ no implementation for\
    \ `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     if number % 1.0 == 0 {\n  |                  ++\n\nerror[E0277]: cannot\
    \ divide-assign `f64` by `{integer}`\n  --> /tmp/tmpz9inwdkx.rs:12:7\n   |\n12\
    \ |     f /= 1;\n   |       ^^ no implementation for `f64 /= {integer}`\n   |\n\
    \   = help: the trait `DivAssign<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `DivAssign<Rhs>`:\n      \
    \       <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n          \
    \   <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n             <i128\
    \ as DivAssign<&i128>>\n             <i128 as DivAssign>\n             <i16 as\
    \ DivAssign<&i16>>\n             <i16 as DivAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    12 |     f /= 1.0;\n   |           ++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut x = number;\n    let mut d = 0;\n    while x > 1.0 {\n\
    \        x /= 10.0;\n        d += 1;\n    }\n    x / 10.0 as f64\n        + &(0.001\
    \ * d - 1.0) as f64 * x as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot multiply `{float}` by `{integer}`\n  --> /tmp/tmp3cgkcriv.rs:15:19\n\
    \   |\n15 |         + &(0.001 * d - 1.0) as f64 * x as f64\n   |             \
    \      ^ no implementation for `{float} * {integer}`\n   |\n   = help: the trait\
    \ `Mul<{integer}>` is not implemented for `{float}`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // If the number is very small, just return the number itself.\n\
    \    if number < 1.0 {\n        return number;\n    }\n\n    // The number can\
    \ only have at most one decimal point (no more, no less).\n    if number >= 1.0\
    \ {\n        return number;\n    }\n\n    // Find the right most digit after the\
    \ decimal point.\n    // That digit cannot be too small and can not be too big.\n\
    \    let mut right_digit: usize = 0;\n    for digit in number.iter() {\n     \
    \   right_digit += digit;\n    }\n    right_digit -= 1;\n\n    // Truncate all\
    \ the digits after the decimal point.\n    // The remainder is always smaller\
    \ than 1, and can be discarded.\n    let trunc_number = number - number.truncate(right_digit);\n\
    \n    // If the truncated number is still too small, just return the number itself.\n\
    \    if trunc_number < 1.0 {\n        return number;\n    }\n\n    // If the truncated\
    \ number is still too big, add one to it.\n    // That is what we want.\n    //\
    \ This also serves as a guard against the case when the number is exactly 1.0.\n\
    \    if trunc_number > 1.0 {\n        return number + 1.0;\n    }\n\n    // The\
    \ number is now small enough, just return the truncated number.\n    return trunc_number;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp23_ulvwi.rs:21:25\n   |\n21 |     for digit in number.iter()\
    \ {\n   |                         ^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `truncate` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp23_ulvwi.rs:28:40\n   |\n28 |     let trunc_number = number - number.truncate(right_digit);\n\
    \   |                                        ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `trunc`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpxiw3l1t9.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let result = number.trunc_div(1);\n    if result == 0 || result\
    \ > number {\n        result\n    } else {\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_div` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpmqtg30_t.rs:8:25\n  |\n8 |     let result = number.trunc_div(1);\n\
    \  |                         ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror[E0277]: can't compare `f64` with `{integer}`\n\
    \ --> /tmp/tmpmqtg30_t.rs:9:15\n  |\n9 |     if result == 0 || result > number\
    \ {\n  |               ^^ no implementation for `f64 == {integer}`\n  |\n  = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `f64`\n  = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n            f32\n \
    \           f64\n            i128\n            i16\n            i32\n        \
    \    i64\n            i8\n            isize\n          and 6 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n  |\n9 |     if result\
    \ == 0.0 || result > number {\n  |                   ++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let dec = number.trunc();\n    match dec.cmp(f64::MIN) {\n   \
    \     Ordering::Greater => dec.ceil(),\n        Ordering::Less => dec,\n    }\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpxha8e35f.rs:10:9\n   |\n10 |         Ordering::Greater => dec.ceil(),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpxha8e35f.rs:11:9\n\
    \   |\n11 |         Ordering::Less => dec,\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0599]: `f64` is not an iterator\n --> /tmp/tmpxha8e35f.rs:9:15\n\
    \  |\n9 |     match dec.cmp(f64::MIN) {\n  |               ^^^ `f64` is not an\
    \ iterator\n  |\n  = note: the following trait bounds were not satisfied:\n  \
    \        `f64: Iterator`\n          which is required by `&mut f64: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut parts = number.trunc_parts() as f64;\n    let decimal_part\
    \ = match parts.len() {\n        1 => None,\n        _ => parts[parts.len() -\
    \ 1] as f64\n    };\n    parts.pop();\n    parts.unwrap_or(decimal_part)\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_parts` found for type `f64` in the\
    \ current scope\n --> /tmp/tmpwyge3cdb.rs:8:28\n  |\n8 |     let mut parts = number.trunc_parts()\
    \ as f64;\n  |                            ^^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().rem().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rem` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpoicz_zgq.rs:8:20\n    |\n8   |     number.trunc().rem().unwrap()\n\
    \    |                    ^^^ method not found in `f64`\n    |\n    = help: items\
    \ from traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n    |\n1   | use\
    \ std::ops::Rem;\n    |\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let digits: Vec<_> = (number.to_string().chars()\n        .filter_map(|c|\
    \ if c == '.' { Some(0) } else { Some(1) }))\n        .collect();\n    let mut\
    \ decimal_part: f64 = 0;\n    for i in 0..digits.len() {\n        if digits[i]\
    \ < 0 {\n            decimal_part /= 10;\n        } else {\n            break;\n\
    \        }\n    }\n    return number\n        .roundf(std::f64::MAX)\n       \
    \ .min(std::f64::MAX)\n        .unwrap_or(decimal_part);\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_gekhe85.rs:11:33\n   |\n\
    11 |     let mut decimal_part: f64 = 0;\n   |                           ---  \
    \ ^\n   |                           |     |\n   |                           |\
    \     expected `f64`, found integer\n   |                           |     help:\
    \ use a float literal: `0.0`\n   |                           expected due to this\n\
    \nerror[E0277]: cannot divide-assign `f64` by `{integer}`\n  --> /tmp/tmp_gekhe85.rs:14:26\n\
    \   |\n14 |             decimal_part /= 10;\n   |                          ^^\
    \ no implementation for `f64 /= {integer}`\n   |\n   = help: the trait `DivAssign<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n           \
    \  <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n             <f64\
    \ as DivAssign>\n             <i128 as DivAssign<&i128>>\n             <i128 as\
    \ DivAssign>\n             <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n\
    \           and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n14 |             decimal_part /= 10.0;\n   |           \
    \                    ++\n\nerror[E0599]: no method named `roundf` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp_gekhe85.rs:20:10\n   |\n20 |    \
    \     .roundf(std::f64::MAX)\n   |          ^^^^^^ help: there is an associated\
    \ function with a similar name: `round`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // If number is not less than 1, return number\n    if number\
    \ < 1.0 {\n        return number;\n    }\n\n    // If number is negative, return\
    \ zero\n    if number < 0.0 {\n        return 0.0;\n    }\n\n    let mut power\
    \ = 0.0;\n\n    let mut number_as_str = number.to_string();\n\n    // Remove decimal\
    \ part from number\n    number_as_str = number_as_str.split('.').last().unwrap();\n\
    \n    // Find largest integer smaller than given number\n    for power in 1..=NUMBER_SAFE_DECIMAL_DIGITS\
    \ {\n        if number.floor() < std::pow(10.0, power) {\n            break;\n\
    \        }\n    }\n\n    // Find leftover part of the number\n    let mut leftover_digits\
    \ = number_as_str.len();\n    for power in 1..=NUMBER_SAFE_DECIMAL_DIGITS {\n\
    \        if number < std::pow(10.0, power) {\n            break;\n        }\n\
    \        leftover_digits += power;\n    }\n\n    // Return number\n    if leftover_digits\
    \ < NUMBER_SAFE_DECIMAL_DIGITS {\n        return number;\n    }\n\n    if leftover_digits\
    \ == NUMBER_SAFE_DECIMAL_DIGITS {\n        return number;\n    }\n\n    // Truncate\
    \ number to an integer part\n    let mut left_shift = NUMBER_SAFE_DECIMAL_DIGITS\
    \ - leftover_digits;\n    number = number / std::pow(10.0, left_shift);\n\n  \
    \  // Add decimal part if required\n    if left_shift > 0 {\n        number =\
    \ number + std::pow(10.0, left_shift);\n    }\n\n    number\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `NUMBER_SAFE_DECIMAL_DIGITS` in this scope\n\
    \  --> /tmp/tmpp9xcbcbw.rs:26:22\n   |\n26 |     for power in 1..=NUMBER_SAFE_DECIMAL_DIGITS\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `pow` in crate `std`\n  --> /tmp/tmpp9xcbcbw.rs:27:34\n\
    \   |\n27 |         if number.floor() < std::pow(10.0, power) {\n   |        \
    \                          ^^^ not found in `std`\n\nerror[E0425]: cannot find\
    \ value `NUMBER_SAFE_DECIMAL_DIGITS` in this scope\n  --> /tmp/tmpp9xcbcbw.rs:34:22\n\
    \   |\n34 |     for power in 1..=NUMBER_SAFE_DECIMAL_DIGITS {\n   |          \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `pow` in crate `std`\n  --> /tmp/tmpp9xcbcbw.rs:35:26\n\
    \   |\n35 |         if number < std::pow(10.0, power) {\n   |                \
    \          ^^^ not found in `std`\n\nerror[E0425]: cannot find value `NUMBER_SAFE_DECIMAL_DIGITS`\
    \ in this scope\n  --> /tmp/tmpp9xcbcbw.rs:42:26\n   |\n42 |     if leftover_digits\
    \ < NUMBER_SAFE_DECIMAL_DIGITS {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `NUMBER_SAFE_DECIMAL_DIGITS`\
    \ in this scope\n  --> /tmp/tmpp9xcbcbw.rs:46:27\n   |\n46 |     if leftover_digits\
    \ == NUMBER_SAFE_DECIMAL_DIGITS {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `NUMBER_SAFE_DECIMAL_DIGITS`\
    \ in this scope\n  --> /tmp/tmpp9xcbcbw.rs:51:26\n   |\n51 |     let mut left_shift\
    \ = NUMBER_SAFE_DECIMAL_DIGITS - leftover_digits;\n   |                      \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `pow` in crate `std`\n  --> /tmp/tmpp9xcbcbw.rs:52:28\n   |\n\
    52 |     number = number / std::pow(10.0, left_shift);\n   |                 \
    \           ^^^ not found in `std`\n\nerror[E0425]: cannot find function `pow`\
    \ in crate `std`\n  --> /tmp/tmpp9xcbcbw.rs:56:32\n   |\n56 |         number =\
    \ number + std::pow(10.0, left_shift);\n   |            "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number\n        .trunc()\n        .unwrap()\n        .try_into()\n\
    \        .unwrap()\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpy6t5twdo.rs:10:10\n   |\n10 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.floor() {\n        0.0 => 0.0,\n        n if n <\
    \ 0.1 => 0.0,\n        n => n,\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp5x4aul6n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimals) = number.trunc_f64();\n    if number >\
    \ trunc_value(number) {\n        number\n    } else {\n        trunc_value(number).try_into().unwrap_or(integer)\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `trunc_value` in this scope\n --> /tmp/tmpqesny2h4.rs:9:17\n\
    \  |\n9 |     if number > trunc_value(number) {\n  |                 ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `trunc_value`\
    \ in this scope\n  --> /tmp/tmpqesny2h4.rs:12:9\n   |\n12 |         trunc_value(number).try_into().unwrap_or(integer)\n\
    \   |         ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `trunc_f64` found for type `f64` in the current scope\n --> /tmp/tmpqesny2h4.rs:8:38\n\
    \  |\n8 |     let (integer, decimals) = number.trunc_f64();\n  |             \
    \                         ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number as f64 - truncate_float_part(number as f64) as f64\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `truncate_float_part` in this scope\n\
    \ --> /tmp/tmpkjzrxc92.rs:8:21\n  |\n8 |     number as f64 - truncate_float_part(number\
    \ as f64) as f64\n  |                     ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut int: f64 = 0;\n    let mut decimal: f64 = 0;\n    if number\
    \ < 0 {\n        int = -number;\n    } else {\n        int = number;\n    }\n\
    \    decimal = (int % 1.0).floor() as f64;\n    if decimal >= 1.0 {\n        decimal\
    \ -= 1.0;\n        int = (int % 1.0).floor() as f64;\n    }\n    int\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpozkoogha.rs:8:24\n  |\n8 |\
    \     let mut int: f64 = 0;\n  |                  ---   ^\n  |               \
    \   |     |\n  |                  |     expected `f64`, found integer\n  |   \
    \               |     help: use a float literal: `0.0`\n  |                  expected\
    \ due to this\n\nerror[E0308]: mismatched types\n --> /tmp/tmpozkoogha.rs:9:28\n\
    \  |\n9 |     let mut decimal: f64 = 0;\n  |                      ---   ^\n  |\
    \                      |     |\n  |                      |     expected `f64`,\
    \ found integer\n  |                      |     help: use a float literal: `0.0`\n\
    \  |                      expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpozkoogha.rs:10:17\n   |\n10 |     if number < 0 {\n   |       \
    \          ^\n   |                 |\n   |                 expected `f64`, found\
    \ integer\n   |                 help: use a float literal: `0.0`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        return -number\n    }\n    number\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsd1lcgnn.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mantissa = number as f64;\n\n    if mantissa > 1.0 {\n   \
    \     return number; // number is bigger than 1\n    }\n\n    let exponent = std::i32::MAX\
    \ as usize;\n\n    let mantissa_truncated = mantissa as f64 / (f64::powf(f64::ONE,\
    \ exponent) - 1.0);\n\n    return mantissa_truncated;\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `ONE` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpqaxuvqkz.rs:16:64\n   |\n16 |     let mantissa_truncated\
    \ = mantissa as f64 / (f64::powf(f64::ONE, exponent) - 1.0);\n   |           \
    \                                                     ^^^ associated item not\
    \ found in `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqaxuvqkz.rs:16:69\n\
    \   |\n16 |     let mantissa_truncated = mantissa as f64 / (f64::powf(f64::ONE,\
    \ exponent) - 1.0);\n   |                                                    \
    \                 ^^^^^^^^ expected `f64`, found `usize`\n   |\nhelp: you can\
    \ cast a `usize` to an `f64`, producing the floating point representation of the\
    \ integer, rounded if necessary\n   |\n16 |     let mantissa_truncated = mantissa\
    \ as f64 / (f64::powf(f64::ONE, exponent as f64) - 1.0);\n   |               \
    \                                                               ++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (num, denom) = number.trunc();\n    num / (f64::from(denom)\
    \ + 1.0)\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5g69t4jk.rs:8:9\n  |\n8 |\
    \     let (num, denom) = number.trunc();\n  |         ^^^^^^^^^^^^   --------------\
    \ this expression has type `f64`\n  |         |\n  |         expected `f64`, found\
    \ tuple\n  |\n  = note: expected type `f64`\n            found tuple `(_, _)`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut n = number;\n    let sign = if n.is_negative() { 1.0 }\
    \ else { -1.0 };\n    n -= sign * n.abs();\n\n    if n < 0.0 {\n        // negative\
    \ number can't have decimals\n        n = -n / &sign;\n    }\n\n    n\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7.0`,\n right: `0.5`', /tmp/tmpxj2cod3b.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut res = 0.0;\n    let mut remain = number;\n\n    loop {\n\
    \        if remain < 1.0 {\n            break;\n        }\n        let n = remain\
    \ as f64;\n        res += n / 10.0;\n        remain = n - res * 10.0;\n    }\n\
    \n    res\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.35`,\n right: `0.5`', /tmp/tmpv4l16obk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number / (1.0 - 1.0e-10)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.50000000035`,\n right: `0.5`', /tmp/tmpe_kntke3.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals: f64 = 0.0;\n    number.ln();\n    number < 1.0\
    \ {\n        number.f64().rsqrt() * number.f64()\n            .rsqrt() * number\n\
    \            .f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n            .min(number.f64())\n            .max(1.0)\n\
    \            .max(&mut decimals)\n            .max(&mut decimals)\n          \
    \  .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() * number.f64().rsqrt()\
    \ * number.f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n            .min(number.f64())\n            .max(1.0)\n\
    \            .max(&mut decimals)\n            .max(&mut decimals)\n          \
    \  .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() * number.f64().rsqrt()\
    \ * number.f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n            .min(number.f64())\n            .max(1.0)\n\
    \            .max(&mut decimals)\n            .max(&mut decimals)\n          \
    \  .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() * number.f64().rsqrt()\
    \ * number.f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n            .min(number.f64())\n            .max(1.0)\n\
    \            .max(&mut decimals)\n            .max(&mut decimals)\n          \
    \  .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() * number.f64().rsqrt()\
    \ * number.f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n            .min(number.f64())\n            .max(1.0)\n\
    \            .max(&mut decimals)\n            .max(&mut decimals)\n          \
    \  .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() * number.f64().rsqrt()\
    \ * number.f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n            .min(number.f64())\n            .max(1.0)\n\
    \            .max(&mut decimals)\n            .max(&mut decimals)\n          \
    \  .max()\n    }\n    number < 1.0 {\n        number.f64().rsqrt() * number.f64().rsqrt()\
    \ * number.f64()\n            .rsqrt()\n            .round()\n            .floor()\n\
    \            .ceil()\n\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp_qcif8z.rs:98:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n...\n84 |     number < 1.0 {\n   |\
    \                  - this delimiter might not be properly closed...\n...\n91 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n98 |\
    \ }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found\
    \ `{`\n  --> /tmp/tmpp_qcif8z.rs:7:40\n   |\n7  | fn truncate_number(number: f64)\
    \ -> f64 {\n   |                                        ^ unclosed delimiter\n\
    ...\n10 |     number < 1.0 {\n   |                 -^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n   |                 |\n   |                 help:\
    \ `}` may belong here\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number.abs();\n    let mut truncated: f64\
    \ = 0.0;\n    let mut quotient = f64::max_value();\n    while remainder > 0 {\n\
    \        remainder = (remainder % 1).clone();\n        truncated = truncated +\
    \ (quotient / remainder);\n        quotient = quotient * 0.0;\n    }\n    truncated\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `max_value` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpk4e4nrcm.rs:10:29\n   |\n10 |\
    \     let mut quotient = f64::max_value();\n   |                             ^^^^^^^^^\
    \ function or associated item not found in `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk4e4nrcm.rs:11:23\n   |\n11 |     while remainder > 0 {\n   | \
    \                      ^\n   |                       |\n   |                 \
    \      expected `f64`, found integer\n   |                       help: use a float\
    \ literal: `0.0`\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpk4e4nrcm.rs:12:32\n\
    \   |\n12 |         remainder = (remainder % 1).clone();\n   |               \
    \                 ^ no implementation for `f64 % {integer}`\n   |\n   = help:\
    \ the trait `Rem<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n12 |         remainder\
    \ = (remainder % 1.0).clone();\n   |                                   ++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut res = number.abs();\n    let mut pow = 1;\n    loop {\n\
    \        if res < pow * 10 {\n            res /= pow;\n            break;\n  \
    \      }\n        pow *= 10;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpncdk06je.rs:11:18\n   |\n\
    11 |         if res < pow * 10 {\n   |                  ^^^^^^^^ expected `f64`,\
    \ found integer\n\nerror[E0277]: cannot divide-assign `f64` by `{integer}`\n \
    \ --> /tmp/tmpncdk06je.rs:12:17\n   |\n12 |             res /= pow;\n   |    \
    \             ^^ no implementation for `f64 /= {integer}`\n   |\n   = help: the\
    \ trait `DivAssign<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n\
    \             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n    \
    \         <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n      \
    \       <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n         \
    \    <i16 as DivAssign>\n           and 20 others\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (_, fraction) = f64::from(number).div_rem(1.0);\n    return\
    \ fraction;\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `div_rem` found for type `f64` in the current\
    \ scope\n --> /tmp/tmph__vn840.rs:8:43\n  |\n8 |     let (_, fraction) = f64::from(number).div_rem(1.0);\n\
    \  |                                           ^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut precision = number.trunc().ceil() as i32;\n\n    if precision\
    \ >= 1 && precision <= 63 {\n        return number;\n    }\n\n    let mut whole_number\
    \ = number.truncate() as i32;\n\n    // If the whole number is < 0, then it's\
    \ 0.\n    if whole_number < 0 {\n        whole_number = 0;\n    }\n\n    // Remove\
    \ trailing zeros.\n    while whole_number == 0 {\n        whole_number += 1;\n\
    \        precision -= 1;\n    }\n\n    // Remove trailing zeros.\n    while whole_number\
    \ == 0 {\n        whole_number -= 1;\n        precision += 1;\n    }\n\n    //\
    \ Add one if the decimal part is 0.\n    if precision == 0 {\n        precision\
    \ += 1;\n    }\n\n    whole_number /= pow(10.0, precision as usize);\n\n    whole_number\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpoinqqag1.rs:38:21\n\
    \   |\n38 |     whole_number /= pow(10.0, precision as usize);\n   |         \
    \            ^^^ not found in this scope\n\nerror[E0599]: no method named `truncate`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpoinqqag1.rs:14:35\n\
    \   |\n14 |     let mut whole_number = number.truncate() as i32;\n   |       \
    \                            ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoinqqag1.rs:40:5\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n40 |     whole_number\n\
    \   |     ^^^^^^^^^^^^ expected `f64`, found integer\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    let mut remainder = number.fract();\n\
    \    while remainder.is_zero() {\n        result = result - 1.0; // don't allow\
    \ to lose precision\n        remainder = remainder - 1.0; // don't allow to lose\
    \ precision\n    }\n    while remainder.is_integer() {\n        result = result\
    \ + 1.0; // don't allow to lose precision\n        remainder = remainder - 1.0;\
    \ // don't allow to lose precision\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp1o72ik8m.rs:10:21\n   |\n10 |     while remainder.is_zero()\
    \ {\n   |                     ^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp1o72ik8m.rs:14:21\n   |\n14 |     while remainder.is_integer() {\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    if remainder > 1 {\n        let\
    \ mut i = 1;\n        while remainder > 1.0 {\n            remainder /= 10.0;\n\
    \            i += 1;\n        }\n        remainder = remainder - i;\n    }\n \
    \   remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcxi_yk9h.rs:9:20\n  |\n9 |\
    \     if remainder > 1 {\n  |                    ^\n  |                    |\n\
    \  |                    expected `f64`, found integer\n  |                   \
    \ help: use a float literal: `1.0`\n\nerror[E0277]: cannot subtract `{integer}`\
    \ from `f64`\n  --> /tmp/tmpcxi_yk9h.rs:15:31\n   |\n15 |         remainder =\
    \ remainder - i;\n   |                               ^ no implementation for `f64\
    \ - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number as f64).trunc()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpwjqshe7n.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().unwrap_or(number)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap_or` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpx4mzogcu.rs:8:20\n  |\n8 |     number.trunc().unwrap_or(number)\n\
    \  |                    ^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().sqrt().round() as f64\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.0`,\n right: `0.5`', /tmp/tmpvh9mefss.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated: f64 = 0.0;\n    let mut remainder: f64 = number;\n\
    \    loop {\n        let mut pow = 1;\n        let mut remainder_pow = 1;\n  \
    \      while remainder_pow <= remainder {\n            pow *= 10;\n          \
    \  remainder_pow *= 10;\n        }\n        truncated = truncated.saturating_add(pow\
    \ * remainder);\n        remainder = remainder.saturating_div(remainder_pow);\n\
    \    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpijstxfaa.rs:13:32\n   |\n\
    13 |         while remainder_pow <= remainder {\n   |                        \
    \        ^^^^^^^^^ expected integer, found `f64`\n\nerror[E0277]: can't compare\
    \ `{integer}` with `f64`\n  --> /tmp/tmpijstxfaa.rs:13:29\n   |\n13 |        \
    \ while remainder_pow <= remainder {\n   |                             ^^ no implementation\
    \ for `{integer} < f64` and `{integer} > f64`\n   |\n   = help: the trait `PartialOrd<f64>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0599]: no method named `saturating_add`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpijstxfaa.rs:17:31\n\
    \   |\n17 |         truncated = truncated.saturating_add(pow * remainder);\n \
    \  |                               ^^^^^^^^^^^^^^ method not found in `f64`\n\n\
    error[E0277]: cannot multiply `{integer}` by `f64`\n  --> /tmp/tmpijstxfaa.rs:17:50\n\
    \   |\n17 |         truncated = truncated.saturating_add(pow * remainder);\n \
    \  |                                                  ^ no implementation for\
    \ `{integer} * f64`\n   |\n   = help: the trait `Mul<f64>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0599]: no method named `saturating_div` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpijstxfaa.rs:18:31\n   |\n18 |         remainder\
    \ = remainder.saturating_div(remainder_pow);\n   |                           \
    \    ^^^^^^^^^^^^^^ method not found in `f64`\n\nwarning: unreachable expression\n\
    \  --> /tmp/tmpijstxfaa.rs:20:5\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exp = 0;\n    let mut bits = number.abs();\n    if bits\
    \ < std::i64::MIN as f64 {\n        exp = std::i32::MAX;\n        bits = bits\
    \ + std::i32::MAX;\n    }\n    let mut decimal_part = bits % std::i32::MAX;\n\
    \    if decimal_part == 0 {\n        decimal_part = std::i32::MAX;\n    } else\
    \ {\n        exp += std::i32::MAX - decimal_part;\n    }\n    decimal_part / std::i32::MAX\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `i32` to `f64`\n  --> /tmp/tmp3aoxutdj.rs:12:21\n\
    \   |\n12 |         bits = bits + std::i32::MAX;\n   |                     ^ no\
    \ implementation for `f64 + i32`\n   |\n   = help: the trait `Add<i32>` is not\
    \ implemented for `f64`\n   = help: the following other types implement trait\
    \ `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n\
    \             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n  \
    \           <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n      \
    \       <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: cannot mod `f64` by `i32`\n  --> /tmp/tmp3aoxutdj.rs:14:33\n\
    \   |\n14 |     let mut decimal_part = bits % std::i32::MAX;\n   |           \
    \                      ^ no implementation for `f64 % i32`\n   |\n   = help: the\
    \ trait `Rem<i32>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3aoxutdj.rs:20:5\n   |\n7  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                                    --- expected `f64` because of\
    \ return type\n...\n20 |     decimal_part / std::i32::MAX\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `f64`, found `i32`\n   |\nhelp: you can convert an `i32` to an `f64`,\
    \ producing the floating point representation of the integer\n   |\n20 |     (decimal_part\
    \ / std::i32::MAX).into()\n   |     +                            ++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number as i64 / 10 as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide `i64` by `f64`\n --> /tmp/tmpouitk6d7.rs:8:19\n\
    \  |\n8 |     number as i64 / 10 as f64\n  |                   ^ no implementation\
    \ for `i64 / f64`\n  |\n  = help: the trait `Div<f64>` is not implemented for\
    \ `i64`\n  = help: the following other types implement trait `Div<Rhs>`:\n   \
    \         <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n         \
    \   <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n            <&'a\
    \ i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n            <&'a i8 as\
    \ Div<i8>>\n            <&'a isize as Div<isize>>\n          and 54 others\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Get integer part and decimals\n    let (integer, decimals)\
    \ = number.trunc();\n\n    // Return decimal part of number\n    decimals\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbxyg0f1w.rs:9:9\n  |\n9 |\
    \     let (integer, decimals) = number.trunc();\n  |         ^^^^^^^^^^^^^^^^^^^\
    \   -------------- this expression has type `f64`\n  |         |\n  |        \
    \ expected `f64`, found tuple\n  |\n  = note: expected type `f64`\n          \
    \  found tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // The largest possible integer smaller than the number.\n   \
    \ let mut int_part = std::f64::MAX;\n\n    // The leftover part will always have\
    \ one unit of precision.\n    let mut decimal_part = number.floor() as f64;\n\n\
    \    // Decompose the floating point number into the integer part and the decimal\
    \ part.\n    if decimal_part > 0.1 {\n        let mut dec = decimal_part - std::f64::EPSILON;\n\
    \        // While the decimal part is larger than 1, add it to int_part and dec\
    \ by 1 unit.\n        while dec > std::f64::EPSILON {\n            int_part +=\
    \ 1;\n            dec -= std::f64::EPSILON;\n        }\n        // Add the leftover\
    \ part to int_part.\n        int_part += dec;\n        // Add 1 to account for\
    \ the number being rounded up and subtract 1 for\n        // the number being\
    \ rounded down.\n        int_part -= 1;\n    }\n    // Return number if there\
    \ are no decimals left to return.\n    number\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `{integer}` to `f64`\n  --> /tmp/tmpn81dp_4l.rs:19:22\n\
    \   |\n19 |             int_part += 1;\n   |                      ^^ no implementation\
    \ for `f64 += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \            <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n19 |             int_part += 1.0;\n   |                \
    \          ++\n\nerror[E0277]: cannot subtract-assign `{integer}` from `f64`\n\
    \  --> /tmp/tmpn81dp_4l.rs:26:18\n   |\n26 |         int_part -= 1;\n   |    \
    \              ^^ no implementation for `f64 -= {integer}`\n   |\n   = help: the\
    \ trait `SubAssign<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n\
    \             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n    \
    \         <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n      \
    \       <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n         \
    \    <i16 as SubAssign>\n           and 20 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n26 |         int_part -= 1.0;\n   | \
    \                     ++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let num = number.trunc();\n    if number - num == 0.0 {\n    \
    \    num\n    } else {\n        num\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp2ooxgp0j.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut n = number;\n    let mut exp = number.exp();\n    loop\
    \ {\n        if exp >= -10.0 {\n            break;\n        }\n        n = f64::from(n.div(2.0).floor());\n\
    \        exp += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `div` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpaq_kf7cs.rs:14:25\n    |\n14  |         n = f64::from(n.div(2.0).floor());\n\
    \    |                         ^^^ method not found in `f64`\n    |\n    = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n\
    1   | use std::ops::Div;\n    |\n\nerror[E0277]: cannot add-assign `{integer}`\
    \ to `f64`\n  --> /tmp/tmpaq_kf7cs.rs:15:13\n   |\n15 |         exp += 1;\n  \
    \ |             ^^ no implementation for `f64 += {integer}`\n   |\n   = help:\
    \ the trait `AddAssign<{integer}>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n15 |         exp += 1.0;\n\
    \   |                 ++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number;\n    }\n    let mut\
    \ remainder = number.remainder(1.0 as f64);\n    if remainder.is_zero() {\n  \
    \      return 0.0;\n    }\n    let mut decimals = 0.0;\n    while remainder >=\
    \ 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n    }\n    remainder\
    \ -= decimals;\n    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `remainder` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpw0imphah.rs:11:32\n   |\n11 |     let mut remainder = number.remainder(1.0\
    \ as f64);\n   |                                ^^^^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > f64::max_value() {\n        number\n    } else {\n\
    \        number.floor() as f64\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `max_value` found for\
    \ type `f64` in the current scope\n --> /tmp/tmpjustjz0e.rs:8:22\n  |\n8 |   \
    \  if number > f64::max_value() {\n  |                      ^^^^^^^^^ function\
    \ or associated item not found in `f64`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exp = std::i32::MAX;\n\n    if number.is_normal() {\n\
    \        exp = 0;\n    } else if number.is_integer() {\n        number.cmp(&number.floor())\
    \ < 0 && number.cmp(&number.ceil()) > 0 {\n            exp = 0;\n        } else\
    \ {\n            exp = 1;\n        }\n    } else {\n        exp = std::i32::MAX;\n\
    \    }\n\n    number.exp(exp)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n\
    \  --> /tmp/tmpcf_6473j.rs:13:75\n   |\n13 |         number.cmp(&number.floor())\
    \ < 0 && number.cmp(&number.ceil()) > 0 {\n   |                              \
    \                                             ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror[E0599]: no method named `is_integer` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpcf_6473j.rs:12:22\n   |\n12 |\
    \     } else if number.is_integer() {\n   |                      ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpcf_6473j.rs:22:12\n    |\n22  |     number.exp(exp)\n\
    \    |            ^^^ --- supplied 1 argument\n    |            |\n    |     \
    \       expected 0 arguments\n    |\nnote: associated function defined here\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number / f64::from(*FRACS);\n    integer_part\
    \ * f64::from(*FRACS) + (*FRACS % f64::from(*FRACS).abs() as f64)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `FRACS` in this scope\n --> /tmp/tmp41_xujjr.rs:8:44\n\
    \  |\n8 |     let integer_part = number / f64::from(*FRACS);\n  |            \
    \                                ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `FRACS` in this scope\n --> /tmp/tmp41_xujjr.rs:9:31\n  |\n\
    9 |     integer_part * f64::from(*FRACS) + (*FRACS % f64::from(*FRACS).abs() as\
    \ f64)\n  |                               ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `FRACS` in this scope\n --> /tmp/tmp41_xujjr.rs:9:42\n  |\n\
    9 |     integer_part * f64::from(*FRACS) + (*FRACS % f64::from(*FRACS).abs() as\
    \ f64)\n  |                                          ^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `FRACS` in this scope\n --> /tmp/tmp41_xujjr.rs:9:61\n\
    \  |\n9 |     integer_part * f64::from(*FRACS) + (*FRACS % f64::from(*FRACS).abs()\
    \ as f64)\n  |                                                             ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number / trunc_1()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `trunc_1` in this scope\n --> /tmp/tmp6ocqwrlx.rs:8:14\n\
    \  |\n8 |     number / trunc_1()\n  |              ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp1x5iulca.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let power = f32::pow(*f32::from(number));\n    if *number >= 0\
    \ {\n        *number\n    } else {\n        f64::pow(*f64::from(number)) - power\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `pow` found for type\
    \ `f32` in the current scope\n --> /tmp/tmpor00xtxv.rs:8:22\n  |\n8 |     let\
    \ power = f32::pow(*f32::from(number));\n  |                      ^^^\n  |   \
    \                   |\n  |                      function or associated item not\
    \ found in `f32`\n  |                      help: there is an associated function\
    \ with a similar name: `powf`\n\nerror[E0277]: the trait bound `f32: From<f64>`\
    \ is not satisfied\n --> /tmp/tmpor00xtxv.rs:8:27\n  |\n8 |     let power = f32::pow(*f32::from(number));\n\
    \  |                           ^^^^^^^^^ the trait `From<f64>` is not implemented\
    \ for `f32`\n  |\n  = help: the following other types implement trait `From<T>`:\n\
    \            <f32 as From<i16>>\n            <f32 as From<i8>>\n            <f32\
    \ as From<u16>>\n            <f32 as From<u8>>\n            <f64 as From<f32>>\n\
    \            <f64 as From<i16>>\n            <f64 as From<i32>>\n            <f64\
    \ as From<i8>>\n          and 67 others\n\nerror[E0614]: type `f32` cannot be\
    \ dereferenced\n --> /tmp/tmpor00xtxv.rs:8:26\n  |\n8 |     let power = f32::pow(*f32::from(number));\n\
    \  |                          ^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n --> /tmp/tmpor00xtxv.rs:9:8\n  |\n9 |     if *number >= 0\
    \ {\n  |        ^^^^^^^\n\nerror[E0614]: type `f64` cannot be dereferenced\n \
    \ --> /tmp/tmpor00xtxv.rs:10:9\n   |\n10 |         *number\n   |         ^^^^^^^\n\
    \nerror[E0599]: no function or associated item named `pow` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpor00xtxv.rs:12:14\n   |\n12 |         f64::pow(*f64::from(number))\
    \ - power\n   |              ^^^\n   |              |\n   |              function\
    \ or associated item not found in `f64`\n   |              help: there is an associated\
    \ function with a similar name: `powf`\n\nerror[E0614]: type `f64` cannot be dereferenced\n\
    \  --> /tmp/tmpor00xtxv.rs:12:18\n   |\n12 |         f64::pow(*f64::from(number))\
    \ - power\n   |                  ^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 7 previous errors\n\nSome errors have detailed explanation"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        number\n    } else {\n        number\
    \ - 1.0\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpxihg527n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let x = number.trunc_div(1.0).floor();\n    let r = number.fract();\n\
    \    x + ((r > 0.0).into() * 1.0)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_div` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp8f2socs2.rs:8:20\n  |\n8 |     let x = number.trunc_div(1.0).floor();\n\
    \  |                    ^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0000000001 {\n        number\n    } else {\n   \
    \     number.trunc() + number.trunc_div(0.0000000001)\n    }\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_div` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpub3uuk97.rs:11:33\n   |\n11 |         number.trunc() +\
    \ number.trunc_div(0.0000000001)\n   |                                 ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `trunc`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp6olk1m6f.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Handle negative number first\n    let negative = number < 0;\n\
    \    number.abs() < 1 ? -number : number\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0573]: expected type, found local variable `number`\n  --> /tmp/tmpcq0jfnfp.rs:10:34\n\
    \   |\n10 |     number.abs() < 1 ? -number : number\n   |                    \
    \              ^^^^^^ expecting a type here because of type ascription\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpcq0jfnfp.rs:9:29\n  |\n9 |     let negative =\
    \ number < 0;\n  |                             ^\n  |                        \
    \     |\n  |                             expected `f64`, found integer\n  |  \
    \                           help: use a float literal: `0.0`\n\nerror[E0277]:\
    \ the `?` operator can only be applied to values that implement `Try`\n  --> /tmp/tmpcq0jfnfp.rs:10:20\n\
    \   |\n10 |     number.abs() < 1 ? -number : number\n   |                    ^^^\
    \ the `?` operator cannot be applied to type `{integer}`\n   |\n   = help: the\
    \ trait `Try` is not implemented for `{integer}`\n\nerror[E0277]: the `?` operator\
    \ can only be used in a function that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmpcq0jfnfp.rs:10:22\n   |\n\
    7  | / fn truncate_number(number: f64) -> f64 {\n8  | |     // Handle negative\
    \ number first\n9  | |     let negative = number < 0;\n10 | |     number.abs()\
    \ < 1 ? -number : number\n   | |                      ^ cannot use the `?` operator\
    \ in a function that returns `f64`\n11 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcq0jfnfp.rs:10:5\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n10 |     number.abs()\
    \ < 1 ? -number : number\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `f64`, found `bool`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0573.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (quotient, remainder) = number.truncate();\n    if remainder\
    \ > 0 {\n        remainder\n    } else {\n        quotient - 1\n    }\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpxz3xywa1.rs:8:40\n  |\n8 |     let (quotient, remainder)\
    \ = number.truncate();\n  |                                        ^^^^^^^^ help:\
    \ there is an associated function with a similar name: `trunc`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n --> /tmp/tmpxz3xywa1.rs:9:18\n  |\n9\
    \ |     if remainder > 0 {\n  |                  ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n  |\n  = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n            f32\n            f64\n            i128\n\
    \            i16\n            i32\n            i64\n            i8\n         \
    \   isize\n          and 6 others\nhelp: consider using a floating-point literal\
    \ by writing it with `.0`\n  |\n9 |     if remainder > 0.0 {\n  |            \
    \         ++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut n = (number.abs()) as u32;\n    loop {\n        n >>=\
    \ 1;\n        match n {\n            0 => {\n                return number;\n\
    \            }\n            _ => {\n                return number / f64::powf(n\
    \ as f64, 10).round() as f64;\n            }\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgt0e51g3.rs:16:53\n   |\n\
    16 |                 return number / f64::powf(n as f64, 10).round() as f64;\n\
    \   |                                                     ^^\n   |           \
    \                                          |\n   |                           \
    \                          expected `f64`, found integer\n   |               \
    \                                      help: use a float literal: `10.0`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        number.ceil()\n    } else {\n     \
    \   number.floor()\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpl41wm1tj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0 {\n        number / f64::powf(10, (number.log10()\
    \ as i32) - 1).round() as f64\n    } else {\n        number.round() as f64\n \
    \   }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3mv4nezf.rs:8:17\n  |\n8 |\
    \     if number > 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3mv4nezf.rs:9:28\n\
    \  |\n9 |         number / f64::powf(10, (number.log10() as i32) - 1).round()\
    \ as f64\n  |                            ^^\n  |                            |\n\
    \  |                            expected `f64`, found integer\n  |           \
    \                 help: use a float literal: `10.0`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp3mv4nezf.rs:9:32\n  |\n9 |         number / f64::powf(10,\
    \ (number.log10() as i32) - 1).round() as f64\n  |                           \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `i32`\n  |\nhelp: you\
    \ can convert an `i32` to an `f64`, producing the floating point representation\
    \ of the integer\n  |\n9 |         number / f64::powf(10, ((number.log10() as\
    \ i32) - 1).into()).round() as f64\n  |                                +     \
    \                      ++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // The number may be negative\n    let negative = (number < 0.0);\n\
    \    let mut number = number.abs();\n    let mut decimal_part = 0.;\n    loop\
    \ {\n        // Truncate to first decimal place\n        let mut number = number\
    \ / 10.;\n        decimal_part += number;\n        if number < 1.0 {\n       \
    \     break;\n        }\n    }\n    if negative {\n        number.neg()\n    }\
    \ else {\n        number\n    }\n    .div(10.)\n    .min(1.)\n    .unwrap_or(decimal_part)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n --> /tmp/tmplota7p7j.rs:9:20\n\
    \  |\n9 |     let negative = (number < 0.0);\n  |                    ^       \
    \     ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n  |\n9 -     let negative = (number < 0.0);\n9 +     let negative\
    \ = number < 0.0;\n  | \n\nerror[E0599]: no method named `neg` found for type\
    \ `f64` in the current scope\n   --> /tmp/tmplota7p7j.rs:21:16\n    |\n21  | \
    \        number.neg()\n    |                ^^^ method not found in `f64`\n  \
    \  |\n    = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n    |\n1   | use std::ops::Neg;\n    |\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmppjuxirfd.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.trunc() {\n        Some(x) => x,\n        None =>\
    \ 0.0\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqozhk9nj.rs:9:9\n  |\n8 |\
    \     match number.trunc() {\n  |           -------------- this expression has\
    \ type `f64`\n9 |         Some(x) => x,\n  |         ^^^^^^^ expected `f64`, found\
    \ enum `Option`\n  |\n  = note: expected type `f64`\n             found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqozhk9nj.rs:10:9\n   |\n8  | \
    \    match number.trunc() {\n   |           -------------- this expression has\
    \ type `f64`\n9  |         Some(x) => x,\n10 |         None => 0.0\n   |     \
    \    ^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected type\
    \ `f64`\n              found enum `Option<_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - (number % 1)) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpxhksp03a.rs:8:23\n\
    \  |\n8 |     (number - (number % 1)) as f64\n  |                       ^ no implementation\
    \ for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     (number - (number % 1.0)) as f64\n  |                          ++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpytfauwor.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut numerator = number;\n    let mut decimals = 0.0;\n   \
    \ let mut remainder = 0.0;\n    let mut decimal_places = 1;\n\n    while numerator.is_negative()\
    \ {\n        numerator = numerator.abs_sub(1.0);\n        decimals += 1.0;\n \
    \       remainder += 1.0;\n    }\n\n    while numerator.is_positive() {\n    \
    \    numerator = numerator.abs_sub(1.0);\n        remainder += 1.0;\n        decimal_places\
    \ += 1;\n    }\n\n    while remainder > 0 {\n        numerator = remainder.floor();\n\
    \        decimals += 1;\n        remainder = numerator % 1.0;\n        numerator\
    \ = numerator - remainder;\n    }\n\n    numerator.truncate();\n    numerator\
    \ * powf(10.0, decimal_places)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `powf` in this scope\n  --> /tmp/tmptzfteqyu.rs:33:17\n\
    \   |\n33 |     numerator * powf(10.0, decimal_places)\n   |                 ^^^^\
    \ not found in this scope\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_negative`: renamed to is_sign_negative\n  --> /tmp/tmptzfteqyu.rs:13:21\n\
    \   |\n13 |     while numerator.is_negative() {\n   |                     ^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated\
    \ associated function `std::f64::<impl f64>::abs_sub`: you probably meant `(self\
    \ - other).abs()`: this operation is `(self - other).max(0.0)` except that `abs_sub`\
    \ also propagates NaNs (also known as `fdim` in C). If you truly need the positive\
    \ difference, consider using that expression or the C function `fdim`, depending\
    \ on how you wish to handle NaN (please consider filing an issue describing your\
    \ use-case too).\n  --> /tmp/tmptzfteqyu.rs:14:31\n   |\n14 |         numerator\
    \ = numerator.abs_sub(1.0);\n   |                               ^^^^^^^\n\nwarning:\
    \ use of deprecated associated function `core::f64::<impl f64>::is_positive`:\
    \ renamed to is_sign_positive\n  --> /tmp/tmptzfteqyu.rs:19:21\n   |\n19 |   \
    \  while numerator.is_positive() {\n   |                     ^^^^^^^^^^^\n\nwarning:\
    \ use of deprecated associated function `std::f64::<impl f64>::abs_sub`: you probably\
    \ meant `(self - other).abs()`: this operation is `(self - other).max(0.0)` except\
    \ that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you truly\
    \ need the positive difference, consider using that expression or the C function\
    \ `fdim`, depending on how you wish to handle NaN (please consider filing an issue\
    \ describing your use-case too).\n  --> /tmp/tmptzfteqyu.rs:20:31\n   |\n20 |\
    \         numerator = numerator.abs_sub(1.0);\n   |                          \
    \     ^^^^^^^\n\nerror[E0277]: can't compare `{float}` with `{integer}`\n  -->\
    \ /tmp/tmptzfteqyu.rs:25:21\n   |\n25 |     while remainder > 0 {\n   |      \
    \               ^ no implementation for `{float} < {integer}` and `{"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        number.floor()\n    } else {\n    \
    \    number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpal1hkm7z.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.0 && number.is_finite() {\n        let rem = number\
    \ % 1.0\n        let whole = number / 1.0\n        if whole < 0.0 {\n        \
    \    whole.powi(2) - 1\n        } else {\n            whole.floor()\n        }\n\
    \    } else {\n        0.0\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpz47331su.rs:9:31\n\
    \   |\n9  |         let rem = number % 1.0\n   |                             \
    \  ^ help: add `;` here\n10 |         let whole = number / 1.0\n   |         ---\
    \ unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpz47331su.rs:10:33\n\
    \   |\n10 |         let whole = number / 1.0\n   |                           \
    \      ^ help: add `;` here\n11 |         if whole < 0.0 {\n   |         -- unexpected\
    \ token\n\nerror[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpz47331su.rs:12:27\n\
    \   |\n12 |             whole.powi(2) - 1\n   |                           ^ no\
    \ implementation for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n12 |             whole.powi(2) - 1.0\n   |             \
    \                 ++\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number.floor();\n    let mut decimals = number.trunc();\n\
    \    number -= decimals;\n    decimals\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpb9k0cexs.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = 0.0;\n    let mut fraction = 1.0;\n    for _\
    \ in 0..number.len() {\n        if integer + fraction > f64::MAX as f64 {\n  \
    \          break;\n        }\n        let (integer, fraction) = (integer.saturating_add(f64::from(fraction)),\
    \ (fraction.saturating_add(f64::from(1.0))));\n    }\n    integer + fraction\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp5ykrfmai.rs:10:24\n   |\n10 |     for _ in 0..number.len()\
    \ {\n   |                        ^^^ help: there is an associated function with\
    \ a similar name: `ln`\n\nerror[E0599]: no method named `saturating_add` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp5ykrfmai.rs:14:44\n   |\n\
    14 |         let (integer, fraction) = (integer.saturating_add(f64::from(fraction)),\
    \ (fraction.saturating_add(f64::from(1.0))));\n   |                          \
    \                  ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `saturating_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp5ykrfmai.rs:14:91\n   |\n14 |         let (integer, fraction) = (integer.saturating_add(f64::from(fraction)),\
    \ (fraction.saturating_add(f64::from(1.0))));\n   |                          \
    \                                                                 ^^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let n = number.trunc();\n    let mut decimals = 0.0f;\n    while\
    \ n >= 10.0 {\n        decimals += n % 10.0;\n        n /= 10.0;\n    }\n    decimals\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `f` for float literal\n --> /tmp/tmpra5egapg.rs:9:24\n\
    \  |\n9 |     let mut decimals = 0.0f;\n  |                        ^^^^ invalid\
    \ suffix `f`\n  |\n  = help: valid suffixes are `f32` and `f64`\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        f64::from(1.0) - number\n    } else\
    \ {\n        number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpwq_0scln.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal = f64::INFINITY;\n    if number < number.floor()\
    \ {\n        number = number.floor();\n        decimal = f64::INFINITY;\n    }\n\
    \    let mut fraction = (number - number.floor()) as f64 / 10.0;\n    if fraction\
    \ < number.fract() {\n        fraction = number.fract();\n    }\n    let mut result\
    \ = fraction.floor();\n    while result > number.fract() {\n        result -=\
    \ 1.0;\n    }\n    result + decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `number`\n  --> /tmp/tmpfu6ntevg.rs:10:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n10 | \
    \        number = number.floor();\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut i = 0;\n    while number > 1.0 {\n        i -= 1;\n  \
    \      number /= 10.0;\n    }\n    number\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "warning: variable `i` is assigned to, but never used\n --> /tmp/tmpzdr7u25k.rs:8:13\n\
    \  |\n8 |     let mut i = 0;\n  |             ^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_i` instead\n\nerror[E0384]: cannot\
    \ assign to immutable argument `number`\n  --> /tmp/tmpzdr7u25k.rs:11:9\n   |\n\
    7  | fn truncate_number(number: f64) -> f64 {\n   |                    ------\
    \ help: consider making this binding mutable: `mut number`\n...\n11 |        \
    \ number /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exp: i32;\n    let mut frac: i32;\n\n    if number < 1.0\
    \ {\n        exp = number.floor() as i32 - 1;\n        frac = number\n       \
    \     .floor()\n            .trunc()\n            .expect(\"number is out of range\"\
    );\n    } else {\n        exp = number.floor() as i32 - 1;\n        frac = number\n\
    \            .floor()\n            .trunc()\n            .expect(\"number is out\
    \ of range\");\n    }\n    number\n        .trunc()\n        .expect(\"number\
    \ is out of range\")\n        * (f64::exp(exp(frac)) - 1.0)\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `expect` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpfpw87_18.rs:16:14\n   |\n16 |             .expect(\"number\
    \ is out of range\");\n   |              ^^^^^^ help: there is an associated function\
    \ with a similar name: `exp`\n\nerror[E0599]: no method named `expect` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpfpw87_18.rs:22:14\n   |\n22 |\
    \             .expect(\"number is out of range\");\n   |              ^^^^^^ help:\
    \ there is an associated function with a similar name: `exp`\n\nerror[E0599]:\
    \ no method named `expect` found for type `f64` in the current scope\n  --> /tmp/tmpfpw87_18.rs:26:10\n\
    \   |\n26 |         .expect(\"number is out of range\")\n   |          ^^^^^^\
    \ help: there is an associated function with a similar name: `exp`\n\nerror[E0618]:\
    \ expected function, found `i32`\n  --> /tmp/tmpfpw87_18.rs:27:21\n   |\n8  |\
    \     let mut exp: i32;\n   |         ------- `exp` has type `i32`\n...\n27 |\
    \         * (f64::exp(exp(frac)) - 1.0)\n   |                     ^^^------\n\
    \   |                     |\n   |                     call expression requires\
    \ function\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0618.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut num_digits = digits(number).unwrap();\n    num_digits\
    \ -= 1;\n    number.trunc().checked_div(10).unwrap() * 10\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmpa65r6xfi.rs:8:26\n\
    \  |\n8 |     let mut num_digits = digits(number).unwrap();\n  |             \
    \             ^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `checked_div` found for type `f64` in the current scope\n  --> /tmp/tmpa65r6xfi.rs:10:20\n\
    \   |\n10 |     number.trunc().checked_div(10).unwrap() * 10\n   |           \
    \         ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        0.0\n    } else {\n        number /\
    \ std::f64::EPSILON\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.5762598695796736e16`,\n right: `0.5`', /tmp/tmpkxfup341.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number <= 0.0 {\n        return 0.0;\n    }\n\n    // The remainder\
    \ is always smaller than 1.0. Truncate it instead.\n    let remainder = number\
    \ % 1.0;\n\n    // Decompose the number into integer and decimal parts\n    let\
    \ (integer, remainder) = remainder.trunc_f64().unwrap();\n\n    // Return the\
    \ fractional part of number\n    integer + (remainder as f64)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp1hbpmcqd.rs:16:42\n   |\n16 |     let (integer, remainder)\
    \ = remainder.trunc_f64().unwrap();\n   |                                    \
    \      ^^^^^^^^^ help: there is an associated function with a similar name: `trunc`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimals) = number.trunc();\n    numerify(decimals,\
    \ integer)\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `numerify` in this scope\n --> /tmp/tmpfehr9wjl.rs:9:5\n\
    \  |\n9 |     numerify(decimals, integer)\n  |     ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfehr9wjl.rs:8:9\n  |\n\
    8 |     let (integer, decimals) = number.trunc();\n  |         ^^^^^^^^^^^^^^^^^^^\
    \   -------------- this expression has type `f64`\n  |         |\n  |        \
    \ expected `f64`, found tuple\n  |\n  = note: expected type `f64`\n          \
    \  found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let precision = std::i32::MAX;\n    number.trunc_f64(precision)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp951m6fhb.rs:9:12\n  |\n9 |     number.trunc_f64(precision)\n\
    \  |            ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut ipart: i32 = 0;\n    let mut fpart: f64 = number.abs();\n\
    \n    while fpart.is_positive() {\n        ipart += 1;\n        fpart -= fpart\
    \ / 10.0;\n    }\n\n    fpart\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let result = number.trunc();\n    if result < number {\n     \
    \   result + 1\n    } else {\n        result\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmp17lr5e9y.rs:10:16\n\
    \   |\n10 |         result + 1\n   |                ^ no implementation for `f64\
    \ + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result + 1.0\n   |                   ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number;\n    if number < std::i32::MIN as f64\
    \ {\n        result = std::i32::MAX as f64;\n    }\n    result / std::powf(10,\
    \ std::i32::MIN as i32);\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `powf` in crate `std`\n  --> /tmp/tmpg2bfcmat.rs:12:19\n\
    \   |\n12 |     result / std::powf(10, std::i32::MIN as i32);\n   |          \
    \         ^^^^ not found in `std`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg2bfcmat.rs:7:36\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |    ---------------\
    \                 ^^^ expected `f64`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n12 |     result\
    \ / std::powf(10, std::i32::MIN as i32);\n   |                               \
    \                  - help: remove this semicolon\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let num = number.trunc_f64();\n    if num == number {\n      \
    \  return num;\n    }\n    if num > 0.f64 {\n        let mut rem = 0.f64;\n  \
    \      let mut exp = num;\n        while exp != 0. {\n            rem = exp;\n\
    \            exp /= 10.0;\n        }\n        if rem != 0.f64 {\n            return\
    \ num / rem;\n        }\n    }\n    return 0.;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp0zenkikt.rs:8:22\n  |\n8 |     let num = number.trunc_f64();\n\
    \  |                      ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror[E0610]: `{integer}` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmp0zenkikt.rs:12:16\n   |\n12 | \
    \    if num > 0.f64 {\n   |                ^^^\n\nerror[E0610]: `{integer}` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp0zenkikt.rs:13:25\n\
    \   |\n13 |         let mut rem = 0.f64;\n   |                         ^^^\n\n\
    error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp0zenkikt.rs:19:21\n   |\n19 |         if rem != 0.f64 {\n   | \
    \                    ^^^\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // we can't use float_div_round_to_zero because we can't guarantee\n\
    \    // that the number is positive before truncating\n    let mut integer = number;\n\
    \    let mut remainder = number;\n    if number < 0 {\n        integer = -integer;\n\
    \        remainder = -remainder;\n    }\n    let result = integer_div_round_to_zero(integer);\n\
    \    if remainder < 1.0 {\n        result\n    } else {\n        integer_div_round_to_zero(result\
    \ - 1.0) + 1.0\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `integer_div_round_to_zero` in this\
    \ scope\n  --> /tmp/tmpshswivov.rs:16:18\n   |\n16 |     let result = integer_div_round_to_zero(integer);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `integer_div_round_to_zero` in this scope\n  --> /tmp/tmpshswivov.rs:20:9\n\
    \   |\n20 |         integer_div_round_to_zero(result - 1.0) + 1.0\n   |      \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpshswivov.rs:12:17\n   |\n12 |     if number < 0 {\n   |\
    \                 ^\n   |                 |\n   |                 expected `f64`,\
    \ found integer\n   |                 help: use a float literal: `0.0`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (mut integer, mut decimal) = number.abs().floor() as (f64,\
    \ f64);\n    if number > 0 {\n        integer = (integer - decimal).trunc();\n\
    \    }\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpspixzo0k.rs:9:17\n  |\n9 |\
    \     if number > 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror[E0605]: non-primitive cast: `f64` as `(f64, f64)`\n\
    \ --> /tmp/tmpspixzo0k.rs:8:38\n  |\n8 |     let (mut integer, mut decimal) =\
    \ number.abs().floor() as (f64, f64);\n  |                                   \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to\
    \ convert between primitive types or to coerce to a specific trait object\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0605.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number as f64 - number % number as f64\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp3au8chvc.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = number.trunc();\n    match integer {\n\
    \        0 => 0,\n        _ => decimal,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2h194eze.rs:8:9\n  |\n8 |\
    \     let (integer, decimal) = number.trunc();\n  |         ^^^^^^^^^^^^^^^^^^\
    \   -------------- this expression has type `f64`\n  |         |\n  |        \
    \ expected `f64`, found tuple\n  |\n  = note: expected type `f64`\n          \
    \  found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2h194eze.rs:10:14\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n10 |       \
    \  0 => 0,\n   |              ^\n   |              |\n   |              expected\
    \ `f64`, found integer\n   |              help: use a float literal: `0.0`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number: f64 = number.abs();\n    let mut decimals = 0.0;\n\
    \    while number >= 1.0 {\n        number /= 10.0;\n        decimals += 1;\n\
    \    }\n    number -= decimals * std::f64::consts::FRACTION_DIGITS.sqrt();\n \
    \   number.round()\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `FRACTION_DIGITS` in module `std::f64::consts`\n\
    \  --> /tmp/tmp8zocfv9d.rs:14:44\n   |\n14 |     number -= decimals * std::f64::consts::FRACTION_DIGITS.sqrt();\n\
    \   |                                            ^^^^^^^^^^^^^^^ not found in\
    \ `std::f64::consts`\n\nerror[E0277]: cannot add-assign `{integer}` to `{float}`\n\
    \  --> /tmp/tmp8zocfv9d.rs:12:18\n   |\n12 |         decimals += 1;\n   |    \
    \              ^^ no implementation for `{float} += {integer}`\n   |\n   = help:\
    \ the trait `AddAssign<{integer}>` is not implemented for `{float}`\n   = help:\
    \ the following other types implement trait `AddAssign<Rhs>`:\n             <f32\
    \ as AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Float is stored as exponent + mantissa, so we need to multiply\
    \ by\n    // the significand to get an estimate of it.\n    let significand =\
    \ number.floor();\n    let exponent = significand as i64 - number.trunc_f64()\
    \ as i64;\n    let mut rem = f64::new(significand);\n    while rem > 0.0 {\n \
    \       let div = rem as f64 / 10.0;\n        rem -= div;\n        significand\
    \ *= 10.0;\n    }\n\n    match exponent {\n        0 => significand,\n       \
    \ e if e == -1 => significand,\n        e => significand * (f64::pow(10.0, e as\
    \ i64)),\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpxqs4hrn_.rs:11:48\n   |\n11 |     let exponent = significand\
    \ as i64 - number.trunc_f64() as i64;\n   |                                  \
    \              ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror[E0599]: no function or associated item named `new` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpxqs4hrn_.rs:12:24\n   |\n\
    12 |     let mut rem = f64::new(significand);\n   |                        ^^^\
    \ function or associated item not found in `f64`\n\nerror[E0599]: no function\
    \ or associated item named `pow` found for type `f64` in the current scope\n \
    \ --> /tmp/tmpxqs4hrn_.rs:22:34\n   |\n22 |         e => significand * (f64::pow(10.0,\
    \ e as i64)),\n   |                                  ^^^\n   |               \
    \                   |\n   |                                  function or associated\
    \ item not found in `f64`\n   |                                  help: there is\
    \ an associated function with a similar name: `powf`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number\n    let mut int_part = 0.0;\n\
    \    while remainder > 1.0 {\n        remainder = remainder - 1.0;\n        int_part\
    \ += 1.0;\n    }\n    int_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpt8hp_1wo.rs:8:36\n\
    \  |\n8 |     let mut remainder: f64 = number\n  |                           \
    \         ^ help: add `;` here\n9 |     let mut int_part = 0.0;\n  |     --- unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut digits = number.to_digits(10);\n    if digits.len() <\
    \ 2 {\n        return 0.0;\n    }\n\n    let mut result = 0.0;\n    while result.is_positive()\
    \ {\n        let (digit, exponent) = digits.pop().unwrap();\n        result *=\
    \ 10.0;\n        result += digit;\n    }\n    result /= 10.0\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpi254kui6.rs:8:29\n  |\n8 |     let mut digits = number.to_digits(10);\n\
    \  |                             ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_bits`\n\nerror[E0689]: can't call method `is_positive`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpi254kui6.rs:14:18\n   |\n\
    14 |     while result.is_positive() {\n   |                  ^^^^^^^^^^^\n   |\n\
    help: you must specify a type for this binding, like `f32`\n   |\n13 |     let\
    \ mut result: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi254kui6.rs:19:5\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                                    --- expected `f64` because\
    \ of return type\n...\n19 |     result /= 10.0\n   |     ^^^^^^^^^^^^^^ expected\
    \ `f64`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = number.trunc_f64();\n    decimal\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp2zurt971.rs:8:37\n  |\n8 |     let (integer, decimal) =\
    \ number.trunc_f64();\n  |                                     ^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `trunc`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        -0.0\n    } else {\n        number\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp94_4s114.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        number.trunc()\n    } else {\n      \
    \  number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg25aunur.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number = number.floor();\n    let remainder = number % 1;\n\
    \    number\n        .trunc()\n        .expect(\"Truncation should work\")\n \
    \       .powf(-(number.len() as i32))\n        .expect(\"Should be able to truncate\
    \ to positive float\")\n        + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpty5or_zl.rs:9:28\n\
    \  |\n9 |     let remainder = number % 1;\n  |                            ^ no\
    \ implementation for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>`\
    \ is not implemented for `f64`\n  = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n            <&'a f32 as Rem<f32>>\n            <&'a f64 as\
    \ Rem<f64>>\n            <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n\
    \            <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n      \
    \      <&'a i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n  |\n9 |     let remainder = number % 1.0;\n  |                      \
    \         ++\n\nerror[E0599]: no method named `expect` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpty5or_zl.rs:12:10\n   |\n12 |         .expect(\"\
    Truncation should work\")\n   |          ^^^^^^ help: there is an associated function\
    \ with a similar name: `exp`\n\nerror[E0599]: no method named `len` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpty5or_zl.rs:13:24\n   |\n13 |\
    \         .powf(-(number.len() as i32))\n   |                        ^^^ help:\
    \ there is an associated function with a similar name: `ln`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut whole = number;\n    let mut truncated = 0.0;\n    let\
    \ mut factor = 0.0;\n    loop {\n        let factor = trunc(whole / 10.0);\n \
    \       truncated = truncated + factor * 10.0;\n        if factor == 0.0 {\n \
    \           break;\n        }\n        whole = whole - factor * 10.0;\n    }\n\
    \    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `trunc` in this scope\n  --> /tmp/tmp15yyadfn.rs:12:22\n\
    \   |\n12 |         let factor = trunc(whole / 10.0);\n   |                  \
    \    ^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp6rm5w4hg.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().into()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp724wh4d4.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let rem = f64::remainder(number, 1.0) as f64;\n    number\n  \
    \      - rem\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `remainder` found for\
    \ type `f64` in the current scope\n --> /tmp/tmp83v5j_jw.rs:8:20\n  |\n8 |   \
    \  let rem = f64::remainder(number, 1.0) as f64;\n  |                    ^^^^^^^^^\
    \ function or associated item not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpjffy_60r.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_div(1.0).unwrap_or(number)\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_div` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp6kaemsiu.rs:8:12\n  |\n8 |     number.trunc_div(1.0).unwrap_or(number)\n\
    \  |            ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut digits: Vec<f64> = number.to_string().chars().collect();\n\
    \    let mut decimal = f64::MAX;\n\n    while !digits.is_empty() && decimal !=\
    \ 0 {\n        decimal *= 10;\n        decimal += digits.last().unwrap();\n  \
    \      digits.pop();\n    }\n\n    if digits.is_empty() {\n        decimal\n \
    \   } else {\n        decimal / digits.last().unwrap()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<f64>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp7x3m46jy.rs:8:59\n     |\n8  \
    \  |     let mut digits: Vec<f64> = number.to_string().chars().collect();\n  \
    \   |                                                           ^^^^^^^ value\
    \ of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=char>`\n \
    \    |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<f64>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7x3m46jy.rs:11:44\n\
    \   |\n11 |     while !digits.is_empty() && decimal != 0 {\n   |             \
    \                               ^\n   |                                      \
    \      |\n   |                                            expected `f64`, found\
    \ integer\n   |                                            help: use a float literal:\
    \ `0.0`\n\nerror[E0277]: cannot multiply-assign `f64` by `{integer}`\n  --> /tmp/tmp7x3m46jy.rs:12:17\n\
    \   |\n12 |         decimal *= 10;\n   |                 ^^ no implementation\
    \ for `f64 *= {integer}`\n   |\n   = help: the trait `MulAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n             <f32\
    \ as MulAssign>\n             <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n\
    \             <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n \
    \            <i16 as MulAssign<&i16>>\n             <i16 as MulAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n12 |         decimal *= 10.0;\n   |                    \
    \  ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut precision = number.bits() - 1;\n    let mut truncated\
    \ = 0;\n    while precision > 0 {\n        if number >= 1.0 {\n            truncated\
    \ = 1;\n            number -= 1.0;\n            precision -= 1;\n        } else\
    \ {\n            truncated = 0;\n            number -= 0.0;\n            precision\
    \ -= 1;\n        }\n    }\n    number if truncated != 0 else\n        number.abs()\
    \ as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpp1is_qls.rs:21:12\n   |\n21 |     number if\
    \ truncated != 0 else\n   |            ^^ expected one of 8 possible tokens\n\n\
    error[E0599]: no method named `bits` found for type `f64` in the current scope\n\
    \ --> /tmp/tmpp1is_qls.rs:8:32\n  |\n8 |     let mut precision = number.bits()\
    \ - 1;\n  |                                ^^^^ help: there is an associated function\
    \ with a similar name: `to_bits`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fraction = number.trunc();\n    let decimals = number.fract();\n\
    \n    if decimals > 1 {\n        fraction -= fraction.floor() as f64;\n    }\n\
    \n    fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk_xyc04b.rs:11:19\n   |\n\
    11 |     if decimals > 1 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `f64`, found integer\n   |                  \
    \ help: use a float literal: `1.0`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number\n        .trunc()\n        .unwrap()\n        .into()\n\
    \        .unwrap_or(number as f64)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpkgnp27oa.rs:10:10\n   |\n10 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number % 1\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpt_wd05k1.rs:8:12\n\
    \  |\n8 |     number % 1\n  |            ^ no implementation for `f64 % {integer}`\n\
    \  |\n  = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n            <&'a f32\
    \ as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n\
    \            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n      \
    \      <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a\
    \ isize as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     number % 1.0\n  |            \
    \   ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp1wk70l3e.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        return number\n    }\n    let n =\
    \ number.into();\n    let mut decimal_part = 0.0;\n    let mut fractional_part\
    \ = 0.0;\n    loop {\n        let x = n.floor();\n        let y = n - x;\n   \
    \     if y != 0 {\n            decimal_part += y;\n            fractional_part\
    \ += x;\n        }\n        match y {\n            0 => {\n                break;\n\
    \            }\n            _ => {}\n        }\n        n = x;\n    }\n    decimal_part\
    \ + fractional_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp9z7cx_ue.rs:15:17\n\
    \   |\n11 |     let n = number.into();\n   |         - consider giving `n` a type\n\
    ...\n15 |         let x = n.floor();\n   |                 ^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0277]: cannot add-assign\
    \ `{integer}` to `{float}`\n  --> /tmp/tmp9z7cx_ue.rs:18:26\n   |\n18 |      \
    \       decimal_part += y;\n   |                          ^^ no implementation\
    \ for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0282.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpwt2431eb.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut dec = 0 as f64;\n    if number > 0 {\n        while number\
    \ > f64::from(0.1) {\n            dec += 0.1;\n            number -= f64::from(0.1);\n\
    \        }\n    }\n    dec\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx_j69pys.rs:9:17\n  |\n9 |\
    \     if number > 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let fraction = number % 1.0;\n    if fraction < 0.0 {\n      \
    \  number - fraction\n    } else {\n        number\n    }\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpa7fwp17r.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut x = number;\n    let mut result = 0.0;\n    let mut remainder\
    \ = 1.0;\n    while remainder > 0 {\n        if remainder < 10.0 {\n         \
    \   result *= 10.0;\n            result += remainder - 10.0;\n            remainder\
    \ = 0.0;\n        } else {\n            result *= 10.0;\n            result +=\
    \ remainder - 10.0;\n            remainder -= 10.0;\n        }\n    }\n    x\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `{float}` with `{integer}`\n  --> /tmp/tmp6w04704j.rs:11:21\n\
    \   |\n11 |     while remainder > 0 {\n   |                     ^ no implementation\
    \ for `{float} < {integer}` and `{float} > {integer}`\n   |\n   = help: the trait\
    \ `PartialOrd<{integer}>` is not implemented for `{float}`\n   = help: the following\
    \ other types implement trait `PartialOrd<Rhs>`:\n             f32\n         \
    \    f64\n             i128\n             i16\n             i32\n            \
    \ i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6w04704j.rs:11:23\n   |\n11 |     while remainder\
    \ > 0 {\n   |                       ^ expected floating-point number, found integer\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let digits = number.trunc_log10();\n    let (integer, decimal)\
    \ = number.div_pow10(digits);\n    truncate_decimal(decimal)\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `truncate_decimal` in this scope\n \
    \ --> /tmp/tmp5rne9m_y.rs:10:5\n   |\n10 |     truncate_decimal(decimal)\n   |\
    \     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `trunc_log10` found for type `f64` in the current scope\n --> /tmp/tmp5rne9m_y.rs:8:25\n\
    \  |\n8 |     let digits = number.trunc_log10();\n  |                        \
    \ ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `div_pow10`\
    \ found for type `f64` in the current scope\n --> /tmp/tmp5rne9m_y.rs:9:37\n \
    \ |\n9 |     let (integer, decimal) = number.div_pow10(digits);\n  |         \
    \                            ^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut ipart: i32 = number.trunc();\n    let mut fraction = number.fract();\n\
    \    if fraction.is_zero() {\n        return ipart;\n    }\n\n    let diff = fraction.abs();\n\
    \    if diff > 0.5 {\n        ipart += 1;\n    }\n    ipart / 10\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwxa6at0d.rs:8:26\n  |\n8 |\
    \     let mut ipart: i32 = number.trunc();\n  |                    ---   ^^^^^^^^^^^^^^\
    \ expected `i32`, found `f64`\n  |                    |\n  |                 \
    \   expected due to this\n\nerror[E0599]: no method named `is_zero` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpwxa6at0d.rs:10:17\n   |\n10 |\
    \     if fraction.is_zero() {\n   |                 ^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwxa6at0d.rs:11:16\n \
    \  |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                    \
    \                --- expected `f64` because of return type\n...\n11 |        \
    \ return ipart;\n   |                ^^^^^ expected `f64`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `f64`, producing the floating point representation\
    \ of the integer\n   |\n11 |         return ipart.into();\n   |              \
    \       +++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwxa6at0d.rs:18:5\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n18 |     ipart\
    \ / 10\n   |     ^^^^^^^^^^ expected `f64`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `f64`, producing the floating point representation of the integer\n\
    \   |\n18 |     (ipart / 10).into()\n   |     +          ++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    let mut decimal_part: f64 = std::f64::MAX;\n\
    \    while remainder < std::f64::MIN {\n        remainder *= 10;\n        decimal_part\
    \ -= std::f64::ONE;\n    }\n\n    Decimal::from_f64(decimal_part).unwrap()\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Decimal`\n  -->\
    \ /tmp/tmpn4rc0049.rs:15:5\n   |\n15 |     Decimal::from_f64(decimal_part).unwrap()\n\
    \   |     ^^^^^^^ use of undeclared type `Decimal`\n\nerror[E0425]: cannot find\
    \ value `ONE` in module `std::f64`\n  --> /tmp/tmpn4rc0049.rs:12:35\n   |\n12\
    \ |         decimal_part -= std::f64::ONE;\n   |                             \
    \      ^^^ not found in `std::f64`\n\nerror[E0277]: cannot multiply-assign `f64`\
    \ by `{integer}`\n  --> /tmp/tmpn4rc0049.rs:11:19\n   |\n11 |         remainder\
    \ *= 10;\n   |                   ^^ no implementation for `f64 *= {integer}`\n\
    \   |\n   = help: the trait `MulAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `MulAssign<Rhs>`:\n    \
    \         <f32 as MulAssign<&f32>>\n             <f32 as MulAssign>\n        \
    \     <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n            \
    \ <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n             <i16\
    \ as MulAssign<&i16>>\n             <i16 as MulAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    11 |         remainder *= 10.0;\n   |                        ++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.truncate() as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpo00tew5y.rs:8:12\n  |\n8 |     number.truncate() as f64\n\
    \  |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let x = number;\n    let xi = x.trunc();\n    let xf = x.fract();\n\
    \n    // Decompose xi into an integer part and a decimal part.\n    let mut decimal_part\
    \ = xi.fract();\n    let mut integer_part = xi;\n\n    while integer_part >= 1.0\
    \ {\n        integer_part -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += decimal_part;\n    return integer_part as f64 / xf\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6.0`,\n right: `0.5`', /tmp/tmpmb2f71ku.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number % 1 == 0 {\n        number / 1\n    } else {\n     \
    \   number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpuggp1kr_.rs:8:15\n\
    \  |\n8 |     if number % 1 == 0 {\n  |               ^ no implementation for\
    \ `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     if number % 1.0 == 0 {\n  |                  ++\n\nerror[E0277]: cannot\
    \ divide `f64` by `{integer}`\n --> /tmp/tmpuggp1kr_.rs:9:16\n  |\n9 |       \
    \  number / 1\n  |                ^ no implementation for `f64 / {integer}`\n\
    \  |\n  = help: the trait `Div<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Div<Rhs>`:\n            <&'a f32\
    \ as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n\
    \            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n      \
    \      <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a\
    \ isize as Div<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |         number / 1.0\n  |        \
    \           ++\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmphgsn9xtz.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let x = number.floor() as f64;\n    let n = number - x;\n    x.checked_div(n\
    \ as f64).unwrap()\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_div` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp8nqp_hvv.rs:10:7\n   |\n10 |     x.checked_div(n\
    \ as f64).unwrap()\n   |       ^^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        f64::MAX / number\n    } else {\n \
    \       f64::MAX / f64::MAX\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmpb4y88r9j.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.truncate()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp4k090s__.rs:8:12\n  |\n8 |     number.truncate()\n  |  \
    \          ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
