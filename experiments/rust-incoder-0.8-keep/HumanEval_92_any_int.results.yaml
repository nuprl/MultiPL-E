name: HumanEval_92_any_int
language: rust
results:
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let result = z == x || y == x || z == y;\n    result && is_int(z)\
    \ && is_int(y) && is_int(x);\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_int` in this scope\n  --> /tmp/tmp1ad10gld.rs:11:15\n\
    \   |\n11 |     result && is_int(z) && is_int(y) && is_int(x);\n   |         \
    \      ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_int`\
    \ in this scope\n  --> /tmp/tmp1ad10gld.rs:11:28\n   |\n11 |     result && is_int(z)\
    \ && is_int(y) && is_int(x);\n   |                            ^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_int` in this scope\n\
    \  --> /tmp/tmp1ad10gld.rs:11:41\n   |\n11 |     result && is_int(z) && is_int(y)\
    \ && is_int(x);\n   |                                         ^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ad10gld.rs:9:39\n\
    \   |\n9  | fn any_int(x: f64, y: f64, z: f64) -> bool {\n   |    -------    \
    \                        ^^^^ expected `bool`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n10 |\
    \     let result = z == x || y == x || z == y;\n11 |     result && is_int(z) &&\
    \ is_int(y) && is_int(x);\n   |                                              \
    \    - help: remove this semicolon\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    any_num(x, y, z) && any_num(y, z, x)\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `any_num` in this scope\n  --> /tmp/tmpoc1y989h.rs:10:5\n\
    \   |\n10 |     any_num(x, y, z) && any_num(y, z, x)\n   |     ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `any_num` in this scope\n\
    \  --> /tmp/tmpoc1y989h.rs:10:25\n   |\n10 |     any_num(x, y, z) && any_num(y,\
    \ z, x)\n   |                         ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n    if x + y == z {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpkqadqkfc.rs:10:21\n   |\n10 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpkqadqkfc.rs:11:21\n   |\n11 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpkqadqkfc.rs:12:21\n   |\n12 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match (x, y, z) {\n        (+_x, _y, +_z) => x >= z && y >= z &&\
    \ z >= x,\n        (_x, +_y, +_z) => x >= z && y >= z && z >= x,\n        (_x,\
    \ _y, +_z) => x >= z && y >= z && z >= x,\n        (_x, _y, _z) => x >= z && y\
    \ >= z && z >= x,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `+`\n  --> /tmp/tmp2oj7p91m.rs:11:10\n \
    \  |\n11 |         (+_x, _y, +_z) => x >= z && y >= z && z >= x,\n   |       \
    \   ^ expected pattern\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x.floor() as i64;\n    let y_int = y.floor() as i64;\n\
    \    let z_int = z.floor() as i64;\n    x_int == y_int || x_int == z_int\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6edyojop.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut min = (x as usize).min(y as usize).min(z as usize);\n  \
    \  let mut max = x.max(y).max(z);\n    (min as f64).is_integer()\n        && (max\
    \ as f64).is_integer()\n        && (min as f64 - max as f64).is_integer()\n  \
    \      && (min as f64 as usize - max as usize).is_zero()\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp7u6tphut.rs:12:18\n   |\n12 |     (min as f64).is_integer()\n\
    \   |                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp7u6tphut.rs:13:25\n\
    \   |\n13 |         && (max as f64).is_integer()\n   |                       \
    \  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp7u6tphut.rs:14:38\n\
    \   |\n14 |         && (min as f64 - max as f64).is_integer()\n   |          \
    \                            ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_zero` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmp7u6tphut.rs:15:49\n   |\n15 |         && (min as f64 as usize - max\
    \ as usize).is_zero()\n   |                                                 ^^^^^^^\
    \ method not found in `usize`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if f64::from(x) + f64::from(y) == f64::from(z) {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3xzo7ynj.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    any_int(x, y, z, false)\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n\
    \  --> /tmp/tmpjhu0y8cp.rs:10:5\n   |\n10 |     any_int(x, y, z, false)\n   |\
    \     ^^^^^^^ -  -  -  ----- supplied 4 arguments\n   |     |\n   |     expected\
    \ 3 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpjhu0y8cp.rs:9:4\n\
    \   |\n9  | fn any_int(x: f64, y: f64, z: f64) -> bool {\n   |    ^^^^^^^ ------\
    \  ------  ------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y + z && x == z && y == z {\n        return true;\n    }\n\
    \    else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_0hviat8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y + z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if y == -x - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n        return true;\n    }\n    if x == -y - z {\n        return true;\n\
    \    }\n    if x == -y - z {\n        return true;\n    }\n    if x == -y - z\
    \ {\n\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpn03mb5ug.rs:164:3\n\
    \    |\n9   | fn any_int(x: f64, y: f64, z: f64) -> bool {\n    |            \
    \                                - unclosed delimiter\n...\n148 |     if x ==\
    \ -y - z {\n    |                    - this delimiter might not be properly closed...\n\
    149 | \n150 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n164 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpn03mb5ug.rs:9:39\n\
    \  |\n9 | fn any_int(x: f64, y: f64, z: f64) -> bool {\n  |    -------       \
    \                     ^^^^ expected `bool`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if *x < y && y < z {\n        *x <= (x+y+z) < (x+y+z) + 2 && *x\
    \ == *x + *y + *z\n    } else {\n        *y <= (x+y+z) < (x+y+z) + 2 && *y ==\
    \ *y + *z\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpmdbpbtf3.rs:11:12\n\
    \   |\n11 |         *x <= (x+y+z) < (x+y+z) + 2 && *x == *x + *y + *z\n   |  \
    \          ^^         ^\n   |\nhelp: split the comparison into two\n   |\n11 |\
    \         *x <= (x+y+z) && (x+y+z) < (x+y+z) + 2 && *x == *x + *y + *z\n   | \
    \                      ++++++++++\n\nerror: comparison operators cannot be chained\n\
    \  --> /tmp/tmpmdbpbtf3.rs:13:12\n   |\n13 |         *y <= (x+y+z) < (x+y+z) +\
    \ 2 && *y == *y + *z\n   |            ^^         ^\n   |\nhelp: split the comparison\
    \ into two\n   |\n13 |         *y <= (x+y+z) && (x+y+z) < (x+y+z) + 2 && *y ==\
    \ *y + *z\n   |                       ++++++++++\n\nerror[E0614]: type `f64` cannot\
    \ be dereferenced\n  --> /tmp/tmpmdbpbtf3.rs:10:8\n   |\n10 |     if *x < y &&\
    \ y < z {\n   |        ^^\n\nerror[E0614]: type `f64` cannot be dereferenced\n\
    \  --> /tmp/tmpmdbpbtf3.rs:11:9\n   |\n11 |         *x <= (x+y+z) < (x+y+z) +\
    \ 2 && *x == *x + *y + *z\n   |         ^^\n\nerror[E0277]: cannot add `{integer}`\
    \ to `f64`\n  --> /tmp/tmpmdbpbtf3.rs:11:33\n   |\n11 |         *x <= (x+y+z)\
    \ < (x+y+z) + 2 && *x == *x + *y + *z\n   |                                 ^\
    \ no implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         *x <= (x+y+z) < (x+y+z) + 2.0 && *x == *x +\
    \ *y + *z\n   |                                    ++\n\nerror[E0614]: type `f64`\
    \ cannot be dereferenced\n  --> /tmp/tmpmdbpbtf3.rs:11:40\n   |\n11 |        \
    \ *x <= (x+y+z) < (x+y+z) + 2 && *x == *x + *y + *z\n   |                    \
    \                    ^^\n\nerror[E0614]: type `f64` cannot be dereferenc"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = (x as i64).into();\n    let y_int = (y as i64).into();\n\
    \    let z_int = (z as i64).into();\n    match x_int + y_int + z_int {\n     \
    \   i if i >= 0 && i <= 64 => true,\n        i if i <  0 && i >= -64 => false,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpag2j8lud.rs:10:9\n\
    \   |\n10 |     let x_int = (x as i64).into();\n   |         ^^^^^ consider giving\
    \ `x_int` a type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y {\n        if x == z {\n            true\n        } else\
    \ {\n            false\n        }\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu56hcbn0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x: i64 = x;\n    let y: i64 = y;\n    let z: i64 = z;\n    x\
    \ >= y && x >= z && y >= z\n}\n\nfn main() {\n    let candidate = any_int;\n \
    \   assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv6c0gixx.rs:10:18\n   |\n\
    10 |     let x: i64 = x;\n   |            ---   ^ expected `i64`, found `f64`\n\
    \   |            |\n   |            expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv6c0gixx.rs:11:18\n   |\n11 |     let y: i64 = y;\n   |\
    \            ---   ^ expected `i64`, found `f64`\n   |            |\n   |    \
    \        expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv6c0gixx.rs:12:18\n\
    \   |\n12 |     let z: i64 = z;\n   |            ---   ^ expected `i64`, found\
    \ `f64`\n   |            |\n   |            expected due to this\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // Don't allow floats\n    if f64::from_bits(x.bits()) < 0 || f64::from_bits(y.bits())\
    \ < 0 || f64::from_bits(z.bits()) < 0 {\n        return false;\n    }\n\n    let\
    \ x_int = x.to_i();\n    let y_int = y.to_i();\n    let z_int = z.to_i();\n  \
    \  if x_int == y_int + z_int {\n        return true;\n    }\n    else if x_int\
    \ < y_int && z_int == y_int {\n        return true;\n    }\n    else if x_int\
    \ < z_int && y_int == z_int{\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `bits` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp5duo70k4.rs:11:25\n   |\n11 |     if f64::from_bits(x.bits())\
    \ < 0 || f64::from_bits(y.bits()) < 0 || f64::from_bits(z.bits()) < 0 {\n   |\
    \                         ^^^^ help: there is an associated function with a similar\
    \ name: `to_bits`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5duo70k4.rs:11:35\n\
    \   |\n11 |     if f64::from_bits(x.bits()) < 0 || f64::from_bits(y.bits()) <\
    \ 0 || f64::from_bits(z.bits()) < 0 {\n   |                                  \
    \ ^\n   |                                   |\n   |                          \
    \         expected `f64`, found integer\n   |                                \
    \   help: use a float literal: `0.0`\n\nerror[E0599]: no method named `bits` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp5duo70k4.rs:11:57\n   |\n\
    11 |     if f64::from_bits(x.bits()) < 0 || f64::from_bits(y.bits()) < 0 || f64::from_bits(z.bits())\
    \ < 0 {\n   |                                                         ^^^^ help:\
    \ there is an associated function with a similar name: `to_bits`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5duo70k4.rs:11:67\n   |\n11 |     if f64::from_bits(x.bits())\
    \ < 0 || f64::from_bits(y.bits()) < 0 || f64::from_bits(z.bits()) < 0 {\n   |\
    \                                                                   ^\n   |  \
    \                                                                 |\n   |    \
    \                                                               expected `f64`,\
    \ found integer\n   |                                                        \
    \           help: use a float literal: `0.0`\n\nerror[E0599]: no method named\
    \ `bits` found for type `f64` in the current scope\n  --> /tmp/tmp5duo70k4.rs:11:89\n\
    \   |\n11 |     if f64::from_bits(x.bits()) < 0 || f64::from_bits(y.bits()) <\
    \ 0 || f64::from_bits(z.bits()) < 0 {\n   |                                  \
    \                                                       ^^^^ help: there is an\
    \ associated function with a similar name: `to_bits`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n        && ((x\
    \ + y).abs() == z.abs())\n}\n\nfn main() {\n    let candidate = any_int;\n   \
    \ assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0,\
    \ 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp2awssnkw.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp2awssnkw.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp2awssnkw.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= z && y <= z && x >= z && x <= y && y >= y && x >= x\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt2p4ze2h.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut total = 0;\n    if x >= y {\n        total += x;\n    }\n\
    \    if y >= z {\n        total += y;\n    }\n    total += z;\n    total > 0\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpgp2aydup.rs:12:15\n\
    \   |\n12 |         total += x;\n   |               ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpgp2aydup.rs:15:15\n\
    \   |\n15 |         total += y;\n   |               ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpgp2aydup.rs:17:11\n\
    \   |\n17 |     total += z;\n   |           ^^ no implementation for `{integer}\
    \ += f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= y && y <= z && x >= 0 && z >= 0\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjgy_eyo3.rs:10:30\n   |\n\
    10 |     x <= y && y <= z && x >= 0 && z >= 0\n   |                          \
    \    ^\n   |                              |\n   |                            \
    \  expected `f64`, found integer\n   |                              help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjgy_eyo3.rs:10:40\n\
    \   |\n10 |     x <= y && y <= z && x >= 0 && z >= 0\n   |                   \
    \                     ^\n   |                                        |\n   | \
    \                                       expected `f64`, found integer\n   |  \
    \                                      help: use a float literal: `0.0`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == z || (x - y == z)) && {\n        let mut n: f64 = 0;\n   \
    \     if x > y { n += x - y; }\n        if x > z { n += x - z; }\n        if y\
    \ > z { n += y - z; }\n        n == x\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3idbqrz.rs:11:26\n   |\n\
    11 |         let mut n: f64 = 0;\n   |                    ---   ^\n   |      \
    \              |     |\n   |                    |     expected `f64`, found integer\n\
    \   |                    |     help: use a float literal: `0.0`\n   |        \
    \            expected due to this\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    !is_integer(x) || !is_integer(y) || !is_integer(z) || x == x + y\
    \ + z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_integer` in this scope\n  --> /tmp/tmpjqek0b_k.rs:10:6\n\
    \   |\n10 |     !is_integer(x) || !is_integer(y) || !is_integer(z) || x == x +\
    \ y + z\n   |      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_integer` in this scope\n  --> /tmp/tmpjqek0b_k.rs:10:24\n\
    \   |\n10 |     !is_integer(x) || !is_integer(y) || !is_integer(z) || x == x +\
    \ y + z\n   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_integer` in this scope\n  --> /tmp/tmpjqek0b_k.rs:10:42\n\
    \   |\n10 |     !is_integer(x) || !is_integer(y) || !is_integer(z) || x == x +\
    \ y + z\n   |                                          ^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    sum.is_integer_from_integer_range(From::from(x),\
    \ From::from(y), From::from(z))\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer_from_integer_range` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpsfyp9fqk.rs:11:9\n   |\n11 |\
    \     sum.is_integer_from_integer_range(From::from(x), From::from(y), From::from(z))\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x == y + z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmprg3zy4_u.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmprg3zy4_u.rs:11:14\n\
    \   |\n11 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmprg3zy4_u.rs:12:14\n   |\n12 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n    x.is_integer() == y.is_integer()\
    \ && x.is_integer() == z.is_integer() && x.is_integer() + y.is_integer() + z.is_integer()\
    \ == 4\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpyzrjaqn0.rs:10:7\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() || x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpyzrjaqn0.rs:10:25\n\
    \   |\n10 |     x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpyzrjaqn0.rs:10:43\n   |\n\
    10 |     x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n   |                               \
    \            ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpyzrjaqn0.rs:10:61\n\
    \   |\n10 |     x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n   |                               \
    \                              ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpyzrjaqn0.rs:10:79\n   |\n10 |     x.is_integer() || y.is_integer() ||\
    \ z.is_integer() || x.is_integer() && y.is_integer() && z.is_integer() &&\n  \
    \ |                                                                          \
    \     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpyzrjaqn0.rs:10:97\n\
    \   |\n10 |     x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n   |                               \
    \                                                                  ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ fo"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x.checked_add(y).checked_add(z).unwrap() {\n        Some(x)\
    \ => x.is_integer(),\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpwuq241sy.rs:10:13\n   |\n10 |     match x.checked_add(y).checked_add(z).unwrap()\
    \ {\n   |             ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int: i32 = (x as isize);\n    let y_int: i32 = (y as isize);\n\
    \    let z_int: i32 = (z as isize);\n    x_int == y_int && x_int == z_int ||\n\
    \        (x_int != y_int && x_int != z_int)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpq0udxz9f.rs:10:22\n\
    \   |\n10 |     let x_int: i32 = (x as isize);\n   |                      ^  \
    \        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n10 -     let x_int: i32 = (x as isize);\n10 +     let\
    \ x_int: i32 = x as isize;\n   | \n\nwarning: unnecessary parentheses around assigned\
    \ value\n  --> /tmp/tmpq0udxz9f.rs:11:22\n   |\n11 |     let y_int: i32 = (y as\
    \ isize);\n   |                      ^          ^\n   |\nhelp: remove these parentheses\n\
    \   |\n11 -     let y_int: i32 = (y as isize);\n11 +     let y_int: i32 = y as\
    \ isize;\n   | \n\nwarning: unnecessary parentheses around assigned value\n  -->\
    \ /tmp/tmpq0udxz9f.rs:12:22\n   |\n12 |     let z_int: i32 = (z as isize);\n \
    \  |                      ^          ^\n   |\nhelp: remove these parentheses\n\
    \   |\n12 -     let z_int: i32 = (z as isize);\n12 +     let z_int: i32 = z as\
    \ isize;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq0udxz9f.rs:10:22\n\
    \   |\n10 |     let x_int: i32 = (x as isize);\n   |                ---   ^^^^^^^^^^^^\
    \ expected `i32`, found `isize`\n   |                |\n   |                expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to an `i32` and panic if\
    \ the converted value doesn't fit\n   |\n10 |     let x_int: i32 = ((x as isize)).try_into().unwrap();\n\
    \   |                      +            +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq0udxz9f.rs:11:22\n   |\n11 |     let y_int:\
    \ i32 = (y as isize);\n   |                ---   ^^^^^^^^^^^^ expected `i32`,\
    \ found `isize`\n   |                |\n   |                expected due to this\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let y_int: i32 = ((y as isize)).try_into().unwrap();\n\
    \   |                      +            +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq0udxz9f.rs:12:22\n   |\n12 |     let z_int:\
    \ i32 = (z as isize);\n   |                ---   ^^^^^^^^^^^^ expected `i32`,\
    \ found `isize`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x != 0 || (y != 0 && z != 0)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0o5e9v_6.rs:10:10\n   |\n\
    10 |     x != 0 || (y != 0 && z != 0)\n   |          ^\n   |          |\n   |\
    \          expected `f64`, found integer\n   |          help: use a float literal:\
    \ `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0o5e9v_6.rs:10:21\n \
    \  |\n10 |     x != 0 || (y != 0 && z != 0)\n   |                     ^\n   |\
    \                     |\n   |                     expected `f64`, found integer\n\
    \   |                     help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0o5e9v_6.rs:10:31\n   |\n10 |     x != 0 || (y != 0 &&\
    \ z != 0)\n   |                               ^\n   |                        \
    \       |\n   |                               expected `f64`, found integer\n\
    \   |                               help: use a float literal: `0.0`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x >= y && y >= z && x >= z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3s97dme6.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= x + y && x <= y + z && x <= z + x && x <= x + z && x <= y +\
    \ x\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpipvcf9u_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // Avoid overflow here.\n    if x > y || y > z {\n        return\
    \ false;\n    }\n    if y > z {\n        return true;\n    }\n    if x > z {\n\
    \        return x.trunc() == y || x.trunc() == z;\n    }\n    return x.trunc()\
    \ == y || x.trunc() == z;\n}\n\nfn main() {\n    let candidate = any_int;\n  \
    \  assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8uco3aur.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y || y == z || z == x {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnemwhxyc.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut x_ints = x.floor() as f64;\n    let mut y_ints = y.floor()\
    \ as f64;\n    let mut z_ints = z.floor() as f64;\n    match x_ints, y_ints, z_ints\
    \ {\n        (Some(x_int), Some(y_int), Some(z_int)) => {\n            // Make\
    \ sure they are all integers\n            if x_int != x_int || y_int != y_int\
    \ || z_int != z_int\n                || (x_int + y_int).abs() != z_int\n     \
    \       {\n                return false;\n            }\n            if x_int\
    \ == x_int + y_int {\n                return x_int == z_int;\n            }\n\
    \            if y_int == y_int + z_int\n                && (x_int == x_int + y_int\n\
    \                    || x_int == y_int + z_int)\n            {\n             \
    \   return true;\n            }\n            if x_int == x_int + y_int + z_int\n\
    \                && (y_int == y_int + z_int\n                    || x_int == x_int\
    \ + y_int + z_int)\n            {\n                return true;\n            }\n\
    \            return false;\n        }\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmp_p9ejqin.rs:13:17\n   |\n13 |     match x_ints, y_ints, z_ints\
    \ {\n   |     -----       ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n\
    \   |     |\n   |     while parsing this `match` expression\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || y.is_integer() || z.is_integer() ||\n        (x.is_integer()\
    \ && y.is_integer() && z.is_integer())\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp06fj60j4.rs:10:7\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() ||\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp06fj60j4.rs:10:25\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer() ||\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp06fj60j4.rs:10:43\n   |\n\
    10 |     x.is_integer() || y.is_integer() || z.is_integer() ||\n   |         \
    \                                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp06fj60j4.rs:11:12\n   |\n11 |         (x.is_integer() && y.is_integer()\
    \ && z.is_integer())\n   |            ^^^^^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp06fj60j4.rs:11:30\n   |\n11 |         (x.is_integer() &&\
    \ y.is_integer() && z.is_integer())\n   |                              ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp06fj60j4.rs:11:48\n   |\n\
    11 |         (x.is_integer() && y.is_integer() && z.is_integer())\n   |      \
    \                                          ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer(*)\
    \ && y.is_integer(*) && z.is_integer(*) || x.is_integer(*) && y.is_integer(*)\
    \ || z.is_integer(*) || x.is_integer(*) || y.is_integer(*) || z.is_integer(*)\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmpc1q32bcl.rs:10:73\n\
    \   |\n10 |     x.is_integer() || y.is_integer() || z.is_integer() || x.is_integer(*)\
    \ && y.is_integer(*) && z.is_integer(*) || x.is_integer(*) && y.i...\n   |   \
    \                                                                      ^ expected\
    \ expression\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer() && x + y + z\
    \ == x.to_f64()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpzk0ayl6m.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == x.to_f64()\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpzk0ayl6m.rs:10:25\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y + z == x.to_f64()\n\
    \   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpzk0ayl6m.rs:10:43\n   |\n10 |     x.is_integer() && y.is_integer() &&\
    \ z.is_integer() && x + y + z == x.to_f64()\n   |                            \
    \               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmpzk0ayl6m.rs:10:74\n\
    \   |\n10 |     x.is_integer() && y.is_integer() && z.is_integer() && x + y +\
    \ z == x.to_f64()\n   |                                                      \
    \                    ^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == f64::from(x + y + z)) && (x.trunc() != f64::from(x).trunc())\
    \ && (x.trunc() != f64::from(y).trunc()) && (x.trunc() != f64::from(z).trunc())\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmfvzc1pq.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x.is_integer() && y.is_integer() && z.is_integer() {\n      \
    \  let s = x + y + z;\n        let f1 = x.abs() + y.abs();\n        let f2 = x.abs()\
    \ + z.abs();\n        if s < f1 && s < f2 {\n            return true;\n      \
    \  }\n    }\n    false\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpvx2hsfqa.rs:10:10\n   |\n10 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpvx2hsfqa.rs:10:28\n   |\n10 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |                            ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpvx2hsfqa.rs:10:46\n   |\n\
    10 |     if x.is_integer() && y.is_integer() && z.is_integer() {\n   |       \
    \                                       ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if f64::from(x + y + z) == z {\n        return true;\n    }\n  \
    \  else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp54jnoeas.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x >= 0 && y >= 0 && z >= 0 && x > y && x > z && y > z && x <= z\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3yqnv5nj.rs:10:10\n   |\n\
    10 |     x >= 0 && y >= 0 && z >= 0 && x > y && x > z && y > z && x <= z\n   |\
    \          ^\n   |          |\n   |          expected `f64`, found integer\n \
    \  |          help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3yqnv5nj.rs:10:20\n   |\n10 |     x >= 0 && y >= 0 && z >= 0 &&\
    \ x > y && x > z && y > z && x <= z\n   |                    ^\n   |         \
    \           |\n   |                    expected `f64`, found integer\n   |   \
    \                 help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3yqnv5nj.rs:10:30\n   |\n10 |     x >= 0 && y >= 0 && z\
    \ >= 0 && x > y && x > z && y > z && x <= z\n   |                            \
    \  ^\n   |                              |\n   |                              expected\
    \ `f64`, found integer\n   |                              help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_abs = std::fabs(x.unwrap());\n    let y_abs = std::fabs(y.unwrap());\n\
    \    let z_abs = std::fabs(z.unwrap());\n    let x_int = x.unwrap() as f64 as\
    \ i64;\n    let y_int = y.unwrap() as f64 as i64;\n    let z_int = z.unwrap()\
    \ as f64 as i64;\n    let x_sum = x_abs + y_abs + z_abs;\n    x_int == x_sum\n\
    \        && y_int == y_abs\n        && z_int == z_abs\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fabs` in crate `std`\n  --> /tmp/tmp5ui9i3vr.rs:10:22\n\
    \   |\n10 |     let x_abs = std::fabs(x.unwrap());\n   |                     \
    \ ^^^^ not found in `std`\n\nerror[E0425]: cannot find function `fabs` in crate\
    \ `std`\n  --> /tmp/tmp5ui9i3vr.rs:11:22\n   |\n11 |     let y_abs = std::fabs(y.unwrap());\n\
    \   |                      ^^^^ not found in `std`\n\nerror[E0425]: cannot find\
    \ function `fabs` in crate `std`\n  --> /tmp/tmp5ui9i3vr.rs:12:22\n   |\n12 |\
    \     let z_abs = std::fabs(z.unwrap());\n   |                      ^^^^ not found\
    \ in `std`\n\nerror[E0599]: no method named `unwrap` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5ui9i3vr.rs:10:29\n   |\n10 |     let x_abs = std::fabs(x.unwrap());\n\
    \   |                             ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmp5ui9i3vr.rs:11:29\n\
    \   |\n11 |     let y_abs = std::fabs(y.unwrap());\n   |                     \
    \        ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp5ui9i3vr.rs:12:29\n\
    \   |\n12 |     let z_abs = std::fabs(z.unwrap());\n   |                     \
    \        ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp5ui9i3vr.rs:13:19\n\
    \   |\n13 |     let x_int = x.unwrap() as f64 as i64;\n   |                  \
    \ ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp5ui9i3vr.rs:14:19\n   |\n\
    14 |     let y_int = y.unwrap() as f64 as i64;\n   |                   ^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmp5ui9i3vr.rs:15:19\n   |\n15 |\
    \     let z_int = z.unwrap() as f64 as i64;\n   |                   ^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 9 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an er"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpzlre9fgx.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpzlre9fgx.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpzlre9fgx.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    match sum.trunc_norm() {\n        Some(v)\
    \ if v == x || v == y || v == z => true,\n        _ => false,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc_norm` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpib_6f4kd.rs:11:15\n   |\n11 |     match sum.trunc_norm()\
    \ {\n   |               ^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x: f64 = x as i32;\n    let y: f64 = y as i32;\n    let z: f64\
    \ = z as i32;\n\n    if x == y && y == z {\n        true\n    } else {\n     \
    \   false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpws6imnua.rs:10:18\n   |\n\
    10 |     let x: f64 = x as i32;\n   |            ---   ^^^^^^^^ expected `f64`,\
    \ found `i32`\n   |            |\n   |            expected due to this\n   |\n\
    help: you can convert an `i32` to an `f64`, producing the floating point representation\
    \ of the integer\n   |\n10 |     let x: f64 = (x as i32).into();\n   |       \
    \           +        ++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpws6imnua.rs:11:18\n\
    \   |\n11 |     let y: f64 = y as i32;\n   |            ---   ^^^^^^^^ expected\
    \ `f64`, found `i32`\n   |            |\n   |            expected due to this\n\
    \   |\nhelp: you can convert an `i32` to an `f64`, producing the floating point\
    \ representation of the integer\n   |\n11 |     let y: f64 = (y as i32).into();\n\
    \   |                  +        ++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpws6imnua.rs:12:18\n   |\n12 |     let z: f64 = z as i32;\n   | \
    \           ---   ^^^^^^^^ expected `f64`, found `i32`\n   |            |\n  \
    \ |            expected due to this\n   |\nhelp: you can convert an `i32` to an\
    \ `f64`, producing the floating point representation of the integer\n   |\n12\
    \ |     let z: f64 = (z as i32).into();\n   |                  +        ++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.floor() == y || x.floor() == z || y.floor() == z\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqoh6t8c.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let min_int = f64::min(x.round() as i64, y.round() as i64, z.round()\
    \ as i64);\n    let max_int = f64::max(x.round() as i64, y.round() as i64, z.round()\
    \ as i64);\n    if min_int <= max_int {\n        if min_int == z && max_int ==\
    \ y {\n            return true;\n        }\n        if min_int == x && max_int\
    \ == z {\n            return true;\n        }\n        if min_int == y && max_int\
    \ == x {\n            return true;\n        }\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \   --> /tmp/tmp2fcefbdj.rs:10:19\n    |\n10  |     let min_int = f64::min(x.round()\
    \ as i64, y.round() as i64, z.round() as i64);\n    |                   ^^^^^^^^\
    \ ----------------  ----------------  ---------------- supplied 3 arguments\n\
    \    |                   |\n    |                   expected 2 arguments\n   \
    \ |\nnote: associated function defined here\n\nerror[E0061]: this function takes\
    \ 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp2fcefbdj.rs:11:19\n\
    \    |\n11  |     let max_int = f64::max(x.round() as i64, y.round() as i64, z.round()\
    \ as i64);\n    |                   ^^^^^^^^ ----------------  ----------------\
    \  ---------------- supplied 3 arguments\n    |                   |\n    |   \
    \                expected 2 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x: f64 = x.into();\n    let y: f64 = y.into();\n    let z: f64\
    \ = z.into();\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x == y\n        || x == z\n        || y == z\n        || (x.is_nan()\
    \ && y.is_nan() && z.is_nan())\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpjttv2sf6.rs:13:7\n   |\n13 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpjttv2sf6.rs:14:14\n\
    \   |\n14 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpjttv2sf6.rs:15:14\n   |\n15 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut z = x + y;\n    z -= z;\n    z != 0 || z != z\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoi3r3wz7.rs:12:10\n   |\n\
    12 |     z != 0 || z != z\n   |          ^\n   |          |\n   |          expected\
    \ `f64`, found integer\n   |          help: use a float literal: `0.0`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // TODO: check bounds\n    let mut sum = 0;\n    sum += x;\n   \
    \ sum += y;\n    sum += z;\n    sum == sum\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpt8hx0he4.rs:12:9\n\
    \   |\n12 |     sum += x;\n   |         ^^ no implementation for `{integer} +=\
    \ f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpt8hx0he4.rs:13:9\n\
    \   |\n13 |     sum += y;\n   |         ^^ no implementation for `{integer} +=\
    \ f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmpt8hx0he4.rs:14:9\n\
    \   |\n14 |     sum += z;\n   |         ^^ no implementation for `{integer} +=\
    \ f64`\n   |\n   = help: the trait `AddAssign<f64>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x as f32;\n    let y_int = y as f32;\n    let z_int\
    \ = z as f32;\n    if x_int + y_int + z_int >= x_int + y_int + z_int\n       \
    \ || x_int + y_int + z_int\n            >= x_int + y_int + z_int\n        || x_int\
    \ + y_int\n            >= x_int + y_int\n    {\n        return true;\n    } else\
    \ {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwlpdfars.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // Check that the numbers are integers\n    assert!(x.is_integer());\n\
    \    assert!(y.is_integer());\n    assert!(z.is_integer());\n\n    // Check that\
    \ the sum of all the numbers is equal to the sum of the other two\n    x + y ==\
    \ z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5v_4t3xr.rs:11:15\n   |\n11 |     assert!(x.is_integer());\n\
    \   |               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp5v_4t3xr.rs:12:15\n\
    \   |\n12 |     assert!(y.is_integer());\n   |               ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp5v_4t3xr.rs:13:15\n   |\n13 |    \
    \ assert!(z.is_integer());\n   |               ^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // TODO: check x,y,z are integer\n    x.iter().any(|&x| x.is_integer())\
    \ && y.iter().any(|&y| y.is_integer()) && z.iter().any(|&z| z.is_integer())\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpnlv_0jl1.rs:11:7\n   |\n11 |     x.iter().any(|&x| x.is_integer())\
    \ && y.iter().any(|&y| y.is_integer()) && z.iter().any(|&z| z.is_integer())\n\
    \   |       ^^^^ method not found in `f64`\n\nerror[E0599]: no method named `iter`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpnlv_0jl1.rs:11:44\n\
    \   |\n11 |     x.iter().any(|&x| x.is_integer()) && y.iter().any(|&y| y.is_integer())\
    \ && z.iter().any(|&z| z.is_integer())\n   |                                 \
    \           ^^^^ method not found in `f64`\n\nerror[E0599]: no method named `iter`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpnlv_0jl1.rs:11:81\n\
    \   |\n11 |     x.iter().any(|&x| x.is_integer()) && y.iter().any(|&y| y.is_integer())\
    \ && z.iter().any(|&z| z.is_integer())\n   |                                 \
    \                                                ^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x.checked_add(y).checked_add(z) {\n        Some(z) => z ==\
    \ x,\n        None => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmptqqsfv9h.rs:10:13\n   |\n10 |     match x.checked_add(y).checked_add(z)\
    \ {\n   |             ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= y + z && x >= y - z && !(x <= y && x <= z && x >= y && x >=\
    \ z)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdd0k7w_6.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y || y == z {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe8pti9a2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x, y, z {\n        x if x == 0 => true,\n        _ if x ==\
    \ y => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmpasiq06ne.rs:10:12\n   |\n10 |     match x, y, z {\n   | \
    \    -----  ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n   | \
    \    |\n   |     while parsing this `match` expression\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.cmp(&y) == 0 && x.cmp(&z) == 0 && y.cmp(&z) == 0\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `f64` is not an iterator\n  --> /tmp/tmpyq0cspuu.rs:10:7\n\
    \   |\n10 |     x.cmp(&y) == 0 && x.cmp(&z) == 0 && y.cmp(&z) == 0\n   |     \
    \  ^^^ `f64` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `f64: Iterator`\n           which is required by\
    \ `&mut f64: Iterator`\n\nerror[E0599]: `f64` is not an iterator\n  --> /tmp/tmpyq0cspuu.rs:10:25\n\
    \   |\n10 |     x.cmp(&y) == 0 && x.cmp(&z) == 0 && y.cmp(&z) == 0\n   |     \
    \                    ^^^ `f64` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror[E0599]: `f64` is not an iterator\n\
    \  --> /tmp/tmpyq0cspuu.rs:10:43\n   |\n10 |     x.cmp(&y) == 0 && x.cmp(&z) ==\
    \ 0 && y.cmp(&z) == 0\n   |                                           ^^^ `f64`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x.to_i64() == y.to_i64()\n        || x.to_i64() == z.to_i64()\n  \
    \      || y.to_i64() == z.to_i64()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5zte47y3.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp5zte47y3.rs:11:14\n\
    \   |\n11 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp5zte47y3.rs:12:14\n   |\n12 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `to_i64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp5zte47y3.rs:13:14\n   |\n13 |         || x.to_i64() == y.to_i64()\n\
    \   |              ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `to_i64` found for type `f64` in the current scope\n  --> /tmp/tmp5zte47y3.rs:13:28\n\
    \   |\n13 |         || x.to_i64() == y.to_i64()\n   |                        \
    \    ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_i64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp5zte47y3.rs:14:14\n\
    \   |\n14 |         || x.to_i64() == z.to_i64()\n   |              ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `to_i64` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp5zte47y3.rs:14:28\n   |\n14 |    \
    \     || x.to_i64() == z.to_i64()\n   |                            ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `to_i64` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp5zte47y3.rs:15:14\n   |\n15 |    \
    \     || y.to_i64() == z.to_i64()\n   |              ^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no method named `to_i64` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5zte47y3.rs:15:28\n   |\n15 |         || y.to_i64()\
    \ == z.to_i64()\n   |                            ^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 9 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n        && x.to_f64()\
    \ + y.to_f64() == z.to_f64()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpcvat3uee.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpcvat3uee.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpcvat3uee.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmpcvat3uee.rs:11:14\n\
    \   |\n11 |         && x.to_f64() + y.to_f64() == z.to_f64()\n   |           \
    \   ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_f64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpcvat3uee.rs:11:27\n\
    \   |\n11 |         && x.to_f64() + y.to_f64() == z.to_f64()\n   |           \
    \                ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmpcvat3uee.rs:11:41\n\
    \   |\n11 |         && x.to_f64() + y.to_f64() == z.to_f64()\n   |           \
    \                              ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match (x, y, z) {\n        (0., 0., 0.0) |\n        (0.0., 0., 0.0)\
    \ |\n        (0.0, 0.0, 0.0) |\n        (0., 0., 0.) |\n        (0.0, _, 0.0)\
    \ |\n        (_, 0.0., 0.0) |\n        (_, _, 0.0) => true,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `)`, `,`, `...`, `..=`, `..`, or `|`, found `.`\n\
    \  --> /tmp/tmpz4bqwm02.rs:12:13\n   |\n12 |         (0.0., 0., 0.0) |\n   | \
    \            ^ expected one of `)`, `,`, `...`, `..=`, `..`, or `|`\n\nerror:\
    \ unexpected `,` in pattern\n  --> /tmp/tmpz4bqwm02.rs:12:14\n   |\n12 |     \
    \    (0.0., 0., 0.0) |\n   |              ^\n   |\nhelp: try adding parentheses\
    \ to match on a tuple...\n   |\n12 |         ((0.0., 0., 0.0)) |\n   |       \
    \  +              +\nhelp: ...or a vertical bar to match on multiple alternatives\n\
    \   |\n12 |         (0.0. | 0. | 0.0) |\n   |         ~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut sum = x;\n    if y != x {\n        sum += y;\n    }\n  \
    \  if z != x {\n        sum += z;\n    }\n    sum != x\n}\n\nfn main() {\n   \
    \ let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuxaecvzn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        && y.is_integer()\n        && z.is_integer()\n\
    \        && x + y == z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpbmt21_zg.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpbmt21_zg.rs:11:14\n\
    \   |\n11 |         && y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpbmt21_zg.rs:12:14\n   |\n12 |    \
    \     && z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        && y.is_integer()\n        && z.is_integer()\n\
    \        && (x.abs() + y.abs() + z.abs()).is_integer()\n}\n\nfn main() {\n   \
    \ let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmptgk03928.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmptgk03928.rs:11:14\n\
    \   |\n11 |         && y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmptgk03928.rs:12:14\n   |\n12 |    \
    \     && z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmptgk03928.rs:13:42\n   |\n13 |         && (x.abs() + y.abs()\
    \ + z.abs()).is_integer()\n   |                                          ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let _x = x.floor();\n    let _y = y.floor();\n    let _z = z.floor();\n\
    \    let _x_i = x.trunc();\n    let _y_i = y.trunc();\n    let _z_i = z.trunc();\n\
    \    let _x_d = x.floor();\n    let _y_d = y.floor();\n    let _z_d = z.floor();\n\
    \    if _x_i.rem(_x_d) == 0 && _y_i.rem(_y_d) == 0 && _z_i.rem(_z_d) == 0 {\n\
    \        return true;\n    } else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rem` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmp89crzmki.rs:19:13\n    |\n19  |     if _x_i.rem(_x_d)\
    \ == 0 && _y_i.rem(_y_d) == 0 && _z_i.rem(_z_d) == 0 {\n    |             ^^^\
    \ method not found in `f64`\n    |\n    = help: items from traits can only be\
    \ used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n    |\n1   | use std::ops::Rem;\n\
    \    |\n\nerror[E0599]: no method named `rem` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmp89crzmki.rs:19:36\n    |\n19  |     if _x_i.rem(_x_d)\
    \ == 0 && _y_i.rem(_y_d) == 0 && _z_i.rem(_z_d) == 0 {\n    |                \
    \                    ^^^ method not found in `f64`\n    |\n    = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n    |\n1   | use\
    \ std::ops::Rem;\n    |\n\nerror[E0599]: no method named `rem` found for type\
    \ `f64` in the current scope\n   --> /tmp/tmp89crzmki.rs:19:59\n    |\n19  | \
    \    if _x_i.rem(_x_d) == 0 && _y_i.rem(_y_d) == 0 && _z_i.rem(_z_d) == 0 {\n\
    \    |                                                           ^^^ method not\
    \ found in `f64`\n    |\n    = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n    |\n1   | use std::ops::Rem;\n    |\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == z {\n        return y == z;\n    } else if x < z {\n   \
    \     if y < z {\n            x < y || y < x\n        } else {\n            x\
    \ < z || z < x\n        }\n    } else {\n        if y > z {\n            y < x\
    \ || y < z\n        } else {\n            y < z || z < y\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmp3db7ni.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == 3 || y == 3 || z == 3 {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8kq9k9k6.rs:10:13\n   |\n\
    10 |     if x == 3 || y == 3 || z == 3 {\n   |             ^\n   |           \
    \  |\n   |             expected `f64`, found integer\n   |             help: use\
    \ a float literal: `3.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kq9k9k6.rs:10:23\n\
    \   |\n10 |     if x == 3 || y == 3 || z == 3 {\n   |                       ^\n\
    \   |                       |\n   |                       expected `f64`, found\
    \ integer\n   |                       help: use a float literal: `3.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8kq9k9k6.rs:10:33\n   |\n10 |     if x == 3\
    \ || y == 3 || z == 3 {\n   |                                 ^\n   |        \
    \                         |\n   |                                 expected `f64`,\
    \ found integer\n   |                                 help: use a float literal:\
    \ `3.0`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x.floor();\n    let y_int = y.floor();\n    let z_int\
    \ = z.floor();\n    if x_int > y_int {\n        x <= x + y && x >= y + z\n   \
    \ } else {\n        y <= y + z && y >= x + z\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzw4ppg1j.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= y && x <= z && x >= y && x >= z\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa2iypt3t.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match (x, y, z) {\n        (0...3) => x.is_integer()\n         \
    \   || y.is_integer()\n            || z.is_integer(),\n        (_, y, z) => y.is_integer()\n\
    \            || z.is_integer(),\n        _ => false,\n    }\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmp0x7ziu70.rs:11:11\n\
    \   |\n11 |         (0...3) => x.is_integer()\n   |           ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0x7ziu70.rs:11:10\n   |\n10 |\
    \     match (x, y, z) {\n   |           --------- this expression has type `(f64,\
    \ f64, f64)`\n11 |         (0...3) => x.is_integer()\n   |          ^   - this\
    \ is of type `{integer}`\n   |          |\n   |          expected tuple, found\
    \ integer\n   |\n   = note: expected tuple `(f64, f64, f64)`\n               found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0x7ziu70.rs:11:14\n\
    \   |\n10 |     match (x, y, z) {\n   |           --------- this expression has\
    \ type `(f64, f64, f64)`\n11 |         (0...3) => x.is_integer()\n   |       \
    \   -   ^ expected tuple, found integer\n   |          |\n   |          this is\
    \ of type `{integer}`\n   |\n   = note: expected tuple `(f64, f64, f64)`\n   \
    \            found type `{integer}`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp0x7ziu70.rs:11:22\n\
    \   |\n11 |         (0...3) => x.is_integer()\n   |                      ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp0x7ziu70.rs:12:18\n   |\n\
    12 |             || y.is_integer()\n   |                  ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp0x7ziu70.rs:13:18\n   |\n13 |    \
    \         || z.is_integer(),\n   |                  ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp0x7ziu70."
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut sum = x + y + z;\n    sum > 0.0 && sum < std::f64::MAX\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiab4g4r2.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x.floor();\n    let y_int = y.floor();\n    let z_int\
    \ = z.floor();\n    if x_int == y_int + z_int {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpejcip8o_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // any number equals the sum of the other two\n    if x == y ||\
    \ x == z {\n        return true;\n    }\n    // all numbers are integers\n   \
    \ if y as f64 > 0 {\n        return true;\n    }\n    if z as f64 > 0 {\n    \
    \    return true;\n    }\n    // all numbers are negative integers\n    if x as\
    \ f64 > 0 {\n        return true;\n    }\n    if y as f64 > 0 {\n        return\
    \ true;\n    }\n    // any number is a positive integer\n    if z as f64 > 0 {\n\
    \        return true;\n    }\n    // all numbers are negative integers\n    if\
    \ x as f64 > 0 {\n        return true;\n    }\n    if y as f64 > 0 {\n       \
    \ return true;\n    }\n    // any number is a positive integer\n    if z as f64\
    \ > 0 {\n        return true;\n    }\n    // all numbers are negative integers\n\
    \    if x as f64 > 0 {\n        return true;\n    }\n    if y as f64 > 0 {\n \
    \       return true;\n    }\n    // all numbers are negative integers\n    if\
    \ z as f64 > 0 {\n        return true;\n    }\n    // all numbers are negative\
    \ integers\n    if x as f64 > 0 {\n        return true;\n    }\n    if y as f64\
    \ > 0 {\n        return true;\n    }\n    if z as f64 > 0 {\n        return true;\n\
    \    }\n    // any number is a positive integer\n    if z as f64 > 0 {\n     \
    \   return true;\n    }\n    // all numbers are negative integers\n    if x as\
    \ f64 > 0 {\n        return true;\n    }\n    if y as f64 > 0 {\n        return\
    \ true;\n    }\n    // any number is a positive integer\n    if z as f64 > 0 {\n\
    \        return true;\n    }\n    // all numbers are negative integers\n    if\
    \ x as f64 > 0 {\n        return true;\n    }\n    if y as f64 > 0 {\n       \
    \ return true;\n    }\n    // any number is a positive integer\n    if z as f64\
    \ > 0 {\n        return true;\n    }\n    // all numbers are negative integers\n\
    \    if x as f64 > 0 {\n        return true;\n    }\n    if y as f64 > 0 {\n \
    \       return true;\n    }\n    // all numbers are negative integers\n    if\
    \ z as f64 > 0 {\n        return true;\n    }\n    // any number is a positive\
    \ integer\n    if z as f64 > 0 {\n        return true;\n    }\n    // all numbers\
    \ are negative integers\n    if x as f64 > 0 {\n        return true;\n    }\n\
    \    if y as f64 > 0 {\n        return true;\n    }\n    // any number is a positive\
    \ integer\n    if z as f64 > 0 {\n        return true;\n    }\n    // all numbers\
    \ are negative integers\n    if x as f64 > 0 {\n        return true;\n    }\n\
    \    if y as f64 > 0 {\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfcd5ws3l.rs:135:3\n\
    \    |\n9   | fn any_int(x: f64, y: f64, z: f64) -> bool {\n    |            \
    \                                - unclosed delimiter\n...\n120 |     if y as\
    \ f64 > 0 {\n    |                     - this delimiter might not be properly\
    \ closed...\n121 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n135 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcd5ws3l.rs:15:19\n\
    \   |\n15 |     if y as f64 > 0 {\n   |                   ^\n   |            \
    \       |\n   |                   expected `f64`, found integer\n   |        \
    \           help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfcd5ws3l.rs:18:19\n   |\n18 |     if z as f64 > 0 {\n   |     \
    \              ^\n   |                   |\n   |                   expected `f64`,\
    \ found integer\n   |                   help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcd5ws3l.rs:22:19\n   |\n22 |     if x as f64\
    \ > 0 {\n   |                   ^\n   |                   |\n   |            \
    \       expected `f64`, found integer\n   |                   help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcd5ws3l.rs:25:19\n\
    \   |\n25 |     if y as f64 > 0 {\n   |                   ^\n   |            \
    \       |\n   |                   expected `f64`, found integer\n   |        \
    \           help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfcd5ws3l.rs:29:19\n   |\n29 |     if z as f64 > 0 {\n   |     \
    \              ^\n   |                   |\n   |                   expected `f64`,\
    \ found integer\n   |                   help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfcd5ws3l.rs:33:19\n   |\n33 |     if x as f64\
    \ > 0 {\n   |                   ^\n   |                   |\n   |            \
    \       expected `f64`, found integer\n   |                   help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcd5ws3l.rs:36:19\n\
    \   |\n36 |     if y as f64 > 0 {\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    any_int_generic(x, y, z, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, \n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpwfr534v_.rs:10:20\n\
    \   |\n9  | fn any_int(x: f64, y: f64, z: f64) -> bool {\n   |               \
    \                             - closing delimiter possibly meant for this\n10\
    \ |     any_int_generic(x, y, z, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, fal...\n   |       \
    \             ^ unclosed delimiter\n11 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find function `any_int_generic` in this scope\n  --> /tmp/tmpwfr534v_.rs:10:5\n\
    \   |\n10 |     any_int_generic(x, y, z, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, fal...\n   |\
    \     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x <= y && y <= z && x >= z {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp71c8l5xc.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y {\n        if x == z {\n            true\n        } else\
    \ {\n            false\n        }\n    } else if y == z {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdtwpls9z.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    let mut x: i64 = x.into();\n    let mut\
    \ y: i64 = y.into();\n    let mut z: i64 = z.into();\n    if sum == x.into() &&\
    \ sum == y.into() && sum == z.into() {\n        return true;\n    }\n    else\
    \ {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `i64: From<f64>` is not satisfied\n  -->\
    \ /tmp/tmpi2aipwhl.rs:11:24\n   |\n11 |     let mut x: i64 = x.into();\n   | \
    \                       ^^^^ the trait `From<f64>` is not implemented for `i64`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <f32 as From<i16>>\n             <f32 as From<i8>>\n             <f32\
    \ as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n   = note: required because of\
    \ the requirements on the impl of `Into<i64>` for `f64`\n\nerror[E0277]: the trait\
    \ bound `i64: From<f64>` is not satisfied\n  --> /tmp/tmpi2aipwhl.rs:12:24\n \
    \  |\n12 |     let mut y: i64 = y.into();\n   |                        ^^^^ the\
    \ trait `From<f64>` is not implemented for `i64`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <f32 as From<i16>>\n  \
    \           <f32 as From<i8>>\n             <f32 as From<u16>>\n             <f32\
    \ as From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n\
    \             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and\
    \ 67 others\n   = note: required because of the requirements on the impl of `Into<i64>`\
    \ for `f64`\n\nerror[E0277]: the trait bound `i64: From<f64>` is not satisfied\n\
    \  --> /tmp/tmpi2aipwhl.rs:13:24\n   |\n13 |     let mut z: i64 = z.into();\n\
    \   |                        ^^^^ the trait `From<f64>` is not implemented for\
    \ `i64`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <f32 as From<i16>>\n             <f32 as From<i8>>\n           \
    \  <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n   = note: required because of\
    \ the requirements on the impl of `Into<i64>` for `f64`\n\nerror[E0277]: the trait\
    \ bound `f64: From<i64>` is not satisfied\n  --> /tmp/tmpi2aipwhl"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int: i32 = x.round();\n    let y_int: i32 = y.round();\n \
    \   let z_int: i32 = z.round();\n    let z_int_sum: i32 = (x_int + y_int + z_int).round();\n\
    \    z_int_sum == x_int + y_int + z_int\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkvv57ajn.rs:10:22\n   |\n\
    10 |     let x_int: i32 = x.round();\n   |                ---   ^^^^^^^^^ expected\
    \ `i32`, found `f64`\n   |                |\n   |                expected due\
    \ to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkvv57ajn.rs:11:22\n\
    \   |\n11 |     let y_int: i32 = y.round();\n   |                ---   ^^^^^^^^^\
    \ expected `i32`, found `f64`\n   |                |\n   |                expected\
    \ due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkvv57ajn.rs:12:22\n\
    \   |\n12 |     let z_int: i32 = z.round();\n   |                ---   ^^^^^^^^^\
    \ expected `i32`, found `f64`\n   |                |\n   |                expected\
    \ due to this\n\nerror[E0599]: no method named `round` found for type `i32` in\
    \ the current scope\n  --> /tmp/tmpkvv57ajn.rs:13:50\n   |\n13 |     let z_int_sum:\
    \ i32 = (x_int + y_int + z_int).round();\n   |                               \
    \                   ^^^^^ method not found in `i32`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let xint: i64 = x as i64;\n    let yint: i64 = y as i64;\n    let\
    \ zint: i64 = z as i64;\n\n    // If any of the values are negative, they cannot\
    \ be equal to the\n    // sum of two other negative values.\n    if xint < 0 {\n\
    \        return false;\n    }\n    if yint < 0 {\n        return false;\n    }\n\
    \    if zint < 0 {\n        return false;\n    }\n\n    // Otherwise, just check\
    \ if any of the values is equal to the sum.\n    return (xint + yint + zint) ==\
    \ (x + y + z);\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8scm5e9.rs:27:36\n   |\n\
    27 |     return (xint + yint + zint) == (x + y + z);\n   |                   \
    \                 ^^^^^^^^^^^ expected `i64`, found `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x.trunc() == x + y || x.trunc() == x + z) && (y.trunc() == y +\
    \ z) || y.trunc() == z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb3wepy14.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y + z && x.is_integer() && y.is_integer() && z.is_integer()\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp01v5myrw.rs:10:24\n   |\n10 |     if x == y + z\
    \ && x.is_integer() && y.is_integer() && z.is_integer() {\n   |              \
    \          ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp01v5myrw.rs:10:42\n\
    \   |\n10 |     if x == y + z && x.is_integer() && y.is_integer() && z.is_integer()\
    \ {\n   |                                          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp01v5myrw.rs:10:60\n   |\n10 |     if x ==\
    \ y + z && x.is_integer() && y.is_integer() && z.is_integer() {\n   |        \
    \                                                    ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let is_int = |x: f64| x.trunc().is_integer();\n    (is_int(x) &&\
    \ is_int(y) && is_int(z)) ||\n        ((x.is_integer() && y.is_integer() && z.is_integer())\
    \ || x == y && y == z || x == -z || y == -x && z == -y)\n}\n\nfn main() {\n  \
    \  let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp1_3x9ud0.rs:10:37\n   |\n10 |     let is_int =\
    \ |x: f64| x.trunc().is_integer();\n   |                                     ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp1_3x9ud0.rs:12:13\n   |\n\
    12 |         ((x.is_integer() && y.is_integer() && z.is_integer()) || x == y &&\
    \ y == z || x == -z || y == -x && z == -y)\n   |             ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp1_3x9ud0.rs:12:31\n   |\n12 |    \
    \     ((x.is_integer() && y.is_integer() && z.is_integer()) || x == y && y ==\
    \ z || x == -z || y == -x && z == -y)\n   |                               ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp1_3x9ud0.rs:12:49\n   |\n\
    12 |         ((x.is_integer() && y.is_integer() && z.is_integer()) || x == y &&\
    \ y == z || x == -z || y == -x && z == -y)\n   |                             \
    \                    ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n        && x\
    \ + y + z == z.iter().map(|&x| x as i32).sum()\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpplgr_upy.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpplgr_upy.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpplgr_upy.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `iter` found for type `f64` in the current scope\n  --> /tmp/tmpplgr_upy.rs:11:27\n\
    \   |\n11 |         && x + y + z == z.iter().map(|&x| x as i32).sum()\n   |  \
    \                         ^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // If the other two are integers, then they must be equal to the\
    \ sum of the other two.\n    if x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x + y == z {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp2z1pe_2x.rs:11:10\n   |\n11 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y == z {\n   |          ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp2z1pe_2x.rs:11:28\n   |\n\
    11 |     if x.is_integer() && y.is_integer() && z.is_integer() && x + y == z {\n\
    \   |                            ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp2z1pe_2x.rs:11:46\n   |\n11 |     if x.is_integer() && y.is_integer()\
    \ && z.is_integer() && x + y == z {\n   |                                    \
    \          ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x = x as u32;\n    let y = y as u32;\n    let z = z as u32;\n\
    \    (x & y & z) == 0xFFFFFFFF\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl7x71c76.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == x + y) && z ==\n        ((x + y) + z).into()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt2loqmyj.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x < 0 || y < 0 || z < 0 ||\n        x > f64::max_value() || y\
    \ > f64::max_value() || z > f64::max_value() ||\n        (x != f64::max_value()\
    \ && y != f64::max_value() && z != f64::max_value()) ||\n        (x != f64::min_value()\
    \ && y != f64::min_value() && z != f64::min_value()) {\n        return false;\n\
    \    }\n    if x == f64::max_value() && y == f64::max_value() && z == f64::max_value()\
    \ {\n        return true;\n    }\n    if x == f64::min_value() && y == f64::min_value()\
    \ && z == f64::min_value() {\n        return true;\n    }\n    if x + y == z {\n\
    \        return true;\n    }\n    if x > z && x < y {\n        return true;\n\
    \    }\n    if y > z && y < x {\n        return true;\n    }\n    if x > y &&\
    \ y < z {\n        return true;\n    }\n    if y > x && y > z {\n        return\
    \ true;\n    }\n    if x > y && x < z {\n        return true;\n    }\n    if y\
    \ > x && y < z {\n        return true;\n    }\n    if z > x && z < y {\n     \
    \   return true;\n    }\n    if z > y && z < x {\n        return true;\n    }\n\
    \    if x > z && y < z {\n        return true;\n    }\n    if x < z && x < y {\n\
    \        return true;\n    }\n    if y < z && y < x {\n        return true;\n\
    \    }\n    if x < z && y < z {\n        return true;\n    }\n    if x < y &&\
    \ y < z {\n        return true;\n    }\n    if z < x && z < y {\n        return\
    \ true;\n    }\n    if z < y && z < x {\n        return true;\n    }\n    if x\
    \ < z && z < y {\n        return true;\n    }\n    if y < z && z < x {\n     \
    \   return true;\n    }\n    if z < x && y < z {\n        return true;\n    }\n\
    \    if z < y && z < x {\n        return true;\n    }\n    if x < y && y < z {\n\
    \        return true;\n    }\n    if z < x && x < y {\n        return true;\n\
    \    }\n    if y < z && x < z {\n        return true;\n    }\n    if x < y &&\
    \ x < z {\n        return true;\n    }\n    if y < x && x < z {\n        return\
    \ true;\n    }\n    if x < z && y < z {\n        return true;\n    }\n    if y\
    \ < x && y < z {\n        return true;\n    }\n    if z < x && x < y {\n     \
    \   return true;\n    }\n    if z < y && x < x {\n\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8vl5lij5.rs:122:3\n\
    \    |\n9   | fn any_int(x: f64, y: f64, z: f64) -> bool {\n    |            \
    \                                - unclosed delimiter\n...\n13  |         (x !=\
    \ f64::min_value() && y != f64::min_value() && z != f64::min_value()) {\n    |\
    \                                                                            \
    \       - this delimiter might not be properly closed...\n14  |         return\
    \ false;\n15  |     }\n    |     - ...as it matches this but it has different\
    \ indentation\n...\n122 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8vl5lij5.rs:10:12\n   |\n10 |     if x < 0 || y < 0 || z < 0 ||\n  \
    \ |            ^\n   |            |\n   |            expected `f64`, found integer\n\
    \   |            help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8vl5lij5.rs:10:21\n   |\n10 |     if x < 0 || y < 0 ||\
    \ z < 0 ||\n   |                     ^\n   |                     |\n   |     \
    \                expected `f64`, found integer\n   |                     help:\
    \ use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8vl5lij5.rs:10:30\n\
    \   |\n10 |     if x < 0 || y < 0 || z < 0 ||\n   |                          \
    \    ^\n   |                              |\n   |                            \
    \  expected `f64`, found integer\n   |                              help: use\
    \ a float literal: `0.0`\n\nerror[E0599]: no function or associated item named\
    \ `max_value` found for type `f64` in the current scope\n  --> /tmp/tmp8vl5lij5.rs:11:18\n\
    \   |\n11 |         x > f64::max_value() || y > f64::max_value() || z > f64::max_value()\
    \ ||\n   |                  ^^^^^^^^^ function or associated item not found in\
    \ `f64`\n\nerror[E0599]: no function or associated item named `max_value` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp8vl5lij5.rs:11:42\n   |\n\
    11 |         x > f64::max_value() || y > f64::max_value() || z > f64::max_value()\
    \ ||\n   |                                          ^^^^^^^^^ function or associated\
    \ item not found in `f64`\n\nerror[E0599]: no"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x.is_integer() && y.is_integer() && z.is_integer() {\n      \
    \  match x + y + z {\n            x if x < y && y < z => true,\n            _\
    \ => false,\n        }\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpns1bvix7.rs:10:10\n   |\n10 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpns1bvix7.rs:10:28\n   |\n10 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |                            ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpns1bvix7.rs:10:46\n   |\n\
    10 |     if x.is_integer() && y.is_integer() && z.is_integer() {\n   |       \
    \                                       ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y {\n        if z == x {\n            true\n        } else\
    \ {\n            false\n        }\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp36_ctuig.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match (x, y, z) {\n        (a, b, _) => a + b == x,\n        (_,\
    \ c, d) => c + d == y,\n        (_, _, e) => e == z,\n        _ => false,\n  \
    \  }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpggesfpu6.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x >= y && x >= z) || (y >= x && y >= z)\n}\n\nfn main() {\n   \
    \ let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpst4kkccw.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x > y && y > z && z > x\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn3mp5___.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.abs() <= y.abs() && (y.abs() <= z.abs() || x.abs() <= z.abs())\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7pjmtwgu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match {\n        x >= y && x >= z => true,\n        y >= x && y\
    \ >= z => true,\n        z >= x && z >= y => true,\n        _ => false,\n    }\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpxqm32igk.rs:11:26\n   |\n11 |         x >= y && x\
    \ >= z => true,\n   |                          ^^ expected one of 8 possible tokens\n\
    \nerror: expected one of `.`, `?`, `{`, or an operator, found `}`\n  --> /tmp/tmpxqm32igk.rs:16:1\n\
    \   |\n10 |     match {\n   |     ----- while parsing this `match` expression\n\
    ...\n15 |     }\n   |      - expected one of `.`, `?`, `{`, or an operator\n16\
    \ | }\n   | ^ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let _x: i64 = x;\n    let _y: i64 = y;\n    let _z: i64 = z;\n \
    \   if _x + _y == _z {\n        return true;\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6kpry4vb.rs:10:19\n   |\n\
    10 |     let _x: i64 = x;\n   |             ---   ^ expected `i64`, found `f64`\n\
    \   |             |\n   |             expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6kpry4vb.rs:11:19\n   |\n11 |     let _y: i64 = y;\n  \
    \ |             ---   ^ expected `i64`, found `f64`\n   |             |\n   |\
    \             expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6kpry4vb.rs:12:19\n\
    \   |\n12 |     let _z: i64 = z;\n   |             ---   ^ expected `i64`, found\
    \ `f64`\n   |             |\n   |             expected due to this\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == (x * y + z)) || (x == (x * y - z)) || (x == (x * z + y))\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp94r8kmtu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x >= 0 && y >= 0 && z >= 0\n        && (x + y == z || x + y == -z\
    \ || y + z == -x)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx3fhw_81.rs:10:10\n   |\n\
    10 |     x >= 0 && y >= 0 && z >= 0\n   |          ^\n   |          |\n   |  \
    \        expected `f64`, found integer\n   |          help: use a float literal:\
    \ `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx3fhw_81.rs:10:20\n \
    \  |\n10 |     x >= 0 && y >= 0 && z >= 0\n   |                    ^\n   |   \
    \                 |\n   |                    expected `f64`, found integer\n \
    \  |                    help: use a float literal: `0.0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx3fhw_81.rs:10:30\n   |\n10 |     x >= 0 && y >= 0 && z\
    \ >= 0\n   |                              ^\n   |                            \
    \  |\n   |                              expected `f64`, found integer\n   |  \
    \                            help: use a float literal: `0.0`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.checked_add(y).is_some() || x.checked_sub(y).is_some() || x.checked_mul(y).is_some()\
    \ || x.checked_div(y).is_some() ||\n        z.checked_add(y).is_some() || z.checked_sub(y).is_some()\
    \ || z.checked_mul(y).is_some() || z.checked_div(y).is_some()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpmr3physq.rs:10:7\n   |\n10 |     x.checked_add(y).is_some()\
    \ || x.checked_sub(y).is_some() || x.checked_mul(y).is_some() || x.checked_div(y).is_some()\
    \ ||\n   |       ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_sub` found for type `f64` in the current scope\n  --> /tmp/tmpmr3physq.rs:10:37\n\
    \   |\n10 |     x.checked_add(y).is_some() || x.checked_sub(y).is_some() || x.checked_mul(y).is_some()\
    \ || x.checked_div(y).is_some() ||\n   |                                     ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_mul` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpmr3physq.rs:10:67\n   |\n\
    10 |     x.checked_add(y).is_some() || x.checked_sub(y).is_some() || x.checked_mul(y).is_some()\
    \ || x.checked_div(y).is_some() ||\n   |                                     \
    \                              ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_div` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpmr3physq.rs:10:97\n   |\n10 |     x.checked_add(y).is_some() || x.checked_sub(y).is_some()\
    \ || x.checked_mul(y).is_some() || x.checked_div(y).is_some() ||\n   |       \
    \                                                                            \
    \              ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_add` found for type `f64` in the current scope\n  --> /tmp/tmpmr3physq.rs:11:11\n\
    \   |\n11 |         z.checked_add(y).is_some() || z.checked_sub(y).is_some() ||\
    \ z.checked_mul(y).is_some() || z.checked_div(y).is_some()\n   |           ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_sub` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpmr3physq.rs:11:41\n   |\n\
    11 |         z.checked_add(y).is_some() || z.checked_sub(y).is_some() || z.checked_mul(y).is_some()\
    \ || z.checked_div(y).is_some()\n   |                                        \
    \ ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y && y == z && z == x {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk7cvd77b.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x < y && x < z && y < z {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprtdqgem5.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpf9xqzx0_.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpf9xqzx0_.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpf9xqzx0_.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= f64::MAX\n        && y <= f64::MAX\n        && z <= f64::MAX\n\
    \        && x <= z\n        && y <= z\n        && x <= y\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvaq9njht.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // The goal is to check whether x (5) is an integer, y (2, and 3)\
    \ and z (7)\n    // are all integers, and that the sum of those three, plus the\
    \ value of x,\n    // is equal to the value of y.\n    // However, this is an\
    \ optimization problem. For example, how can\n    // we optimize this algorithm\
    \ to determine that 7 + 5 = 13?\n    // Well, we could say that 13 + 5 = 17 because\
    \ 7 + 5 = 13\n    // and 17 is also an integer, and if we add x to 17, we get\
    \ 20\n    // which is the same value that is equal to y.\n    // What if we could\
    \ say that 7 + 5 = 13, 17 + 5 = 20 and 17 = 13\n    // and 20 = 17?\n    // What\
    \ if 17 + 5 = 20 and 17 = 13 and 20 = 17?\n    // We could do this by considering\
    \ every number from 17 to 20 and counting\n    // the number of times we see each\
    \ number. With these two numbers, we can\n    // determine that 7 + 5 = 13, 17\
    \ + 5 = 20, and 17 = 13, and 20 = 17 (and\n    // 17 is also an integer).\n  \
    \  // But what if x = 5? If y = 2 and z = 7, we can say\n    // x + 2 = 7 + 2\
    \ and x + 2 = 9 + 2, so\n    // x + 2 = 13 + 2 = 19, and we can say that 7 + 2\
    \ = 9.\n    // So we see that 7 + 2 = 9.\n    // We can do that by adding 7 +\
    \ 2 = 9 + 2, which is 15 to the power of 2.\n    // 15 is equal to x to the power\
    \ of 3.\n    // So we can say that 7 + 2 = 9, x + 2 = 15 + 2 = 25, and\n    //\
    \ we can say that 7 + 2 = 9, x + 2 = 25.\n    // So 7 + 2 = 9, x + 2 = 25.\n \
    \   // This means that we know that 7 + 2 = 9, x + 2 = 25, and that x = 25.\n\
    \    // So, we have found that 7 + 2 = 9, x = 25.\n    // And we can return that\
    \ x is an integer.\n    // The algorithm is simple: Add up the numbers from 17\
    \ to 20, and\n    // keep track of how many times each number is seen.\n    //\
    \ If the number of times that a number is seen is equal to or greater than the\n\
    \    // number of times that x is seen, then x is an integer.\n    // If the number\
    \ of times that a number is seen is less than the number of times\n    // that\
    \ x is seen, then x is not an integer.\n    // Because we know that the first\
    \ 17 + 2 numbers are all integers, we can also add\n    // the first 17 numbers\
    \ and see that the result is equal to the sum of the\n    // first 17 numbers,\
    \ which is 17 + 2 = 19.\n    // So, the first 17 + 2 = 19 numbers are all integers.\n\
    \    // So the first 17 numbers are \n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpb_uzhe3n.rs:9:39\n  |\n9 |\
    \ fn any_int(x: f64, y: f64, z: f64) -> bool {\n  |    -------               \
    \             ^^^^ expected `bool`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x as i32;\n    let y_int = y as i32;\n    let z_int\
    \ = z as i32;\n    x_int >= y_int && x_int <= z_int\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwbyrnq7t.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y && x == z {\n        return true;\n    } else if x ==\
    \ y {\n        return false;\n    } else if y == z {\n        return true;\n \
    \   } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn1f9l9rk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x.is_nan() || y.is_nan() || z.is_nan() {\n        return false;\n\
    \    }\n\n    if x.is_zero() || y.is_zero() || z.is_zero() {\n        return true;\n\
    \    }\n\n    if x == 0 || y == 0 || z == 0 {\n        return false;\n    }\n\n\
    \    x != z || y != z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpfz1mk9n3.rs:14:10\n   |\n14 |     if x.is_zero() || y.is_zero()\
    \ || z.is_zero() {\n   |          ^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_zero` found for type `f64` in the current scope\n  --> /tmp/tmpfz1mk9n3.rs:14:25\n\
    \   |\n14 |     if x.is_zero() || y.is_zero() || z.is_zero() {\n   |         \
    \                ^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_zero` found for type `f64` in the current scope\n  --> /tmp/tmpfz1mk9n3.rs:14:40\n\
    \   |\n14 |     if x.is_zero() || y.is_zero() || z.is_zero() {\n   |         \
    \                               ^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfz1mk9n3.rs:18:13\n   |\n18 |     if x == 0\
    \ || y == 0 || z == 0 {\n   |             ^\n   |             |\n   |        \
    \     expected `f64`, found integer\n   |             help: use a float literal:\
    \ `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfz1mk9n3.rs:18:23\n \
    \  |\n18 |     if x == 0 || y == 0 || z == 0 {\n   |                       ^\n\
    \   |                       |\n   |                       expected `f64`, found\
    \ integer\n   |                       help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfz1mk9n3.rs:18:33\n   |\n18 |     if x == 0\
    \ || y == 0 || z == 0 {\n   |                                 ^\n   |        \
    \                         |\n   |                                 expected `f64`,\
    \ found integer\n   |                                 help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = (x as f64).floor() as i64;\n    let y_int = (y as f64).floor()\
    \ as i64;\n    let z_int = (z as f64).floor() as i64;\n    x_int == y_int || x_int\
    \ == z_int || y_int == z_int\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo56umzq4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpv7s6m5i2.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpv7s6m5i2.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpv7s6m5i2.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    if sum == x || sum == y || sum == z {\n\
    \        return true;\n    } else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu7ev75p4.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    use std::cmp::Ordering;\n    use std::cmp::PartialOrd;\n\n    if\
    \ x < y {\n        if x < z {\n            true\n        } else {\n          \
    \  false\n        }\n    } else {\n        if y < z {\n            false\n   \
    \     } else {\n            true\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeuu81ffg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x = x * (x as f64) + (y as f64) + (z as f64);\n    x.is_integer()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp2cgbi7h7.rs:11:7\n   |\n11 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n        && (x\
    \ + y + z).is_integer()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpk0ait937.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpk0ait937.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpk0ait937.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpk0ait937.rs:11:24\n   |\n11 |         && (x + y + z).is_integer()\n\
    \   |                        ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= z && y <= z && x <= z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph6tu8b47.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let result = (x + y + z) == (x * y * z);\n    let mut is_int = true;\n\
    \    loop {\n        if result {\n            is_int = true;\n            break;\n\
    \        }\n        if x > y {\n            x = x - y;\n        }\n        else\
    \ {\n            y = y - x;\n        }\n        if x > z {\n            x = x\
    \ - z;\n        }\n        else {\n            z = z - x;\n        }\n       \
    \ if y > z {\n            y = y - z;\n        }\n        else {\n            z\
    \ = z - y;\n        }\n    }\n    is_int\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `is_int` is never read\n  --> /tmp/tmp89xjqx59.rs:11:13\n\
    \   |\n11 |     let mut is_int = true;\n   |             ^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `x`\n\
    \  --> /tmp/tmp89xjqx59.rs:18:13\n   |\n9  | fn any_int(x: f64, y: f64, z: f64)\
    \ -> bool {\n   |            - help: consider making this binding mutable: `mut\
    \ x`\n...\n18 |             x = x - y;\n   |             ^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror[E0384]: cannot assign to immutable argument `y`\n\
    \  --> /tmp/tmp89xjqx59.rs:21:13\n   |\n9  | fn any_int(x: f64, y: f64, z: f64)\
    \ -> bool {\n   |                    - help: consider making this binding mutable:\
    \ `mut y`\n...\n21 |             y = y - x;\n   |             ^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror[E0384]: cannot assign to immutable argument\
    \ `x`\n  --> /tmp/tmp89xjqx59.rs:24:13\n   |\n9  | fn any_int(x: f64, y: f64,\
    \ z: f64) -> bool {\n   |            - help: consider making this binding mutable:\
    \ `mut x`\n...\n24 |             x = x - z;\n   |             ^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror[E0384]: cannot assign to immutable argument\
    \ `z`\n  --> /tmp/tmp89xjqx59.rs:27:13\n   |\n9  | fn any_int(x: f64, y: f64,\
    \ z: f64) -> bool {\n   |                            - help: consider making this\
    \ binding mutable: `mut z`\n...\n27 |             z = z - x;\n   |           \
    \  ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot assign\
    \ to immutable argument `y`\n  --> /tmp/tmp89xjqx59.rs:30:13\n   |\n9  | fn any_int(x:\
    \ f64, y: f64, z: f64) -> bool {\n   |                    - help: consider making\
    \ this binding mutable: `mut y`\n...\n30 |             y = y - z;\n   |      \
    \       ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `z`\n  --> /tmp/tmp89xjqx59.rs:33:13\n   |\n9 \
    \ | fn any_int(x: f64, y: f64, z: f64) -> bool {\n   |                       \
    \     - help: consider making this binding mutable: `mut"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x <= z && y <= z && x >= z {\n        return true;\n    } else\
    \ {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkpatfy0d.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n    x.partial_cmp(&y)\n        && z.partial_cmp(&x)\n\
    \        && z.partial_cmp(&y)\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp2xkepzuc.rs:10:21\n   |\n10 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp2xkepzuc.rs:11:21\n   |\n11 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp2xkepzuc.rs:12:21\n   |\n12 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2xkepzuc.rs:13:5\n   |\n13 |     x.partial_cmp(&y)\n\
    \   |     ^^^^^^^^^^^^^^^^^ expected `bool`, found enum `Option`\n   |\n   = note:\
    \ expected type `bool`\n              found enum `Option<std::cmp::Ordering>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2xkepzuc.rs:14:12\n   |\n14 |\
    \         && z.partial_cmp(&x)\n   |            ^^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found enum `Option`\n   |\n   = note: expected type `bool`\n              found\
    \ enum `Option<std::cmp::Ordering>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2xkepzuc.rs:15:12\n\
    \   |\n15 |         && z.partial_cmp(&y)\n   |            ^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n       \
    \       found enum `Option<std::cmp::Ordering>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x + y + z) == (x + y) && (x + z) && (y + z)\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp91nxtied.rs:10:31\n   |\n\
    10 |     (x + y + z) == (x + y) && (x + z) && (y + z)\n   |                  \
    \             ^^^^^^^ expected `bool`, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp91nxtied.rs:10:42\n   |\n10 |     (x + y + z) == (x + y)\
    \ && (x + z) && (y + z)\n   |                                          ^^^^^^^\
    \ expected `bool`, found `f64`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || x.is_nan() || y.is_integer() || y.is_nan() ||\
    \ z.is_integer() || z.is_nan()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpo3tfex82.rs:10:7\n   |\n10 |     x.is_integer()\
    \ || x.is_nan() || y.is_integer() || y.is_nan() || z.is_integer() || z.is_nan()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpo3tfex82.rs:10:39\n\
    \   |\n10 |     x.is_integer() || x.is_nan() || y.is_integer() || y.is_nan() ||\
    \ z.is_integer() || z.is_nan()\n   |                                       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpo3tfex82.rs:10:71\n   |\n\
    10 |     x.is_integer() || x.is_nan() || y.is_integer() || y.is_nan() || z.is_integer()\
    \ || z.is_nan()\n   |                                                        \
    \               ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x: f64 = match x {\n        f32 | f64 => x,\n        _ => panic!(\"\
    Unsupported argument type: f64\"),\n    };\n    let y: f64 = match y {\n     \
    \   f32 | f64 => y,\n        _ => panic!(\"Unsupported argument type: f64\"),\n\
    \    };\n    let z: f64 = match z {\n        f32 | f64 => z,\n        _ => panic!(\"\
    Unsupported argument type: f64\"),\n    };\n\n    x <= y && y <= z &&\n    x.is_integer()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0408]: variable `f32` is not bound in all patterns\n  --> /tmp/tmplparlift.rs:11:15\n\
    \   |\n11 |         f32 | f64 => x,\n   |         ---   ^^^ pattern doesn't bind\
    \ `f32`\n   |         |\n   |         variable not in all patterns\n\nerror[E0408]:\
    \ variable `f64` is not bound in all patterns\n  --> /tmp/tmplparlift.rs:11:9\n\
    \   |\n11 |         f32 | f64 => x,\n   |         ^^^   --- variable not in all\
    \ patterns\n   |         |\n   |         pattern doesn't bind `f64`\n\nerror[E0408]:\
    \ variable `f32` is not bound in all patterns\n  --> /tmp/tmplparlift.rs:15:15\n\
    \   |\n15 |         f32 | f64 => y,\n   |         ---   ^^^ pattern doesn't bind\
    \ `f32`\n   |         |\n   |         variable not in all patterns\n\nerror[E0408]:\
    \ variable `f64` is not bound in all patterns\n  --> /tmp/tmplparlift.rs:15:9\n\
    \   |\n15 |         f32 | f64 => y,\n   |         ^^^   --- variable not in all\
    \ patterns\n   |         |\n   |         pattern doesn't bind `f64`\n\nerror[E0408]:\
    \ variable `f32` is not bound in all patterns\n  --> /tmp/tmplparlift.rs:19:15\n\
    \   |\n19 |         f32 | f64 => z,\n   |         ---   ^^^ pattern doesn't bind\
    \ `f32`\n   |         |\n   |         variable not in all patterns\n\nerror[E0408]:\
    \ variable `f64` is not bound in all patterns\n  --> /tmp/tmplparlift.rs:19:9\n\
    \   |\n19 |         f32 | f64 => z,\n   |         ^^^   --- variable not in all\
    \ patterns\n   |         |\n   |         pattern doesn't bind `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmplparlift.rs:24:7\n   |\n24 |     x.is_integer()\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 7 previous errors\n\nSome\
    \ errors have detailed explanations: E0408, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0408`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x > y && x > z {\n        if y > z {\n            return true;\n\
    \        }\n        else {\n            return false;\n        }\n    }\n    else\
    \ if y > x && y > z {\n        if x > z {\n            return true;\n        }\n\
    \        else {\n            return false;\n        }\n    }\n    else {\n   \
    \     if z > x {\n            return true;\n        }\n        else {\n      \
    \      return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8rpq6b8m.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x==z || y==z {\n        return true;\n    }\n    let x = int(x);\n\
    \    let y = int(y);\n    let z = int(z);\n    if x == y {\n        return true;\n\
    \    }\n    if x == z || y == z {\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `int` in this scope\n  --> /tmp/tmpmm4udsww.rs:13:13\n\
    \   |\n13 |     let x = int(x);\n   |             ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `int` in this scope\n  --> /tmp/tmpmm4udsww.rs:14:13\n\
    \   |\n14 |     let y = int(y);\n   |             ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `int` in this scope\n  --> /tmp/tmpmm4udsww.rs:15:13\n\
    \   |\n15 |     let z = int(z);\n   |             ^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x > y && x > z {\n        return true;\n    }\n    if x < y &&\
    \ x < z {\n        return false;\n    }\n    if y > z && y < x {\n        return\
    \ true;\n    }\n    if z > x && z < y {\n        return false;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8faiuws1.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == 0 || y == 0 || z == 0 {\n        return false;\n    }\n\
    \    let another_x = if x == y || x == z { x } else { x };\n    let another_y\
    \ = if y == x || y == z { y } else { y };\n    let another_z = if z == x || z\
    \ == y { z } else { z };\n    let another_sum = x + y + z;\n    another_sum ==\
    \ another_x + another_y + another_z\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8qb1t4_8.rs:10:13\n   |\n\
    10 |     if x == 0 || y == 0 || z == 0 {\n   |             ^\n   |           \
    \  |\n   |             expected `f64`, found integer\n   |             help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8qb1t4_8.rs:10:23\n\
    \   |\n10 |     if x == 0 || y == 0 || z == 0 {\n   |                       ^\n\
    \   |                       |\n   |                       expected `f64`, found\
    \ integer\n   |                       help: use a float literal: `0.0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8qb1t4_8.rs:10:33\n   |\n10 |     if x == 0\
    \ || y == 0 || z == 0 {\n   |                                 ^\n   |        \
    \                         |\n   |                                 expected `f64`,\
    \ found integer\n   |                                 help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x.cmp(&z) {\n        Ordering::Less => {\n            match\
    \ y.cmp(&z) {\n                Ordering::Less => false,\n                _ =>\
    \ true,\n            }\n        }\n        Ordering::Greater => false,\n     \
    \   _ => x.cmp(&y) == Ordering::Equal,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp20r8z1mt.rs:11:9\n   |\n11 |         Ordering::Less => {\n   |     \
    \    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmp20r8z1mt.rs:13:17\n   |\n13\
    \ |                 Ordering::Less => false,\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmp20r8z1mt.rs:17:9\n   |\n17 |         Ordering::Greater\
    \ => false,\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp20r8z1mt.rs:18:27\n\
    \   |\n18 |         _ => x.cmp(&y) == Ordering::Equal,\n   |                 \
    \          ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]: `f64` is\
    \ not an iterator\n  --> /tmp/tmp20r8z1mt.rs:10:13\n   |\n10 |     match x.cmp(&z)\
    \ {\n   |             ^^^ `f64` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror[E0599]: `f64` is not an iterator\n\
    \  --> /tmp/tmp20r8z1mt.rs:12:21\n   |\n12 |             match y.cmp(&z) {\n \
    \  |                     ^^^ `f64` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror[E0599]: `f64` is not an iterator\n\
    \  --> /tmp/tmp20r8z1mt.rs:18:16\n   |\n18 |         _ => x.cmp(&y) == Ordering::Equal,\n\
    \   |                ^^^ `f64` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n        && (x\
    \ + y + z) == x.to_f64() + y.to_f64() + z.to_f64()\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp54c14xrj.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp54c14xrj.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp54c14xrj.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmp54c14xrj.rs:11:29\n\
    \   |\n11 |         && (x + y + z) == x.to_f64() + y.to_f64() + z.to_f64()\n \
    \  |                             ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmp54c14xrj.rs:11:42\n\
    \   |\n11 |         && (x + y + z) == x.to_f64() + y.to_f64() + z.to_f64()\n \
    \  |                                          ^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `to_f64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp54c14xrj.rs:11:55\n   |\n11 |         && (x + y + z) == x.to_f64()\
    \ + y.to_f64() + z.to_f64()\n   |                                            \
    \           ^^^^^^ method not found in `f64`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    if sum == 0.0 {\n        return false;\n\
    \    }\n    let sum_int = sum as i32;\n    if sum_int < 0 {\n        return false;\n\
    \    }\n    let ints = [x, y, z].iter().map(|x| x as i64).collect();\n    if ints.iter().any(|i|\
    \ i as i32 != sum_int) {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp7bx8of1b.rs:19:8\n\
    \   |\n18 |     let ints = [x, y, z].iter().map(|x| x as i64).collect();\n   |\
    \         ---- consider giving `ints` a type\n19 |     if ints.iter().any(|i|\
    \ i as i32 != sum_int) {\n   |        ^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0606]: casting `&f64` as `i64` is\
    \ invalid\n  --> /tmp/tmp7bx8of1b.rs:18:41\n   |\n18 |     let ints = [x, y, z].iter().map(|x|\
    \ x as i64).collect();\n   |                                         -^^^^^^^\n\
    \   |                                         |\n   |                        \
    \                 cannot cast `&f64` as `i64`\n   |                          \
    \               help: dereference the expression: `*x`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0606.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match (x, y, z) {\n        (x, y, z) => x >= y && x >= z && y >=\
    \ z,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphauo7be7.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= y && y <= z && x >= z\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkenyknx9.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x_to_int(x, y) {\n        Some(xy) => x_to_int(z - xy, z),\n\
    \        None => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `x_to_int` in this scope\n  --> /tmp/tmpn0c8vzcd.rs:10:11\n\
    \   |\n10 |     match x_to_int(x, y) {\n   |           ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `x_to_int` in this scope\n  -->\
    \ /tmp/tmpn0c8vzcd.rs:11:21\n   |\n11 |         Some(xy) => x_to_int(z - xy, z),\n\
    \   |                     ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x = x as i32;\n    let y = y as i32;\n    let z = z as i32;\n\
    \    if x == z && y == z {\n        true\n    } else if x != z {\n        false\n\
    \    } else if y != z {\n        true\n    } else {\n        false\n    }\n}\n\
    \nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwrglr0p3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut sum = z + y;\n    if x != sum {\n        return false;\n\
    \    }\n    for i in 0..z.num() as usize {\n        sum += x.num()[i] as f64;\n\
    \    }\n    sum <= x.num() as f64 && sum >= y.num() as f64\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `num` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpwlvogrqf.rs:14:19\n   |\n14 |     for i in 0..z.num() as\
    \ usize {\n   |                   ^^^ help: there is an associated function with\
    \ a similar name: `signum`\n\nerror[E0599]: no method named `num` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpwlvogrqf.rs:15:18\n   |\n15 |    \
    \     sum += x.num()[i] as f64;\n   |                  ^^^ help: there is an associated\
    \ function with a similar name: `signum`\n\nerror[E0599]: no method named `num`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpwlvogrqf.rs:17:14\n\
    \   |\n17 |     sum <= x.num() as f64 && sum >= y.num() as f64\n   |         \
    \     ^^^ help: there is an associated function with a similar name: `signum`\n\
    \nerror[E0599]: no method named `num` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpwlvogrqf.rs:17:39\n   |\n17 |     sum <= x.num() as f64 && sum\
    \ >= y.num() as f64\n   |                                       ^^^ help: there\
    \ is an associated function with a similar name: `signum`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x.is_integer() && y.is_integer() && z.is_integer() {\n      \
    \  x.as_int() + (y.as_int() + z.as_int()) == x.as_int() && x.as_int() + (y.as_int()\
    \ - z.as_int()) == y.as_int()\n    } else if x.is_integer() && y.is_integer()\
    \ {\n        x.as_int() + (y.as_int() - z.as_int()) == x.as_int() && x.as_int()\
    \ - (y.as_int() + z.as_int()) == y.as_int()\n    } else if x.is_integer() && y.is_integer()\
    \ {\n        x.as_int() - (y.as_int() + z.as_int()) == x.as_int() && x.as_int()\
    \ + (y.as_int() - z.as_int()) == y.as_int()\n    } else if x.is_integer() {\n\
    \        y.as_int() - (z.as_int() + x.as_int()) == y.as_int() && y.as_int() -\
    \ (z.as_int() - x.as_int()) == z.as_int()\n    } else if y.is_integer() {\n  \
    \      z.as_int() - (x.as_int() + y.as_int()) == z.as_int() && z.as_int() - (x.as_int()\
    \ - y.as_int()) == x.as_int()\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpwxcfwxdp.rs:10:10\n   |\n10 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpwxcfwxdp.rs:10:28\n   |\n10 |     if x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n   |                            ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpwxcfwxdp.rs:10:46\n   |\n\
    10 |     if x.is_integer() && y.is_integer() && z.is_integer() {\n   |       \
    \                                       ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `as_int` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpwxcfwxdp.rs:11:11\n   |\n11 |         x.as_int() + (y.as_int()\
    \ + z.as_int()) == x.as_int() && x.as_int() + (y.as_int() - z.as_int()) == y.as_int()\n\
    \   |           ^^^^^^ help: there is an associated function with a similar name:\
    \ `asin`\n\nerror[E0599]: no method named `as_int` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpwxcfwxdp.rs:11:25\n   |\n11 |         x.as_int()\
    \ + (y.as_int() + z.as_int()) == x.as_int() && x.as_int() + (y.as_int() - z.as_int())\
    \ == y.as_int()\n   |                         ^^^^^^ help: there is an associated\
    \ function with a similar name: `asin`\n\nerror[E0599]: no method named `as_int`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpwxcfwxdp.rs:11:38\n\
    \   |\n11 |         x.as_int() + (y.as_int() + z.as_int()) == x.as_int() && x.as_int()\
    \ + (y.as_int() - z.as_int()) == y.as_int()\n   |                            \
    \          ^^^^^^ help: there is an associated function with a similar name: `asin`\n\
    \nerror[E0599]: no method named `as_int` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpwxcfwxdp.rs:11:53\n   |\n11 |         x.as_int() + (y.as_int()\
    \ + z.as_int()) == x.as_int() && x.as_int() + (y.as_int() - z.as_int()) == y.as_int()\n\
    \   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmphmnmzsnb.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmphmnmzsnb.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmphmnmzsnb.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match f64::try_from(x).unwrap() {\n        Some(a) => f64::try_from(y).unwrap().is_some()\
    \ && a.try_from(x).unwrap().is_some() && a.try_from(z).unwrap().is_some(),\n \
    \       _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n \
    \   assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `try_from` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpy49tkib8.rs:10:16\n   |\n10 |\
    \     match f64::try_from(x).unwrap() {\n   |                ^^^^^^^^ function\
    \ or associated item not found in `f64`\n   |\n   = help: items from traits can\
    \ only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::convert::TryFrom;\n\
    \   |\n\nerror[E0599]: no function or associated item named `try_from` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmpy49tkib8.rs:11:25\n   |\n11 |\
    \         Some(a) => f64::try_from(y).unwrap().is_some() && a.try_from(x).unwrap().is_some()\
    \ && a.try_from(z).unwrap().is_some(),\n   |                         ^^^^^^^^\
    \ function or associated item not found in `f64`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::convert::TryFrom;\n   |\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // We can't use the equality operator, because f64s can't hold NaNs.\n\
    \    // We also can't use std::cmp::max, because it returns false even if all\
    \ the numbers are equal\n    if x == y || y == z || x == z {\n        return true;\n\
    \    }\n    else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2_fq2yki.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n    if x == y && y == z {\n        true\n\
    \    } else if x > y {\n        false\n    } else {\n        any_int(x-y, y-z,\
    \ z-x)\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpeok86hrq.rs:10:21\n   |\n10 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpeok86hrq.rs:11:21\n   |\n11 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpeok86hrq.rs:12:21\n   |\n12 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x as i64;\n    let y_int = y as i64;\n    let z_int\
    \ = z as i64;\n    z_int == x_int || z_int == y_int\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfxzbbehq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match f64::max(x, y) {\n        None => false,\n        Some(max)\
    \ => f64::min(z, max) == x,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp72e0ka9s.rs:11:9\n   |\n\
    10 |     match f64::max(x, y) {\n   |           -------------- this expression\
    \ has type `f64`\n11 |         None => false,\n   |         ^^^^ expected `f64`,\
    \ found enum `Option`\n   |\n   = note: expected type `f64`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72e0ka9s.rs:12:9\n\
    \   |\n10 |     match f64::max(x, y) {\n   |           -------------- this expression\
    \ has type `f64`\n11 |         None => false,\n12 |         Some(max) => f64::min(z,\
    \ max) == x,\n   |         ^^^^^^^^^ expected `f64`, found enum `Option`\n   |\n\
    \   = note: expected type `f64`\n              found enum `Option<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        && y.is_integer()\n        && z.is_integer()\n\
    \        && (x + y + z).is_integer()\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpwqjpzlzl.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpwqjpzlzl.rs:11:14\n\
    \   |\n11 |         && y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpwqjpzlzl.rs:12:14\n   |\n12 |    \
    \     && z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpwqjpzlzl.rs:13:24\n   |\n13 |         && (x + y + z).is_integer()\n\
    \   |                        ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x.checked_add(y) {\n        Some(y) => z.checked_add(y).is_some(),\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpcf6c5igv.rs:10:13\n   |\n10 |     match x.checked_add(y)\
    \ {\n   |             ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no\
    \ method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpcf6c5igv.rs:11:22\n   |\n11 |         Some(y) => z.checked_add(y).is_some(),\n\
    \   |                      ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut z = z - x + y;\n    let mut sum = 0;\n    loop {\n     \
    \   if z < 0 {\n            break;\n        }\n        sum += z;\n        z -=\
    \ x;\n    }\n    sum == x && sum == y\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ub3ftfj.rs:13:16\n   |\n\
    13 |         if z < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `f64`, found integer\n   |                help: use a\
    \ float literal: `0.0`\n\nerror[E0277]: cannot add-assign `f64` to `{integer}`\n\
    \  --> /tmp/tmp4ub3ftfj.rs:16:13\n   |\n16 |         sum += z;\n   |         \
    \    ^^ no implementation for `{integer} += f64`\n   |\n   = help: the trait `AddAssign<f64>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ub3ftfj.rs:19:12\n\
    \   |\n19 |     sum == x && sum == y\n   |            ^ expected integer, found\
    \ `f64`\n\nerror[E0277]: can't compare `{integer}` with `f64`\n  --> /tmp/tmp4ub3ftfj.rs:19:9\n\
    \   |\n19 |     sum == x && sum == y\n   |         ^^ no implementation for `{integer}\
    \ == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ub3ftfj.rs:19:24\n\
    \   |\n19 |     sum == x && sum == y\n   |                        ^ expected integer,\
    \ found `f64`\n\nerror[E0277]: can't compare `{integer}` with `f64`\n  --> /tmp/tmp4ub3ftfj.rs:19:21\n\
    \   |\n19 |     sum == x && sum == y\n   |                     ^^ no implementation\
    \ for `{integer} == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    let abs_sum = std::f64::abs(sum) as f64;\n\
    \    if abs_sum < 1e-6 {\n        return true;\n    }\n    else if abs_sum < 1e-4\
    \ {\n        return false;\n    }\n    else {\n        false;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmp5qjjq8zy.rs:11:29\n\
    \   |\n11 |     let abs_sum = std::f64::abs(sum) as f64;\n   |               \
    \              ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5qjjq8zy.rs:18:10\n   |\n18 |       else {\n   |  __________^\n\
    19 | |         false;\n   | |              - help: remove this semicolon\n20 |\
    \ |     }\n   | |_____^ expected `bool`, found `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    any_int_f64(x, y, z) || any_int_f64(-x, -y, -z)\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `any_int_f64` in this scope\n  --> /tmp/tmpydtt7l5f.rs:10:5\n\
    \   |\n10 |     any_int_f64(x, y, z) || any_int_f64(-x, -y, -z)\n   |     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `any_int_f64`\
    \ in this scope\n  --> /tmp/tmpydtt7l5f.rs:10:29\n   |\n10 |     any_int_f64(x,\
    \ y, z) || any_int_f64(-x, -y, -z)\n   |                             ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5yftauwl.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp5yftauwl.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp5yftauwl.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let int_x = x::floor() as f64;\n    let int_y = y::floor() as f64;\n\
    \    let int_z = z::floor() as f64;\n    let x_plus_y_int = x.checked_add(y).unwrap();\n\
    \    let x_minus_y_int = x.checked_sub(y).unwrap();\n    let x_times_y_int = x.checked_mul(y).unwrap();\n\
    \    let x_div_y_int = x.checked_div(y).unwrap();\n\n    match x_plus_y_int.cmp(&int_x)\
    \ && x_minus_y_int.cmp(&int_x) && x_times_y_int.cmp(&int_x) && x_div_y_int.cmp(&int_x)\
    \ && x_plus_y_int.cmp(&int_y) && x_minus_y_int.cmp(&int_y) && x_times_y_int.cmp(&int_y)\
    \ && x_div_y_int.cmp(&int_y) && x_plus_y_int.cmp(&int_z) && x_minus_y_int.cmp(&int_z)\
    \ && x_times_y_int.cmp(&int_z) && x_div_y_int.cmp(&int_z) {\n        Ordering::Greater\
    \ => true,\n        Ordering::Equal => false,\n        Ordering::Less => false,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `x`\n\
    \  --> /tmp/tmppmhxndut.rs:10:17\n   |\n10 |     let int_x = x::floor() as f64;\n\
    \   |                 ^ use of undeclared crate or module `x`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `y`\n  --> /tmp/tmppmhxndut.rs:11:17\n\
    \   |\n11 |     let int_y = y::floor() as f64;\n   |                 ^ use of\
    \ undeclared crate or module `y`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `z`\n  --> /tmp/tmppmhxndut.rs:12:17\n   |\n12 |     let int_z\
    \ = z::floor() as f64;\n   |                 ^ use of undeclared crate or module\
    \ `z`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmppmhxndut.rs:19:9\n   |\n19 |         Ordering::Greater => true,\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmppmhxndut.rs:20:9\n\
    \   |\n20 |         Ordering::Equal => false,\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmppmhxndut.rs:21:9\n   |\n21 |         Ordering::Less => false,\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]: no method\
    \ named `checked_add` found for type `f64` in the current scope\n  --> /tmp/tmppmhxndut.rs:13:26\n\
    \   |\n13 |     let x_plus_y_int = x.checked_add(y).unwrap();\n   |          \
    \                ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_sub` found for type `f64` in the current scope\n  --> /tmp/tmppmhxndut.rs:14:27\n\
    \   |\n14 |     let x_minus_y_int = x.checked_sub(y).unwrap();\n   |         \
    \                  ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_mul` found for type `f64` in the current scope\n  --> /tmp/tmppmhxndut.rs:15:27\n\
    \   |\n15 |     let x_times_y_int = x.checked_mul(y).unwrap();\n   |         \
    \                  ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_div` found for type `f64` in the curr"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || y.is_integer() || z.is_integer()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpdogxzly0.rs:10:7\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpdogxzly0.rs:10:25\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpdogxzly0.rs:10:43\n   |\n\
    10 |     x.is_integer() || y.is_integer() || z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x = f64::from(x);\n    let y = f64::from(y);\n    let z = f64::from(z);\n\
    \    if x >= y {\n        x >= z\n    } else {\n        y >= z\n    }\n}\n\nfn\
    \ main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0),\
    \ true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppqn0h2ep.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x, y, z) == f64::min() + f64::max() + f64::max()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 0 arguments were supplied\n\
    \   --> /tmp/tmps2u2yw34.rs:10:18\n    |\n10  |     (x, y, z) == f64::min() +\
    \ f64::max() + f64::max()\n    |                  ^^^^^^^^-- supplied 0 arguments\n\
    \    |                  |\n    |                  expected 2 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 2\
    \ arguments but 0 arguments were supplied\n   --> /tmp/tmps2u2yw34.rs:10:31\n\
    \    |\n10  |     (x, y, z) == f64::min() + f64::max() + f64::max()\n    |   \
    \                            ^^^^^^^^-- supplied 0 arguments\n    |          \
    \                     |\n    |                               expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 2 arguments but 0 arguments were supplied\n   --> /tmp/tmps2u2yw34.rs:10:44\n\
    \    |\n10  |     (x, y, z) == f64::min() + f64::max() + f64::max()\n    |   \
    \                                         ^^^^^^^^-- supplied 0 arguments\n  \
    \  |                                            |\n    |                     \
    \                       expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps2u2yw34.rs:10:18\n\
    \   |\n10 |     (x, y, z) == f64::min() + f64::max() + f64::max()\n   |      \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found `f64`\n\
    \   |\n   = note: expected tuple `(f64, f64, f64)`\n               found type\
    \ `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpdvcenyp7.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpdvcenyp7.rs:11:14\n\
    \   |\n11 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpdvcenyp7.rs:12:14\n   |\n12 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n        x.unwrap() + y.unwrap() + z.unwrap() == *\n            std::mem::transmute::<_,\
    \ isize>(x + y + z)\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp5gnz8g4a.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer() &&\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp5gnz8g4a.rs:10:25\n   |\n\
    10 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp5gnz8g4a.rs:10:43\n   |\n10 |     x.is_integer() && x.is_integer() &&\
    \ y.is_integer() && z.is_integer() &&\n   |                                  \
    \         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp5gnz8g4a.rs:10:61\n\
    \   |\n10 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\
    \ &&\n   |                                                             ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmp5gnz8g4a.rs:11:11\n   |\n11 |\
    \         x.unwrap() + y.unwrap() + z.unwrap() == *\n   |           ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp5gnz8g4a.rs:11:24\n   |\n11 |    \
    \     x.unwrap() + y.unwrap() + z.unwrap() == *\n   |                        ^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmp5gnz8g4a.rs:11:37\n   |\n11 |\
    \         x.unwrap() + y.unwrap() + z.unwrap() == *\n   |                    \
    \                 ^^^^^^ method not found in `f64`\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmp5gnz8g4a.rs:11:49\n   |\n11 |        \
    \   x.unwrap() + y.unwrap() + z.unwrap() == *\n   |  _________________________________________________^\n\
    12 | |             std::mem"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x < y && y < z && z < x {\n        return true;\n    }\n    if\
    \ x < y && y < z && z < y {\n        return true;\n    }\n    if x < z && z <\
    \ x {\n        return true;\n    }\n    if x < z && z < y {\n        return true;\n\
    \    }\n    if y < z && z < x {\n        return true;\n    }\n    if y < z &&\
    \ z < y {\n        return true;\n    }\n    if z < x {\n        return true;\n\
    \    }\n    if z < y {\n        return true;\n    }\n    if z < z {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcs3mx16j.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || y.is_integer() || z.is_integer()\n        || (x.is_real()\
    \ && y.is_real() && z.is_real())\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpt0qjfeky.rs:10:7\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpt0qjfeky.rs:10:25\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpt0qjfeky.rs:10:43\n   |\n\
    10 |     x.is_integer() || y.is_integer() || z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_real` found for type `f64` in the current scope\n  --> /tmp/tmpt0qjfeky.rs:11:15\n\
    \   |\n11 |         || (x.is_real() && y.is_real() && z.is_real())\n   |     \
    \          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_normal`\n\nerror[E0599]: no method named `is_real` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpt0qjfeky.rs:11:30\n   |\n11 |         ||\
    \ (x.is_real() && y.is_real() && z.is_real())\n   |                          \
    \    ^^^^^^^ help: there is an associated function with a similar name: `is_normal`\n\
    \nerror[E0599]: no method named `is_real` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpt0qjfeky.rs:11:45\n   |\n11 |         || (x.is_real() &&\
    \ y.is_real() && z.is_real())\n   |                                          \
    \   ^^^^^^^ help: there is an associated function with a similar name: `is_normal`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || (x.is_integer() && y.is_integer() && z.is_integer())\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp11nl65pl.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp11nl65pl.rs:11:14\n\
    \   |\n11 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp11nl65pl.rs:12:14\n   |\n12 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp11nl65pl.rs:13:15\n   |\n13 |         || (x.is_integer()\
    \ && y.is_integer() && z.is_integer())\n   |               ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp11nl65pl.rs:13:33\n   |\n13 |    \
    \     || (x.is_integer() && y.is_integer() && z.is_integer())\n   |          \
    \                       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp11nl65pl.rs:13:51\n   |\n13 |         || (x.is_integer() && y.is_integer()\
    \ && z.is_integer())\n   |                                                   ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 6 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x > y && x > z && y > z && x.is_integer() && y.is_integer() && z.is_integer()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpcmva_lmk.rs:10:34\n   |\n10 |     x > y && x >\
    \ z && y > z && x.is_integer() && y.is_integer() && z.is_integer()\n   |     \
    \                             ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpcmva_lmk.rs:10:52\n   |\n10 |     x > y && x > z && y > z && x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                                  \
    \                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpcmva_lmk.rs:10:70\n\
    \   |\n10 |     x > y && x > z && y > z && x.is_integer() && y.is_integer() &&\
    \ z.is_integer()\n   |                                                       \
    \               ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match &z {\n        Some(..) => !((x as i64 + y as i64 == z as i64),\n\
    \                  (x as i64 + y as i64 + z as i64 as i64 > 0),\n            \
    \      (x as i64 + y as i64 + z as i64 as i64 < 0)),\n        None => !(x as i64\
    \ + y as i64 == z as i64),\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: `<` is interpreted as a start of generic arguments for `i64`, not\
    \ a comparison\n  --> /tmp/tmpibm0rt39.rs:13:58\n   |\n13 |                  \
    \ (x as i64 + y as i64 + z as i64 as i64 < 0)),\n   |                        \
    \                                  ^ -- interpreted as generic arguments\n   |\
    \                                                          |\n   |           \
    \                                               not interpreted as comparison\n\
    \   |\nhelp: try comparing the cast value\n   |\n13 |                   (x as\
    \ i64 + y as i64 + (z as i64 as i64) < 0)),\n   |                            \
    \              +               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibm0rt39.rs:11:9\n\
    \   |\n10 |     match &z {\n   |           -- this expression has type `&f64`\n\
    11 |         Some(..) => !((x as i64 + y as i64 == z as i64),\n   |         ^^^^^^^^\
    \ expected `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpibm0rt39.rs:14:9\n   |\n10 |     match &z {\n   |           -- this\
    \ expression has type `&f64`\n...\n14 |         None => !(x as i64 + y as i64\
    \ == z as i64),\n   |         ^^^^ expected `f64`, found enum `Option`\n   |\n\
    \   = note: expected type `f64`\n              found enum `Option<_>`\n\nerror[E0600]:\
    \ cannot apply unary operator `!` to type `(bool, bool, bool)`\n  --> /tmp/tmpibm0rt39.rs:11:21\n\
    \   |\n11 |           Some(..) => !((x as i64 + y as i64 == z as i64),\n   | \
    \ _____________________^\n12 | |                   (x as i64 + y as i64 + z as\
    \ i64 as i64 > 0),\n13 | |                   (x as i64 + y as i64 + z as i64 as\
    \ i64 < 0)),\n   | |______________________________________________________________^\
    \ cannot apply unary operator `!`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let any = x.is_any() || y.is_any() || z.is_any();\n    if any {\n\
    \        if x.is_any() {\n            return y.is_any() && z.is_any();\n     \
    \   }\n        if y.is_any() {\n            return x.is_any() && z.is_any();\n\
    \        }\n        return x.is_any() && y.is_any();\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0,\
    \ 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_any` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpf6g7ad_j.rs:10:17\n   |\n10 |     let any = x.is_any()\
    \ || y.is_any() || z.is_any();\n   |                 ^^^^^^ help: there is an\
    \ associated function with a similar name: `is_nan`\n\nerror[E0599]: no method\
    \ named `is_any` found for type `f64` in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:10:31\n\
    \   |\n10 |     let any = x.is_any() || y.is_any() || z.is_any();\n   |      \
    \                         ^^^^^^ help: there is an associated function with a\
    \ similar name: `is_nan`\n\nerror[E0599]: no method named `is_any` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:10:45\n   |\n10 |    \
    \ let any = x.is_any() || y.is_any() || z.is_any();\n   |                    \
    \                         ^^^^^^ help: there is an associated function with a\
    \ similar name: `is_nan`\n\nerror[E0599]: no method named `is_any` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:12:14\n   |\n12 |    \
    \     if x.is_any() {\n   |              ^^^^^^ help: there is an associated function\
    \ with a similar name: `is_nan`\n\nerror[E0599]: no method named `is_any` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:13:22\n   |\n\
    13 |             return y.is_any() && z.is_any();\n   |                      ^^^^^^\
    \ help: there is an associated function with a similar name: `is_nan`\n\nerror[E0599]:\
    \ no method named `is_any` found for type `f64` in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:13:36\n\
    \   |\n13 |             return y.is_any() && z.is_any();\n   |               \
    \                     ^^^^^^ help: there is an associated function with a similar\
    \ name: `is_nan`\n\nerror[E0599]: no method named `is_any` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:15:14\n   |\n15 |         if\
    \ y.is_any() {\n   |              ^^^^^^ help: there is an associated function\
    \ with a similar name: `is_nan`\n\nerror[E0599]: no method named `is_any` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpf6g7ad_j.rs:16:22\n   |\n\
    16 |             return x.is_a"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x > y && x > z && x < y + z && x < z + y\n}\n\nfn main() {\n   \
    \ let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8u68cx_f.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n\n    let x: i64 = x.to_i32();\n    let y:\
    \ i64 = y.to_i32();\n    let z: i64 = z.to_i32();\n\n    x >= y && x >= z && y\
    \ >= z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpda_hxmfh.rs:10:21\n   |\n10 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpda_hxmfh.rs:11:21\n   |\n11 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpda_hxmfh.rs:12:21\n   |\n12 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_i32` found for type `f64` in the current scope\n  --> /tmp/tmpda_hxmfh.rs:14:20\n\
    \   |\n14 |     let x: i64 = x.to_i32();\n   |                    ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `to_i32` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpda_hxmfh.rs:15:20\n   |\n15 |    \
    \ let y: i64 = y.to_i32();\n   |                    ^^^^^^ method not found in\
    \ `f64`\n\nerror[E0599]: no method named `to_i32` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpda_hxmfh.rs:16:20\n   |\n16 |     let z: i64 =\
    \ z.to_i32();\n   |                    ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp6ngzoug3.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp6ngzoug3.rs:10:25\n   |\n\
    10 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\n\
    \   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp6ngzoug3.rs:10:43\n   |\n10 |     x.is_integer() && x.is_integer() &&\
    \ y.is_integer() && z.is_integer()\n   |                                     \
    \      ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp6ngzoug3.rs:10:61\n\
    \   |\n10 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\n\
    \   |                                                             ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x = if x % 1 == 0.0 && x % 2 == 0.0 { 0.0 } else { x };\n  \
    \  let y = if y % 1 == 0.0 && y % 2 == 0.0 { 0.0 } else { y };\n    let z = if\
    \ z % 1 == 0.0 && z % 2 == 0.0 { 0.0 } else { z };\n    match x + y + z {\n  \
    \      x if x == z => true,\n        x if x == y => true,\n        x if x == 0.0\
    \ => false,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpqp3jk_qx.rs:10:18\n\
    \   |\n10 |     let x = if x % 1 == 0.0 && x % 2 == 0.0 { 0.0 } else { x };\n\
    \   |                  ^ no implementation for `f64 % {integer}`\n   |\n   = help:\
    \ the trait `Rem<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n10 |     let x = if x\
    \ % 1.0 == 0.0 && x % 2 == 0.0 { 0.0 } else { x };\n   |                     ++\n\
    \nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpqp3jk_qx.rs:10:34\n\
    \   |\n10 |     let x = if x % 1 == 0.0 && x % 2 == 0.0 { 0.0 } else { x };\n\
    \   |                                  ^ no implementation for `f64 % {integer}`\n\
    \   |\n   = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Rem<Rhs>`:\n            \
    \ <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n10 |     let x\
    \ = if x % 1 == 0.0 && x % 2.0 == 0.0 { 0.0 } else { x };\n   |              \
    \                       ++\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n\
    \  --> /tmp/tmpqp3jk_qx.rs:11:18\n   |\n11 |     let y = if y % 1 == 0.0 && y\
    \ % 2 == 0.0 { 0.0 } else { y };\n   |                  ^ no implementation for\
    \ `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.checked_add(&y).is_some() && y.checked_add(&z).is_some()\n   \
    \     && x.checked_add(&z).is_none() && y.checked_add(&x).is_none()\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_add` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpeqd6823l.rs:10:7\n   |\n10 |     x.checked_add(&y).is_some()\
    \ && y.checked_add(&z).is_some()\n   |       ^^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `checked_add` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpeqd6823l.rs:10:38\n   |\n10 |     x.checked_add(&y).is_some()\
    \ && y.checked_add(&z).is_some()\n   |                                      ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_add` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpeqd6823l.rs:11:14\n   |\n\
    11 |         && x.checked_add(&z).is_none() && y.checked_add(&x).is_none()\n \
    \  |              ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_add` found for type `f64` in the current scope\n  --> /tmp/tmpeqd6823l.rs:11:45\n\
    \   |\n11 |         && x.checked_add(&z).is_none() && y.checked_add(&x).is_none()\n\
    \   |                                             ^^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x + (y as f64) + (z as f64)).is_integer()\n}\n\nfn main() {\n \
    \   let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmprlucid1e.rs:10:35\n   |\n10 |     (x + (y as f64)\
    \ + (z as f64)).is_integer()\n   |                                   ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x {\n        f64::MIN_INFINITY..=f64::MAX_INFINITY => y ==\
    \ z && x.floor() as i64 == (x.ceil() as i64 - 1),\n        f64::MIN_POSITIVE..=f64::MAX_NEGATIVE\
    \ => y == z && x.floor() as i64 >= 0,\n        f64::MIN..=f64::MAX => y == z &&\
    \ x.floor() as i64 == x.ceil() as i64,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no associated item named `MIN_INFINITY` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpd1br5iu4.rs:11:14\n   |\n11 |         f64::MIN_INFINITY..=f64::MAX_INFINITY\
    \ => y == z && x.floor() as i64 == (x.ceil() as i64 - 1),\n   |              ^^^^^^^^^^^^\n\
    \   |              |\n   |              associated item not found in `f64`\n \
    \  |              help: there is an associated constant with a similar name: `INFINITY`\n\
    \nerror[E0599]: no associated item named `MAX_INFINITY` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmpd1br5iu4.rs:11:34\n   |\n11 |         f64::MIN_INFINITY..=f64::MAX_INFINITY\
    \ => y == z && x.floor() as i64 == (x.ceil() as i64 - 1),\n   |              \
    \                    ^^^^^^^^^^^^\n   |                                  |\n \
    \  |                                  associated item not found in `f64`\n   |\
    \                                  help: there is an associated constant with\
    \ a similar name: `INFINITY`\n\nerror[E0599]: no associated item named `MAX_NEGATIVE`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpd1br5iu4.rs:12:34\n\
    \   |\n12 |         f64::MIN_POSITIVE..=f64::MAX_NEGATIVE => y == z && x.floor()\
    \ as i64 >= 0,\n   |                                  ^^^^^^^^^^^^ associated\
    \ item not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut sum = x + y + z;\n    sum = (sum - (sum % 1)) as f64;\n\n\
    \    match num::try_from(x).unwrap() as u64 { // Cast to u64 because f64 does\
    \ not implement PartialOrd.\n        Some(a) if a == sum as u64 && a == x + y\
    \ + z as u64 => true\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found reserved\
    \ identifier `_`\n  --> /tmp/tmp_v9jyf5w.rs:15:9\n   |\n14 |         Some(a) if\
    \ a == sum as u64 && a == x + y + z as u64 => true\n   |                     \
    \                                        --     - expected one of `,`, `.`, `?`,\
    \ `}`, or an operator\n   |                                                  \
    \           |\n   |                                                          \
    \   while parsing the `match` arm starting here\n15 |         _ => false,\n  \
    \ |         ^ unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `num`\n  --> /tmp/tmp_v9jyf5w.rs:13:11\n   |\n13 |     match\
    \ num::try_from(x).unwrap() as u64 { // Cast to u64 because f64 does not implement\
    \ PartialOrd.\n   |           ^^^ use of undeclared crate or module `num`\n\n\
    error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp_v9jyf5w.rs:11:23\n\
    \   |\n11 |     sum = (sum - (sum % 1)) as f64;\n   |                       ^\
    \ no implementation for `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |     sum = (sum - (sum % 1.0)) as f64;\n   |       \
    \                   ++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y + z {\n        true\n    } else {\n        false\n   \
    \ }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp27bymucj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int: i64 = x.trunc();\n    let y_int: i64 = y.trunc();\n \
    \   let z_int: i64 = z.trunc();\n    (x_int + y_int + z_int) == x.trunc() + y.trunc()\
    \ + z.trunc()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77grds71.rs:10:22\n   |\n\
    10 |     let x_int: i64 = x.trunc();\n   |                ---   ^^^^^^^^^ expected\
    \ `i64`, found `f64`\n   |                |\n   |                expected due\
    \ to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77grds71.rs:11:22\n\
    \   |\n11 |     let y_int: i64 = y.trunc();\n   |                ---   ^^^^^^^^^\
    \ expected `i64`, found `f64`\n   |                |\n   |                expected\
    \ due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77grds71.rs:12:22\n\
    \   |\n12 |     let z_int: i64 = z.trunc();\n   |                ---   ^^^^^^^^^\
    \ expected `i64`, found `f64`\n   |                |\n   |                expected\
    \ due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp77grds71.rs:13:32\n\
    \   |\n13 |     (x_int + y_int + z_int) == x.trunc() + y.trunc() + z.trunc()\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `i64`, found `f64`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y || x == z {\n        return true;\n    }\n    if x !=\
    \ z && y != z && x != -z && y != -z && z != -z && z != -z {\n        return false;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv4kw1jig.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int = x.trun();\n    let y_int = y.trun();\n    let z_int\
    \ = z.trun();\n    let x_frac = x.fract();\n    let y_frac = y.fract();\n    let\
    \ z_frac = z.fract();\n    let x_fraction = if x_frac > 0.0 { x_frac } else {\
    \ -1.0 * x_frac };\n    let y_fraction = if y_frac > 0.0 { y_frac } else { -1.0\
    \ * y_frac };\n    let z_fraction = if z_frac > 0.0 { z_frac } else { -1.0 * z_frac\
    \ };\n\n    match x_int, y_int, z_int, x_fraction, y_fraction, z_fraction {\n\
    \        (Some(x), Some(y), Some(z), Some(xf), Some(yf), Some(zf)) if x == x +\
    \ y && y == y + z && z == z + xf => {\n            true\n        }\n        _\
    \ => false,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmpw88uqc8k.rs:20:16\n   |\n20 |     match x_int, y_int, z_int,\
    \ x_fraction, y_fraction, z_fraction {\n   |     -----      ^ expected one of\
    \ `!`, `.`, `::`, `?`, `{`, or an operator\n   |     |\n   |     while parsing\
    \ this `match` expression\n\nerror[E0599]: no method named `trun` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpw88uqc8k.rs:10:19\n   |\n10 |    \
    \ let x_int = x.trun();\n   |                   ^^^^ help: there is an associated\
    \ function with a similar name: `trunc`\n\nerror[E0599]: no method named `trun`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpw88uqc8k.rs:11:19\n\
    \   |\n11 |     let y_int = y.trun();\n   |                   ^^^^ help: there\
    \ is an associated function with a similar name: `trunc`\n\nerror[E0599]: no method\
    \ named `trun` found for type `f64` in the current scope\n  --> /tmp/tmpw88uqc8k.rs:12:19\n\
    \   |\n12 |     let z_int = z.trun();\n   |                   ^^^^ help: there\
    \ is an associated function with a similar name: `trunc`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    !x.is_nan() && y.is_nan() && z.is_nan() || x.is_integer() && y.is_integer()\
    \ && z.is_integer() && x.to_f64() + y.to_f64() + z.to_f64() == 0\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpeav9j1oa.rs:10:50\n   |\n10 |     !x.is_nan() &&\
    \ y.is_nan() && z.is_nan() || x.is_integer() && y.is_integer() && z.is_integer()\
    \ && x.to_f64() + y.to_f64() + z.to_f64()...\n   |                           \
    \                       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpeav9j1oa.rs:10:68\n   |\n10 |     !x.is_nan() && y.is_nan() && z.is_nan()\
    \ || x.is_integer() && y.is_integer() && z.is_integer() && x.to_f64() + y.to_f64()\
    \ + z.to_f64()...\n   |                                                      \
    \              ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpeav9j1oa.rs:10:86\n\
    \   |\n10 |     !x.is_nan() && y.is_nan() && z.is_nan() || x.is_integer() && y.is_integer()\
    \ && z.is_integer() && x.to_f64() + y.to_f64() + z.to_f64()...\n   |         \
    \                                                                            \
    \ ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_f64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpeav9j1oa.rs:10:104\n\
    \   |\n10 | ...integer() && y.is_integer() && z.is_integer() && x.to_f64() + y.to_f64()\
    \ + z.to_f64() == 0\n   |                                                    \
    \   ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `to_f64`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpeav9j1oa.rs:10:117\n\
    \   |\n10 | ...y.is_integer() && z.is_integer() && x.to_f64() + y.to_f64() + z.to_f64()\
    \ == 0\n   |                                                       ^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `to_f64` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpeav9j1oa.rs:10:130\n   |\n10 | ...)\
    \ && z.is_integer() && x.to_f64() + y.to_f64() + z.to_f64() == 0\n   |       \
    \                                                ^^^^^^ method not found in `f64`\n\
    \nerror: aborting due "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x > z) == (y == z) || (y < z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8a89m383.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x < y && x < z {\n        true\n    } else if x < y || x < z\
    \ {\n        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7i881apg.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\n\
    \        && (x.to_double() + z.to_double() == y.to_double() || y.to_double() +\
    \ z.to_double() == x.to_double())\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpmwimc1ir.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && x.is_integer() && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpmwimc1ir.rs:10:25\n   |\n\
    10 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\n\
    \   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpmwimc1ir.rs:10:43\n   |\n10 |     x.is_integer() && x.is_integer() &&\
    \ y.is_integer() && z.is_integer()\n   |                                     \
    \      ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `is_integer`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpmwimc1ir.rs:10:61\n\
    \   |\n10 |     x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer()\n\
    \   |                                                             ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `to_double` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpmwimc1ir.rs:11:15\n   |\n11 |    \
    \     && (x.to_double() + z.to_double() == y.to_double() || y.to_double() + z.to_double()\
    \ == x.to_double())\n   |               ^^^^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `to_double` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpmwimc1ir.rs:11:31\n   |\n11 |         && (x.to_double()\
    \ + z.to_double() == y.to_double() || y.to_double() + z.to_double() == x.to_double())\n\
    \   |                               ^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `to_double` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpmwimc1ir.rs:11:48\n   |\n11 |         && (x.to_double() + z.to_double()\
    \ == y.to_double() || y.to_double() + z.to_double() == x.to_double())\n   |  \
    \                                              ^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no met"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut a = x as i32;\n    let mut b = y as i32;\n    let mut c\
    \ = z as i32;\n\n    if a < 0 || b < 0 || c < 0 {\n        return false;\n   \
    \ }\n\n    a = a as usize;\n    b = b as usize;\n    c = c as usize;\n\n    if\
    \ a == 0 || b == 0 || c == 0 {\n        return false;\n    }\n\n    if a + b ==\
    \ c {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphnp0gyyl.rs:18:9\n   |\n\
    10 |     let mut a = x as i32;\n   |                 -------- expected due to\
    \ this value\n...\n18 |     a = a as usize;\n   |         ^^^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphnp0gyyl.rs:19:9\n\
    \   |\n11 |     let mut b = y as i32;\n   |                 -------- expected\
    \ due to this value\n...\n19 |     b = b as usize;\n   |         ^^^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphnp0gyyl.rs:20:9\n\
    \   |\n12 |     let mut c = z as i32;\n   |                 -------- expected\
    \ due to this value\n...\n20 |     c = c as usize;\n   |         ^^^^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && x.is_integer() && x.is_integer() && y.is_integer()\
    \ && y.is_integer() && z.is_integer() && z.is_integer() &&\n    (x + y + z).is_integer()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpv5cln69l.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && x.is_integer() && x.is_integer() && y.is_integer() && y.is_integer() && z.is_integer()\
    \ && z.is_integer() &&\n   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpv5cln69l.rs:10:25\n   |\n10 |     x.is_integer() && x.is_integer() &&\
    \ x.is_integer() && y.is_integer() && y.is_integer() && z.is_integer() && z.is_integer()\
    \ &&\n   |                         ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpv5cln69l.rs:10:43\n   |\n10 |     x.is_integer() && x.is_integer() &&\
    \ x.is_integer() && y.is_integer() && y.is_integer() && z.is_integer() && z.is_integer()\
    \ &&\n   |                                           ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpv5cln69l.rs:10:61\n   |\n10 |     x.is_integer()\
    \ && x.is_integer() && x.is_integer() && y.is_integer() && y.is_integer() && z.is_integer()\
    \ && z.is_integer() &&\n   |                                                 \
    \            ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpv5cln69l.rs:10:79\n\
    \   |\n10 |     x.is_integer() && x.is_integer() && x.is_integer() && y.is_integer()\
    \ && y.is_integer() && z.is_integer() && z.is_integer() &&\n   |             \
    \                                                                  ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpv5cln69l.rs:10:97\n   |\n\
    10 |     x.is_integer() && x.is_integer() && x.is_integer() && y.is_integer()\
    \ && y.is_integer() && z.is_integer() && z.is_integer() &&\n   |             \
    \                                                                 "
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum: f64 = x + y + z;\n    match sum {\n        z => z < 0,\n\
    \        _ => z > 0,\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7c8071es.rs:12:18\n   |\n\
    12 |         z => z < 0,\n   |                  ^\n   |                  |\n \
    \  |                  expected `f64`, found integer\n   |                  help:\
    \ use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7c8071es.rs:13:18\n\
    \   |\n13 |         _ => z > 0,\n   |                  ^\n   |               \
    \   |\n   |                  expected `f64`, found integer\n   |             \
    \     help: use a float literal: `0.0`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == z || y == z || x == y) as bool\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7qrgtr5_.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let abs_x = x.abs();\n    let abs_y = y.abs();\n    let abs_z =\
    \ z.abs();\n    if abs_x > abs_y && abs_x > abs_z {\n        return true;\n  \
    \  } else if abs_y > abs_z {\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2f0awr3z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer() &&\n        x.checked_add(y).checked_add(z).is_some()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp1eo8ot31.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp1eo8ot31.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer() &&\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp1eo8ot31.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer() &&\n   |         \
    \                                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `checked_add` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp1eo8ot31.rs:11:11\n   |\n11 |         x.checked_add(y).checked_add(z).is_some()\n\
    \   |           ^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    !check_integral(sum)\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_integral` in this scope\n  -->\
    \ /tmp/tmp649dhpud.rs:11:6\n   |\n11 |     !check_integral(sum)\n   |      ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x >= y + z && x <= y + z + 1 && x >= z && x <= z + 1\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpd5i3pg79.rs:10:30\n\
    \   |\n10 |     x >= y + z && x <= y + z + 1 && x >= z && x <= z + 1\n   |   \
    \                           ^ no implementation for `f64 + {integer}`\n   |\n\
    \   = help: the trait `Add<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n10 |     x >= y + z\
    \ && x <= y + z + 1.0 && x >= z && x <= z + 1\n   |                          \
    \       ++\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpd5i3pg79.rs:10:54\n\
    \   |\n10 |     x >= y + z && x <= y + z + 1 && x >= z && x <= z + 1\n   |   \
    \                                                   ^ no implementation for `f64\
    \ + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |     x >= y + z && x <= y + z + 1 && x >= z && x <= z + 1.0\n\
    \   |                                                         ++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    // Convert all inputs to integers and add them\n    // If any of\
    \ them is not an integer, return false as we are looking for\n    // whether any\
    \ of them is equal to the sum\n    if x.is_integer() || y.is_integer() || z.is_integer()\
    \ {\n        if x.is_integer() {\n            if x.is_positive() || y.is_positive()\
    \ || z.is_positive() {\n                x.checked_add(y.checked_add(z)).unwrap()\
    \ == x.checked_add(y.checked_add(z)).unwrap()\n            } else {\n        \
    \        false\n            }\n        } else {\n            if x.checked_add(y).unwrap()\
    \ == x.checked_add(y).unwrap() {\n                if x.is_positive() || y.is_positive()\
    \ || z.is_positive() {\n                    true\n                } else {\n \
    \                   false\n                }\n            } else {\n         \
    \       false\n            }\n        }\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpda39zjy7.rs:13:10\n   |\n13 |     if x.is_integer()\
    \ || y.is_integer() || z.is_integer() {\n   |          ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpda39zjy7.rs:13:28\n   |\n13 |     if x.is_integer()\
    \ || y.is_integer() || z.is_integer() {\n   |                            ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpda39zjy7.rs:13:46\n   |\n\
    13 |     if x.is_integer() || y.is_integer() || z.is_integer() {\n   |       \
    \                                       ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpda39zjy7.rs:14:14\n   |\n14 |         if x.is_integer()\
    \ {\n   |              ^^^^^^^^^^ method not found in `f64`\n\nwarning: use of\
    \ deprecated associated function `core::f64::<impl f64>::is_positive`: renamed\
    \ to is_sign_positive\n  --> /tmp/tmpda39zjy7.rs:15:18\n   |\n15 |           \
    \  if x.is_positive() || y.is_positive() || z.is_positive() {\n   |          \
    \        ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\n\
    warning: use of deprecated associated function `core::f64::<impl f64>::is_positive`:\
    \ renamed to is_sign_positive\n  --> /tmp/tmpda39zjy7.rs:15:37\n   |\n15 |   \
    \          if x.is_positive() || y.is_positive() || z.is_positive() {\n   |  \
    \                                   ^^^^^^^^^^^\n\nwarning: use of deprecated\
    \ associated function `core::f64::<impl f64>::is_positive`: renamed to is_sign_positive\n\
    \  --> /tmp/tmpda39zjy7.rs:15:56\n   |\n15 |             if x.is_positive() ||\
    \ y.is_positive() || z.is_positive() {\n   |                                 \
    \                       ^^^^^^^^^^^\n\nerror[E0599]: no method named `checked_add`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpda39zjy7.rs:16:19\n\
    \   |\n16 |                 x.checked_add(y.checked_add(z)"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let sum = x + y + z;\n    match (x, z, y) {\n        (Some(x), Some(z),\
    \ Some(y)) => x == sum,\n        _ => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr0jeq6kq.rs:12:10\n   |\n\
    11 |     match (x, z, y) {\n   |           --------- this expression has type\
    \ `(f64, f64, f64)`\n12 |         (Some(x), Some(z), Some(y)) => x == sum,\n \
    \  |          ^^^^^^^ expected `f64`, found enum `Option`\n   |\n   = note: expected\
    \ type `f64`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr0jeq6kq.rs:12:19\n   |\n11 |     match (x, z, y) {\n \
    \  |           --------- this expression has type `(f64, f64, f64)`\n12 |    \
    \     (Some(x), Some(z), Some(y)) => x == sum,\n   |                   ^^^^^^^\
    \ expected `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr0jeq6kq.rs:12:28\n   |\n11 |     match (x, z, y) {\n   |          \
    \ --------- this expression has type `(f64, f64, f64)`\n12 |         (Some(x),\
    \ Some(z), Some(y)) => x == sum,\n   |                            ^^^^^^^ expected\
    \ `f64`, found enum `Option`\n   |\n   = note: expected type `f64`\n         \
    \     found enum `Option<_>`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == y) || (x == z) || (y == z)\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaqfex6d2.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    match x {\n        0..=z | y..=z => z == x + y,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_w9_0i_h.rs:11:9\n   |\n\
    10 |     match x {\n   |           - this expression has type `f64`\n11 |    \
    \     0..=z | y..=z => z == x + y,\n   |         ^   - this is of type `f64`\n\
    \   |         |\n   |         expected `f64`, found integer\n   |         help:\
    \ use a float literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n\
    \    debug_assert!(z.is_integer());\n    if x + y == z {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp9lh2d244.rs:10:21\n   |\n10 |     debug_assert!(x.is_integer());\n\
    \   |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp9lh2d244.rs:11:21\n   |\n11 |     debug_assert!(y.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp9lh2d244.rs:12:21\n   |\n12 |     debug_assert!(z.is_integer());\n \
    \  |                     ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let x_int: i64 = x.trunc_to_inner();\n    let y_int: i64 = y.trunc_to_inner();\n\
    \    let z_int: i64 = z.trunc_to_inner();\n    match x_int, y_int, z_int {\n \
    \       (x, y, z) => x + y + z == x,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found\
    \ `,`\n  --> /tmp/tmp2gmrdfx2.rs:13:16\n   |\n13 |     match x_int, y_int, z_int\
    \ {\n   |     -----      ^ expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n\
    \   |     |\n   |     while parsing this `match` expression\n\nerror[E0599]: no\
    \ method named `trunc_to_inner` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp2gmrdfx2.rs:10:24\n   |\n10 |     let x_int: i64 = x.trunc_to_inner();\n\
    \   |                        ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `trunc_to_inner` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp2gmrdfx2.rs:11:24\n   |\n11 |     let y_int: i64 = y.trunc_to_inner();\n\
    \   |                        ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `trunc_to_inner` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp2gmrdfx2.rs:12:24\n   |\n12 |     let z_int: i64 = z.trunc_to_inner();\n\
    \   |                        ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    any_int3(x, y, z) == 3\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `any_int3` in this scope\n  --> /tmp/tmpxxnpt9p1.rs:10:5\n\
    \   |\n10 |     any_int3(x, y, z) == 3\n   |     ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x == (y + z)) && (x % 1_000_000_000_000 == 0)\n}\n\nfn main() {\n\
    \    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp1rvglgea.rs:10:26\n\
    \   |\n10 |     (x == (y + z)) && (x % 1_000_000_000_000 == 0)\n   |         \
    \                 ^ no implementation for `f64 % {integer}`\n   |\n   = help:\
    \ the trait `Rem<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n10 |     (x == (y + z))\
    \ && (x % 1_000_000_000_000.0 == 0)\n   |                                    \
    \         ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x % z == 0 || y % z == 0\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphpd_i73h.rs:10:14\n   |\n\
    10 |     x % z == 0 || y % z == 0\n   |              ^\n   |              |\n\
    \   |              expected `f64`, found integer\n   |              help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphpd_i73h.rs:10:28\n\
    \   |\n10 |     x % z == 0 || y % z == 0\n   |                            ^\n\
    \   |                            |\n   |                            expected `f64`,\
    \ found integer\n   |                            help: use a float literal: `0.0`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    fn is_int(x: i64) -> bool {\n        x.is_integer() && x >= 0\n\
    \    }\n\n    if is_int(x) && is_int(y) && is_int(z) {\n        (x + y + z).is_integer()\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n\
    \    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmbhgfmc0.rs:14:15\n   |\n\
    14 |     if is_int(x) && is_int(y) && is_int(z) {\n   |               ^ expected\
    \ `i64`, found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmbhgfmc0.rs:14:28\n\
    \   |\n14 |     if is_int(x) && is_int(y) && is_int(z) {\n   |               \
    \             ^ expected `i64`, found `f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmbhgfmc0.rs:14:41\n   |\n14 |     if is_int(x) && is_int(y) &&\
    \ is_int(z) {\n   |                                         ^ expected `i64`,\
    \ found `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpmbhgfmc0.rs:15:21\n   |\n15 |         (x\
    \ + y + z).is_integer()\n   |                     ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `i64`\
    \ in the current scope\n  --> /tmp/tmpmbhgfmc0.rs:11:11\n   |\n11 |         x.is_integer()\
    \ && x >= 0\n   |           ^^^^^^^^^^ method not found in `i64`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    use std::cmp::Ordering;\n    let one = x.saturating_add(y.saturating_add(z));\n\
    \    Ordering::GreaterOrEqual == one || Ordering::Equal == one || Ordering::LessOrEqual\
    \ == one\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `saturating_add` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmp38jrkhmp.rs:11:17\n   |\n11 |     let one =\
    \ x.saturating_add(y.saturating_add(z));\n   |                 ^^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `saturating_add`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp38jrkhmp.rs:11:34\n\
    \   |\n11 |     let one = x.saturating_add(y.saturating_add(z));\n   |       \
    \                           ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no variant or associated item named `GreaterOrEqual` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp38jrkhmp.rs:12:15\n   |\n12 |     Ordering::GreaterOrEqual\
    \ == one || Ordering::Equal == one || Ordering::LessOrEqual == one\n   |     \
    \          ^^^^^^^^^^^^^^ variant or associated item not found in `std::cmp::Ordering`\n\
    \nerror[E0599]: no variant or associated item named `LessOrEqual` found for enum\
    \ `std::cmp::Ordering` in the current scope\n  --> /tmp/tmp38jrkhmp.rs:12:76\n\
    \   |\n12 |     Ordering::GreaterOrEqual == one || Ordering::Equal == one || Ordering::LessOrEqual\
    \ == one\n   |                                                               \
    \             ^^^^^^^^^^^ variant or associated item not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let mut m = x + y + z;\n    m /= 3;\n    m == x || m == y || m ==\
    \ z\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot divide-assign `f64` by `{integer}`\n  --> /tmp/tmpf6ya5jjw.rs:11:7\n\
    \   |\n11 |     m /= 3;\n   |       ^^ no implementation for `f64 /= {integer}`\n\
    \   |\n   = help: the trait `DivAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `DivAssign<Rhs>`:\n    \
    \         <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n        \
    \     <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n            \
    \ <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n             <i16\
    \ as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    11 |     m /= 3.0;\n   |           ++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() && y.is_integer() && z.is_integer()\n        && x\
    \ != 0 && y != 0 && z != 0\n}\n\nfn main() {\n    let candidate = any_int;\n \
    \   assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp_3gbo6d8.rs:10:7\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp_3gbo6d8.rs:10:25\n   |\n10 |     x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp_3gbo6d8.rs:10:43\n   |\n\
    10 |     x.is_integer() && y.is_integer() && z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_3gbo6d8.rs:11:17\n   |\n11 |         && x !=\
    \ 0 && y != 0 && z != 0\n   |                 ^\n   |                 |\n   |\
    \                 expected `f64`, found integer\n   |                 help: use\
    \ a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3gbo6d8.rs:11:27\n\
    \   |\n11 |         && x != 0 && y != 0 && z != 0\n   |                      \
    \     ^\n   |                           |\n   |                           expected\
    \ `f64`, found integer\n   |                           help: use a float literal:\
    \ `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3gbo6d8.rs:11:37\n \
    \  |\n11 |         && x != 0 && y != 0 && z != 0\n   |                       \
    \              ^\n   |                                     |\n   |           \
    \                          expected `f64`, found integer\n   |               \
    \                      help: use a float literal: `0.0`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    if x == y || x == z || y == z {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsb4rogpo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x <= z && y <= z && x <= y\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2h9xz2yf.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    let total = x + y + z;\n    if total == x || total == y || total\
    \ == z {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp62m2a4w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        && y.is_integer()\n        && z.is_integer()\n\
    \        && f64::from(x) + f64::from(y) == f64::from(z) as f64\n}\n\nfn main()\
    \ {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n\
    \    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp8hg8dxqs.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp8hg8dxqs.rs:11:14\n\
    \   |\n11 |         && y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp8hg8dxqs.rs:12:14\n   |\n12 |    \
    \     && z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    use std::cmp::Ordering;\n\n    x < y && x < z && y < z && x.cmp(&y)\
    \ == Ordering::Less && x.cmp(&z) == Ordering::Less\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `f64` is not an iterator\n  --> /tmp/tmp74wniwns.rs:12:34\n\
    \   |\n12 |     x < y && x < z && y < z && x.cmp(&y) == Ordering::Less && x.cmp(&z)\
    \ == Ordering::Less\n   |                                  ^^^ `f64` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \nerror[E0599]: `f64` is not an iterator\n  --> /tmp/tmp74wniwns.rs:12:65\n  \
    \ |\n12 |     x < y && x < z && y < z && x.cmp(&y) == Ordering::Less && x.cmp(&z)\
    \ == Ordering::Less\n   |                                                    \
    \             ^^^ `f64` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `f64: Iterator`\n           which is\
    \ required by `&mut f64: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer() || y.is_integer() || z.is_integer()\n        || (x.is_integer()\
    \ && y.is_integer() && z.is_integer())\n}\n\nfn main() {\n    let candidate =\
    \ any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp41_mgf9c.rs:10:7\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer()\n   |       ^^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `is_integer` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp41_mgf9c.rs:10:25\n   |\n10 |     x.is_integer()\
    \ || y.is_integer() || z.is_integer()\n   |                         ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp41_mgf9c.rs:10:43\n   |\n\
    10 |     x.is_integer() || y.is_integer() || z.is_integer()\n   |            \
    \                               ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp41_mgf9c.rs:11:15\n   |\n11 |         || (x.is_integer() && y.is_integer()\
    \ && z.is_integer())\n   |               ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `is_integer` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp41_mgf9c.rs:11:33\n   |\n11 |         || (x.is_integer()\
    \ && y.is_integer() && z.is_integer())\n   |                                 ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp41_mgf9c.rs:11:51\n   |\n\
    11 |         || (x.is_integer() && y.is_integer() && z.is_integer())\n   |   \
    \                                                ^^^^^^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 6 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x.is_negative()\n        || y.is_negative()\n        || z.is_negative()\n\
    }\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp0lzs5ans.rs:10:7\n   |\n10 |     x.is_integer()\n\
    \   |       ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp0lzs5ans.rs:11:14\n\
    \   |\n11 |         || y.is_integer()\n   |              ^^^^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_integer` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp0lzs5ans.rs:12:14\n   |\n12 |    \
    \     || z.is_integer()\n   |              ^^^^^^^^^^ method not found in `f64`\n\
    \nwarning: use of deprecated associated function `core::f64::<impl f64>::is_negative`:\
    \ renamed to is_sign_negative\n  --> /tmp/tmp0lzs5ans.rs:13:14\n   |\n13 |   \
    \      || x.is_negative()\n   |              ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::f64::<impl\
    \ f64>::is_negative`: renamed to is_sign_negative\n  --> /tmp/tmp0lzs5ans.rs:14:14\n\
    \   |\n14 |         || y.is_negative()\n   |              ^^^^^^^^^^^\n\nwarning:\
    \ use of deprecated associated function `core::f64::<impl f64>::is_negative`:\
    \ renamed to is_sign_negative\n  --> /tmp/tmp0lzs5ans.rs:15:14\n   |\n15 |   \
    \      || z.is_negative()\n   |              ^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors; 3 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x + y).is_integer()\n        && (x + z).is_integer()\n        &&\
    \ (y + z).is_integer()\n}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
    \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
    \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
    \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
    \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpum80g64x.rs:10:13\n   |\n10 |     (x + y).is_integer()\n\
    \   |             ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpum80g64x.rs:11:20\n\
    \   |\n11 |         && (x + z).is_integer()\n   |                    ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpum80g64x.rs:12:20\n   |\n\
    12 |         && (y + z).is_integer()\n   |                    ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes 3 numbers.\n/// Returns true if one of\
    \ the numbers is equal to the sum of the other two, and all numbers are integers.\n\
    /// Returns false in any other cases.\n/// Examples\n/// any_int(5, 2, 7) \u279E\
    \ True\n/// any_int(3, 2, 2) \u279E False\n/// any_int(3, -2, 1) \u279E True\n\
    /// any_int(3.6, -2.2, 2) \u279E False\nfn any_int(x: f64, y: f64, z: f64) ->\
    \ bool {\n    (x < y && y < z) && (x < z && z < y)\n}\n\nfn main() {\n    let\
    \ candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5,\
    \ 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0,\
    \ 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2,\
    \ 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0,\
    \ 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0,\
    \ 4.0, 7.0), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphyqxxuy8.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
