name: HumanEval_91_is_bored
language: rust
results:
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c.is_ascii_lowercase()).count() == \"i\"\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp094n109j.rs:10:61\n   |\n\
    10 |     S.chars().filter(|c| c.is_ascii_lowercase()).count() == \"i\"\n   | \
    \                                                            ^^^ expected `usize`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp094n109j.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_lowercase()).count() == \"i\"\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored: isize = 0;\n    let mut idx = 0;\n    while idx < S.len() {\n       \
    \ let c: char;\n        match S[idx].as_ref() {\n            '.' => c = '.',\n\
    \            '?' => c = '?',\n            '!' => c = '!',\n            _ => continue,\n\
    \        };\n        idx += 1;\n        if c == 'I' {\n            bored += 1;\n\
    \        }\n    }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2lwm8pww.rs:14:15\n\
    \   |\n14 |         match S[idx].as_ref() {\n   |               ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = 0;\n    for s in S.split_whitespace() {\n        i += s.starts_with(\"I\"\
    .to_owned());\n    }\n    i\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmp9b42q8jc.rs:12:28\n     |\n12   |         i += s.starts_with(\"\
    I\".to_owned());\n     |                ----------- ^^^^^^^^^^^^^^ expected an\
    \ implementor of trait `Pattern<'_>`\n     |                |\n     |        \
    \        required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n12   |         i += s.starts_with(&\"I\".to_owned());\n     |\
    \                            +\n\nerror[E0277]: cannot add-assign `bool` to `{integer}`\n\
    \  --> /tmp/tmp9b42q8jc.rs:12:11\n   |\n12 |         i += s.starts_with(\"I\"\
    .to_owned());\n   |           ^^ no implementation for `{integer} += bool`\n \
    \  |\n   = help: the trait `AddAssign<bool>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = vec![];\n    for word in S.split() {\n        match word {\n     \
    \       \"I\" => boredom.push(1),\n            \".\" | \"?\" | \"!\" => {\n  \
    \              boredom.push(0);\n                break;\n            }\n     \
    \       _ => {}\n        }\n    }\n    boredom.iter().sum()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpz1_hxw2s.rs:11:19\n     |\n11   |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmptu3vqf1d.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmptu3vqf1d.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmptu3vqf1d.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptu3vqf1d.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    for ch in S.chars() {\n        cnt += if ch == '.' || ch == '?'\
    \ || ch == '!' { 1 } else { 0 };\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp1z6z9psx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ is_bored = vec![];\n    let mut char_count = S;\n    while char_count.len()\
    \ > 0 {\n        let mut is_bored_char = char_count[0];\n        for i in 1..char_count.len()\
    \ {\n            if char_count[i] != '.' && char_count[i] != '?' && char_count[i]\
    \ != '!' && char_count[i] == is_bored_char {\n                is_bored += 1;\n\
    \            }\n        }\n        is_bored.push(is_bored_char);\n        char_count\
    \ = char_count.trim_start().trim_end();\n    }\n    is_bored.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpnlrb_3th.rs:13:33\n   |\n13 |         let mut is_bored_char = char_count[0];\n\
    \   |                                 ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnlrb_3th.rs:15:16\n   |\n15 |             if char_count[i] != '.'\
    \ && char_count[i] != '?' && char_count[i] != '!' && char_count[i] == is_bored_char\
    \ {\n   |                ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnlrb_3th.rs:15:40\n   |\n15 |             if char_count[i] != '.'\
    \ && char_count[i] != '?' && char_count[i] != '!' && char_count[i] == is_bored_char\
    \ {\n   |                                        ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if S.chars().count(|c|\
    \ *c != '?' *c != '!') >= 2 {\n        0\n    } else {\n        1\n    }\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpvru70d2x.rs:10:31\n\
    \   |\n10 |     if S.chars().count(|c| *c != '?' *c != '!') >= 2 {\n   |     \
    \                          ^^        ^^\n\nerror[E0282]: type annotations needed\n\
    \  --> /tmp/tmpvru70d2x.rs:10:25\n   |\n10 |     if S.chars().count(|c| *c !=\
    \ '?' *c != '!') >= 2 {\n   |                         ^ consider giving this closure\
    \ parameter a type\n   |\n   = note: type must be known at this point\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvru70d2x.rs:10:44\n   |\n10 |     if S.chars().count(|c|\
    \ *c != '?' *c != '!') >= 2 {\n   |                                          \
    \  ^^^ expected `bool`, found `char`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpvru70d2x.rs:10:18\n    |\n10  |\
    \     if S.chars().count(|c| *c != '?' *c != '!') >= 2 {\n    |              \
    \    ^^^^^ ----------------------- supplied 1 argument\n    |                \
    \  |\n    |                  expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0282, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    match\
    \ S\n        .split_whitespace()\n        .filter(|&s| s.starts_with(\"I\"))\n\
    \        .count() {\n        0 => 0,\n        _ => 1,\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpodgwog5i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0 as usize;\n    let mut s: String = S.clone();\n    let mut is_bored\
    \ = true;\n    while !s.is_empty() {\n        if s.is_prefix(\"I\") {\n      \
    \      is_bored = false;\n            break;\n        }\n        let pos = s.find(\"\
    .\");\n        if pos == usize::max_value() || pos == 0 {\n            break;\n\
    \        }\n        count += 1;\n        s = &s[pos..];\n    }\n    if is_bored\
    \ {\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prefix` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpz4a1u82o.rs:14:14\n   |\n14 |         if s.is_prefix(\"\
    I\") {\n   |              ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `strip_prefix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4a1u82o.rs:19:19\n\
    \   |\n19 |         if pos == usize::max_value() || pos == 0 {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n  \
    \ = note: expected enum `Option<usize>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n19 |         if pos == Some(usize::max_value())\
    \ || pos == 0 {\n   |                   +++++                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz4a1u82o.rs:19:48\n   |\n19 |         if pos\
    \ == usize::max_value() || pos == 0 {\n   |                                  \
    \              ^ expected enum `Option`, found integer\n   |\n   = note: expected\
    \ enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n19 |         if pos == usize::max_value() ||\
    \ pos == Some(0) {\n   |                                                +++++\
    \ +\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpz4a1u82o.rs:23:14\n   |\n23 |         s = &s[pos..];\n   |    \
    \          ^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4a1u82o.rs:23:13\n\
    \   |\n11 |     let mut s: String = S.clone();\n   |                ------ expected\
    \ due"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    boredoms(S).iter().filter(|word|\
    \ word.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `boredoms` in this scope\n  --> /tmp/tmpmlw7_7mz.rs:10:5\n\
    \   |\n10 |     boredoms(S).iter().filter(|word| word.starts_with(\"I\")).count()\n\
    \   |     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = 1;\n    let mut i = 0;\n    while i != S.len() {\n        i += 1;\n\
    \        if S[i] == '.' {\n            if S[i + 1] == '.' {\n                if\
    \ S[i + 2] == '.' {\n                    i += 3;\n                } else {\n \
    \                   i += 2;\n                }\n            } else {\n       \
    \         i += 1;\n            }\n        } else {\n            boredom = boredom\
    \ + 1;\n        }\n    }\n    return boredom;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3k8_2pvc.rs:14:12\n\
    \   |\n14 |         if S[i] == '.' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3k8_2pvc.rs:15:16\n   |\n15 |             if S[i + 1] == '.' {\n\
    \   |                ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3k8_2pvc.rs:16:20\n\
    \   |\n16 |                 if S[i + 2] == '.' {\n   |                    ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    for word in S.split(\" \").filter(|w| w.len() > 0 && w.starts_with(\"\
    I\")) {\n        if word.ends_with('.') || word.ends_with('?') || word.ends_with('!'){\n\
    \            counter = counter + 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpbk_mvg3z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    match\
    \ S\n        .chars()\n        .filter(|c| c == '.' || c == '?' || c == '!')\n\
    \        .filter(|c| !c.is_ascii_lowercase())\n        .cloned()\n        .take_while(|c|\
    \ !c.is_ascii_lowercase())\n        .count() {\n        1 => 0,\n        _ =>\
    \ 1,\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6g3l2nkv.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == '.' || c == '?' || c == '!')\n   |      \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp6g3l2nkv.rs:12:35\n   |\n12 |         .filter(|c|\
    \ c == '.' || c == '?' || c == '!')\n   |                                   ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp6g3l2nkv.rs:12:47\n\
    \   |\n12 |         .filter(|c| c == '.' || c == '?' || c == '!')\n   |      \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0271]: type\
    \ mismatch resolving `<Filter<Filter<Chars<'_>, [closure@/tmp/tmp6g3l2nkv.rs:12:17:\
    \ 12:53]>, [closure@/tmp/tmp6g3l2nkv.rs:13:17: 13:44]> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmp6g3l2nkv.rs:14:10\n     |\n14   |         .cloned()\n     | \
    \         ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `take_while` exists for struct\
    \ `Cloned<Filter<Filter<Chars<'_>, [closure@/tmp/tmp6g3l2nkv.rs:12:17: 12:53]>,\
    \ [closure@/tmp/tmp6g3l2nkv.rs:13:17: 13:44]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp6g3l2nkv.rs:15:10\n   |\n15 |            .take_while(|c|\
    \ !c.is_ascii_lowercase())\n   |             ^^^^^^^^^^ method cannot be called\
    \ on `Cloned<Filter<Filter<Chars<'_>, [closure@/tmp/tmp6g3l2nkv.rs:12:17: 12:53]>,\
    \ [closure@/tmp/tmp6g3l2nkv.rs:13:17: 13:44]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the f"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom_cnt = 0;\n    for word in S.chars().map(|c| c as char) {\n        match\
    \ word {\n            'I' => {\n                if boredom_cnt > 0 {\n       \
    \             boredom_cnt = 0;\n                }\n            },\n          \
    \  '.' | '?' | '!' => {\n                boredom_cnt += 1;\n            },\n \
    \           _ => {}\n        }\n    }\n    boredom_cnt\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmptiexokkd.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i: usize = 0;\n\n    for (i, c) in S.chars().enumerate() {\n        match c\
    \ {\n            '.' | '?' | '!' => continue,\n            _ => break\n      \
    \  }\n    }\n\n    i + 1\n}\n\nfn main() {\n    let candidate = is_bored;\n  \
    \  assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxwybw9cx.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     i + 1\n   |     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     (i + 1).try_into().unwrap()\n\
    \   |     +     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_impl(S).is_ok()\n\
    \        && is_bored_impl(S).unwrap().len() == 1\n    {\n        0\n    } else\
    \ {\n        1\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_impl` in this scope\n  -->\
    \ /tmp/tmpz_vouhne.rs:10:8\n   |\n10 |     if is_bored_impl(S).is_ok()\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_bored_impl` in this scope\n  --> /tmp/tmpz_vouhne.rs:11:12\n   |\n11 | \
    \        && is_bored_impl(S).unwrap().len() == 1\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom_counter = 0;\n    for s in S.split_whitespace() {\n        if s == \"\
    I\" {\n            boredom_counter += 1;\n        }\n    }\n    boredom_counter\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpekvwakec.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // BEGIN\
    \ PUBDEV\n    let mut bored = 0;\n    let mut sentences = S.split_whitespace().collect::<Vec<_>>();\n\
    \    for i in 0..sentences.len() {\n        if let Ok(s) = sentences[i] {\n  \
    \          if s == \"I\".to_string() {\n                bored += 1;\n        \
    \    }\n        }\n    }\n    return bored;\n    // END PUBDEV\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpltkb3f0l.rs:14:16\n   |\n\
    14 |         if let Ok(s) = sentences[i] {\n   |                ^^^^^   ------------\
    \ this expression has type `&str`\n   |                |\n   |               \
    \ expected `str`, found enum `Result`\n   |\n   = note: expected type `str`\n\
    \              found enum `Result<_, _>`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmpltkb3f0l.rs:14:16\n\
    \    |\n14  |         if let Ok(s) = sentences[i] {\n    |                ^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Ok`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.rfind(\"\
    I\", String::npos, -1).unwrap()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpduypql2t.rs:10:26\n   |\n10 | \
    \    S.rfind(\"I\", String::npos, -1).unwrap()\n   |                         \
    \ ^^^^ function or associated item not found in `String`\n\nerror[E0061]: this\
    \ function takes 1 argument but 3 arguments were supplied\n    --> /tmp/tmpduypql2t.rs:10:7\n\
    \     |\n10   |     S.rfind(\"I\", String::npos, -1).unwrap()\n     |       ^^^^^\
    \ ---  ------------  -- supplied 3 arguments\n     |       |\n     |       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpduypql2t.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.rfind(\"I\", String::npos, -1).unwrap()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n10 |     S.rfind(\"I\", String::npos, -1).unwrap().try_into().unwrap()\n\
    \   |                                            ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = 1;\n    let mut i = 0;\n    let mut word = \"\";\n    let mut sentence\
    \ = S.to_string();\n\n    while let Some(letter) = sentence[i..].chars().next()\
    \ {\n        if letter == '.' || letter == '?' || letter == '!' {\n          \
    \  if word == letter {\n                boredoms += 1;\n            }\n      \
    \      i += 1;\n            word = \"\";\n        }\n        else {\n        \
    \    word += &sentence[i..];\n        }\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp0gi6p4l9.rs:17:21\n\
    \   |\n17 |             if word == letter {\n   |                     ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp0gi6p4l9.rs:24:13\n\
    \   |\n24 |             word += &sentence[i..];\n   |             ----^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0368.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // YOUR\
    \ CODE HERE\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1o95c6zk.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_internal(S.as_bytes())\
    \ != 0\n    {\n        0\n    }\n    else if is_bored_internal(S.as_bytes()).is_err()\n\
    \    {\n        1\n    }\n    else if is_bored_internal(S.as_bytes()).is_ok()\n\
    \    {\n        2\n    }\n    else\n    {\n        3\n    }\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_internal` in this scope\n\
    \  --> /tmp/tmp09btrnbj.rs:10:8\n   |\n10 |     if is_bored_internal(S.as_bytes())\
    \ != 0\n   |        ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_bored_internal` in this scope\n  --> /tmp/tmp09btrnbj.rs:14:13\n\
    \   |\n14 |     else if is_bored_internal(S.as_bytes()).is_err()\n   |       \
    \      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_bored_internal` in this scope\n  --> /tmp/tmp09btrnbj.rs:18:13\n\
    \   |\n18 |     else if is_bored_internal(S.as_bytes()).is_ok()\n   |        \
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ num_bored = 0;\n    let words = S.split_whitespace();\n    for word in words\
    \ {\n        if !word.starts_with(\"I\") {\n            num_bored += 1;\n    \
    \    }\n    }\n    num_bored\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `0`', /tmp/tmphc0iudlr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    for s in S.split(|&c| c.is_ascii_letter() || c == ' ') {\n \
    \       if s.starts_with(\"I\") {\n            bored += 1;\n        }\n    }\n\
    \    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmpqoxiiznu.rs:11:23\n\
    \   |\n11 |     for s in S.split(|&c| c.is_ascii_letter() || c == ' ') {\n   |\
    \                       ^^ consider giving this closure parameter the explicit\
    \ type `&_`, with the type parameters specified\n   |\n   = note: type must be\
    \ known at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ words = S.split_whitespace();\n\n    let mut boredoms = 0;\n    let mut i =\
    \ 0;\n    for word in words {\n        i += 1; // to track position within a word\n\
    \        if word == \"I\" {\n            boredoms += 1;\n        }\n    }\n\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpy8bdx2wc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored_count = 0;\n    let mut sentence_delimiters = vec![\".\", \"?\", \"!\"\
    ];\n\n    for (i, token) in S.split_whitespace().iter().enumerate() {\n      \
    \  if token == \"I\" {\n            bored_count += 1;\n        }\n        for\
    \ delimiter in &sentence_delimiters {\n            if token.starts_with(delimiter)\
    \ {\n                bored_count += 1;\n            }\n        }\n    }\n    bored_count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp5dw70oiy.rs:13:44\n   |\n13 |     for (i,\
    \ token) in S.split_whitespace().iter().enumerate() {\n   |                  \
    \                          ^^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = false;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            bored = true;\n            break;\n        }\n    }\n    bored\
    \ ? 1 : 0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmpr7r85z5x.rs:17:13\n   |\n17 |     bored ? 1 : 0\n   |         \
    \    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ words = S.split_whitespace();\n    let mut i = 0;\n    let mut count = 0;\n\
    \    while i < words.len() {\n        if words[i].is_ascii_lowercase() && i <\
    \ words.len() {\n            let mut is_bored = false;\n            if words[i]\
    \ == \"i\" {\n                is_bored = true;\n            } else if words[i]\
    \ == \"?\" || words[i] == \"!\" {\n                count += 1;\n             \
    \   i += 1;\n            } else {\n                i += 1;\n            }\n  \
    \          i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpgwjm7d80.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpgwjm7d80.rs:14:12\n   |\n14 |         if words[i].is_ascii_lowercase()\
    \ && i < words.len() {\n   |            ^^^^^^^^\n\nerror[E0599]: no method named\
    \ `len` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpgwjm7d80.rs:14:55\n\
    \   |\n14 |         if words[i].is_ascii_lowercase() && i < words.len() {\n  \
    \ |                                                       ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpgwjm7d80.rs:16:16\n   |\n16 |         \
    \    if words[i] == \"i\" {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpgwjm7d80.rs:18:23\n\
    \   |\n18 |             } else if words[i] == \"?\" || words[i] == \"!\" {\n \
    \  |                       ^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpgwjm7d80.rs:18:42\n   |\n18 | \
    \            } else if words[i] == \"?\" || words[i] == \"!\" {\n   |        \
    \                                  ^^^^^^^^\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.split(\"\
    .\").filter(|w| w == \"I\").count() + 1\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp17mbrjas.rs:10:31\n\
    \   |\n10 |     S.split(\".\").filter(|w| w == \"I\").count() + 1\n   |      \
    \                         ^^ no implementation for `&str == str`\n   |\n   = help:\
    \ the trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp17mbrjas.rs:10:5\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n10\
    \ |     S.split(\".\").filter(|w| w == \"I\").count() + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.split(\"\
    .\").filter(|w| w == \"I\").count() + 1).try_into().unwrap()\n   |     +     \
    \                                        +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut delimiters = vec![\".\", \"?\", \"!\"];\n    for word\
    \ in S.split_whitespace() {\n        for delimiter in delimiters {\n         \
    \   if word.starts_with(delimiter) {\n                bored += 1;\n          \
    \      break;\n            }\n        }\n    }\n    bored\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpusbl0ejb.rs:11:9\n\
    \   |\n11 |     let mut delimiters = vec![\".\", \"?\", \"!\"];\n   |        \
    \ ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: use of moved\
    \ value: `delimiters`\n   --> /tmp/tmpusbl0ejb.rs:13:26\n    |\n11  |     let\
    \ mut delimiters = vec![\".\", \"?\", \"!\"];\n    |         -------------- move\
    \ occurs because `delimiters` has type `Vec<&str>`, which does not implement the\
    \ `Copy` trait\n12  |     for word in S.split_whitespace() {\n13  |         for\
    \ delimiter in delimiters {\n    |                          ^^^^^^^^^^ `delimiters`\
    \ moved due to this implicit call to `.into_iter()`, in previous iteration of\
    \ loop\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `delimiters`\nhelp: consider iterating over a slice of the `Vec<&str>`'s\
    \ content to avoid moving into the `for` loop\n    |\n13  |         for delimiter\
    \ in &delimiters {\n    |                          +\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: Vec<&str> = vec![];\n    for word in S.split_whitespace() {\n    \
    \    if let Some(i) = str_contains_any(&word, \"i\".to_string()) {\n         \
    \   boredoms.push(word.to_string());\n        }\n    }\n\n    // We only want\
    \ to return the count of boredoms, and not a count of sentences.\n    boredoms.iter().filter(|&x|\
    \ x.contains(\".\")).filter(|&x| x.contains(\"?\")).filter(|&x| x.contains(\"\
    !\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `str_contains_any` in this scope\n \
    \ --> /tmp/tmpw9hyicrk.rs:12:26\n   |\n12 |         if let Some(i) = str_contains_any(&word,\
    \ \"i\".to_string()) {\n   |                          ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9hyicrk.rs:13:27\n\
    \   |\n13 |             boredoms.push(word.to_string());\n   |               \
    \            ^^^^^^^^^^^^^^^^\n   |                           |\n   |        \
    \                   expected `&str`, found struct `String`\n   |             \
    \              help: consider borrowing here: `&word.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw9hyicrk.rs:18:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n...\n18 |     boredoms.iter().filter(|&x| x.contains(\".\")).filter(|&x|\
    \ x.contains(\"?\")).filter(|&x| x.contains(\"!\")).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms.iter().filter(|&x|\
    \ x.contains(\".\")).filter(|&x| x.contains(\"?\")).filter(|&x| x.contains(\"\
    !\")).count().try_into().unwrap()\n   |                                      \
    \                                                                            \
    \ ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    loop {\n\
    \        let mut is_bored = false;\n        for c in S.chars() {\n           \
    \ if c == 'I' {\n                is_bored = true;\n                break;\n  \
    \          }\n        }\n        if is_bored {\n            return 1;\n      \
    \  }\n        S.remove_prefix(1);\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `remove_prefix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpyr5lfvm7.rs:21:11\n   |\n21 |         S.remove_prefix(1);\n\
    \   |           ^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let boredom\
    \ = vec![\"I\"];\n    boredom.iter().cloned().map(|s| s.to_lowercase()).filter(|s|\
    \ s.contains(\".\"))\n        .filter(|s| s.contains(\"?\"))\n        .filter(|s|\
    \ s.contains(\"!\"))\n        .count(|s| S == s)\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpc_wjul3h.rs:14:10\n    |\n14  |         .count(|s| S == s)\n \
    \   |          ^^^^^ ---------- supplied 1 argument\n    |          |\n    | \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc_wjul3h.rs:11:5\n   |\n9  | \
    \  fn is_bored(S: String) -> isize {\n   |                             ----- expected\
    \ `isize` because of return type\n10 |       let boredom = vec![\"I\"];\n11 |\
    \ /     boredom.iter().cloned().map(|s| s.to_lowercase()).filter(|s| s.contains(\"\
    .\"))\n12 | |         .filter(|s| s.contains(\"?\"))\n13 | |         .filter(|s|\
    \ s.contains(\"!\"))\n14 | |         .count(|s| S == s)\n   | |__________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |         .count(|s|\
    \ S == s).try_into().unwrap()\n   |                           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_impl(S)\
    \ == 1 { 1 } else { 0 }\n}\n\nfn main() {\n    let candidate = is_bored;\n   \
    \ assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_impl` in this scope\n  -->\
    \ /tmp/tmpt6hewsno.rs:10:8\n   |\n10 |     if is_bored_impl(S) == 1 { 1 } else\
    \ { 0 }\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    let mut bored = false;\n\n    for word in S.split_whitespace()\
    \ {\n        count += 1;\n\n        if word != \"I\" {\n            bored = true;\n\
    \        }\n    }\n\n    bored ? count : 0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `count`\n\
    \  --> /tmp/tmpos7uzskz.rs:21:13\n   |\n21 |     bored ? count : 0\n   |     \
    \        ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ s = S;\n    while !s.is_empty() {\n        let next = if let Some(next) = s.split_first_of('.')\
    \ {\n            next\n        } else {\n            return 0;\n        };\n \
    \       if let Some(next) = s.split_first_of('?') {\n            next\n      \
    \  } else {\n            return 0;\n        };\n        if let Some(next) = s.split_first_of('!')\
    \ {\n            next\n        } else {\n            return 0;\n        };\n \
    \       if next != \"I\" {\n            return 0;\n        };\n        s = &s[..];\n\
    \    }\n    1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `split_first_of` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmptv4e2h_b.rs:12:42\n   |\n12 |         let\
    \ next = if let Some(next) = s.split_first_of('.') {\n   |                   \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split_at`\n\nerror[E0599]: no method named `split_first_of`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmptv4e2h_b.rs:17:31\n\
    \   |\n17 |         if let Some(next) = s.split_first_of('?') {\n   |        \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split_at`\n\nerror[E0599]: no method named `split_first_of`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmptv4e2h_b.rs:22:31\n\
    \   |\n22 |         if let Some(next) = s.split_first_of('!') {\n   |        \
    \                       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split_at`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptv4e2h_b.rs:30:13\n\
    \   |\n10 |     let mut s = S;\n   |                 - expected due to this value\n\
    ...\n30 |         s = &s[..];\n   |             ^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n30 |        \
    \ s = (&s[..]).to_string();\n   |             +      +++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ n = S.len();\n    let mut bored_cnt = 0;\n    let mut i = 0;\n    for c in S\
    \ {\n        if c == 'i' || c == 'I' {\n            i += 1;\n        }\n     \
    \   if c == '.' || c == '?' || c == '!' {\n            if i == 0 {\n         \
    \       return bored_cnt;\n            }\n            i += 1;\n        }\n   \
    \     n -= 1;\n    }\n    return bored_cnt;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpl8j2sia7.rs:13:14\n\
    \   |\n13 |     for c in S {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored(S.chars().collect::<String>())\
    \ {\n        S.len()\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp932osrse.rs:10:8\n   |\n\
    10 |     if is_bored(S.chars().collect::<String>()) {\n   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp932osrse.rs:11:9\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     if is_bored(S.chars().collect::<String>())\
    \ {\n11 |         S.len()\n   |         ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |         S.len().try_into().unwrap()\n   |    \
    \            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0usize;\n    let mut bored_word: Vec<String> = vec![];\n    let mut\
    \ pos = 0;\n    for c in S.chars() {\n        if let Some(c) = (&c.to_ascii_lowercase()\
    \ + &c.to_ascii_uppercase()).chars().next() {\n            if c == 'I' {\n   \
    \             bored += 1;\n                if pos == 0 {\n                   \
    \ bored_word.clear();\n                } else {\n                    bored_word.push(S.substring(pos,\
    \ c));\n                }\n                pos = c + 1;\n            }\n     \
    \   } else {\n            pos += 1;\n        }\n    }\n    if pos == S.len() {\n\
    \        bored += 1;\n        bored_word.push(S.substr(pos));\n    }\n    if bored_word.is_empty()\
    \ {\n        bored += 1;\n    }\n    bored\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&char` to `&char`\n  --> /tmp/tmpqb44w4yy.rs:14:51\n\
    \   |\n14 |         if let Some(c) = (&c.to_ascii_lowercase() + &c.to_ascii_uppercase()).chars().next()\
    \ {\n   |                           ----------------------- ^ -----------------------\
    \ &char\n   |                           |\n   |                           &char\n\
    \nerror[E0599]: no method named `substring` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpqb44w4yy.rs:20:39\n   |\n20 |                     bored_word.push(S.substring(pos,\
    \ c));\n   |                                       ^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `substr` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpqb44w4yy.rs:30:27\n   |\n30 |         bored_word.push(S.substr(pos));\n\
    \   |                           ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqb44w4yy.rs:35:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n...\n35 |     bored\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |     bored.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S\n  \
    \      .chars()\n        .filter_map(|c| {\n            if c.to_ascii_lowercase()\
    \ == 'i' {\n                Some(true)\n            } else {\n               \
    \ Some(false)\n            }\n        })\n        .count()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp47zmt6o2.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S\n11 | |         .chars()\n\
    12 | |         .filter_map(|c| {\n13 | |             if c.to_ascii_lowercase()\
    \ == 'i' {\n...  |\n18 | |         })\n19 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom: usize = 0;\n    let mut i = S.len();\n    while i >0 {\n        let\
    \ char = S.chars();\n        if char.next().unwrap().unwrap() == '.' {\n     \
    \       boredom += 1;\n        }\n        i -= 1;\n    }\n    boredom\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp53s_9r51.rs:14:33\n   |\n14 |         if char.next().unwrap().unwrap()\
    \ == '.' {\n   |                                 ^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp53s_9r51.rs:19:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredom\n   |     ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     boredom.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = 0;\n    let mut s = S.to_string();\n    let mut i = s.len();\n\n\
    \    while i > 0 {\n        if s[i] == ' ' || s[i] == '.' || s[i] == '?' || s[i]\
    \ == '!' {\n            boredoms += 1;\n        }\n        i -= 1;\n    }\n  \
    \  boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpirlmpjot.rs:15:12\n\
    \   |\n15 |         if s[i] == ' ' || s[i] == '.' || s[i] == '?' || s[i] == '!'\
    \ {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpirlmpjot.rs:15:27\n   |\n15 |         if s[i] == ' ' || s[i] ==\
    \ '.' || s[i] == '?' || s[i] == '!' {\n   |                           ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpirlmpjot.rs:15:42\n   |\n15 |         if s[i] == ' ' || s[i] ==\
    \ '.' || s[i] == '?' || s[i] == '!' {\n   |                                  \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as I"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: Vec<String> = vec![];\n\n    for (i, word) in S.chars().enumerate()\
    \ {\n        match word.to_string() {\n            \"I\" => boredoms.push(S.clone()),\n\
    \            \".\" | \"?\" | \"!\" => (),\n            _ => {}\n        }\n  \
    \  }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n  \
    \  assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbdede5jg.rs:14:13\n   |\n\
    13 |         match word.to_string() {\n   |               ---------------- this\
    \ expression has type `String`\n14 |             \"I\" => boredoms.push(S.clone()),\n\
    \   |             ^^^ expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbdede5jg.rs:15:13\n   |\n13 |         match\
    \ word.to_string() {\n   |               ---------------- this expression has\
    \ type `String`\n14 |             \"I\" => boredoms.push(S.clone()),\n15 |   \
    \          \".\" | \"?\" | \"!\" => (),\n   |             ^^^ expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdede5jg.rs:15:19\n\
    \   |\n13 |         match word.to_string() {\n   |               ----------------\
    \ this expression has type `String`\n14 |             \"I\" => boredoms.push(S.clone()),\n\
    15 |             \".\" | \"?\" | \"!\" => (),\n   |                   ^^^ expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdede5jg.rs:15:25\n\
    \   |\n13 |         match word.to_string() {\n   |               ----------------\
    \ this expression has type `String`\n14 |             \"I\" => boredoms.push(S.clone()),\n\
    15 |             \".\" | \"?\" | \"!\" => (),\n   |                         ^^^\
    \ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpbdede5jg.rs:19:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n19 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    let mut words = S.split('.');\n    for w in words {\n      \
    \  if w == \"I\" {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpbpb63qiv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().enumerate().find(|&(ref\
    \ i, _)| i > 0 && S[0..i].starts_with(\"I\"))\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiyoc2whz.rs:10:50\n   |\n\
    10 |     S.chars().enumerate().find(|&(ref i, _)| i > 0 && S[0..i].starts_with(\"\
    I\"))\n   |                                                  ^\n   |         \
    \                                         |\n   |                            \
    \                      expected `&usize`, found integer\n   |                \
    \                                  help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiyoc2whz.rs:10:60\n   |\n10 |     S.chars().enumerate().find(|&(ref\
    \ i, _)| i > 0 && S[0..i].starts_with(\"I\"))\n   |                          \
    \                                  ^ expected integer, found `&usize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n10 |     S.chars().enumerate().find(|&(ref\
    \ i, _)| i > 0 && S[0..*i].starts_with(\"I\"))\n   |                         \
    \                                   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiyoc2whz.rs:10:5\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n10\
    \ |     S.chars().enumerate().find(|&(ref i, _)| i > 0 && S[0..i].starts_with(\"\
    I\"))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<(usize, char)>`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    let mut words = S.split_whitespace();\n    while !words.next().is_none()\
    \ {\n        let mut word: String = words.next().unwrap();\n        if word.starts_with(\"\
    I\") {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaqseakuf.rs:13:32\n   |\n\
    13 |         let mut word: String = words.next().unwrap();\n   |             \
    \          ------   ^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                       |        |\n   |                \
    \       |        expected struct `String`, found `&str`\n   |                \
    \       expected due to this\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.len()\
    \ / 2 + S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 3\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp82xarwys.rs:10:42\n\
    \   |\n10 |     S.len() / 2 + S.chars().filter(|c| c == '.' || c == '?' || c ==\
    \ '!').count() + 3\n   |                                          ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp82xarwys.rs:10:54\n\
    \   |\n10 |     S.len() / 2 + S.chars().filter(|c| c == '.' || c == '?' || c ==\
    \ '!').count() + 3\n   |                                                     \
    \ ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp82xarwys.rs:10:66\n\
    \   |\n10 |     S.len() / 2 + S.chars().filter(|c| c == '.' || c == '?' || c ==\
    \ '!').count() + 3\n   |                                                     \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82xarwys.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.len() / 2 + S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.len()\
    \ / 2 + S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 3).try_into().unwrap()\n\
    \   |     +                                                                  \
    \              +++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    for s in S.chars().filter_map(|c|\n        match c {\n       \
    \     '.' => Some(true),\n            '?' => Some(true),\n            '!' => Some(true),\n\
    \            _ => None,\n        }\n    ).filter(|&&x| x.is_some()).rev() {\n\
    \        if s == Some('I') {\n            cnt += 1;\n        } else {\n      \
    \      break;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqe6c1bq8.rs:18:16\n   |\n\
    18 |     ).filter(|&&x| x.is_some()).rev() {\n   |                ^-\n   |   \
    \             ||\n   |                |expected due to this\n   |            \
    \    expected `bool`, found reference\n   |                help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `bool`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqe6c1bq8.rs:19:17\n\
    \   |\n19 |         if s == Some('I') {\n   |                 ^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // TODO:\
    \ Your code here\n    let mut bored_str = \"\";\n    for s in S.split_whitespace()\
    \ {\n        if s.is_bored() {\n            bored_str += &*s;\n        }\n   \
    \ }\n    bored_str.count(\"I\".to_string())\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_bored` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpqy43239v.rs:13:14\n   |\n13 |         if s.is_bored()\
    \ {\n   |              ^^^^^^^^ method not found in `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpqy43239v.rs:14:13\n\
    \   |\n14 |             bored_str += &*s;\n   |             ---------^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0599]:\
    \ `&str` is not an iterator\n  --> /tmp/tmpqy43239v.rs:17:15\n   |\n17 |     bored_str.count(\"\
    I\".to_string())\n   |               ^^^^^ `&str` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `&str: Iterator`\n           which is required by `&mut\
    \ &str: Iterator`\n           `str: Iterator`\n           which is required by\
    \ `&mut str: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0368, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    let mut words = S.split_whitespace();\n\n    for w in words\
    \ {\n        if w.as_str() == \"I\".as_str() {\n            counter += 1;\n  \
    \      }\n    }\n\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmplklbyrbs.rs:14:14\n   |\n14 |         if w.as_str()\
    \ == \"I\".as_str() {\n   |             -^^^^^^-- help: remove this method call\n\
    \nerror[E0599]: no method named `as_str` found for reference `&'static str` in\
    \ the current scope\n  --> /tmp/tmplklbyrbs.rs:14:30\n   |\n14 |         if w.as_str()\
    \ == \"I\".as_str() {\n   |                             -^^^^^^-- help: remove\
    \ this method call\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // Your\
    \ code here...\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1x3l4ted.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = S.len();\n    let mut boredoms: Vec<&str> = vec![];\n    for w in S.split_whitespace()\
    \ {\n        if w.starts_with(\"I\") {\n            count -= 1;\n        } else\
    \ {\n            boredoms.push(w);\n        }\n    }\n    if boredoms.is_empty()\
    \ {\n        0\n    } else {\n        boredoms.iter().count(|&w| w == \".\" ||\
    \ w == \"?\" || w == \"!\")\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpzb8oa5xp.rs:22:25\n    |\n22  |         boredoms.iter().count(|&w|\
    \ w == \".\" || w == \"?\" || w == \"!\")\n    |                         ^^^^^\
    \ ------------------------------------- supplied 1 argument\n    |           \
    \              |\n    |                         expected 0 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzb8oa5xp.rs:22:9\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n...\n\
    22 |         boredoms.iter().count(|&w| w == \".\" || w == \"?\" || w == \"!\"\
    )\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |         boredoms.iter().count(|&w|\
    \ w == \".\" || w == \"?\" || w == \"!\").try_into().unwrap()\n   |          \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ I = 0;\n    let mut B = 0;\n    let mut dot = 0;\n    let mut question = 0;\n\
    \    let mut exclamation = 0;\n    for x in S.chars() {\n        if x == 'I' {\n\
    \            I += 1;\n        } else if x == '.' {\n            dot += 1;\n  \
    \      } else if x == '?' {\n            question += 1;\n        } else if x ==\
    \ '!' {\n            exclamation += 1;\n        }\n    }\n    (I * 2 + dot * 2\
    \ + question * 2 + exclamation * 2) + (I - dot)\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `0`', /tmp/tmp90zupau_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 1; // count boredoms found\n    let mut has_I = false;\n\n    for c\
    \ in S.chars() {\n        match c {\n            '.' | '?' | '!' | ' ' => {\n\
    \                count = 1;\n            }\n            _ => if c == 'I' {\n \
    \               has_I = true;\n            }\n        }\n    }\n\n    if !has_I\
    \ {\n        return 0;\n    }\n    count += 1;\n    return count;\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `0`', /tmp/tmpj62nsmct.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut lower = S.chars().nth(1).unwrap();\n    let mut upper\
    \ = S.chars().nth(S.len() - 1).unwrap();\n    let mut i = 1;\n\n    // Iterate\
    \ from right to left over the string\n    while i < S.len() {\n        // If this\
    \ character is a question mark\n        if S[i] == '?' {\n            // Skip\
    \ all characters to the end\n            i += S.len() - i;\n            // If\
    \ this character is a question mark\n            if S[i] == '?' {\n          \
    \      // Check if previous character was a period\n                if S[i-1]\
    \ == '.' {\n                    // If previous character was a period, set upper\
    \ = previous character\n                    if i > 0 {\n                     \
    \   upper = S[i-1];\n                    }\n                } else {\n       \
    \             // If the previous character was anything but a period, increment\
    \ bored\n                    bored++;\n                }\n                // If\
    \ this is a question mark, the current character is now the previous character\n\
    \                i += 1;\n            } else {\n                // If the current\
    \ character is a period, increment bored and set lower to the current character\n\
    \                bored++;\n                lower = S[i];\n                // Skip\
    \ all characters to the end\n                i += S.len() - i;\n            }\n\
    \        } else {\n            // If the current character is a period, increment\
    \ bored and set lower to the current character\n            bored++;\n       \
    \     lower = S[i];\n            // Skip all characters to the end\n         \
    \   i += S.len() - i;\n        }\n    }\n    bored + 1 + is_bored(lower) + is_bored(upper)\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpkr64uf8j.rs:31:26\n\
    \   |\n31 |                     bored++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |       \
    \              { let tmp = bored; bored += 1; tmp };\n   |                   \
    \  +++++++++++      ~~~~~~~~~~~~~~~~~~~\n31 -                     bored++;\n31\
    \ +                     bored += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpkr64uf8j.rs:37:22\n   |\n37 |                 bored++;\n\
    \   |                      ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n37 |                 { let tmp = bored; bored += 1; tmp };\n\
    \   |                 +++++++++++      ~~~~~~~~~~~~~~~~~~~\n37 -             \
    \    bored++;\n37 +                 bored += 1;\n   | \n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmpkr64uf8j.rs:44:18\n   |\n44 |            \
    \ bored++;\n   |                  ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n44 |             { let tmp = bored; bored += 1; tmp\
    \ };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n44 -            \
    \ bored++;\n44 +             bored += 1;\n   | \n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpkr64uf8j.rs:18:12\n   |\n18 |  \
    \       if S[i] == '?' {\n   |            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkr64uf8j.rs:22:16\n   |\n22 |             if S[i] == '?' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = he"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.split_whitespace().filter(|x|\
    \ x.chars().any(|y| y == '.'))\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf6vy4zhu.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.split_whitespace().filter(|x|\
    \ x.chars().any(|y| y == '.'))\n11 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.rfind('.')\n\
    \        .or_else(|| S.rfind('?'))\n        .or_else(|| S.rfind('!'))\n      \
    \  .unwrap_or(0)\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvh_xj7xb.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S.rfind('.')\n11 | |   \
    \      .or_else(|| S.rfind('?'))\n12 | |         .or_else(|| S.rfind('!'))\n13\
    \ | |         .unwrap_or(0)\n   | |_____________________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |         .unwrap_or(0).try_into().unwrap()\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    for ch in S.chars() {\n        match ch {\n            '.' |\
    \ '?' | '!' => continue,\n            'I' => {\n                if count == 0\
    \ {\n                    count = 1;\n                } else {\n              \
    \      count = 1;\n                }\n                continue;\n            }\n\
    \            _ => count += 1,\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `0`', /tmp/tmpfr9vy7gh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    for s in S.split('.') {\n        count += 1;\n        for w\
    \ in s.split('?') {\n            count += 1;\n            for w in s.split('!')\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmp_jc6tj5i.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter_map(|c|\
    \ {\n        if c.is_ascii_lowercase() {\n            if c.is_ascii_uppercase()\
    \ || c.is_ascii_alphanumeric() {\n                Some(c.to_string())\n      \
    \      } else {\n                None\n            }\n        } else {\n     \
    \       None\n        }\n    }).filter(|s| s.is_ascii_alphanumeric()).count()\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_alphanumeric` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpo97ryfll.rs:20:21\n   |\n20 |\
    \     }).filter(|s| s.is_ascii_alphanumeric()).count() == 0\n   |            \
    \         ^^^^^^^^^^^^^^^^^^^^^ method not found in `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo97ryfll.rs:10:5\n   |\n9  |   fn is_bored(S:\
    \ String) -> isize {\n   |                             ----- expected `isize`\
    \ because of return type\n10 | /     S.chars().filter_map(|c| {\n11 | |      \
    \   if c.is_ascii_lowercase() {\n12 | |             if c.is_ascii_uppercase()\
    \ || c.is_ascii_alphanumeric() {\n13 | |                 Some(c.to_string())\n\
    ...  |\n19 | |         }\n20 | |     }).filter(|s| s.is_ascii_alphanumeric()).count()\
    \ == 0\n   | |_________________________________________________________^ expected\
    \ `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored_words = vec![];\n    let mut bored_sentences = vec![];\n    for s in S.split()\
    \ {\n        if let Ok(s) = s.split_whitespace() {\n            if s.starts_with(\"\
    I\") {\n                bored_sentences.push(s);\n            } else {\n     \
    \           bored_words.push(s);\n            }\n        }\n    }\n    bored_words.iter().filter(|word|\
    \ {\n        bored_sentences.iter().any(|sentence| {\n            sentence.starts_with(word)\n\
    \        })\n    }).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpvo2lm_ko.rs:12:16\n     |\n12   |     for s in S.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvo2lm_ko.rs:13:16\n\
    \   |\n13 |         if let Ok(s) = s.split_whitespace() {\n   |              \
    \  ^^^^^   -------------------- this expression has type `SplitWhitespace<'_>`\n\
    \   |                |\n   |                expected struct `SplitWhitespace`,\
    \ found enum `Result`\n   |\n   = note: expected struct `SplitWhitespace<'_>`\n\
    \                found enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvo2lm_ko.rs:21:5\n   |\n9  |   fn is_bored(S: String) -> isize\
    \ {\n   |                             ----- expected `isize` because of return\
    \ type\n...\n21 | /     bored_words.iter().filter(|word| {\n22 | |         bored_sentences.iter().any(|sentence|\
    \ {\n23 | |             sentence.starts_with(word)\n24 | |         })\n25 | |\
    \     }).count()\n   | |______________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n25 |     }).count().try_into().unwrap()\n   |           \
    \    ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    for word in S.split() {\n        if word.len() > 0 {\n   \
    \         if word.to_ascii_lowercase()[0] == 'i' {\n                counter +=\
    \ 1;\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp9kkn_401.rs:11:19\n     |\n11   |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmp9kkn_401.rs:13:16\n   |\n13 |             if word.to_ascii_lowercase()[0]\
    \ == 'i' {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0277.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = false;\n    let mut bored = 0;\n    for (i, c) in S.chars().enumerate()\
    \ {\n        bored += is_bored_word(c, i);\n        if i == 0 {\n            boredom\
    \ = c != 'I';\n        }\n    }\n    bored\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_word` in this scope\n  -->\
    \ /tmp/tmpo5ne70gz.rs:13:18\n   |\n13 |         bored += is_bored_word(c, i);\n\
    \   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = 0;\n    for s in S.split() {\n        if s.len() == 1 && s.starts_with(\"\
    I\") {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpegzn7vdm.rs:11:16\n     |\n11   |     for s in S.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counts: Vec<usize> = vec![];\n    let mut words = vec![];\n    for (i, s) in\
    \ S.chars().enumerate() {\n        if s == ' ' {\n            if !words.is_empty()\
    \ {\n                counts.push(i);\n            }\n            words = vec![];\n\
    \        } else if s == '.' || s == '?' || s == '!' {\n            if !words.is_empty()\
    \ {\n                words.push(i);\n            }\n        } else {\n       \
    \     words.push(i);\n        }\n    }\n\n    if !words.is_empty() {\n       \
    \ counts.push(i);\n    }\n    counts.iter().filter(|&x| x == 1).count()\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpkxda8qq0.rs:28:21\n\
    \   |\n28 |         counts.push(i);\n   |                     ^ help: a local\
    \ variable with a similar name exists: `S`\n\nerror[E0277]: can't compare `&usize`\
    \ with `{integer}`\n  --> /tmp/tmpkxda8qq0.rs:30:33\n   |\n30 |     counts.iter().filter(|&x|\
    \ x == 1).count()\n   |                                 ^^ no implementation for\
    \ `&usize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&usize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkxda8qq0.rs:30:5\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n...\n\
    30 |     counts.iter().filter(|&x| x == 1).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n30 |     counts.iter().filter(|&x|\
    \ x == 1).count().try_into().unwrap()\n   |                                  \
    \            ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    boredoms(S).next()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `boredoms` in this scope\n  --> /tmp/tmp2jbimfoe.rs:10:5\n\
    \   |\n10 |     boredoms(S).next()\n   |     ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    match\
    \ (S.chars().skip_while(|&c| !c.is_ascii()).take(5).collect::<Vec<_>>()) {\n \
    \       \"I\" => 0,\n        \"I!\" => 1,\n        \"I?\" => 1,\n        \"I..\"\
    \ => 1,\n        \"I...\" => 1,\n        _ => 0,\n    }\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `match` scrutinee expression\n\
    \  --> /tmp/tmpxul_e9g6.rs:10:11\n   |\n10 |     match (S.chars().skip_while(|&c|\
    \ !c.is_ascii()).take(5).collect::<Vec<_>>()) {\n   |           ^            \
    \                                                        ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n10 -     match (S.chars().skip_while(|&c|\
    \ !c.is_ascii()).take(5).collect::<Vec<_>>()) {\n10 +     match S.chars().skip_while(|&c|\
    \ !c.is_ascii()).take(5).collect::<Vec<_>>() {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxul_e9g6.rs:11:9\n   |\n10 |     match (S.chars().skip_while(|&c|\
    \ !c.is_ascii()).take(5).collect::<Vec<_>>()) {\n   |           ----------------------------------------------------------------------\
    \ this expression has type `Vec<char>`\n11 |         \"I\" => 0,\n   |       \
    \  ^^^ expected struct `Vec`, found `&str`\n   |\n   = note: expected struct `Vec<char>`\n\
    \           found reference `&'static str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxul_e9g6.rs:12:9\n   |\n10 |     match (S.chars().skip_while(|&c|\
    \ !c.is_ascii()).take(5).collect::<Vec<_>>()) {\n   |           ----------------------------------------------------------------------\
    \ this expression has type `Vec<char>`\n11 |         \"I\" => 0,\n12 |       \
    \  \"I!\" => 1,\n   |         ^^^^ expected struct `Vec`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<char>`\n           found reference `&'static\
    \ str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxul_e9g6.rs:13:9\n   |\n\
    10 |     match (S.chars().skip_while(|&c| !c.is_ascii()).take(5).collect::<Vec<_>>())\
    \ {\n   |           ----------------------------------------------------------------------\
    \ this expression has type `Vec<char>`\n...\n13 |         \"I?\" => 1,\n   | \
    \        ^^^^ expected struct `Vec`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<char>`\n           found reference `&'static str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxul_e9g6.rs:14:9\n   |\n10 |     match (S.chars().skip_while(|&c|\
    \ !c.is_ascii()).take(5).collect::<"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars()\n\
    \        .filter(|&c| c != '.' && c != '?' && c != '!')\n        .count(|c| c\
    \ == 'I')\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpz16n9a7z.rs:12:10\n    |\n12  |         .count(|c| c == 'I')\n\
    \    |          ^^^^^ ------------ supplied 1 argument\n    |          |\n   \
    \ |          expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz16n9a7z.rs:10:5\n   |\n9  | \
    \  fn is_bored(S: String) -> isize {\n   |                             ----- expected\
    \ `isize` because of return type\n10 | /     S.chars()\n11 | |         .filter(|&c|\
    \ c != '.' && c != '?' && c != '!')\n12 | |         .count(|c| c == 'I')\n   |\
    \ |____________________________^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n12 |         .count(|c| c == 'I').try_into().unwrap()\n   |     \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ idx = 0;\n    let mut in_boredom = false;\n    while idx < S.len() {\n     \
    \   let c = S[idx as usize];\n        if c == '.' || c == '?' || c == '!' {\n\
    \            idx += 1;\n            in_boredom = true;\n        } else if c ==\
    \ 'I' {\n            idx += 1;\n            in_boredom = true;\n        } else\
    \ {\n            idx += 1;\n        }\n        if in_boredom {\n            break;\n\
    \        }\n    }\n    idx as isize\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1rvm43fd.rs:13:17\n\
    \   |\n13 |         let c = S[idx as usize];\n   |                 ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.rfind(\"\
    .\")\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8pz5gegc.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.rfind(\".\")\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    debug_assert!(S.len()\
    \ > 0);\n    debug_assert!(S.len() <= MAX_STR_LEN);\n    let mut cnt = 0;\n  \
    \  for ch in S.chars() {\n        if ch.is_ascii() {\n            if ch == ' '\
    \ || ch == '.' || ch == '?' || ch == '!' {\n                cnt += 1;\n      \
    \      }\n        } else {\n            cnt += 2;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_STR_LEN` in this scope\n  --> /tmp/tmpf2nd_jr7.rs:11:30\n\
    \   |\n11 |     debug_assert!(S.len() <= MAX_STR_LEN);\n   |                 \
    \             ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    let mut words = split_sentence(&S);\n    loop {\n        counter\
    \ += 1;\n        if words[0] == \"I\" {\n            break;\n        }\n     \
    \   words = words.next();\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `split_sentence` in this scope\n  -->\
    \ /tmp/tmp7pvuvurn.rs:11:21\n   |\n11 |     let mut words = split_sentence(&S);\n\
    \   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ num_bored = 0;\n    let mut s = S;\n    while !s.is_empty() {\n        match\
    \ s.chars().next() {\n            Some('.') => (),\n            Some('?') => (),\n\
    \            Some('!') => (),\n            Some(_) => (),\n            None =>\
    \ (),\n        }\n        match s.chars().next() {\n            Some('I') => (),\n\
    \            Some(_) => (),\n            None => (),\n        }\n        match\
    \ s.chars().next() {\n            Some(_) => (),\n            None => (),\n  \
    \      }\n        match s.chars().next() {\n            Some(_) => (),\n     \
    \       None => (),\n        }\n        match s.chars().next() {\n           \
    \ Some(_) => (),\n            Some(_) => (),\n            None => (),\n      \
    \  }\n        match s.chars().next() {\n            Some(_) => (),\n         \
    \   Some(_) => (),\n            None => (),\n        }\n        match s.chars().next()\
    \ {\n            Some(_) => (),\n            Some(_) => (),\n            None\
    \ => (),\n        }\n        match s.chars().next() {\n            Some(_) =>\
    \ (),\n            Some(_) => (),\n            None => (),\n        }\n      \
    \  match s.chars().next() {\n            Some(_) => (),\n            Some(_) =>\
    \ (),\n            None => (),\n        }\n        match s.chars().next() {\n\
    \            Some(_) => (),\n            Some(_) => (),\n            None => (),\n\
    \        }\n        match s.chars().next() {\n            Some(_) => (),\n   \
    \         Some(_) => (),\n            None => (),\n        }\n        match s.chars().next()\
    \ {\n            Some(_) => (),\n            Some(_) => (),\n            None\
    \ => (),\n        }\n        match s.chars().next() {\n            Some(_) =>\
    \ (),\n            Some(_) => (),\n            None => (),\n        }\n      \
    \  match s.chars().next() {\n            Some(_) => (),\n            Some(_) =>\
    \ (),\n            None => (),\n        }\n        match s.chars().next() {\n\
    \            Some(_) => (),\n            Some(_) => (),\n            None => (),\n\
    \        }\n        match s.chars().next() {\n            Some(_) => (),\n   \
    \         Some(_) => (),\n            None => (),\n        }\n        match s.chars().next()\
    \ {\n            Some(_) => (),\n            Some(_) => (),\n            None\
    \ => (),\n        }\n        match s.chars().next() {\n            Some(_) =>\
    \ (),\n            Some(_) => (),\n            None => (),\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp7iheb8sm.rs:112:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n...\n12  |     while !s.is_empty() {\n    | \
    \                        - unclosed delimiter\n...\n98  |         match s.chars().next()\
    \ {\n    |                                - this delimiter might not be properly\
    \ closed...\n...\n102 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n112 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmp7iheb8sm.rs:12:5\n    |\n9   |   fn is_bored(S: String) -> isize {\n\
    \    |                             ----- expected `isize` because of return type\n\
    ...\n12  | /     while !s.is_empty() {\n13  | |         match s.chars().next()\
    \ {\n14  | |             Some('.') => (),\n15  | |             Some('?') => (),\n\
    ...   |\n111 | |     assert_eq!(candidate(String::from(\"You and I are going for\
    \ a walk\")), 0);\n112 | | }\n    | |__^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = true;\n    let mut counter = 0;\n    let mut current_word = S;\n\n\
    \    while boredom && current_word.len() > 0 {\n        if current_word.starts_with(\"\
    I\") {\n            boredom = false;\n        }\n        current_word = current_word.next();\n\
    \        counter += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpwr1rsdsz.rs:18:37\n   |\n18 |         current_word = current_word.next();\n\
    \   |                                     ^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c == 'I' || c == '.' || c == '?' || c == '!')\n        .filter(|c| !is_bored(&c.to_string()))\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjurody65.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == 'I' || c == '.' || c == '?' || c ==\
    \ '!')\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpjurody65.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == 'I' || c == '.' || c == '?' || c == '!')\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpjurody65.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == 'I' || c == '.' || c == '?' || c == '!')\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpjurody65.rs:10:64\n   |\n10\
    \ |     S.chars().filter(|c| c == 'I' || c == '.' || c == '?' || c == '!')\n \
    \  |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjurody65.rs:11:31\n   |\n11 |  \
    \       .filter(|c| !is_bored(&c.to_string()))\n   |                         \
    \      ^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n   |\nhelp: consider\
    \ removing the borrow\n   |\n11 -         .filter(|c| !is_bored(&c.to_string()))\n\
    11 +         .filter(|c| !is_bored(c.to_string()))\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjurody65.rs:11:21\n   |\n11 |         .filter(|c| !is_bored(&c.to_string()))\n\
    \   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.lines().map(|s|\
    \ s.chars().count(|c| c == '.' || c == '?' || c == '!')).sum()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp5kewktmq.rs:10:33\n    |\n10  |     S.lines().map(|s| s.chars().count(|c|\
    \ c == '.' || c == '?' || c == '!')).sum()\n    |                            \
    \     ^^^^^ ------------------------------------ supplied 1 argument\n    |  \
    \                               |\n    |                                 expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]:\
    \ the trait bound `isize: Sum<usize>` is not satisfied\n    --> /tmp/tmp5kewktmq.rs:10:78\n\
    \     |\n10   |     S.lines().map(|s| s.chars().count(|c| c == '.' || c == '?'\
    \ || c == '!')).sum()\n     |                                                \
    \                              ^^^ the trait `Sum<usize>` is not implemented for\
    \ `isize`\n     |\n     = help: the following other types implement trait `Sum<A>`:\n\
    \               <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n         \
    \      <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128\
    \ as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a\
    \ i16>>\n               <i16 as Sum>\n             and 20 others\nnote: required\
    \ by a bound in `std::iter::Iterator::sum`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // Your\
    \ code here\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1uee_08z.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // TODO(burnik):\
    \ Can we make this faster?\n    // Iterate through all words.\n    for word in\
    \ S.split_whitespace() {\n        assert!(word == \"I\" || word == \"!\" || word\
    \ == \"?\" || word == \".\");\n    }\n    // Count the number of words with an\
    \ \"I\" in them.\n    S.split_whitespace().iter().filter_map(|w| {\n        if\
    \ w == \"I\" {\n            Some(w)\n        } else {\n            None\n    \
    \    }\n    }).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpm3v1c8cp.rs:16:26\n   |\n16 |     S.split_whitespace().iter().filter_map(|w|\
    \ {\n   |                          ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.trim().replace(\"\
    ?\", \"\").replace(\"!\", \"\").chars().filter(|&x| x == 'I').count() == 3\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp22oxw9id.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.trim().replace(\"?\", \"\").replace(\"\
    !\", \"\").chars().filter(|&x| x == 'I').count() == 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    let mut words = S\n        .lines()\n        .filter_map(|s|\
    \ s.chars().filter_map(|c| match c {\n            '.' => true,\n            '?'\
    \ => true,\n            '!' => true,\n            _ => false,\n        }))\n \
    \       .collect();\n    let mut first_word = false;\n    let mut first_sentence\
    \ = false;\n    for word in words {\n        if first_word {\n            if first_sentence\
    \ {\n                if word == \"I\" {\n                    counter += 1;\n \
    \               }\n            } else {\n                if word == \"I\" {\n\
    \                    counter += 1;\n                }\n            }\n       \
    \ } else {\n            if word == \"I\" {\n                first_word = true;\n\
    \                first_sentence = false;\n            } else {\n             \
    \   if word == \".\" || word == \"?\" || word == \"!\" {\n                   \
    \ first_word = true;\n                    first_sentence = true;\n           \
    \     }\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5tt3bj23.rs:14:20\n   |\n\
    14 |             '.' => true,\n   |                    ^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n14 |       \
    \      '.' => Some(true),\n   |                    +++++    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5tt3bj23.rs:13:25\n   |\n13 |           .filter_map(|s|\
    \ s.chars().filter_map(|c| match c {\n   |  _________________________^\n14 | |\
    \             '.' => true,\n15 | |             '?' => true,\n16 | |          \
    \   '!' => true,\n17 | |             _ => false,\n18 | |         }))\n   | |__________^\
    \ expected enum `Option`, found struct `FilterMap`\n   |\n   = note: expected\
    \ enum `Option<_>`\n            found struct `FilterMap<Chars<'_>, [closure@/tmp/tmp5tt3bj23.rs:13:46:\
    \ 18:10]>`\nhelp: try wrapping the expression in `Some`\n   |\n13 ~         .filter_map(|s|\
    \ Some(s.chars().filter_map(|c| match c {\n14 |             '.' => true,\n15 |\
    \             '?' => true,\n16 |             '!' => true,\n17 |             _\
    \ => false,\n18 ~         })))\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len() {\n        let\
    \ s = S[i];\n        i += 1;\n        if s == '.' || s == '!' || s == '?' {\n\
    \            boredoms += 1;\n        }\n        if i == S.len() {\n          \
    \  return boredoms;\n        }\n    }\n    0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptx7_5lhh.rs:13:17\n\
    \   |\n13 |         let s = S[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_helper(S).is_some()\
    \ {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_helper` in this scope\n  -->\
    \ /tmp/tmp76wysnzs.rs:10:8\n   |\n10 |     if is_bored_helper(S).is_some() {\n\
    \   |        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0usize;\n    for (i, word) in S.char_indices().filter_map(|it| {\n\
    \        if let Some(c) = it.next() {\n            if c == '.' || c == '?' ||\
    \ c == '!' {\n                counter = counter + 1;\n            }\n        }\n\
    \        it.next()\n    }) {\n        if word.starts_with(\"I'\") {\n        \
    \    counter = counter + 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmp42lfh83s.rs:12:29\n   |\n12 |         if let\
    \ Some(c) = it.next() {\n   |                             ^^^^ method not found\
    \ in `(usize, char)`\n\nerror[E0599]: no method named `next` found for tuple `(usize,\
    \ char)` in the current scope\n  --> /tmp/tmp42lfh83s.rs:17:12\n   |\n17 |   \
    \      it.next()\n   |            ^^^^ method not found in `(usize, char)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp42lfh83s.rs:23:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n23 |     counter\n   |     ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |     counter.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars()\n\
    \        .filter(|c| c == '.' || c == '?' || c == '!')\n        .count(|c| c ==\
    \ 'I')\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcb0f_4_b.rs:11:23\n\
    \   |\n11 |         .filter(|c| c == '.' || c == '?' || c == '!')\n   |      \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpcb0f_4_b.rs:11:35\n   |\n11 |         .filter(|c|\
    \ c == '.' || c == '?' || c == '!')\n   |                                   ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcb0f_4_b.rs:11:47\n\
    \   |\n11 |         .filter(|c| c == '.' || c == '?' || c == '!')\n   |      \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcb0f_4_b.rs:12:10\n\
    \    |\n12  |         .count(|c| c == 'I')\n    |          ^^^^^ ------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcb0f_4_b.rs:10:5\n   |\n9  |   fn is_bored(S: String) -> isize\
    \ {\n   |                             ----- expected `isize` because of return\
    \ type\n10 | /     S.chars()\n11 | |         .filter(|c| c == '.' || c == '?'\
    \ || c == '!')\n12 | |         .count(|c| c == 'I')\n   | |____________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |         .count(|c|\
    \ c == 'I').try_into().unwrap()\n   |                             ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    let mut boredoms: Vec<&str> = vec![];\n    for (i, &word) in\
    \ S.split_whitespace().enumerate() {\n        let mut pos = i;\n        while\
    \ pos < S.len() && S[pos] == ' ' {\n            pos += 1;\n        }\n       \
    \ if pos != i {\n            boredoms.push(&S[i..pos]);\n        }\n    }\n  \
    \  for boredom in boredoms {\n        if boredom.starts_with(\"I\") {\n      \
    \      count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp780a4eh8.rs:12:14\n   |\n12 |     for (i, &word) in S.split_whitespace().enumerate()\
    \ {\n   |              ^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp780a4eh8.rs:14:32\n   |\n14 |         while pos <\
    \ S.len() && S[pos] == ' ' {\n   |                                ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut i = 0;\n    for word in S.chars().filter(|c| !c.is_ascii_letter()).take(100)\
    \ {\n        if i == 0 {\n            if word == 'I' {\n                i += 1;\n\
    \            }\n        } else {\n            if word == ('.' || '?' || '!') {\n\
    \                i += 1;\n            }\n        }\n    }\n    bored\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpk77rnihj.rs:12:41\n   |\n12 |     for word\
    \ in S.chars().filter(|c| !c.is_ascii_letter()).take(100) {\n   |            \
    \                             ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk77rnihj.rs:18:25\n\
    \   |\n18 |             if word == ('.' || '?' || '!') {\n   |               \
    \          ^^^ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk77rnihj.rs:18:32\n   |\n18 |             if word == ('.' || '?'\
    \ || '!') {\n   |                                ^^^ expected `bool`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk77rnihj.rs:18:39\n   |\n18 |\
    \             if word == ('.' || '?' || '!') {\n   |                         \
    \              ^^^ expected `bool`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk77rnihj.rs:18:24\n   |\n18 |             if word == ('.' || '?'\
    \ || '!') {\n   |                        ^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `bool`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0 as isize;\n    let mut word = S;\n    loop {\n        if word.starts_with(\"\
    I\") {\n            count += 1;\n            word = word.trim_start_matches(\"\
    .!?\");\n        } else {\n            break;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpru8hvn90.rs:15:20\n   |\n\
    11 |     let mut word = S;\n   |                    - expected due to this value\n\
    ...\n15 |             word = word.trim_start_matches(\".!?\");\n   |         \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = S.len();\n    for ch in S {\n        if ch == '!' || ch == '.' || ch ==\
    \ '?' {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpynr_hlgc.rs:11:15\n\
    \   |\n11 |     for ch in S {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpynr_hlgc.rs:16:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n16 |     cnt\n   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |     cnt.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom_count = 0;\n    for (i, word) in S.split_whitespace().into_iter().enumerate()\
    \ {\n        let word = word.to_string();\n        boredom_count += word.starts_with(\"\
    I\");\n    }\n    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmpe4aujynp.rs:13:23\n\
    \   |\n13 |         boredom_count += word.starts_with(\"I\");\n   |          \
    \             ^^ no implementation for `{integer} += bool`\n   |\n   = help: the\
    \ trait `AddAssign<bool>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // split\
    \ input into sentences, ignoring periods, question marks and exclamation marks\n\
    \    let mut sentences = S.split(\"[.?!]\").collect::<Vec<&str>>();\n    let mut\
    \ boredoms = 0;\n    for sentence in sentences {\n        // skip all but the\
    \ first word, because that indicates boredom\n        if let Some(word) = sentence.split_whitespace().next()\
    \ {\n            if word == \"I\" {\n                boredoms += 1;\n        \
    \    }\n        }\n    }\n    return boredoms;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpm5o0jqa1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt: isize = 0;\n    let mut start = String::new();\n    let mut end = String::new();\n\
    \    let mut last: &mut String = null;\n    for s in S.chars() {\n        match\
    \ s {\n            ' ' => (),\n            '.' => start = \"\",\n            '?'\
    \ => start = \"\",\n            '!' => start = \"\",\n            c => {\n   \
    \             if start.is_empty() {\n                    start = &c.to_string();\n\
    \                    last = &c;\n                } else {\n                  \
    \  if start.starts_with(last.as_str()) {\n                        last.clear();\n\
    \                    } else {\n                        cnt += 1;\n           \
    \         }\n                    start = &c.to_string();\n                   \
    \ last = &c;\n                }\n            }\n        }\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `null` in this scope\n  --> /tmp/tmpymbv17h9.rs:13:33\n\
    \   |\n13 |     let mut last: &mut String = null;\n   |                      \
    \           ^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::ptr::null;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpymbv17h9.rs:17:28\n   |\n11 |     let mut start = String::new();\n\
    \   |                     ------------- expected due to this value\n...\n17 |\
    \             '.' => start = \"\",\n   |                            ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpymbv17h9.rs:18:28\n   |\n11 |\
    \     let mut start = String::new();\n   |                     ------------- expected\
    \ due to this value\n...\n18 |             '?' => start = \"\",\n   |        \
    \                    ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpymbv17h9.rs:19:28\n\
    \   |\n11 |     let mut start = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n19 |             '!' => start = \"\",\n   |\
    \                            ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpymbv17h9.rs:22:29\n\
    \   |\n11 |     let mut start = String::new();\n   |                     -------------\
    \ expected due to this value\n...\n22 |                     start = &c.to_string();\n\
    \   |                             ^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&String`\n   |\nhelp: consider removing the borrow\n   |\n22 -            \
    \         start = &c.to_string();\n22 +                     start = c.to_string();\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpymbv17h9.rs:23:28\n  \
    \ |\n23 |       "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if !S.is_empty()\
    \ {\n        let mut is_bored = true;\n        let mut prev_char = S[0];\n   \
    \     for c in S.chars() {\n            if c == '?' || c == '!' || c == '.' {\n\
    \                is_bored = false;\n            }\n            if c == prev_char\
    \ {\n                is_bored = true;\n            }\n            prev_char +=\
    \ 1;\n        }\n        if is_bored {\n            return 1;\n        }\n   \
    \ }\n    return 0;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp36423wc3.rs:12:29\n   |\n12 |         let mut prev_char = S[0];\n  \
    \ |                             ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmp36423wc3.rs:20:13\n   |\n20 |             prev_char\
    \ += 1;\n   |             ---------^^^^^\n   |             |\n   |           \
    \  cannot use `+=` on type `char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.split(\"\
    .\").map(|w| if w == String::from(\"I\") { return 1 }).sum()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp804vdl9v.rs:10:26\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `_` because of return type\n10 |     S.split(\".\").map(|w| if w == String::from(\"\
    I\") { return 1 }).sum()\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `()`\n   |\nnote: return type inferred to be `{integer}`\
    \ here\n  --> /tmp/tmp804vdl9v.rs:10:61\n   |\n10 |     S.split(\".\").map(|w|\
    \ if w == String::from(\"I\") { return 1 }).sum()\n   |                      \
    \                                       ^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ I: isize = 0;\n    let mut found = false;\n    let mut prev_start = 0;\n   \
    \ for c in S.chars() {\n        if c == '.' {\n            if found {\n      \
    \          I = I + 1;\n                found = false;\n            } else {\n\
    \                found = true;\n            }\n        } else if c == '?' {\n\
    \            found = true;\n        } else if c == '!' {\n            if found\
    \ {\n                I = I + 1;\n            } else {\n                found =\
    \ true;\n            }\n        } else if c == 'I' {\n            if !found {\n\
    \                I = I + 1;\n            }\n        } else {\n            found\
    \ = true;\n        }\n    }\n\n    if found {\n        I = I + 1;\n    }\n\n \
    \   I\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpi0su0bba.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count_boredom: isize = 0;\n    for word in S.split_whitespace() {\n        if\
    \ word == \"I\" || word == \"I'\" || word == \"i\" {\n            count_boredom++;\n\
    \        }\n    }\n    return count_boredom;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp8mi8q2wl.rs:13:26\n\
    \   |\n13 |             count_boredom++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n13 |       \
    \      { let tmp = count_boredom; count_boredom += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n13 -             count_boredom++;\n\
    13 +             count_boredom += 1;\n   | \n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = Vec::new();\n    for c in S.chars() {\n        match c {\n       \
    \     'I' | '.' | '?' | '!' => boredom.push(true),\n            _ => boredom.push(false),\n\
    \        }\n    }\n    boredom.iter().filter(|&b| b).count() as isize\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3tdivi9.rs:17:32\n   |\n\
    17 |     boredom.iter().filter(|&b| b).count() as isize\n   |                \
    \                ^ expected `bool`, found `&bool`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n17 |     boredom.iter().filter(|&b| *b).count() as isize\n\
    \   |                                +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    count_boredoms(S,\
    \ \"\")\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_boredoms` in this scope\n  -->\
    \ /tmp/tmpro78hu2o.rs:10:5\n   |\n10 |     count_boredoms(S, \"\")\n   |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    boredom_count(&S).unwrap()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmp06j8eacg.rs:10:5\n   |\n10 |     boredom_count(&S).unwrap()\n   |  \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // write\
    \ code here\n    let mut boredCount = 0;\n    let mut sentence_end = S.clone();\n\
    \    let mut first_token = String::new();\n    loop {\n        if sentence_end\
    \ == \".\" || sentence_end == \"?\" || sentence_end == \"!\" {\n            break;\n\
    \        }\n        let first_char: Char = sentence_end.chars().next().unwrap();\n\
    \        if first_char == 'I' && first_token == \"I\" {\n            boredCount+=1;\n\
    \        }\n        sentence_end = &sentence_end[1..];\n        first_token =\
    \ first_char.to_string();\n    }\n    return boredCount;\n}\n\nfn main() {\n \
    \   let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpozy4tf3t.rs:18:25\n\
    \   |\n18 |         let first_char: Char = sentence_end.chars().next().unwrap();\n\
    \   |                         ^^^^ help: a builtin type with a similar name exists\
    \ (notice the capitalization): `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpozy4tf3t.rs:22:24\n   |\n12 |     let mut sentence_end = S.clone();\n\
    \   |                            --------- expected due to this value\n...\n22\
    \ |         sentence_end = &sentence_end[1..];\n   |                        ^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n22 |         sentence_end = (&sentence_end[1..]).to_string();\n   |   \
    \                     +                  +++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ num = 0;\n    let mut idx = 0;\n    let mut word: &str;\n    while idx < S.len()\
    \ {\n        word = &S[idx..].to_ascii_lowercase();\n        if !word.is_ascii_lowercase()\
    \ {\n            break;\n        }\n        if word == \"i\" {\n            num\
    \ +=1;\n        }\n        idx += 1;\n    }\n    num\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmptdl1tq3x.rs:15:18\n   |\n15 |   \
    \      if !word.is_ascii_lowercase() {\n   |                  ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    for (i, c) in S.chars().enumerate() {\n        if c.is_lowercase()\
    \ && i > 0\n            && &S[i] != &S[i-1]\n            && &S[i] != &S[i+1]\n\
    \            && &S[i] != &S[i+2]\n            && &S[i] != &S[i+3]\n          \
    \  && &S[i] != &S[i+4]\n            && &S[i] != &S[i+5]\n            && &S[i]\
    \ != &S[i+6]\n            && &S[i] != &S[i+7]\n            && &S[i] != &S[i+8]\n\
    \        {\n            bored += 1;\n        }\n    }\n    bored\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphring7pc.rs:13:17\n\
    \   |\n13 |             && &S[i] != &S[i-1]\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphring7pc.rs:13:26\n   |\n13 |             && &S[i] != &S[i-1]\n\
    \   |                          ^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphring7pc.rs:14:17\n   |\n14 |             && &S[i] != &S[i+1]\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: t"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ *c != 'I').count() + is_bored_str(&S)\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_str` in this scope\n  -->\
    \ /tmp/tmpn29yrx2l.rs:10:47\n   |\n10 |     S.chars().filter(|c| *c != 'I').count()\
    \ + is_bored_str(&S)\n   |                                               ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn29yrx2l.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ *c != 'I').count() + is_bored_str(&S)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ *c != 'I').count() + is_bored_str(&S)).try_into().unwrap()\n   |     +     \
    \                                                     +++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter_map(|c|\n\
    \        match (c) {\n            '.' => Some(_),\n            '?' => Some(_),\n\
    \            '!' => Some(_),\n            _ => None,\n        }\n    ).count()\
    \ == 3\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `match` scrutinee expression\n\
    \  --> /tmp/tmp68h1av33.rs:11:15\n   |\n11 |         match (c) {\n   |       \
    \        ^ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n11 -         match (c) {\n11 +         match c {\n\
    \   | \n\nerror: in expressions, `_` can only be used on the left-hand side of\
    \ an assignment\n  --> /tmp/tmp68h1av33.rs:12:25\n   |\n12 |             '.' =>\
    \ Some(_),\n   |                         ^ `_` not allowed here\n\nerror: in expressions,\
    \ `_` can only be used on the left-hand side of an assignment\n  --> /tmp/tmp68h1av33.rs:13:25\n\
    \   |\n13 |             '?' => Some(_),\n   |                         ^ `_` not\
    \ allowed here\n\nerror: in expressions, `_` can only be used on the left-hand\
    \ side of an assignment\n  --> /tmp/tmp68h1av33.rs:14:25\n   |\n14 |         \
    \    '!' => Some(_),\n   |                         ^ `_` not allowed here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp68h1av33.rs:10:5\n   |\n9  |   fn\
    \ is_bored(S: String) -> isize {\n   |                             ----- expected\
    \ `isize` because of return type\n10 | /     S.chars().filter_map(|c|\n11 | |\
    \         match (c) {\n12 | |             '.' => Some(_),\n13 | |            \
    \ '?' => Some(_),\n...  |\n16 | |         }\n17 | |     ).count() == 3\n   | |__________________^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let boredom\
    \ = vec![\"I\"];\n    let mut count = 0;\n    let mut word_index = 0;\n    while\
    \ word_index < S.len() {\n        // if we've reached the end of the string...\n\
    \        if word_index >= S.len()-1 {\n            return count;\n        }\n\
    \        // if this char is a boredom...\n        if let Ok(ch) = S[word_index]\
    \ {\n            if boredom.contains(&ch) {\n                count = count + 1;\n\
    \            }\n        }\n        // otherwise increment the current index...\n\
    \        word_index = word_index + 1;\n    }\n    // return 0 if we've reached\
    \ the end of the string...\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg2lwf76a.rs:19:25\n\
    \   |\n19 |         if let Ok(ch) = S[word_index] {\n   |                    \
    \     ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ I: isize = 0;\n    for word in S.split() {\n        if word == \"I\" {\n   \
    \         I+=1;\n        }\n    }\n    return I;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpg9ujm45x.rs:11:19\n     |\n11   |     for word in S.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S\n  \
    \      .split_whitespace()\n        .filter(|w| w.starts_with(\"I\"))\n      \
    \  .count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphdrf0vxx.rs:10:5\n   |\n\
    9  |   fn is_bored(S: String) -> isize {\n   |                             -----\
    \ expected `isize` because of return type\n10 | /     S\n11 | |         .split_whitespace()\n\
    12 | |         .filter(|w| w.starts_with(\"I\"))\n13 | |         .count()\n  \
    \ | |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // BEGIN\
    \ Practice \n    let mut boredoms = 0;\n    let mut boredom_counter = 0;\n   \
    \ let mut boredom_counter2 = 0;\n    let mut boredom_counter3 = 0;\n    let mut\
    \ boredom_counter4 = 0;\n    let mut boredom_counter5 = 0;\n    let mut boredom_counter6\
    \ = 0;\n    let mut boredom_counter7 = 0;\n    let mut boredom_counter8 = 0;\n\
    \    let mut boredom_counter9 = 0;\n    let mut boredom_counter10 = 0;\n    let\
    \ mut boredom_counter11 = 0;\n    let mut boredom_counter12 = 0;\n    let mut\
    \ boredom_counter13 = 0;\n    let mut boredom_counter14 = 0;\n    let mut boredom_counter15\
    \ = 0;\n    let mut boredom_counter16 = 0;\n    let mut boredom_counter17 = 0;\n\
    \    let mut boredom_counter18 = 0;\n    let mut boredom_counter19 = 0;\n    let\
    \ mut boredom_counter20 = 0;\n    let mut boredom_counter21 = 0;\n    let mut\
    \ boredom_counter22 = 0;\n    let mut boredom_counter23 = 0;\n    let mut boredom_counter24\
    \ = 0;\n    let mut boredom_counter25 = 0;\n    let mut boredom_counter26 = 0;\n\
    \    let mut boredom_counter27 = 0;\n    let mut boredom_counter28 = 0;\n    let\
    \ mut boredom_counter29 = 0;\n    let mut boredom_counter30 = 0;\n    let mut\
    \ boredom_counter31 = 0;\n    let mut boredom_counter32 = 0;\n    let mut boredom_counter33\
    \ = 0;\n    let mut boredom_counter34 = 0;\n    let mut boredom_counter35 = 0;\n\
    \    let mut boredom_counter36 = 0;\n    let mut boredom_counter37 = 0;\n    let\
    \ mut boredom_counter38 = 0;\n    let mut boredom_counter39 = 0;\n    let mut\
    \ boredom_counter40 = 0;\n    let mut boredom_counter41 = 0;\n    let mut boredom_counter42\
    \ = 0;\n    let mut boredom_counter43 = 0;\n    let mut boredom_counter44 = 0;\n\
    \    let mut boredom_counter45 = 0;\n    let mut boredom_counter46 = 0;\n    let\
    \ mut boredom_counter47 = 0;\n    let mut boredom_counter48 = 0;\n    let mut\
    \ boredom_counter49 = 0;\n    let mut boredom_counter50 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyko2w83c.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpyko2w83c.rs:9:27\n  |\n\
    9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // TODO:\
    \ Your code here\n    let mut count = 0;\n    for (i, word) in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph8gikgo9.rs:12:9\n   |\n\
    12 |     for (i, word) in S.split_whitespace() {\n   |         ^^^^^^^^^    --------------------\
    \ this expression has type `Option<&str>`\n   |         |\n   |         expected\
    \ `str`, found tuple\n   |\n   = note: expected type `str`\n             found\
    \ tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.lines()\n\
    \        .filter(|s| s == \"I\" || s == \"!\" || s == \"?\")\n        .count()\
    \ > 1\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp70xuziju.rs:11:23\n\
    \   |\n11 |         .filter(|s| s == \"I\" || s == \"!\" || s == \"?\")\n   |\
    \                       ^^ no implementation for `&str == str`\n   |\n   = help:\
    \ the trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmp70xuziju.rs:11:35\n   |\n11 |         .filter(|s|\
    \ s == \"I\" || s == \"!\" || s == \"?\")\n   |                              \
    \     ^^ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmp70xuziju.rs:11:47\n   |\n11 |         .filter(|s|\
    \ s == \"I\" || s == \"!\" || s == \"?\")\n   |                              \
    \                 ^^ no implementation for `&str == str`\n   |\n   = help: the\
    \ trait `PartialEq<str>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ *c == '.' || c == '?' || c == '!')\n        .count(|c| c == 'I')\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_49v_3km.rs:10:41\n\
    \   |\n10 |     S.chars().filter(|c| *c == '.' || c == '?' || c == '!')\n   |\
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_49v_3km.rs:10:53\n   |\n10 |   \
    \  S.chars().filter(|c| *c == '.' || c == '?' || c == '!')\n   |             \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp_49v_3km.rs:11:10\n\
    \    |\n11  |         .count(|c| c == 'I')\n    |          ^^^^^ ------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_49v_3km.rs:10:5\n   |\n9  |   fn is_bored(S: String) -> isize\
    \ {\n   |                             ----- expected `isize` because of return\
    \ type\n10 | /     S.chars().filter(|c| *c == '.' || c == '?' || c == '!')\n11\
    \ | |         .count(|c| c == 'I')\n   | |____________________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |         .count(|c|\
    \ c == 'I').try_into().unwrap()\n   |                             ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    for x in S.chars() {\n \
    \       if x == ' ' {\n            i += 1;\n        }\n        if x == '.' {\n\
    \            i += 1;\n        }\n        if x == '?' {\n            i += 1;\n\
    \        }\n        if x == '!' {\n            i += 1;\n        }\n        if\
    \ x == 'I' {\n            i += 1;\n        }\n        if x == '.' || x == '?'\
    \ || x == '!' || x == 'I'\n        {\n            i += 1;\n            j += 1;\n\
    \        }\n        if x == '.' {\n            i += 1;\n        }\n        if\
    \ x == '?' {\n            i += 1;\n        }\n        if x == '!' {\n        \
    \    i += 1;\n        }\n        if x == 'I'\n        {\n            i += 1;\n\
    \        }\n        if x == '.' || x == '?' || x == '!' || x == 'I'\n        {\n\
    \            i += 1;\n            j += 1;\n        }\n        if x == '.' {\n\
    \            i += 1;\n        }\n        if x == '?' {\n            i += 1;\n\
    \        }\n        if x == '!' {\n            i += 1;\n        }\n        if\
    \ x == 'I'\n        {\n            i += 1;\n        }\n        if x == '.' ||\
    \ x == '?' || x == '!' || x == 'I'\n        {\n            i += 1;\n         \
    \   j += 1;\n        }\n        if x == '.' {\n            i += 1;\n        }\n\
    \        if x == '?' {\n            i += 1;\n        }\n        if x == '!' {\n\
    \            i += 1;\n        }\n        if x == 'I'\n        {\n            i\
    \ += 1;\n        }\n        if x == '.' || x == '?' || x == '!' || x == 'I'\n\
    \        {\n            i += 1;\n            j += 1;\n        }\n        if x\
    \ == '.' {\n            i += 1;\n        }\n        if x == '?' {\n          \
    \  i += 1;\n        }\n        if x == '!' {\n            i += 1;\n        }\n\
    \        if x == 'I'\n        {\n            i += 1;\n        }\n        if x\
    \ == '.' || x == '?' || x == '!' || x == 'I'\n        {\n            i += 1;\n\
    \            j += 1;\n        }\n        if x == '.' {\n            i += 1;\n\
    \        }\n        if x == '?' {\n            i += 1;\n        }\n        if\
    \ x == '!' {\n            i += 1;\n        }\n        if x == 'I'\n        {\n\
    \            i += 1;\n        }\n        if x == '.' || x == '?' || x == '!' ||\
    \ x == 'I'\n        {\n            \n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpd4zmg1_d.rs:132:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n...\n13  |     for x in S.chars() {\n    |  \
    \                      - unclosed delimiter\n...\n120 |         {\n    |     \
    \    - this delimiter might not be properly closed...\n121 |             \n122\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n132\
    \ | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpd4zmg1_d.rs:13:5\n\
    \    |\n9   |   fn is_bored(S: String) -> isize {\n    |                     \
    \        ----- expected `isize` because of return type\n...\n13  | /     for x\
    \ in S.chars() {\n14  | |         if x == ' ' {\n15  | |             i += 1;\n\
    16  | |         }\n...   |\n131 | |     assert_eq!(candidate(String::from(\"You\
    \ and I are going for a walk\")), 0);\n132 | | }\n    | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    count_boredoms(S,\
    \ BoredomDelimiter::All)\n}\n\nfn main() {\n    let candidate = is_bored;\n  \
    \  assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BoredomDelimiter`\n\
    \  --> /tmp/tmpwak_gok4.rs:10:23\n   |\n10 |     count_boredoms(S, BoredomDelimiter::All)\n\
    \   |                       ^^^^^^^^^^^^^^^^ use of undeclared type `BoredomDelimiter`\n\
    \nerror[E0425]: cannot find function `count_boredoms` in this scope\n  --> /tmp/tmpwak_gok4.rs:10:5\n\
    \   |\n10 |     count_boredoms(S, BoredomDelimiter::All)\n   |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() > 2\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp14q12775.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 2\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp14q12775.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 2\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp14q12775.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 2\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp14q12775.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 2\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored_words: isize = 0;\n    for ch in S.chars() {\n        if ch.is_space()\
    \ {\n            continue;\n        }\n\n        if ch.is_punctuation() {\n  \
    \          if ch.is_punctuation('.') || ch.is_punctuation('!') || ch.is_punctuation('?')\
    \ {\n                continue;\n            }\n        }\n\n        bored_words\
    \ += 1;\n    }\n\n    bored_words\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_space` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpr1m95e4s.rs:12:15\n   |\n12 |         if ch.is_space()\
    \ {\n   |               ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_whitespace`\n\nerror[E0599]: no method named `is_punctuation`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpr1m95e4s.rs:16:15\n\
    \   |\n16 |         if ch.is_punctuation() {\n   |               ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii_punctuation`\n\
    \nerror[E0599]: no method named `is_punctuation` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpr1m95e4s.rs:17:19\n   |\n17 |             if ch.is_punctuation('.')\
    \ || ch.is_punctuation('!') || ch.is_punctuation('?') {\n   |                \
    \   ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii_punctuation`\n\nerror[E0599]: no method named `is_punctuation` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpr1m95e4s.rs:17:45\n   |\n\
    17 |             if ch.is_punctuation('.') || ch.is_punctuation('!') || ch.is_punctuation('?')\
    \ {\n   |                                             ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_punctuation`\n\nerror[E0599]:\
    \ no method named `is_punctuation` found for type `char` in the current scope\n\
    \  --> /tmp/tmpr1m95e4s.rs:17:71\n   |\n17 |             if ch.is_punctuation('.')\
    \ || ch.is_punctuation('!') || ch.is_punctuation('?') {\n   |                \
    \                                                       ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_punctuation`\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    boredom_count(S).0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `boredom_count` in this scope\n  -->\
    \ /tmp/tmpy6a2qlqj.rs:10:5\n   |\n10 |     boredom_count(S).0\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_impl(&S.as_bytes(),\
    \ \".\", \"?\", \"!\").unwrap_or(0) == 0 {\n        0\n    } else {\n        1\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_impl` in this scope\n  -->\
    \ /tmp/tmpjuo_79oj.rs:10:8\n   |\n10 |     if is_bored_impl(&S.as_bytes(), \"\
    .\", \"?\", \"!\").unwrap_or(0) == 0 {\n   |        ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if S ==\
    \ \"\" {\n        return 0;\n    }\n\n    let mut bored_count = 0;\n    for w\
    \ in S.split_whitespace() {\n        if w.starts_with(\"I\") {\n            bored_count\
    \ += 1;\n        }\n    }\n    bored_count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpks3a5cxi.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    \n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptsax28z1.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = S.len();\n    let mut bored_sentence = false;\n    for word in S.split(\"\
    \ \") {\n        if word.starts_with(\"I\") {\n            bored_sentence = true;\n\
    \        }\n        if bored_sentence {\n            count--;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpi9qq9br3.rs:17:20\n\
    \   |\n17 |             count--;\n   |                    ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi9qq9br3.rs:20:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n20 |     count\n   |     ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if S.is_empty()\
    \ || S.is_below_str(String::from(\"I\")) {\n        return 0;\n    }\n    let\
    \ mut i = 0;\n    for c in S.chars() {\n        if c == '.' || c == '?' || c ==\
    \ '!' {\n            i += 1;\n        }\n    }\n    i + 1\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_below_str` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp7smia0fy.rs:10:26\n   |\n10 |     if S.is_empty()\
    \ || S.is_below_str(String::from(\"I\")) {\n   |                          ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `as_str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0u64;\n    S.chars().for_each(|c|{\n        match c {\n            '.'\
    \ | '?' | '!' => count+=1,\n            _ => (),\n        }\n    });\n    count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9lkd7b7u.rs:17:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n17 |     count\n   |     ^^^^^ expected\
    \ `isize`, found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n17 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    for (i, item) in S.chars().enumerate().filter(|(_, c)| c.is_ascii_letter())\
    \ {\n        let char = item as u8;\n        if char == b'I'\n            || char\
    \ == b'!' || char == b'?' || char == b'!' || char == b'?'\n            || char\
    \ == b'!' || char == b'?' || char == b'?' || char == b'!'\n        {\n       \
    \     count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmprmy1dk4f.rs:11:62\n   |\n11 |     for (i,\
    \ item) in S.chars().enumerate().filter(|(_, c)| c.is_ascii_letter()) {\n   |\
    \                                                              ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = S.split_whitespace();\n    boredom.next();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap();\n    boredom.next().unwrap();\n    boredom.next().unwrap();\n\
    \    boredom.next().unwrap\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0615]: attempted to take value of method `unwrap` on type `Option<&str>`\n\
    \  --> /tmp/tmpb3zdv3r9.rs:73:20\n   |\n73 |     boredom.next().unwrap\n   | \
    \                   ^^^^^^ method, not a field\n   |\nhelp: use parentheses to\
    \ call the method\n   |\n73 |     boredom.next().unwrap()\n   |              \
    \            ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0615`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = 0;\n    for ch in S.chars() {\n        match ch {\n            '.' | '?'\
    \ | !'I ' as _ => i += 1,\n            _ => {}\n        }\n    }\n    i\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpmz5d07rh.rs:13:29\n\
    \   |\n13 |             '.' | '?' | !'I ' as _ => i += 1,\n   |              \
    \               ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars()\n\
    \        .filter(|c| !c.is_alphanumeric())\n        .filter(|c| !c.is_punctuation())\n\
    \        .filter(|c| !c.is_whitespace())\n        .count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_punctuation` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmptjciwac7.rs:12:24\n   |\n12 |         .filter(|c|\
    \ !c.is_punctuation())\n   |                        ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_punctuation`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmptjciwac7.rs:14:10\n\
    \    |\n14  |         .count(|c| c == 'I')\n    |          ^^^^^ ------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptjciwac7.rs:10:5\n   |\n9  |   fn is_bored(S: String) -> isize\
    \ {\n   |                             ----- expected `isize` because of return\
    \ type\n10 | /     S.chars()\n11 | |         .filter(|c| !c.is_alphanumeric())\n\
    12 | |         .filter(|c| !c.is_punctuation())\n13 | |         .filter(|c| !c.is_whitespace())\n\
    14 | |         .count(|c| c == 'I')\n   | |____________________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n14 |         .count(|c|\
    \ c == 'I').try_into().unwrap()\n   |                             ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ n = 0;\n    let mut boredoms: Vec<&str> = vec![];\n    for &s in S.split('.')\
    \ {\n        if !boredoms.contains(&s[0]) {\n            if s[0] == \"I\" {\n\
    \                boredoms.push(&s);\n            } else {\n                boredoms.push(s);\n\
    \            }\n        } else {\n            boredoms.remove(&s[0]);\n      \
    \  }\n    }\n    for &s in boredoms {\n        n += 1;\n    }\n    n\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpoe9mn3zb.rs:12:10\n   |\n12 |     for &s in S.split('.')\
    \ {\n   |          ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpoe9mn3zb.rs:13:32\n   |\n13 |         if !boredoms.contains(&s[0])\
    \ {\n   |                                ^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n\
    \   = note: you can use `.chars().nth()` or `.bytes().nth()`\n           for more\
    \ information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpoe9mn3zb.rs:14:16\n\
    \   |\n14 |             if s[0] == \"I\" {\n   |                ^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoe9mn3zb.rs:17:31\n   |\n17 |\
    \                 boredoms.push(s);\n   |                               ^\n  \
    \ |                               |\n   |                               expected\
    \ `&str`, found `str`\n   |                               help: consider borrowing\
    \ here: `&s`\n\nerror[E0277]: the type `str` cannot be indexed"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ is_bored = 0;\n    let mut s = S.to_string();\n    let mut words: Vec<String>\
    \ = Vec::new();\n    while !s.is_empty() {\n        if s.starts_with(\"I\") {\n\
    \            words = s.split_whitespace().collect();\n            is_bored +=\
    \ 1;\n        }\n        s = &s[..];\n    }\n    is_bored\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp858ffbgw.rs:15:42\n     |\n15\
    \   |             words = s.split_whitespace().collect();\n     |            \
    \                              ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp858ffbgw.rs:18:13\n   |\n11 |     let mut s\
    \ = S.to_string();\n   |                 ------------- expected due to this value\n\
    ...\n18 |         s = &s[..];\n   |             ^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n18 |        \
    \ s = (&s[..]).to_string();\n   |             +      +++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_boredom_end(S)\n\
    \        || (S.len() == 1 && S[0] == 'I')\n        || (S.len() == 2 && S[0] ==\
    \ 'I' && S[1] == '.')\n        || (S.len() == 3 && S[0] == 'I' && S[1] == '.'\
    \ && S[2] == '!')\n    {\n        1\n    } else {\n        0\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_boredom_end` in this scope\n  -->\
    \ /tmp/tmpokhgpj09.rs:10:8\n   |\n10 |     if is_boredom_end(S)\n   |        ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpokhgpj09.rs:11:29\n   |\n11 |         || (S.len()\
    \ == 1 && S[0] == 'I')\n   |                             ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpokhgpj09.rs:12:29\n   |\n12 |         || (S.len() == 2 && S[0]\
    \ == 'I' && S[1] == '.')\n   |                             ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpokhgpj09.rs:12:44\n   |\n12 |         || (S.len() == 2 && S[0]\
    \ == 'I' && S[1] == '.')\n   |                                            ^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<Ran"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    for s in S.split() {\n        if s.starts_with(\"I\") {\n  \
    \          count = count + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpwwl2bfd6.rs:11:16\n     |\n11   |     for s in S.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = S.to_string();\n    boredom.replace(\". . . . . . . . . . . .\", \"\
    .\").replace(\". . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . .\"\
    , \".\")\n        .replace(\". . . . . . . . . . . .\", \".\").replace(\". . .\
    \ . . . . . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n  \
    \      .replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . . .\
    \ . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n        .replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\"\
    , \".\").replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . . .\
    \ . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n\
    \        .replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . .\
    \ . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\")\n        .replace(\"\
    . . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . . .\", \".\")\n        .replace(\". . . . . . . . . . . .\"\
    , \".\").replace(\". . . . . . . . . . .\", \".\").replace(\". . . . . . . . .\
    \ . .\", \".\")\n        .replace(\". . . . . . . . . . .\", \".\").replace(\"\
    . . . . . . . . . . .\", \".\").replace(\". . . . . . . . . . .\", \".\")\n  \
    \      .replace(\". . . . . . . . . . . .\", \".\").replace(\". . . . . . . .\
    \ . . . .\", \".\").replace(\". . . . . \n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfw4r5eue.rs:31:70\n\
    \   |\n31 |       assert_eq!(candidate(String::from(\"You and I are going for\
    \ a walk\")), 0);\n   |  ______________________________________________________________________^\n\
    32 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = 0;\n    let mut sentences = split_sentence(S);\n    for sentence\
    \ in sentences {\n        if sentence.starts_with(\"I\") {\n            boredoms++;\n\
    \        }\n    }\n    return boredoms;\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpa_hf0siw.rs:14:21\n\
    \   |\n14 |             boredoms++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n14 |             { let tmp =\
    \ boredoms; boredoms += 1; tmp };\n   |             +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n\
    14 -             boredoms++;\n14 +             boredoms += 1;\n   | \n\nerror[E0425]:\
    \ cannot find function `split_sentence` in this scope\n  --> /tmp/tmpa_hf0siw.rs:11:25\n\
    \   |\n11 |     let mut sentences = split_sentence(S);\n   |                 \
    \        ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ idx = 0;\n\n    while idx < S.len() {\n        if S[idx] == 'I' {\n        \
    \    if idx+1 < S.len() {\n                if S[idx+1] == '.' || S[idx+1] == '?'\
    \ || S[idx+1] == '!' {\n                    idx += 3;\n                } else\
    \ {\n                    idx += 2;\n                }\n            } else {\n\
    \                idx += 1;\n            }\n        } else {\n            idx +=\
    \ 1;\n        }\n    }\n\n    idx\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph96qnyxn.rs:13:12\n\
    \   |\n13 |         if S[idx] == 'I' {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph96qnyxn.rs:15:20\n   |\n15 |                 if S[idx+1] == '.'\
    \ || S[idx+1] == '?' || S[idx+1] == '!' {\n   |                    ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph96qnyxn.rs:15:39\n   |\n15 |                 if S[idx+1] == '.'\
    \ || S[idx+1] == '?' || S[idx+1] == '!' {\n   |                              \
    \         ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    let mut words: Vec<String> = S.split(\" \").collect();\n\
    \    for word in words {\n        boredoms += match word {\n            \"I\"\
    \ => 1,\n            \".\" => 1,\n            \"?\" => 1,\n            \"!\" =>\
    \ 1,\n            _ => 0,\n        };\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpo5o_vi6u.rs:11:47\n     |\n11\
    \   |     let mut words: Vec<String> = S.split(\" \").collect();\n     |     \
    \                                          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5o_vi6u.rs:14:13\n\
    \   |\n13 |         boredoms += match word {\n   |                           ----\
    \ this expression has type `String`\n14 |             \"I\" => 1,\n   |      \
    \       ^^^ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo5o_vi6u.rs:15:13\n   |\n13 |         boredoms += match\
    \ word {\n   |                           ---- this expression has type `String`\n\
    14 |             \"I\" => 1,\n15 |             \".\" => 1,\n   |             ^^^\
    \ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpo5o_vi6u.rs:16:13\n   |\n13 |         boredoms += match word {\n\
    \   |                           ---- this expression has type `String`\n...\n\
    16 |             \"?\" => 1,\n   |             ^^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5o_vi6u.rs:17:13\n\
    \   |\n13 |         boredoms += match word {\n   |                           ----\
    \ this expression has type `String`\n...\n17 |             \"!\" => 1,\n   | \
    \            ^^^ expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = String::new();\n    for (i, c) in S.chars().enumerate() {\n      \
    \  if c == '.' || c == '?' || c == '!' {\n            boredom = S\n          \
    \      .to_string()\n                .split_whitespace()\n                .skip(i)\n\
    \                .next()\n                .unwrap();\n            break;\n   \
    \     }\n    }\n    boredom.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvkwyhse.rs:13:23\n   |\n\
    10 |       let mut boredom = String::new();\n   |                         -------------\
    \ expected due to this value\n...\n13 |               boredom = S\n   |  _______________________^\n\
    14 | |                 .to_string()\n15 | |                 .split_whitespace()\n\
    16 | |                 .skip(i)\n17 | |                 .next()\n18 | |      \
    \           .unwrap();\n   | |                         ^- help: try using a conversion\
    \ method: `.to_string()`\n   | |_________________________|\n   |             \
    \              expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyvkwyhse.rs:22:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n22 |     boredom.len()\n   |     ^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |     boredom.len().try_into().unwrap()\n\
    \   |                  ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    let mut s = S;\n    s.replace('!', ' ');\n    s.replace('?', '\
    \ ');\n    s.replace('.', ' ');\n    s.replace('i', ' ');\n    s.replace('e',\
    \ ' ');\n    s.replace('r', ' ');\n    s.replace('n', ' ');\n    s.replace('t',\
    \ ' ');\n    s.replace('s', ' ');\n    s.replace('u', ' ');\n    s.replace('v',\
    \ ' ');\n    s.replace('w', ' ');\n    s.replace('l', ' ');\n    s.replace('o',\
    \ ' ');\n    s.replace('p', ' ');\n    s.replace('d', ' ');\n    s.replace('j',\
    \ ' ');\n    s.replace('g', ' ');\n    s.replace('h', ' ');\n    s.replace('f',\
    \ ' ');\n    s.replace('z', ' ');\n    s.replace('j', ' ');\n    s.replace('c',\
    \ ' ');\n    s.replace('y', ' ');\n    s.replace('k', ' ');\n    s.replace('g',\
    \ ' ');\n    s.replace('f', ' ');\n    s.replace('y', ' ');\n    s.replace('h',\
    \ ' ');\n    s.replace('v', ' ');\n    s.replace('u', ' ');\n    s.replace('i',\
    \ ' ');\n    s.replace('y', ' ');\n    s.replace('t', ' ');\n    s.replace('f',\
    \ ' ');\n    s.replace('u', ' ');\n    s.replace('i', ' ');\n    s.replace(' ',\
    \ ' ');\n    s.replace('\\n', ' ');\n    s.replace('\\r', ' ');\n    let mut s\
    \ = S;\n    while let Some(c) = (s.chars().find(|&x| *x == ' ')) {\n        cnt\
    \ = cnt + 1;\n        s = s.to_owned();\n    }\n    cnt\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmpmz3rtxol.rs:53:25\n   |\n53 |     while let Some(c) = (s.chars().find(|&x|\
    \ *x == ' ')) {\n   |                         ^                              ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n53 -     while let Some(c) = (s.chars().find(|&x| *x == ' ')) {\n53 + \
    \    while let Some(c) = s.chars().find(|&x| *x == ' ') {\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmz3rtxol.rs:12:20\n   |\n12 |     s.replace('!',\
    \ ' ');\n   |                    ^^^ expected `&str`, found `char`\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n12 |     s.replace('!',\
    \ \" \");\n   |                    ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmz3rtxol.rs:13:20\n   |\n13 |     s.replace('?', ' ');\n   |       \
    \             ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n13 |     s.replace('?', \" \");\n\
    \   |                    ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmz3rtxol.rs:14:20\n\
    \   |\n14 |     s.replace('.', ' ');\n   |                    ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n14 |     s.replace('.', \" \");\n   |                    ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmz3rtxol.rs:15:20\n   |\n15 |\
    \     s.replace('i', ' ');\n   |                    ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n15 |     s.replace('i', \" \");\n   |                    ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmz3rtxol.rs:16:20\n   |\n16 |     s.replace('e',\
    \ ' ');\n   |                    ^^^ expected `&str`, found `char`\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n16 |     s.replace('e',\
    \ \" \");\n   |                    ~~~\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmz3rtxol.rs:17:20\n   |\n17 |     s.replace('r', ' ');\n   |       \
    \             ^^^ expected `&str`, found `char"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = 0usize;\n    let mut i: usize = S.len();\n    while i != 0usize &&\
    \ S[i..].starts_with(\"I\") {\n        if S[i..].starts_with(\".\")\n        \
    \    || S[i..].starts_with(\"!\")\n            || S[i..].starts_with(\"?\")\n\
    \        {\n            boredom++;\n        }\n        i--;\n    }\n    boredom\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp1vjxmivc.rs:17:20\n\
    \   |\n17 |             boredom++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |             { let tmp =\
    \ boredom; boredom += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    17 -             boredom++;\n17 +             boredom += 1;\n   | \n\nerror: expected\
    \ expression, found `;`\n  --> /tmp/tmp1vjxmivc.rs:19:12\n   |\n19 |         i--;\n\
    \   |            ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1vjxmivc.rs:21:5\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n...\n\
    21 |     boredom\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |     boredom.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n\n    let mut i = 0;\n    while i < S.len() {\n        let char\
    \ = S[i];\n        if char == \".\" || char == \"?\" || char == \"!\" {\n    \
    \        i += 1;\n            continue;\n        }\n        if char == \" \" {\n\
    \            i += 1;\n            continue;\n        }\n        break;\n    }\n\
    \    i += 1;\n\n    while i < S.len() {\n        let char = S[i];\n        if\
    \ char == \"I\" {\n            i += 1;\n            continue;\n        }\n   \
    \     if char == \" \" {\n            i += 1;\n            continue;\n       \
    \ }\n        break;\n    }\n    i += 1;\n\n    while i < S.len() {\n        let\
    \ char = S[i];\n        if char == \".\" || char == \"?\" || char == \"!\" {\n\
    \            i += 1;\n            continue;\n        }\n        count += 1;\n\
    \        i += 1;\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphduikl5x.rs:14:20\n\
    \   |\n14 |         let char = S[i];\n   |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphduikl5x.rs:28:20\n   |\n28 |         let char = S[i];\n   |  \
    \                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphduikl5x.rs:42:20\n   |\n42 |         let char = S[i];\n   |  \
    \                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous erro"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ has_bored = false;\n    for s in S.chars() {\n        match s {\n          \
    \  '.' => has_bored = true,\n            '?' => has_bored = true,\n          \
    \  '!' => has_bored = true,\n            _ => (),\n        }\n    }\n    match\
    \ has_bored {\n        true => 0,\n        false => 1,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp0rb5wl7d.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = false;\n    let mut char_count = 0;\n    let mut sentence_count =\
    \ 1;\n\n    for c in S {\n        if c == '.' || c == '?' || c == '!' {\n    \
    \        if char_count == 0 {\n                boredom = true;\n            }\
    \ else {\n                boredom = false;\n            }\n        }\n       \
    \ char_count += 1;\n        if boredom {\n            sentence_count += 1;\n \
    \       }\n    }\n    return sentence_count;\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmph_u9fp3t.rs:14:14\n\
    \   |\n14 |     for c in S {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for word in S.chars() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpov6ubkq9.rs:12:17\n   |\n12 |         if word.starts_with(\"\
    I\") {\n   |                 ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = S.len();\n    loop {\n        i -= 1;\n        match S[i].rev() {\n    \
    \        \".\" | \"?\" | \"!\" => { i += 1 },\n            _ => continue,\n  \
    \      }\n        return i;\n    }\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkodcn1_6.rs:13:15\n\
    \   |\n13 |         match S[i].rev() {\n   |               ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkodcn1_6.rs:17:16\n\
    \   |\n17 |         return i;\n   |                ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         return i.try_into().unwrap();\n   |  \
    \               ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_ascii_digit()).filter(|c| c == ' ').count()\
    \ > 3\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp1kcek6am.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_ascii_digit()).filter(|c| c == ' ').count()\
    \ > 3\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp1kcek6am.rs:10:91\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_ascii_digit()).filter(|c| c == ' ').count()\
    \ > 3\n   |                                                                  \
    \                         ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1kcek6am.rs:10:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n10 |     S.chars().filter(|c| c.is_ascii_letter()).filter(|c| c.is_ascii_digit()).filter(|c|\
    \ c == ' ').count() > 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    boredoms(S).iter().filter(|&boredom|\
    \ boredom == \"I\").count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `boredoms` in this scope\n  --> /tmp/tmp7axtaezu.rs:10:5\n\
    \   |\n10 |     boredoms(S).iter().filter(|&boredom| boredom == \"I\").count()\n\
    \   |     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    loop {\n\
    \        let mut i: isize = 0;\n        for w in S.split_whitespace() {\n    \
    \        if w.starts_with(\"I\") {\n                i += 1;\n            }\n \
    \       }\n        if i == 0 {\n            break;\n        }\n    }\n    i\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp5fpo13om.rs:21:5\n\
    \   |\n21 |     i\n   |     ^ help: a local variable with a similar name exists:\
    \ `S`\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.split('.').filter(|&x|\
    \ !x.starts_with(\"I\")).count() \n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpok4yunrc.rs:10:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.split('.').filter(|&x| !x.starts_with(\"\
    I\")).count() \n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.split('.').filter(|&x|\
    \ !x.starts_with(\"I\")).count().try_into().unwrap() \n   |                  \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    for s in S.chars() {\n        cnt += if s.is_letter()\n      \
    \      && s != \"I\"\n            && !(s.is_space() || s.is_punctuation())\n \
    \           && !s.is_ascii()\n            {\n                1\n            }\
    \ else {\n                0\n            };\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpthx7ym4j.rs:12:21\n   |\n12 |         cnt += if\
    \ s.is_letter()\n   |                     ^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpthx7ym4j.rs:13:21\n   |\n13 |\
    \             && s != \"I\"\n   |                     ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n13 |             && s != 'I'\n   |                     ~~~\n\nerror[E0599]:\
    \ no method named `is_space` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpthx7ym4j.rs:14:20\n   |\n14 |             && !(s.is_space() || s.is_punctuation())\n\
    \   |                    ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_whitespace`\n\nerror[E0599]: no method named `is_punctuation`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpthx7ym4j.rs:14:36\n\
    \   |\n14 |             && !(s.is_space() || s.is_punctuation())\n   |       \
    \                             ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii_punctuation`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ I = 0;\n    let mut boredoms: Vec<String> = vec![];\n    for words in S.split_whitespace()\
    \ {\n        for word in words.split_ascii_words() {\n            if let Some(index)\
    \ = get_index_boredom(&word) {\n                boredoms.push(words.to_string());\n\
    \                I = index;\n            }\n        }\n    }\n    I\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_index_boredom` in this scope\n\
    \  --> /tmp/tmpst27m3wg.rs:14:34\n   |\n14 |             if let Some(index) =\
    \ get_index_boredom(&word) {\n   |                                  ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `split_ascii_words`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpst27m3wg.rs:13:27\n\
    \   |\n13 |         for word in words.split_ascii_words() {\n   |            \
    \               ^^^^^^^^^^^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored: isize = 0;\n    let words = S.split_whitespace();\n    for i in 0..(words.len()\
    \ - 1) {\n        if words[i] == \"I\" && words[i + 1] == \"I\" {\n          \
    \  bored += 1;\n        }\n    }\n    bored\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpm5wg78kw.rs:12:24\n   |\n12 |     for i\
    \ in 0..(words.len() - 1) {\n   |                        ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpm5wg78kw.rs:13:12\n   |\n13 |         if\
    \ words[i] == \"I\" && words[i + 1] == \"I\" {\n   |            ^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpm5wg78kw.rs:13:31\n\
    \   |\n13 |         if words[i] == \"I\" && words[i + 1] == \"I\" {\n   |    \
    \                           ^^^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ c = 0;\n    for ch in S {\n        match ch {\n            '.' | '?' | '!' =>\
    \ c += 1,\n            _ => continue,\n        }\n    }\n    c\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpbxgi5v19.rs:11:15\n\
    \   |\n11 |     for ch in S {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_str(&S)\
    \ == 0\n        || (is_bored_str(&S) == 1 && S.contains(\".\"))\n        || (is_bored_str(&S)\
    \ == 1 && S.contains(\"?\"))\n        || (is_bored_str(&S) == 1 && S.contains(\"\
    !\"))\n    {\n        0\n    } else {\n        1\n    }\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_str` in this scope\n  -->\
    \ /tmp/tmpwffcpxmw.rs:10:8\n   |\n10 |     if is_bored_str(&S) == 0\n   |    \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_bored_str` in this scope\n  --> /tmp/tmpwffcpxmw.rs:11:13\n   |\n11 |  \
    \       || (is_bored_str(&S) == 1 && S.contains(\".\"))\n   |             ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_bored_str`\
    \ in this scope\n  --> /tmp/tmpwffcpxmw.rs:12:13\n   |\n12 |         || (is_bored_str(&S)\
    \ == 1 && S.contains(\"?\"))\n   |             ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_bored_str` in this scope\n \
    \ --> /tmp/tmpwffcpxmw.rs:13:13\n   |\n13 |         || (is_bored_str(&S) == 1\
    \ && S.contains(\"!\"))\n   |             ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ N = 0;\n\n    for w in S.split('.') {\n        if w == \"I\" {\n           \
    \ N += 1;\n        }\n    }\n\n    N\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp8t8n6r_o.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = 0;\n    \n    for sentence in S.split_whitespace() {\n        if let\
    \ Some(sentence) = sentence.to_lowercase() {\n            if sentence.starts_with(\"\
    i\") {\n                boredom += 1;\n            }\n        }\n    }\n    \n\
    \    boredom\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzbdqrtt8.rs:13:16\n   |\n\
    13 |         if let Some(sentence) = sentence.to_lowercase() {\n   |         \
    \       ^^^^^^^^^^^^^^   ----------------------- this expression has type `String`\n\
    \   |                |\n   |                expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // Your\
    \ code here\n    \n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgezl5eo7.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ is_bored = 0;\n    for word in S.split_whitespace() {\n        if word == \"\
    I\" {\n            is_bored += 1;\n        }\n    }\n    is_bored\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpvkyroc1k.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = vec![\"I\"];\n    let mut words = S.split_whitespace().collect::<Vec<&str>>();\n\
    \    loop {\n        if !words.next().unwrap().starts_with(\"I\") {\n        \
    \    return 0;\n        }\n        bored.push(words.next().unwrap());\n    }\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmpl08ml59l.rs:13:19\n   |\n13 |         if !words.next().unwrap().starts_with(\"\
    I\") {\n   |                   ^^^^ method not found in `Vec<&str>`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmpl08ml59l.rs:16:26\n   |\n16 |         bored.push(words.next().unwrap());\n\
    \   |                          ^^^^ method not found in `Vec<&str>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.trim().chars().filter(|c|\
    \ c == 'I' || c == '.' || c == '?' || c == '!').count() + 1\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpghle3f8f.rs:10:35\n\
    \   |\n10 |     S.trim().chars().filter(|c| c == 'I' || c == '.' || c == '?' ||\
    \ c == '!').count() + 1\n   |                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpghle3f8f.rs:10:47\n\
    \   |\n10 |     S.trim().chars().filter(|c| c == 'I' || c == '.' || c == '?' ||\
    \ c == '!').count() + 1\n   |                                               ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpghle3f8f.rs:10:59\n\
    \   |\n10 |     S.trim().chars().filter(|c| c == 'I' || c == '.' || c == '?' ||\
    \ c == '!').count() + 1\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpghle3f8f.rs:10:71\n   |\n10 |     S.trim().chars().filter(|c| c\
    \ == 'I' || c == '.' || c == '?' || c == '!').count() + 1\n   |              \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpghle3f8f.rs:10:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.trim().chars().filter(|c| c == 'I'\
    \ || c == '.' || c == '?' || c == '!').count() + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if S ==\
    \ \"I\" || S.starts_with(\"I\") {\n        return 0;\n    }\n\n    let mut count\
    \ = 1;\n    let mut i = 0;\n\n    while i < S.len() {\n        if S[i] == ' '\
    \ || S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i += 1;\n      \
    \  } else {\n            break;\n        }\n    }\n\n    for i in 0..count {\n\
    \        if S[i] == '.' {\n            return i - 1;\n        }\n    }\n\n   \
    \ count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpemyybm3x.rs:18:12\n\
    \   |\n18 |         if S[i] == ' ' || S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpemyybm3x.rs:18:27\n   |\n18 |         if S[i] == ' ' || S[i] ==\
    \ '.' || S[i] == '?' || S[i] == '!' {\n   |                           ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpemyybm3x.rs:18:42\n   |\n18 |         if S[i] == ' ' || S[i] ==\
    \ '.' || S[i] == '?' || S[i] == '!' {\n   |                                  \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as I"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n\n    for word in S.split_whitespace() {\n        if !word.starts_with(\"\
    I\") {\n            counter += 1;\n        }\n    }\n\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `0`', /tmp/tmp51i9yvgd.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2wuwjk12.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp2wuwjk12.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp2wuwjk12.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2wuwjk12.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    for ch in S.chars() {\n        if ch != 'I' {\n            cnt\
    \ += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `0`', /tmp/tmpj_5l8t2a.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    for ch in S {\n        if ch.is_alphabetic() {\n            cnt\
    \ += 1;\n        } else if ch == '.' || ch == '?' || ch == '!' {\n           \
    \ cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2b55387n.rs:11:15\n\
    \   |\n11 |     for ch in S {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ words: Vec<String> = S\n        .split_whitespace()\n        .filter(|w| w.len()\
    \ > 0)\n        .collect();\n    let mut counts: Vec<usize> = Vec::new();\n  \
    \  let mut j: usize = 0;\n    for word in words {\n        counts.clear();\n \
    \       for (i, char) in word.chars().enumerate() {\n            if char == char::from(\"\
    I\") {\n                counts.push(i);\n            }\n        }\n        if\
    \ counts.len() > 1 {\n            j = counts.iter().max().unwrap_or(usize) + 1;\n\
    \        }\n    }\n    j\n}\n\nfn main() {\n    let candidate = is_bored;\n  \
    \  assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found builtin type `usize`\n  --> /tmp/tmp40r8wp06.rs:24:47\n\
    \   |\n24 |             j = counts.iter().max().unwrap_or(usize) + 1;\n   |  \
    \                                             ^^^^^ not a value\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmp40r8wp06.rs:13:10\n     |\n13   |         .collect();\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the trait bound `char: From<&str>`\
    \ is not satisfied\n  --> /tmp/tmp40r8wp06.rs:19:24\n   |\n19 |             if\
    \ char == char::from(\"I\") {\n   |                        ^^^^^^^^^^ the trait\
    \ `From<&str>` is not implemented for `char`\n   |\n   = help: the trait `From<u8>`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40r8wp06.rs:27:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n27 |     j\n   |     ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n27 |     j.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    is_bored_str(&S.split(\"\
    \ \"))\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_str` in this scope\n  -->\
    \ /tmp/tmp0rpdx_g3.rs:10:5\n   |\n10 |     is_bored_str(&S.split(\" \"))\n   |\
    \     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom_words = vec![];\n    \n    for word in S.split_whitespace() {\n    \
    \    match word {\n            \"I\".to_string() => boredom_words.push(word),\n\
    \            _ => {\n                boredom_words.clear();\n            }\n \
    \       }\n    }\n    \n    boredom_words.len()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `.`\n\
    \  --> /tmp/tmp10be9wpl.rs:14:16\n   |\n14 |             \"I\".to_string() =>\
    \ boredom_words.push(word),\n   |                ^ expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp10be9wpl.rs:21:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n21 |     boredom_words.len()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |     boredom_words.len().try_into().unwrap()\n   |          \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|&c|\
    \ !c.is_ascii()).filter(|c| c.is_ascii_letter()).filter(|c| c == ' ' || c == '.'\
    \ || c == '?' || c == '!').count() == 0\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpj01w5sae.rs:10:55\n   |\n10 | ...s_ascii()).filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c == ' ' || c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpj01w5sae.rs:10:87\n   |\n10 |     S.chars().filter(|&c|\
    \ !c.is_ascii()).filter(|c| c.is_ascii_letter()).filter(|c| c == ' ' || c == '.'\
    \ || c == '?' || c == '!').count()...\n   |                                  \
    \                                                     ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpj01w5sae.rs:10:99\n\
    \   |\n10 | ... c.is_ascii_letter()).filter(|c| c == ' ' || c == '.' || c == '?'\
    \ || c == '!').count() == 0\n   |                                            \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpj01w5sae.rs:10:111\n\
    \   |\n10 | ...letter()).filter(|c| c == ' ' || c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpj01w5sae.rs:10:123\n\
    \   |\n10 | ...lter(|c| c == ' ' || c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let boredoms\
    \ = vec![\n        \"I\",\n        \"me\",\n        \"my\",\n        \"we\",\n\
    \        \"our\",\n        \"ours\",\n        \"ourselves\",\n        \"you\"\
    ,\n        \"your\",\n        \"yours\",\n        \"yourself\",\n        \"yourselves\"\
    ,\n        \"he\",\n        \"him\",\n        \"his\",\n        \"himself\",\n\
    \        \"she\",\n        \"her\",\n        \"hers\",\n        \"herself\",\n\
    \        \"it\",\n        \"its\",\n        \"itself\",\n        \"they\",\n \
    \       \"them\",\n        \"their\",\n        \"theirs\",\n        \"themselves\"\
    ,\n        \"what\",\n        \"which\",\n        \"who\",\n        \"whom\",\n\
    \        \"this\",\n        \"that\",\n        \"these\",\n        \"those\",\n\
    \        \"am\",\n        \"is\",\n        \"are\",\n        \"was\",\n      \
    \  \"were\",\n        \"be\",\n        \"been\",\n        \"being\",\n       \
    \ \"have\",\n        \"has\",\n        \"had\",\n        \"having\",\n       \
    \ \"do\",\n        \"does\",\n        \"did\",\n        \"doing\",\n        \"\
    a\",\n        \"an\",\n        \"the\",\n        \"and\",\n        \"but\",\n\
    \        \"if\",\n        \"or\",\n        \"because\",\n        \"as\",\n   \
    \     \"until\",\n        \"while\",\n        \"of\",\n        \"at\",\n     \
    \   \"by\",\n        \"for\",\n        \"with\",\n        \"about\",\n       \
    \ \"against\",\n        \"between\",\n        \"into\",\n        \"through\",\n\
    \        \"during\",\n        \"before\",\n        \"after\",\n        \"above\"\
    ,\n        \"below\",\n        \"to\",\n        \"from\",\n        \"up\",\n \
    \       \"down\",\n        \"in\",\n        \"out\",\n        \"on\",\n      \
    \  \"off\",\n        \"over\",\n        \"under\",\n        \"again\",\n     \
    \   \"further\",\n        \"then\",\n        \"once\",\n        \"here\",\n  \
    \      \"there\",\n        \"when\",\n        \"where\",\n        \"why\",\n \
    \       \"how\",\n        \"all\",\n        \"any\",\n        \"both\",\n    \
    \    \"each\",\n        \"few\",\n        \"more\",\n        \"most\",\n     \
    \   \"other\",\n        \"some\",\n        \"such\",\n        \"no\",\n      \
    \  \"nor\",\n        \"not\",\n        \"only\",\n        \"own\",\n        \"\
    same\",\n        \"so\",\n        \"than\",\n        \"too\",\n        \"very\"\
    ,\n        \"s\",\n        \"t\",\n        \"can\",\n        \"will\",\n     \
    \   \"just\",\n        \"don\",\n        \"\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmp20ym0ksb.rs:145:70\n\
    \    |\n145 |       assert_eq!(candidate(String::from(\"You and I are going for\
    \ a walk\")), 0);\n    |  ______________________________________________________________________^\n\
    146 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored_start = 0;\n    let mut bored_end = 0;\n\n    for s in S.split() {\n \
    \       if s == \".\" || s == \"?\" || s == \"!\" {\n            bored_end = s.len();\n\
    \        } else {\n            bored_end = s.len();\n            bored_start =\
    \ bored_end;\n        }\n\n        if bored_start == 0 {\n            continue;\n\
    \        }\n        if s.starts_with(\"I\") {\n            return 1;\n       \
    \ }\n    }\n    0\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpvt5og9qj.rs:13:16\n     |\n13   |     for s in S.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = 0;\n    S.chars().filter(|&x| x == ' ' || x == '.' || x == '?' || x == '!').for_each(|x|\
    \ {\n        i = i + (x.as_bytes().to_vec().iter().any(|&b| *b == 0x51).unwrap_or(false)\
    \ as isize);\n    });\n    i\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpjsfv9jk8.rs:12:20\n   |\n12 |         i = i + (x.as_bytes().to_vec().iter().any(|&b|\
    \ *b == 0x51).unwrap_or(false) as isize);\n   |                    ^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ n = 0;\n    S.chars().for_each(|c| {\n        if c == 'I' || c == '.' || c ==\
    \ '?' || c == '!' {\n            n += 1;\n        }\n    });\n    n\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `0`', /tmp/tmptsipu22e.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    // Your\
    \ code here\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphmlnusc6.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.split(\"\
    .\").count(|&x| x != \"I\")\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp91a24ih_.rs:10:18\n    |\n10  |     S.split(\".\").count(|&x|\
    \ x != \"I\")\n    |                  ^^^^^ ------------- supplied 1 argument\n\
    \    |                  |\n    |                  expected 0 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp91a24ih_.rs:10:5\n   |\n9  | fn is_bored(S: String) -> isize {\n   |\
    \                           ----- expected `isize` because of return type\n10\
    \ |     S.split(\".\").count(|&x| x != \"I\")\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.split(\"\
    .\").count(|&x| x != \"I\").try_into().unwrap()\n   |                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    for (i, s) in S.chars().enumerate() {\n        let word = s.to_string();\n\
    \        if word.is_ascii() || word.is_lowercase() {\n            cnt += 1;\n\
    \            cnt += 1 // TODO: handle case where word starts with \"i\"\n    \
    \    } else {\n            // TODO: handle case where word is all punctuation\n\
    \        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpf42d5htj.rs:13:36\n   |\n13 |         if\
    \ word.is_ascii() || word.is_lowercase() {\n   |                             \
    \       ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c >= 'I').count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc17bito.rs:10:31\n   |\n\
    10 |     S.chars().filter(|c| c >= 'I').count()\n   |                        \
    \       ^^^\n   |                               |\n   |                      \
    \         expected `&char`, found `char`\n   |                               help:\
    \ consider borrowing here: `&'I'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplc17bito.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c >= 'I').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c >= 'I').count().try_into().unwrap()\n   |                                \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let words\
    \ = S.splitn(3, '.').collect::<Vec<_>>();\n    let mut n = 0;\n    for &w in words\
    \ {\n        n += if w == \"I\" { 1 } else { 0 };\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpnz4ns6w9.rs:12:10\n   |\n12 |     for &w in words {\n  \
    \ |          ^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: all local variables must\
    \ have a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpnz4ns6w9.rs:13:19\n\
    \   |\n13 |         n += if w == \"I\" { 1 } else { 0 };\n   |               \
    \    ^^ no implementation for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored_count = 0;\n    let mut S = S.to_string();\n\n    for i in S {\n     \
    \   if i != \"I\" {\n            bored_count += 1;\n        }\n    }\n    bored_count\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmps4pb2ev1.rs:13:14\n\
    \   |\n13 |     for i in S {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = String::new();\n    boredom.clear();\n    let mut bored = 0;\n   \
    \ let mut index = S.find(' ');\n    if index == S.len() {\n        bored = 0;\n\
    \        return bored;\n    }\n\n    loop {\n        boredom.push_str(&S[..index]);\n\
    \        if S[..index].starts_with(\"I\") {\n            bored = bored + 1;\n\
    \            break;\n        }\n        index = S.find(' ', index);\n        if\
    \ index == S.len() {\n            bored = bored + 1;\n            break;\n   \
    \     }\n        boredom.push_str(&S[..index]);\n    }\n    bored\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkl5av0fy.rs:14:17\n   |\n\
    14 |     if index == S.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \     if index == Some(S.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmpkl5av0fy.rs:20:27\n\
    \   |\n20 |         boredom.push_str(&S[..index]);\n   |                     \
    \      ^^^^^^^^^^ `String` cannot be indexed by `RangeTo<Option<usize>>`\n   |\n\
    \   = help: the trait `Index<RangeTo<Option<usize>>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \  --> /tmp/tmpkl5av0fy.rs:21:12\n   |\n21 |         if S[..index].starts_with(\"\
    I\") {\n   |            ^^^^^^^^^^ `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeTo<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n    --> /tmp/tmpkl5av0fy.rs:25:19\n     |\n25   |         index =\
    \ S.find(' ', index);\n     |                   ^^^^ ---  ----"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.split('.').count(|x|\
    \ {\n        x.contains(\"I\")\n    })\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp9fjapvps.rs:10:25\n\
    \   |\n10 |     S.split('.').count(|x| {\n   |                         ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmp9fjapvps.rs:10:18\n    |\n10  |       S.split('.').count(|x|\
    \ {\n    |  __________________^^^^^_-\n    | |                  |\n    | |   \
    \               expected 0 arguments\n11  | |         x.contains(\"I\")\n12  |\
    \ |     })\n    | |_____- supplied 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9fjapvps.rs:10:5\n\
    \   |\n9  |   fn is_bored(S: String) -> isize {\n   |                        \
    \     ----- expected `isize` because of return type\n10 | /     S.split('.').count(|x|\
    \ {\n11 | |         x.contains(\"I\")\n12 | |     })\n   | |______^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |     }).try_into().unwrap()\n\
    \   |       ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_empty(S)\
    \ || S == \"I\" || S == \"my\" || S == \"I'm\" || S == \"i'm\" {\n        return\
    \ 0;\n    }\n\n    let mut count = 0;\n    let mut idx = 0;\n    while idx < S.len()\
    \ {\n        if S[idx] == '.' || S[idx] == '?' || S[idx] == '!' {\n          \
    \  count++;\n        }\n        idx += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp30ea26cm.rs:18:18\n\
    \   |\n18 |             count++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp =\
    \ count; count += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    18 -             count++;\n18 +             count += 1;\n   | \n\nerror[E0425]:\
    \ cannot find function `is_empty` in this scope\n  --> /tmp/tmp30ea26cm.rs:10:8\n\
    \   |\n10 |     if is_empty(S) || S == \"I\" || S == \"my\" || S == \"I'm\" ||\
    \ S == \"i'm\" {\n   |        ^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp30ea26cm.rs:17:12\n\
    \   |\n17 |         if S[idx] == '.' || S[idx] == '?' || S[idx] == '!' {\n   |\
    \            ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp30ea26cm.rs:17:29\n   |\n17 |         if S[idx] == '.' || S[idx]\
    \ == '?' || S[idx] == '!' {\n   |                             ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms: isize = 0;\n    for s in S.split_whitespace() {\n        if s.starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp_e3h_wky.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    let mut words = S.split_whitespace();\n    let mut has_boredom\
    \ = false;\n    while !words.is_empty() {\n        if words[0] == \"I\" {\n  \
    \          cnt += 1;\n            has_boredom = true;\n        }\n        words\
    \ = words.next();\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0g2mhshf.rs:13:18\n   |\n13 |     while\
    \ !words.is_empty() {\n   |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp0g2mhshf.rs:14:12\n   |\n14 |         if words[0] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0g2mhshf.rs:18:17\n\
    \   |\n11 |     let mut words = S.split_whitespace();\n   |                  \
    \   -------------------- expected due to this value\n...\n18 |         words =\
    \ words.next();\n   |                 ^^^^^^^^^^^^ expected struct `SplitWhitespace`,\
    \ found enum `Option`\n   |\n   = note: expected struct `SplitWhitespace<'_>`\n\
    \                found enum `Option<&str>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    for (i, s) in S.chars().enumerate() {\n        if s == \"I\"\
    \ {\n            bored += 1;\n        }\n        if s.is_whitespace() {\n    \
    \        continue;\n        }\n        if i == 0 {\n            bored += 1;\n\
    \        }\n        if i == S.len() - 1 {\n            bored += 1;\n        }\n\
    \        if s.is_punctuation() {\n            bored += 1;\n        }\n    }\n\
    \    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa1nci8uh.rs:12:17\n   |\n\
    12 |         if s == \"I\" {\n   |                 ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n12 |         if s == 'I' {\n   |                 ~~~\n\nerror[E0599]: no\
    \ method named `is_punctuation` found for type `char` in the current scope\n \
    \ --> /tmp/tmpa1nci8uh.rs:24:14\n   |\n24 |         if s.is_punctuation() {\n\
    \   |              ^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii_punctuation`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let boredom\
    \ = vec![\"I\"];\n    let words = S.chars().map(|c| match c {\n        c if c.is_digit()\
    \ => c,\n        c if c.is_ascii_lowercase() => c + 1,\n        c if c.is_ascii_uppercase()\
    \ => c + 1,\n        _ => c,\n    }).collect();\n    words.iter().filter(|w| boredom.contains(&w)).count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp6zmm7riw.rs:12:16\n    |\n12  |         c if c.is_digit() => c,\n\
    \    |                ^^^^^^^^- supplied 0 arguments\n    |                |\n\
    \    |                expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp6zmm7riw.rs:13:42\n\
    \   |\n13 |         c if c.is_ascii_lowercase() => c + 1,\n   |              \
    \                          - ^ - {integer}\n   |                             \
    \           |\n   |                                        char\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmp6zmm7riw.rs:14:42\n   |\n14\
    \ |         c if c.is_ascii_uppercase() => c + 1,\n   |                      \
    \                  - ^ - {integer}\n   |                                     \
    \   |\n   |                                        char\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0369.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored_impl::<S::Item>()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpcmimgvcq.rs:11:1\n   |\n\
    10 |     if is_bored_impl::<S::Item>()\n   |     -- this `if` expression has a\
    \ condition, but no block\n11 | }\n   | ^ expected `{`\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ i = 0;\n    loop {\n        i = S.len();\n        S += String::from(\".\")[..i];\n\
    \        if S == String::from(\"I\") {\n            return i;\n        }\n   \
    \ }\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq0oij6oz.rs:13:14\n   |\n\
    13 |         S += String::from(\".\")[..i];\n   |              ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found `str`\n   |   \
    \           help: consider borrowing here: `&String::from(\".\")[..i]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq0oij6oz.rs:15:20\n   |\n15 |             return\
    \ i;\n   |                    ^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |             return i.try_into().unwrap();\n   |            \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ *c == '.' || c == '?' || c == '!').count() == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgtd_iyix.rs:10:41\n\
    \   |\n10 |     S.chars().filter(|c| *c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                         ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgtd_iyix.rs:10:53\n\
    \   |\n10 |     S.chars().filter(|c| *c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgtd_iyix.rs:10:5\n   |\n9  | fn\
    \ is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n10 |     S.chars().filter(|c| *c == '.' || c\
    \ == '?' || c == '!').count() == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    let mut words = S.split_whitespace();\n    let mut iter = words.iter();\n\
    \    let mut boredom = iter.next().unwrap();\n    while let Some(word) = {\n \
    \       if word == \"I\" {\n            count += 1;\n            boredom = Some(word);\n\
    \        } else {\n            iter = words.iter();\n            iter = iter.skip(1).peekable();\n\
    \            count += 1;\n            boredom = Some(iter.next().unwrap());\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `count`\n  --> /tmp/tmpdea_euyt.rs:25:5\n  \
    \ |\n14 |       while let Some(word) = {\n   |  _____-----_-\n   | |     |\n \
    \  | |     while parsing the body of this `while` expression\n15 | |         if\
    \ word == \"I\" {\n16 | |             count += 1;\n17 | |             boredom\
    \ = Some(word);\n...  |\n23 | |         }\n24 | |     }\n   | |_____- this `while`\
    \ condition successfully parsed\n25 |       count\n   |       ^^^^^ expected `{`\n\
    \   |\nhelp: try placing this code inside a block\n   |\n25 |     { count }\n\
    \   |     +       +\n\nerror[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpdea_euyt.rs:12:26\n   |\n12 |     let mut\
    \ iter = words.iter();\n   |                          ^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ bored = 0;\n    let mut start = 0;\n    for &s in S.split_whitespace() {\n \
    \       if s.starts_with(\"I\") {\n            if start > 0 {\n              \
    \  bored += 1;\n            }\n            start = s.len();\n        } else {\n\
    \            bored += s.len() - start;\n            start = 0;\n        }\n  \
    \  }\n    bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpo3jaqvv2.rs:12:10\n   |\n12 |     for &s in S.split_whitespace()\
    \ {\n   |          ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo3jaqvv2.rs:23:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n23 |     bored\n   |   \
    \  ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     bored.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.lines()\n\
    \        .map(|s| {\n            s.chars().filter(|c| c == '.' || c == '?' ||\
    \ c == '!').count() == 0\n        })\n        .sum::<bool>()\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzdlf2qdz.rs:12:36\n\
    \   |\n12 |             s.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                    ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpzdlf2qdz.rs:12:48\n   |\n12\
    \ |             s.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzdlf2qdz.rs:12:60\n\
    \   |\n12 |             s.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                                                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: the trait bound `bool: Sum` is not satisfied\n \
    \   --> /tmp/tmpzdlf2qdz.rs:14:10\n     |\n14   |         .sum::<bool>()\n   \
    \  |          ^^^ the trait `Sum` is not implemented for `bool`\n     |\n    \
    \ = help: the following other types implement trait `Sum<A>`:\n              \
    \ <Duration as Sum<&'a Duration>>\n               <Duration as Sum>\n        \
    \       <Option<T> as Sum<Option<U>>>\n               <Result<T, E> as Sum<Result<U,\
    \ E>>>\n               <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n     \
    \          <Simd<f32, LANES> as Sum>\n               <Simd<f64, LANES> as Sum<&'a\
    \ Simd<f64, LANES>>>\n               <Simd<f64, LANES> as Sum>\n             and\
    \ 72 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzdlf2qdz.rs:10:5\n   |\n9  |   fn is_bored(S:\
    \ String) -> isize {\n   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ cnt = 0;\n    let mut i = 1;\n    for s in S.split_whitespace() {\n        if\
    \ s == \"I\" {\n            i += 1;\n        } else {\n            cnt += i;\n\
    \            i = 0;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpv2mqdy7z.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = S.len();\n    let mut flag = false;\n\n    for ch in S {\n        match\
    \ ch {\n            '.' | '?' | '!' => flag = true,\n            _ => (),\n  \
    \      }\n\n        if flag {\n            count -= 1;\n        }\n    }\n\n \
    \   count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpbwnyqd16.rs:13:15\n\
    \   |\n13 |     for ch in S {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbwnyqd16.rs:24:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n24 |     count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |     count.try_into().unwrap()\n   |          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredoms = 0; // Boredoms starts at 0\n    let mut first = true; // Set to true\
    \ while scanning for the first 'I', or the first '.'\n    let mut last = 0; //\
    \ Last character of sentence that started the boredom\n    let mut sentence =\
    \ String::new(); // Temporary string to scan for the first 'I', or the first '.'\n\
    \    \n    S.chars().filter(|c| {\n        if first {\n            first = false;\n\
    \            return c.is_ascii_letter() || c == '.';\n        }\n        if c\
    \ == '.' {\n            last = c;\n            return false;\n        }\n    \
    \    if c == '?' || c == '!' {\n            return false;\n        }\n       \
    \ if last == 0 {\n            return true;\n        }\n        if last != 0 &&\
    \ last != c {\n            boredoms += 1; // Increase count for current boredom\n\
    \            last = 0; // Set last character to 0\n            return false;\n\
    \        }\n        \n        sentence = sentence.push(c);\n        return false;\n\
    \    }).count();\n    \n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpvysbs4iw.rs:18:22\n   |\n18 |          \
    \   return c.is_ascii_letter() || c == '.';\n   |                      ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpvysbs4iw.rs:18:45\n   |\n18\
    \ |             return c.is_ascii_letter() || c == '.';\n   |                \
    \                             ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpvysbs4iw.rs:20:14\n   |\n20 |         if\
    \ c == '.' {\n   |              ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvysbs4iw.rs:21:20\n   |\n12 |     let mut last = 0; //\
    \ Last character of sentence that started the boredom\n   |                  \
    \  - expected due to this value\n...\n21 |             last = c;\n   |       \
    \             ^ expected integer, found `&char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpvysbs4iw.rs:24:14\n   |\n24 |         if\
    \ c == '?' || c == '!' {\n   |              ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpvysbs4iw.rs:24:26\n   |\n24 |   \
    \      if c == '?' || c == '!' {\n   |                          ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvysbs4iw.rs:30:33\n   |\n30 |  \
    \       if last != 0 && last != c {\n   |                 "
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ is_bored_char(c)).count() as isize\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_bored_char` in this scope\n  -->\
    \ /tmp/tmp1qp_1llh.rs:10:26\n   |\n10 |     S.chars().filter(|c| is_bored_char(c)).count()\
    \ as isize\n   |                          ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    if is_bored(S)\
    \ == 1 {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = 0.0;\n    for (i, word) in S.chars().enumerate() {\n        if *word\
    \ == 'I' {\n            boredom = boredom + 1.0;\n        }\n    }\n    return\
    \ boredom;\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmptcla8bya.rs:12:12\n\
    \   |\n12 |         if *word == 'I' {\n   |            ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptcla8bya.rs:16:12\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n...\n16 |     return boredom;\n   |            ^^^^^^^ expected\
    \ `isize`, found floating-point number\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() > 3\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkbhqhykw.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 3\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpkbhqhykw.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 3\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpkbhqhykw.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 3\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkbhqhykw.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 3\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ counter = 0;\n    let mut words = S.split_whitespace();\n\n    for word in words\
    \ {\n        if word.to_lowercase() == \"i\" {\n            counter += 1;\n  \
    \      }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2egmwcne.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ count = 0;\n    let mut s = S;\n    loop {\n        if s.starts_with(\"I\")\
    \ {\n            break;\n        }\n        if let Some(pos) = s.find('.')? {\n\
    \            count += 1;\n            s = &s[pos..];\n        } else {\n     \
    \       break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the `?` operator can only be used in a function that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmpk1mkz0ey.rs:16:39\n   |\n9  | / fn is_bored(S: String) -> isize {\n\
    10 | |     let mut count = 0;\n11 | |     let mut s = S;\n12 | |     loop {\n\
    ...  |\n16 | |         if let Some(pos) = s.find('.')? {\n   | |             \
    \                          ^ cannot use the `?` operator in a function that returns\
    \ `isize`\n...  |\n23 | |     count\n24 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk1mkz0ey.rs:16:16\n\
    \   |\n16 |         if let Some(pos) = s.find('.')? {\n   |                ^^^^^^^^^\
    \   ------------ this expression has type `usize`\n   |                |\n   |\
    \                expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk1mkz0ey.rs:18:17\n   |\n11 |     let mut s = S;\n   |\
    \                 - expected due to this value\n...\n18 |             s = &s[pos..];\n\
    \   |                 ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n18 |             s = (&s[pos..]).to_string();\n\
    \   |                 +         +++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ boredom = 1;\n    let mut i = 0;\n    while i < S.len() {\n        if S[i] ==\
    \ \".\" || S[i] == \"?\" || S[i] == \"!\" {\n            boredom++;\n        }\n\
    \        i += 1;\n    }\n    boredom\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpq51zq6mn.rs:14:20\n\
    \   |\n14 |             boredom++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n14 |             { let tmp =\
    \ boredom; boredom += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    14 -             boredom++;\n14 +             boredom += 1;\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq51zq6mn.rs:13:12\n\
    \   |\n13 |         if S[i] == \".\" || S[i] == \"?\" || S[i] == \"!\" {\n   |\
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq51zq6mn.rs:13:27\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq51zq6mn.rs:13:42\n   |\n13 |         if S[i] == \".\" || S[i]\
    \ == \"?\" || S[i] == \"!\" {\n   |                                          ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: t"
  exit_code: 1
  status: SyntaxError
- program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(\"\
    Hello world\")\n/// 0\n/// >>> is_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut\
    \ is_bored = 0;\n    for word in S.split('.') {\n        let word = word.to_lowercase();\n\
    \        if word.starts_with(\"i\") {\n            is_bored += 1;\n        }\n\
    \    }\n    is_bored\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpjxy3471s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
