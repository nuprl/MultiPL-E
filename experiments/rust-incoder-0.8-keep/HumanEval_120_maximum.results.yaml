name: HumanEval_120_maximum
language: rust
results:
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![std::i32::MIN; k];\n    let len = arr.len();\n    for i in 0..len\
    \ {\n        let mut max_idx = 0;\n        let max_value = std::i32::MIN;\n  \
    \      for j in 0..k {\n            if arr[j] > max_value {\n                max_value\
    \ = arr[j];\n                max_idx = j;\n            }\n        }\n        if\
    \ max_idx < k {\n            res[max_idx] = max_value;\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ydkv_wh.rs:17:39\n   |\n\
    17 |     let mut res = vec![std::i32::MIN; k];\n   |                         \
    \              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut res = vec![std::i32::MIN; k.try_into().unwrap()];\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7ydkv_wh.rs:23:16\n\
    \   |\n23 |             if arr[j] > max_value {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7ydkv_wh.rs:24:29\n   |\n24 |  \
    \               max_value = arr[j];\n   |                             ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[i32]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7ydkv_wh.rs:29:13\n   |\n29 |  \
    \           res[max_idx] = max_value;\n   |             ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ydkv_wh.rs:32:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of retur"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|a,\
    \ b| b.cmp(a))\n        .take_while(|&x| x != 0)\n        .take_last(k)\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp820_0ypf.rs:18:10\n\
    \   |\n18 |         .take_while(|&x| x != 0)\n   |          ^^^^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_num = arr[0];\n    let mut max_idx = arr.len() - 1;\n\n    for idx in\
    \ arr.iter().rev().skip(k) {\n        if *idx > max_num {\n            max_idx\
    \ = idx;\n            max_num = *idx;\n        }\n    }\n\n    vec![max_num] +\
    \ vec![arr[max_idx]]\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtwub0ey.rs:20:38\n   |\n\
    20 |     for idx in arr.iter().rev().skip(k) {\n   |                         \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n20\
    \ |     for idx in arr.iter().rev().skip(k.try_into().unwrap()) {\n   |      \
    \                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxtwub0ey.rs:22:23\n   |\n18 |     let mut max_idx = arr.len()\
    \ - 1;\n   |                       ------------- expected due to this value\n\
    ...\n22 |             max_idx = idx;\n   |                       ^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0369]: cannot add `Vec<isize>` to `Vec<isize>`\n\
    \  --> /tmp/tmpxtwub0ey.rs:27:19\n   |\n27 |     vec![max_num] + vec![arr[max_idx]]\n\
    \   |     ------------- ^ ------------------ Vec<isize>\n   |     |\n   |    \
    \ Vec<isize>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // Your\
    \ code goes here\n    if arr.len() < k {\n        return vec![arr.iter().max().unwrap()];\n\
    \    }\n    if k == 1 {\n        return vec![arr.iter().max().unwrap()];\n   \
    \ }\n    let mut maxs = vec![arr.iter().max().unwrap()];\n    let mut maxidx =\
    \ maxs.iter().next().unwrap();\n    let mut newmaxs = vec![arr.iter().max().unwrap()];\n\
    \    let mut newmaxidx = maxs.iter().next().unwrap();\n    let mut newmaxs = vec![arr.iter().max().unwrap()];\n\
    \    let mut newmaxidx = maxs.iter().next().unwrap();\n    for i in 0..(arr.len()\
    \ - k) {\n        if arr[i] == arr[i] {\n            newmaxs[idx] = newmaxidx;\n\
    \            newmaxidx += 1;\n        } else {\n            if newmaxidx > newmaxs[idx]\
    \ {\n                newmaxs = vec![arr.iter().max().unwrap()];\n            \
    \    newmaxidx = maxs.iter().next().unwrap();\n            }\n            newmaxs[idx]\
    \ = arr[i];\n        }\n    }\n    newmaxidx = newmaxs.iter().next().unwrap();\n\
    \    for i in 0..(arr.len() - k) {\n        if arr[i] == newmaxidx {\n       \
    \     newmaxidx += 1;\n        } else {\n            if newmaxidx > newmaxs[idx]\
    \ {\n                newmaxs = vec![arr.iter().max().unwrap()];\n            \
    \    newmaxidx = maxs.iter().next().unwrap();\n            }\n            newmaxs[idx]\
    \ = arr[i];\n        }\n    }\n    newmaxidx = newmaxs.iter().next().unwrap();\n\
    \    for i in 0..(arr.len() - k) {\n        if arr[i] == newmaxidx {\n       \
    \     newmaxidx += 1;\n        } else {\n            if newmaxidx > newmaxs[idx]\
    \ {\n                newmaxs = vec![arr.iter().max().unwrap()];\n            \
    \    newmaxidx = maxs.iter().next().unwrap();\n            }\n            newmaxs[idx]\
    \ = arr[i];\n        }\n    }\n    newmaxidx = newmaxs.iter().next().unwrap();\n\
    \    for i in 0..(arr.len() - k) {\n        if arr[i] == newmaxidx {\n       \
    \     newmaxidx += 1;\n        } else {\n            if newmaxidx > newmaxs[idx]\
    \ {\n                newmaxs = vec![arr.iter().max().unwrap()];\n            \
    \    newmaxidx = maxs.iter().next().unwrap();\n            }\n            newmaxs[idx]\
    \ = arr[i];\n        }\n    }\n    newmaxidx = newmaxs.iter().next().unwrap();\n\
    \    for i in 0..(arr.len() - k) {\n        if arr[i] == newmaxidx {\n       \
    \     newmaxidx += 1;\n        } else {\n            if newmaxidx > \n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4fay0piy.rs:99:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n79\
    \ |     for i in 0..(arr.len() - k) {\n   |                                 -\
    \ unclosed delimiter\n...\n82 |         } else {\n   |                - this delimiter\
    \ might not be properly closed...\n83 |             if newmaxidx > \n84 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n99 | }\n\
    \   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp4fay0piy.rs:84:1\n\
    \   |\n84 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `idx`\
    \ in this scope\n  --> /tmp/tmp4fay0piy.rs:32:21\n   |\n32 |             newmaxs[idx]\
    \ = newmaxidx;\n   |                     ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `idx` in this scope\n  --> /tmp/tmp4fay0piy.rs:35:36\n   |\n\
    35 |             if newmaxidx > newmaxs[idx] {\n   |                         \
    \           ^^^ not found in this scope\n\nerror[E0425]: cannot find value `idx`\
    \ in this scope\n  --> /tmp/tmp4fay0piy.rs:39:21\n   |\n39 |             newmaxs[idx]\
    \ = arr[i];\n   |                     ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `idx` in this scope\n  --> /tmp/tmp4fay0piy.rs:47:36\n   |\n\
    47 |             if newmaxidx > newmaxs[idx] {\n   |                         \
    \           ^^^ not found in this scope\n\nerror[E0425]: cannot find value `idx`\
    \ in this scope\n  --> /tmp/tmp4fay0piy.rs:51:21\n   |\n51 |             newmaxs[idx]\
    \ = arr[i];\n   |                     ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `idx` in this scope\n  --> /tmp/tmp4fay0piy.rs:59:36\n   |\n\
    59 |             if newmaxidx > newmaxs[idx] {\n   |                         \
    \           ^^^ not found in this scope\n\nerror[E0425]: cannot find value `idx`\
    \ in this scope\n  --> /tmp/tmp4fay0piy.rs:63:21\n   |\n63 |             newmaxs[idx]\
    \ = arr[i];\n   |                     ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `idx` in this sco"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // write\
    \ your code here\n    let len = arr.len();\n    if k > len {\n        return vec![];\n\
    \    }\n    let mut max = arr[0];\n    let mut ans = vec![max];\n    for i in\
    \ 1..k {\n        if max > arr[i] {\n            max = arr[i];\n        }\n  \
    \      ans.push(max);\n    }\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk9vws6sn.rs:19:12\n   |\n\
    19 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpk9vws6sn.rs:25:18\n   |\n25 |         if max\
    \ > arr[i] {\n   |                  ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpk9vws6sn.rs:26:19\n   |\n26 |             max = arr[i];\n   | \
    \                  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ > arr.len() {\n        return arr;\n    }\n\n    let mut max = arr[0];\n   \
    \ for i in 1 .. k {\n        if max < arr[i] {\n            max = arr[i];\n  \
    \      }\n    }\n\n    let mut ret = Vec::new();\n    for i in 0 .. k {\n    \
    \    if arr[i] > max {\n            ret.push(max);\n            max = arr[i];\n\
    \        } else {\n            ret.push(arr[i]);\n        }\n    }\n    ret.push(max);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo1mzbh9f.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpo1mzbh9f.rs:23:18\n   |\n23 |  \
    \       if max < arr[i] {\n   |                  ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo1mzbh9f.rs:24:19\n   |\n24 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpo1mzbh9f.rs:30:12\n   |\n30 |         if arr[i]\
    \ > max {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpo1mzbh9f.rs:32:19\n   |\n32 |             max = arr[i];\n   | \
    \                  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is im"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result: Vec<isize> = vec![];\n    if arr.len() < k || arr.len() > k {\n\
    \        return result;\n    }\n    let mut max_arr = arr[0..k];\n    let mut\
    \ min_arr = arr[0..k];\n    let mut flag = true;\n    for i in 0..k {\n      \
    \  if max_arr[i] > min_arr[i] {\n            max_arr[i] = max_arr[i] + min_arr[i];\n\
    \        } else {\n            max_arr[i] = min_arr[i];\n            flag = false;\n\
    \        }\n    }\n    for i in 0..k {\n        if flag {\n            if max_arr[i]\
    \ > max_arr[i + 1] {\n                max_arr[i] = max_arr[i + 1];\n         \
    \   }\n        } else {\n            if min_arr[i] < min_arr[i + 1] {\n      \
    \          min_arr[i] = min_arr[i + 1];\n            }\n        }\n    }\n   \
    \ for i in 0..k {\n        result.push(max_arr[i]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu8uwnfqi.rs:18:20\n   |\n\
    18 |     if arr.len() < k || arr.len() > k {\n   |                    ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     if arr.len() <\
    \ k.try_into().unwrap() || arr.len() > k {\n   |                     ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu8uwnfqi.rs:18:37\n   |\n18 |\
    \     if arr.len() < k || arr.len() > k {\n   |                              \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n18 |     if\
    \ arr.len() < k || arr.len() > k.try_into().unwrap() {\n   |                 \
    \                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpu8uwnfqi.rs:21:23\n\
    \   |\n21 |     let mut max_arr = arr[0..k];\n   |                       ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpu8uwnfqi.rs:22:23\n\
    \   |\n22 |     let mut min_arr = arr[0..k];\n   |                       ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::R"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // Solution\
    \ 1 \n    // var result: Vec<isize> = vec![std::i32::MAX; k];\n    // for (i,\
    \ val) in arr.iter().enumerate() {\n    //     if val > result[k - i] { result[k]\
    \ = val }\n    // }\n    // return result;\n\n    // Solution 2 \n    let mut\
    \ result: Vec<isize> = vec![std::i32::MAX; k];\n    for i in 0..arr.len() {\n\
    \        if arr[i] > result[k - i] {\n            result[k] = arr[i]\n       \
    \ } else {\n            result[k] += arr[i]\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplqk5dwsd.rs:25:39\n   |\n\
    25 |     let mut result: Vec<isize> = vec![std::i32::MAX; k];\n   |          \
    \                             ^^^^^^^^^^^^^ expected `isize`, found `i32`\n  \
    \ |\nhelp: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n25 |     let mut result: Vec<isize> = vec![std::i32::MAX.try_into().unwrap();\
    \ k];\n   |                                                    ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplqk5dwsd.rs:25:54\n   |\n25 |\
    \     let mut result: Vec<isize> = vec![std::i32::MAX; k];\n   |             \
    \                                         ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |     let mut result: Vec<isize> = vec![std::i32::MAX;\
    \ k.try_into().unwrap()];\n   |                                              \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplqk5dwsd.rs:27:32\n\
    \   |\n27 |         if arr[i] > result[k - i] {\n   |                        \
    \        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize`\
    \ from `isize`\n  --> /tmp/tmplqk5dwsd.rs:27:30\n   |\n27 |         if arr[i]\
    \ > result[k - i] {\n   |                              ^ no implementation for\
    \ `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmplqk5dwsd.rs:27:21\n   |\n27 |         if arr[i] > result[k - i]\
    \ {\n   |                     ^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the tra"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|a,\
    \ b| a.cmp(b).reverse())\n        .take_while(|&x| x < k)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpgxhf6oiw.rs:18:10\n\
    \   |\n18 |         .take_while(|&x| x < k)\n   |          ^^^^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![Vec::new(); k];\n    let mut i = k;\n    while i < arr.len()\
    \ {\n        result[i] = if arr[i] > result[i-1] {arr[i]} else {result[i-1]};\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9qq8yrn.rs:17:39\n   |\n\
    17 |     let mut result = vec![Vec::new(); k];\n   |                         \
    \              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut result = vec![Vec::new(); k.try_into().unwrap()];\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9qq8yrn.rs:19:15\n   |\n19 |     while i < arr.len() {\n\
    \   |               ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |     while i < arr.len().try_into().unwrap() {\n   |        \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpb9qq8yrn.rs:20:9\n   |\n20 |         result[i]\
    \ = if arr[i] > result[i-1] {arr[i]} else {result[i-1]};\n   |         ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<_>]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<Vec<_>>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpb9qq8yrn.rs:20:24\n\
    \   |\n20 |         result[i] = if arr[i] > result[i-1] {arr[i]} else {result[i-1]};\n\
    \   |                        ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<_>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpb9qq8yrn.rs:20:33\n   |\n20 |         result[i] = if arr[i] > result[i-1]\
    \ {arr[i]} else {result[i-1]};\n   |                                 ^^^^^^^^^^^\
    \ slice indices are of type `"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.is_empty() {\n        vec![]\n    } else if arr.len() == 1 {\n \
    \       vec![arr[0]]\n    } else {\n        let mut max_so_far = arr[0];\n   \
    \     let mut max_so_far_k = 0;\n        for elem in arr.iter().rev() {\n    \
    \        if elem > max_so_far {\n                max_so_far = elem;\n        \
    \        max_so_far_k = 0;\n            }\n            if max_so_far_k == k {\n\
    \                break;\n            }\n            max_so_far_k++;\n        }\n\
    \        vec![max_so_far]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp00t4yslf.rs:32:25\n\
    \   |\n32 |             max_so_far_k++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n32 |         \
    \    { let tmp = max_so_far_k; max_so_far_k += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n32 -             max_so_far_k++;\n32\
    \ +             max_so_far_k += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp00t4yslf.rs:25:23\n   |\n25 |             if elem > max_so_far\
    \ {\n   |                       ^^^^^^^^^^\n   |                       |\n   |\
    \                       expected `&isize`, found `isize`\n   |               \
    \        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp00t4yslf.rs:26:30\n   |\n22 |         let mut max_so_far\
    \ = arr[0];\n   |                              ------ expected due to this value\n\
    ...\n26 |                 max_so_far = elem;\n   |                           \
    \   ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |                 max_so_far = *elem;\n   |           \
    \                   +\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let len = arr.len();\n\n    // Step 1: Sort the\
    \ elements to reduce the complexity.\n    let mut tmp_arr = arr.iter().cloned();\n\
    \    tmp_arr.sort_unstable();\n    result.extend_from_slice(&tmp_arr[0..k - 1])\n\
    \    \n    // Step 2: Fill in the remaining elements.\n    for i in 0..k - 1 {\n\
    \        let mut max_val = max_or_default(&tmp_arr[0..len]);\n        result.append(&mut\
    \ max_val);\n    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpe2pov1mj.rs:23:49\n\
    \   |\n23 |     result.extend_from_slice(&tmp_arr[0..k - 1])\n   |           \
    \                                      ^ help: add `;` here\n...\n26 |     for\
    \ i in 0..k - 1 {\n   |     --- unexpected token\n\nerror[E0425]: cannot find\
    \ function `max_or_default` in this scope\n  --> /tmp/tmpe2pov1mj.rs:27:27\n \
    \  |\n27 |         let mut max_val = max_or_default(&tmp_arr[0..len]);\n   | \
    \                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `sort_unstable` found for struct `Cloned` in the current scope\n\
    \  --> /tmp/tmpe2pov1mj.rs:22:13\n   |\n22 |     tmp_arr.sort_unstable();\n  \
    \ |             ^^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0608]: cannot index into a value of type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmpe2pov1mj.rs:23:31\n   |\n23 |     result.extend_from_slice(&tmp_arr[0..k\
    \ - 1])\n   |                               ^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Cloned<std::slice::Iter<'_, isize>>`\n  -->\
    \ /tmp/tmpe2pov1mj.rs:27:43\n   |\n27 |         let mut max_val = max_or_default(&tmp_arr[0..len]);\n\
    \   |                                           ^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![]; k];\n\n    for i in 0..k {\n        let mut temp:\
    \ Vec<isize> = arr;\n        temp = temp.iter().take_while(|&x| x > 0).collect();\n\
    \        result.push(temp.max().unwrap());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv6vlmd5t.rs:17:35\n   |\n\
    17 |     let mut result = vec![vec![]; k];\n   |                             \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![vec![]; k.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv6vlmd5t.rs:21:48\n   |\n21 |         temp = temp.iter().take_while(|&x|\
    \ x > 0).collect();\n   |                                                ^\n \
    \  |                                                |\n   |                  \
    \                              expected `&isize`, found integer\n   |        \
    \                                        help: consider borrowing here: `&0`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpv6vlmd5t.rs:21:51\n     |\n\
    21   |         temp = temp.iter().take_while(|&x| x > 0).collect();\n     |  \
    \                                                 ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpv6vlmd5t.rs:22:26\n    |\n22  |  \
    \       result.push(temp.max().unwrap());\n    |                          ^^^-\
    \ supplied 0 arguments\n    |                          |\n    |              \
    \            expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `unwrap` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpv6vlmd5t.rs:22:32\n   |\n22 |         result.push(temp.max().unwrap());\n\
    \   |                                ^^^^^^ help: there is an associated function\
    \ with a similar name: `swap`\n\nerror[E0308]: mismatched ty"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr: Vec<isize> = vec![];\n    let mut max_value: isize = std::i32::MAX;\n\
    \    let mut cur_max = std::i32::MIN;\n    \n    for i in arr.iter() {\n     \
    \   if i < cur_max {\n            max_arr.push(i);\n            max_value = i;\n\
    \        }\n        if i > cur_max {\n            max_value = std::i32::MIN;\n\
    \        }\n        cur_max = i;\n    }\n\n    if k <= max_arr.len() {\n     \
    \   max_arr.sort();\n        for a in &mut max_arr[k..] {\n            max_arr.remove(a);\n\
    \        }\n        return max_arr;\n    } else {\n        return vec![];\n  \
    \  }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:18:32\n   |\n\
    18 |     let mut max_value: isize = std::i32::MAX;\n   |                     \
    \   -----   ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |                \
    \        |\n   |                        expected due to this\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |     let mut max_value: isize = std::i32::MAX.try_into().unwrap();\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:22:16\n   |\n22 |         if i <\
    \ cur_max {\n   |                ^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:23:26\n   |\n23 |             max_arr.push(i);\n\
    \   |                          ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n23 |             max_arr.push(*i);\n\
    \   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:24:25\n\
    \   |\n18 |     let mut max_value: isize = std::i32::MAX;\n   |              \
    \          ----- expected due to this type\n...\n24 |             max_value =\
    \ i;\n   |                         ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n24 |             max_value = *i;\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:26:16\n\
    \   |\n26 |         if i > cur_max {\n   |                ^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:27:25\n\
    \   |\n18 |     let mut max_value: isize = std::i32::MAX;\n   |              \
    \          ----- expected due to this type\n...\n27 |             max_value =\
    \ std::i32::MIN;\n   |                         ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4lzfn7ww.rs:29:19\n\
    \   |\n19 |     let mut cur_max = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n29 |         cur_max = i;\n   |           \
    \        ^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ len = arr.len();\n    let mut result = Vec::with_capacity(k);\n    let mut cur_max\
    \ = std::i32::MAX;\n    let mut cur = 0;\n    for (i, el) in arr.iter().enumerate()\
    \ {\n        cur_max = el if el > cur_max { cur_max = el };\n        if i >= k\
    \ {\n            result[cur..cur + i - k].sort();\n            cur += i - k;\n\
    \        }\n    }\n    result[cur..].sort();\n    result\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpypsygoc3.rs:22:22\n   |\n22 |         cur_max\
    \ = el if el > cur_max { cur_max = el };\n   |                      ^^ expected\
    \ one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpypsygoc3.rs:18:41\n\
    \   |\n18 |     let mut result = Vec::with_capacity(k);\n   |                \
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     let mut result = Vec::with_capacity(k.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        return arr;\n    }\n    let mut n = arr.len();\n    let mut\
    \ max = arr[k..k+k];\n    for i in 0..k-1 {\n        if max[i] > max[i+1] {\n\
    \            max = arr[k..k+k];\n        } else {\n            max = max[i];\n\
    \        }\n    }\n    let mut res = vec![max[k..n-1]];\n    for i in k..n {\n\
    \        if max[i] > res[k] {\n            res[k] = max[i];\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbtys45nr.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpbtys45nr.rs:21:19\n\
    \   |\n21 |     let mut max = arr[k..k+k];\n   |                   ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpbtys45nr.rs:24:19\n\
    \   |\n24 |             max = arr[k..k+k];\n   |                   ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbtys45nr.rs:29:31\n   |\n29 |     let mut res = vec![max[k..n-1]];\n\
    \   |                               ^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbtys45nr.rs:30:17\n   |\n30 |     for i in k..n\
    \ {\n   |                 ^ expected `isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpbtys45nr.rs:31:21\n \
    \  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut l = arr;\n    for i in (0..k).rev() {\n        l = l.iter().max_by_key(|&x|\
    \ *x).unwrap();\n    }\n    l\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwmrnmxh.rs:19:13\n   |\n\
    17 |     let mut l = arr;\n   |                 --- expected due to this value\n\
    18 |     for i in (0..k).rev() {\n19 |         l = l.iter().max_by_key(|&x| *x).unwrap();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ reference `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut largest = arr[0];\n    for i in 1..k {\n        if arr[i] > largest {\n\
    \            largest = arr[i];\n        }\n    }\n    vec![largest]\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpv4i4byoh.rs:19:12\n\
    \   |\n19 |         if arr[i] > largest {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpv4i4byoh.rs:20:23\n   |\n20 |            \
    \ largest = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max: isize = arr[0];\n    let mut max_index = 0;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n < max {\n            max = n;\n            max_index = i;\n\
    \        }\n    }\n\n    let mut max_arr: Vec<isize> = Vec::new();\n    max_arr.push(arr[max_index]);\n\
    \n    let mut next_index = 0;\n    for i in 0..k {\n        let mut next_max =\
    \ max;\n        let mut next_max_index = 0;\n\n        for (j, m) in arr.iter().enumerate()\
    \ {\n            if m < next_max {\n                next_max = m;\n          \
    \      next_max_index = j;\n            }\n        }\n\n        if next_max_index\
    \ > max_index {\n            max_arr.push(arr[next_max_index]);\n            next_index\
    \ = next_max_index;\n        } else {\n            break;\n        }\n    }\n\n\
    \    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg8abt1j5.rs:20:16\n   |\n\
    20 |         if n < max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8abt1j5.rs:21:19\n\
    \   |\n17 |     let mut max: isize = arr[0];\n   |                  ----- expected\
    \ due to this type\n...\n21 |             max = n;\n   |                   ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |             max = *n;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg8abt1j5.rs:35:20\n   |\n35 |             if m < next_max\
    \ {\n   |                    ^^^^^^^^\n   |                    |\n   |       \
    \             expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&next_max`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg8abt1j5.rs:36:28\n   |\n31 |         let mut next_max = max;\n   |\
    \                            --- expected due to this value\n...\n36 |       \
    \          next_max = m;\n   |                            ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |  \
    \               next_max = *m;\n   |                            +\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        return arr;\n    }\n    let mut max_arr = arr[0..k].iter().max().unwrap_or(-isize::MAX);\n\
    \    let mut max_idx = arr.iter().position(|&x| x == max_arr).unwrap();\n    \n\
    \    for e in &arr[k..] {\n        if *e > max_arr {\n            max_arr = e;\n\
    \            max_idx = k - 1;\n        }\n    }\n    \n    vec![max_arr]\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps34lsh3n.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmps34lsh3n.rs:20:23\n\
    \   |\n20 |     let mut max_arr = arr[0..k].iter().max().unwrap_or(-isize::MAX);\n\
    \   |                       ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `std::ops::Range<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<isize>>` for\
    \ `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmps34lsh3n.rs:23:15\n   |\n23 |     for e in &arr[k..] {\n   |  \
    \             ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeFrom<usize> as SliceIndex<[T]>>\n             <RangeFrom<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps34lsh3n.rs:26:23\n   |\n21 |     let mut max_idx = arr.iter().position(|&x|\
    \ x == max_arr).unwrap();\n   |                       -----------------------------------------------\
    \ expected due to this value\n...\n26 |             max_idx = k - 1;\n   |   \
    \                    ^^^^^ expected `usize`, found `isize`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanati"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        arr\n    } else {\n        let mut max_nums = arr.split_off(arr.len()\
    \ - k);\n        max_nums.sort_by(|a, b| a.partial_cmp(b).unwrap());\n       \
    \ arr[..k]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_c2xcs_i.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_c2xcs_i.rs:20:54\n   |\n20 |         let mut max_nums\
    \ = arr.split_off(arr.len() - k);\n   |                                      \
    \                ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract\
    \ `isize` from `usize`\n  --> /tmp/tmp_c2xcs_i.rs:20:52\n   |\n20 |         let\
    \ mut max_nums = arr.split_off(arr.len() - k);\n   |                         \
    \                           ^ no implementation for `usize - isize`\n   |\n  \
    \ = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmp_c2xcs_i.rs:22:9\n\
    \   |\n22 |         arr[..k]\n   |         ^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `RangeTo<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeTo<usize> as SliceIndex<[T]>>\n\
    \             <RangeTo<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeTo<isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = vec![std::i32::MAX;k];\n    for i in 0..arr.len() {\n        let mut\
    \ t = max.clone();\n        for t in arr {\n            if *t > i {\n        \
    \        break;\n            }\n        }\n        max[k] = i;\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsc7aqpx_.rs:17:38\n   |\n\
    17 |     let mut max = vec![std::i32::MAX;k];\n   |                          \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n17\
    \ |     let mut max = vec![std::i32::MAX;k.try_into().unwrap()];\n   |       \
    \                                ++++++++++++++++++++\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpsc7aqpx_.rs:21:16\n   |\n21 |        \
    \     if *t > i {\n   |                ^^\n\nerror[E0277]: the type `[i32]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpsc7aqpx_.rs:25:9\n   |\n25 |         max[k]\
    \ = i;\n   |         ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[i32]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsc7aqpx_.rs:27:5\n   |\n16 | fn\
    \ maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |                   \
    \                       ---------- expected `Vec<isize>` because of return type\n\
    ...\n27 |     max\n   |     ^^^ expected `isize`, found `i32`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<i32>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = vec![vec![vec![0, 0]; k]; arr.len()];\n    for i in 0..(arr.len()\
    \ - 1) {\n        for j in 0..k {\n            max[i][j] = if arr[i] > arr[j]\
    \ {\n                arr[i]\n            } else {\n                arr[j]\n  \
    \          };\n        }\n    }\n    return max;\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeyrplgtx.rs:17:41\n   |\n\
    17 |     let mut max = vec![vec![vec![0, 0]; k]; arr.len()];\n   |           \
    \                              ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     let mut max = vec![vec![vec![0, 0]; k.try_into().unwrap()];\
    \ arr.len()];\n   |                                          ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpeyrplgtx.rs:20:13\n   |\n20 |             max[i][j] = if arr[i] > arr[j]\
    \ {\n   |             ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpeyrplgtx.rs:20:37\n   |\n20 |             max[i][j]\
    \ = if arr[i] > arr[j] {\n   |                                     ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpeyrplgtx.rs:23:17\n   |\n23 |  \
    \               arr[j]\n   |                 ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeyrplgtx.rs:27:12\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ > k {\n        return arr.iter().take(k).collect();\n    }\n\n    let mut maximum\
    \ = arr[0] as isize;\n    for x in arr.iter().skip(1) {\n        if maximum >\
    \ x {\n            maximum = x;\n        }\n    }\n    return vec![maximum];\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5fm0m16.rs:17:20\n   |\n\
    17 |     if arr.len() > k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() > k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp5fm0m16.rs:18:32\n   |\n18 |         return arr.iter().take(k).collect();\n\
    \   |                                ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |         return arr.iter().take(k.try_into().unwrap()).collect();\n\
    \   |                                 ++++++++++++++++++++\n\nerror[E0277]: a\
    \ value of type `Vec<isize>` cannot be built from an iterator over elements of\
    \ type `&isize`\n    --> /tmp/tmpp5fm0m16.rs:18:35\n     |\n18   |         return\
    \ arr.iter().take(k).collect();\n     |                                   ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp5fm0m16.rs:23:22\n   |\n23 |         if maximum > x {\n   |       \
    \               ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |         if maximum > *x {\n   |                     \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp5fm0m16.rs:24:23\n   |\n\
    21 |     let mut maximum = arr[0] as isize;\n   |                       ---------------\
    \ expected due to this value\n...\n24 |             maximum = x;\n   |       \
    \                ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |             maximum = *x;\n   |                     \
    \  +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E03"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_list = vec![];\n    let mut max_list_len = k + 1;\n    for i in 0..k\
    \ {\n        if let Some(max) = arr.rev().iter().take(max_list_len).max_by_key(|x|\
    \ *x) {\n            max_list.push(max);\n            max_list_len += 1;\n   \
    \     }\n    }\n    max_list\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpdejpy9dm.rs:20:32\n\
    \    |\n20  |           if let Some(max) = arr.rev().iter().take(max_list_len).max_by_key(|x|\
    \ *x) {\n    |                                  ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut largest = arr\n        .windows(k)\n        .filter(|&x| x >= 0)\n     \
    \   .max_by_key(|x| x);\n    largest.clone_from_slice(&arr[0..k]);\n    largest\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmovfmfep.rs:18:18\n   |\n\
    18 |         .windows(k)\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         .windows(k.try_into().unwrap())\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpmovfmfep.rs:19:27\n   |\n19 |         .filter(|&x| x >= 0)\n   |\
    \                           ^ expected `&[isize]`, found integer\n\nerror[E0599]:\
    \ no method named `clone_from_slice` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpmovfmfep.rs:21:13\n   |\n21 |     largest.clone_from_slice(&arr[0..k]);\n\
    \   |             ^^^^^^^^^^^^^^^^ method not found in `Option<&[isize]>`\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmpmovfmfep.rs:21:31\n   |\n21 |     largest.clone_from_slice(&arr[0..k]);\n\
    \   |                               ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `std::ops::Range<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<isize>>` for\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmovfmfep.rs:22:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     largest\n   |     ^^^^^^^ expected struct `Vec`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \         found enum `Option<&[isize]>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ <= arr.len() {\n        // sorting the array in descending order first, then\
    \ select top k\n        arr.sort_by(|a, b| b.cmp(&a).reverse().unwrap());\n  \
    \      arr[0..k].collect()\n    } else {\n        vec![]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw3z29h4m.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n  -->\
    \ /tmp/tmpw3z29h4m.rs:19:48\n   |\n19 |         arr.sort_by(|a, b| b.cmp(&a).reverse().unwrap());\n\
    \   |                                                ^^^^^^ method not found in\
    \ `std::cmp::Ordering`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `std::ops::Range<isize>`\n  --> /tmp/tmpw3z29h4m.rs:20:9\n   |\n20 |       \
    \  arr[0..k].collect()\n   |         ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `std::ops::Range<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<isize>>` for\
    \ `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    for e in arr.iter() {\n        if result.len() <=\
    \ k {\n            result.push(e);\n            continue;\n        }\n       \
    \ if e > result[k] {\n            result[k] = e;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_wc4xbm.rs:19:28\n   |\n\
    19 |         if result.len() <= k {\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         if result.len()\
    \ <= k.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[&isize]` cannot be indexed by `isize`\n  --> /tmp/tmpc_wc4xbm.rs:23:16\n\
    \   |\n23 |         if e > result[k] {\n   |                ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<&isize>`\n\nerror[E0277]: the type `[&isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc_wc4xbm.rs:24:13\n   |\n24 |         \
    \    result[k] = e;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_wc4xbm.rs:27:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n27 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|a,\
    \ b| b.cmp_max(&a))\n        .take(k)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `cmp_max` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpwwmtpsui.rs:17:26\n   |\n17 |     arr.sort_by(|a,\
    \ b| b.cmp_max(&a))\n   |                          ^^^^^^^ method not found in\
    \ `&isize`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpwwmtpsui.rs:18:10\n\
    \   |\n18 |         .take(k)\n   |          ^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        return vec![];\n    }\n    let mut max_num = arr[0];\n    for\
    \ num in arr {\n        if num > max_num {\n            max_num = num;\n     \
    \   }\n    }\n    arr.sort_by(|x, y| {\n        if x == -1 {\n            return\
    \ -1;\n        }\n        if y > -1 {\n            return -1;\n        }\n   \
    \     if x < y {\n            return 1;\n        }\n        if x > y {\n     \
    \       return 1;\n        }\n        return 0;\n    });\n    let mut result =\
    \ vec![max_num; k];\n    if arr.len() <= k {\n        for elem in arr.iter() {\n\
    \            result.push(elem);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7klad2nu.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmp7klad2nu.rs:27:14\n   |\n27 |     \
    \    if x == -1 {\n   |              ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7klad2nu.rs:28:20\n\
    \   |\n28 |             return -1;\n   |                    ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7klad2nu.rs:30:16\n\
    \   |\n30 |         if y > -1 {\n   |                ^^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&-1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7klad2nu.rs:41:36\n\
    \   |\n41 |     let mut result = vec![max_num; k];\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    41 |     let mut result = vec![max_num; k.try_into().unwrap()];\n   |        \
    \                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7klad2nu.rs:42:21\n   |\n42 |     if arr.len() <= k {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n42 |     if arr.len() <= k.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E030"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    \n \
    \   let mut max_array: Vec<isize> = Vec::with_capacity(k)\n    let mut index:\
    \ usize = 0\n    \n    while index < k {\n        let max_value: isize\n     \
    \       \n        max_value = max_array[index].min(&arr[index])\n        max_array.push(max_value)\n\
    \        \n        index += 1\n    }\n    \n    max_array\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpnlwc3b1d.rs:18:58\n\
    \   |\n18 |     let mut max_array: Vec<isize> = Vec::with_capacity(k)\n   |  \
    \                                                        ^ help: add `;` here\n\
    19 |     let mut index: usize = 0\n   |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `while`\n  --> /tmp/tmpnlwc3b1d.rs:19:29\n   |\n19 |    \
    \ let mut index: usize = 0\n   |                             ^ help: add `;` here\n\
    20 |     \n21 |     while index < k {\n   |     ----- unexpected token\n\nerror:\
    \ expected `;`, found `max_value`\n  --> /tmp/tmpnlwc3b1d.rs:22:29\n   |\n22 |\
    \         let max_value: isize\n   |                             ^ help: add `;`\
    \ here\n23 |             \n24 |         max_value = max_array[index].min(&arr[index])\n\
    \   |         --------- unexpected token\n\nerror: expected `;`, found `max_array`\n\
    \  --> /tmp/tmpnlwc3b1d.rs:24:54\n   |\n24 |         max_value = max_array[index].min(&arr[index])\n\
    \   |                                                      ^ help: add `;` here\n\
    25 |         max_array.push(max_value)\n   |         --------- unexpected token\n\
    \nerror: expected `;`, found `index`\n  --> /tmp/tmpnlwc3b1d.rs:25:34\n   |\n\
    25 |         max_array.push(max_value)\n   |                                 \
    \ ^ help: add `;` here\n26 |         \n27 |         index += 1\n   |         -----\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnlwc3b1d.rs:18:56\n\
    \   |\n18 |     let mut max_array: Vec<isize> = Vec::with_capacity(k)\n   |  \
    \                                                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     let mut max_array: Vec<isize> =\
    \ Vec::with_capacity(k.try_into().unwrap())\n   |                            \
    \                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnlwc3b1d.rs:21:19\n   |\n21 |     while index < k {\n \
    \  |                   ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and p"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ret = vec![None; k];\n    for i in 0..k {\n        let max = *arr.iter().max_unwrap_or(arr.len());\n\
    \        ret[i] = *&arr[max];\n        arr.retain(|x| x > i);\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3yrga0e5.rs:17:30\n   |\n\
    17 |     let mut ret = vec![None; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut ret = vec![None;\
    \ k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `max_unwrap_or` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp3yrga0e5.rs:19:31\n   |\n19 |         let\
    \ max = *arr.iter().max_unwrap_or(arr.len());\n   |                          \
    \     ^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0277]:\
    \ the type `[Option<_>]` cannot be indexed by `isize`\n  --> /tmp/tmp3yrga0e5.rs:20:9\n\
    \   |\n20 |         ret[i] = *&arr[max];\n   |         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Option<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Option<_>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3yrga0e5.rs:21:28\n   |\n21 |         arr.retain(|x| x > i);\n   | \
    \                           ^\n   |                            |\n   |       \
    \                     expected `&isize`, found `isize`\n   |                 \
    \           help: consider borrowing here: `&i`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3yrga0e5.rs:23:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n23 |     ret\n   |     ^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<_>>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ == 0 || k == 0 {\n        return vec![];\n    }\n\n    let mut max = arr[0];\n\
    \    let mut i = 1;\n\n    // The first time we find the max num, we will update\
    \ max and i\n    // so that later we can move the min num to the front\n    while\
    \ i < arr.len() {\n        if arr[i] > max {\n            max = arr[i];\n    \
    \    }\n        i += 1;\n    }\n\n    let mut new_arr = vec![max];\n\n    // We\
    \ will do the rest after we find the max num\n    while i < arr.len() {\n    \
    \    // If the max is less than the max of next num\n        if arr[i] > max {\n\
    \            // We will append max and arr[i] to new_arr\n            new_arr.push(max);\n\
    \            new_arr.push(arr[i]);\n        }\n        // If arr[i] is equal to\
    \ max, we just append arr[i]\n        // to the new_arr\n        else {\n    \
    \        new_arr.push(arr[i]);\n        }\n        i += 1;\n    }\n\n    // Return\
    \ the new_arr which has max k numbers in it\n    new_arr.drain(..k);\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `RangeTo<isize>: RangeBounds<usize>` is not\
    \ satisfied\n    --> /tmp/tmpozyxi712.rs:52:19\n     |\n52   |     new_arr.drain(..k);\n\
    \     |             ----- ^^^ the trait `RangeBounds<usize>` is not implemented\
    \ for `RangeTo<isize>`\n     |             |\n     |             required by a\
    \ bound introduced by this call\n     |\n     = help: the following other types\
    \ implement trait `RangeBounds<T>`:\n               RangeTo<&T>\n            \
    \   RangeTo<T>\nnote: required by a bound in `Vec::<T, A>::drain`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpozyxi712.rs:16:42\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |    -------                     \
    \          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr: Vec<isize> = vec![];\n    for i in 0..k {\n        max_arr.push(arr[0]);\n\
    \    }\n    for i in 1..arr.len() {\n        let max_element = max_arr[k - i];\n\
    \        max_arr.push(*max_element) if (max_element != arr[i]);\n    }\n    max_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpu2jcvuey.rs:23:36\n   |\n23 |         max_arr.push(*max_element)\
    \ if (max_element != arr[i]);\n   |                                    ^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu2jcvuey.rs:22:39\n   |\n22 |         let max_element = max_arr[k\
    \ - i];\n   |                                       ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpu2jcvuey.rs:22:37\n\
    \   |\n22 |         let max_element = max_arr[k - i];\n   |                  \
    \                   ^ no implementation for `isize - usize`\n   |\n   = help:\
    \ the trait `Sub<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpu2jcvuey.rs:22:27\n  \
    \ |\n22 |         let max_element = max_arr[k - i];\n   |                    \
    \       ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ > k {\n        maximum_recursive(arr, k)\n    } else {\n        vec![arr[0]]\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `maximum_recursive` in this scope\n\
    \  --> /tmp/tmpvnsghhfx.rs:18:9\n   |\n18 |         maximum_recursive(arr, k)\n\
    \   |         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvnsghhfx.rs:17:20\n   |\n17 |     if arr.len() > k {\n\
    \   |                    ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     if arr.len() > k.try_into().unwrap() {\n   |                 \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = arr[0];\n    let mut max_i = 1;\n    for i in 0..arr.len() {\n   \
    \     if arr[i] > max {\n            max = arr[i];\n            max_i = i;\n \
    \       }\n    }\n    let mut result = vec![max];\n    let mut rest = vec![max];\n\
    \    for i in (0..k).rev() {\n        if rest == vec![max] {\n            result.push(max);\n\
    \            break;\n        }\n        let mut cur_max = arr[i];\n        for\
    \ j in 0..max_i {\n            if arr[j] > cur_max {\n                cur_max\
    \ = arr[j];\n            }\n        }\n        rest.push(cur_max);\n        result.push(rest);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpaudbqutl.rs:32:27\n\
    \   |\n32 |         let mut cur_max = arr[i];\n   |                          \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaudbqutl.rs:39:21\n   |\n39 |         result.push(rest);\n\
    \   |                     ^^^^ expected `isize`, found struct `Vec`\n   |\n  \
    \ = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_unstable();\n\
    \    arr.take(k)\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpvo5sjwjm.rs:18:9\n\
    \    |\n18  |       arr.take(k)\n    |           ^^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_vec: Vec<isize> = vec![];\n    max_vec.push(arr[0]); // push the first\
    \ element to the max vector\n    max_vec.push(arr[arr.len() - 1]);\n\n    let\
    \ mut max_index: usize = 0;\n    let mut current_max = max_vec[0];\n    for current_index\
    \ in range(1, arr.len()) {\n        current_max = current_max * max_index + arr[current_index];\n\
    \        if current_index == k {\n            max_vec.push(current_max);\n   \
    \         max_index = current_index + 1;\n        }\n    }\n\n    max_vec\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpwt65hogz.rs:23:26\n\
    \   |\n23 |     for current_index in range(1, arr.len()) {\n   |             \
    \             ^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwt65hogz.rs:24:37\n   |\n24 |         current_max = current_max\
    \ * max_index + arr[current_index];\n   |                                    \
    \ ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize`\
    \ by `usize`\n  --> /tmp/tmpwt65hogz.rs:24:35\n   |\n24 |         current_max\
    \ = current_max * max_index + arr[current_index];\n   |                      \
    \             ^ no implementation for `isize * usize`\n   |\n   = help: the trait\
    \ `Mul<usize>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0isize; k]; // create a vector which size is k\n    let mut\
    \ max_pos = 0;\n    let mut max_value = arr[0];\n    for &i in arr.iter().cloned()\
    \ {\n        if i > max_value {\n            max_value = i;\n        }\n    }\n\
    \    for (i, &v) in result.iter_mut().zip(arr.iter().cloned()) {\n        if v\
    \ < max_value {\n            result[i] = v;\n        }\n    }\n    for i in 0..k\
    \ {\n        result[i] = max_value;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjrg1nhso.rs:17:35\n   |\n\
    17 |     let mut result = vec![0isize; k]; // create a vector which size is k\n\
    \   |                                   ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut result = vec![0isize; k.try_into().unwrap()];\
    \ // create a vector which size is k\n   |                                   \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjrg1nhso.rs:20:9\n\
    \   |\n20 |     for &i in arr.iter().cloned() {\n   |         ^^    -------------------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjrg1nhso.rs:25:13\n  \
    \ |\n25 |     for (i, &v) in result.iter_mut().zip(arr.iter().cloned()) {\n  \
    \ |             ^^     ------------------------------------------ this expression\
    \ has type `Option<(&mut isize, isize)>`\n   |             |\n   |           \
    \  expected `isize`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `v`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `&mut isize`\n  --> /tmp/tmpjrg1nhso.rs:27:13\n   |\n27 |       \
    \      result[i] = v;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `&mut isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&mut isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjrg1nhso.rs:31:9\n   |\n31 |         result[i]\
    \ = max_value;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the tr"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_val: isize = arr.iter().max().unwrap();\n    for i in arr.iter() {\n\
    \        if *i > max_val {\n            max_val = *i;\n        }\n    }\n    let\
    \ mut ans = Vec::new();\n    for i in 0..k {\n        ans.push(max_val);\n   \
    \     max_val -= 1;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvd13tavs.rs:17:30\n   |\n\
    17 |     let mut max_val: isize = arr.iter().max().unwrap();\n   |           \
    \           -----   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |                      |\n   |                      expected due to this\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n17 |     let mut max_val:\
    \ isize = *arr.iter().max().unwrap();\n   |                              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    \n \
    \   let mut arr_max = vec![None; k]\n    for mut elem in arr.clone() {\n     \
    \   arr_max[k] = if elem > arr_max[k] {\n            elem\n        } else {\n\
    \            arr_max[k]\n        }\n    }\n    arr_max\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp26_ha23h.rs:18:36\n\
    \   |\n18 |     let mut arr_max = vec![None; k]\n   |                        \
    \            ^ help: add `;` here\n19 |     for mut elem in arr.clone() {\n  \
    \ |     --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp26_ha23h.rs:18:34\n\
    \   |\n18 |     let mut arr_max = vec![None; k]\n   |                        \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n18 |     let\
    \ mut arr_max = vec![None; k.try_into().unwrap()]\n   |                      \
    \             ++++++++++++++++++++\n\nerror[E0277]: the type `[Option<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp26_ha23h.rs:20:9\n   |\n20 |         arr_max[k]\
    \ = if elem > arr_max[k] {\n   |         ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Option<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Option<_>>`\n\nerror[E0277]: the type `[Option<_>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp26_ha23h.rs:20:32\n   |\n20 |  \
    \       arr_max[k] = if elem > arr_max[k] {\n   |                            \
    \    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Option<_>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Option<_>>`\n\
    \nerror[E0277]: the type `[Option<_>]` cannot be indexed by `isize`\n  --> /tmp/tmp26_ha23h.rs:23:13\n\
    \   |\n23 |             arr_max[k]\n   |             ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Option<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements o"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 {\n        vec![]\n    } else if k >= arr.len() {\n        vec![arr[k]]\n\
    \    } else {\n        let mut result = vec![];\n        let mut max_k = k;\n\
    \        let mut max_element = arr[k];\n        for element in arr.iter().rev()\
    \ {\n            if element > max_element {\n                result.push(element);\n\
    \                if max_k == 0 {\n                    break;\n               \
    \ } else {\n                    max_k -= 1;\n                }\n            }\
    \ else {\n                result.push(max_element);\n                break;\n\
    \            }\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0dxvi7lh.rs:19:20\n   |\n\
    19 |     } else if k >= arr.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     } else if k >=\
    \ arr.len().try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp0dxvi7lh.rs:20:14\n\
    \   |\n20 |         vec![arr[k]]\n   |              ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp0dxvi7lh.rs:24:31\n   |\n24 |         let\
    \ mut max_element = arr[k];\n   |                               ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dxvi7lh.rs:38:9\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n38 |         result\n   |         ^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = arr[0];\n    let mut max_idx = 1;\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        if max < arr[i] {\n            max = arr[i];\n      \
    \      max_idx = i;\n        }\n        i += 1;\n    }\n    let mut result = vec![max];\n\
    \    for i in 0..k {\n        result[i] = arr[(max_idx + i) % arr.len()];\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplqm7jphf.rs:29:9\n\
    \   |\n29 |         result[i] = arr[(max_idx + i) % arr.len()];\n   |        \
    \ ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   =\
    \ help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplqm7jphf.rs:29:36\n   |\n29 |\
    \         result[i] = arr[(max_idx + i) % arr.len()];\n   |                  \
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add\
    \ `isize` to `usize`\n  --> /tmp/tmplqm7jphf.rs:29:34\n   |\n29 |         result[i]\
    \ = arr[(max_idx + i) % arr.len()];\n   |                                  ^ no\
    \ implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ret: Vec<isize> = vec![];\n    if arr.len() <= k {\n        let mut max\
    \ = arr[0];\n        for e in arr {\n            if e > max {\n              \
    \  max = e;\n            }\n        }\n        ret.push(max);\n    } else {\n\
    \        let mut max_so_far = arr[0];\n        let mut max_so_far_index = 0;\n\
    \        for e in arr.iter().rev() {\n            if e > max_so_far {\n      \
    \          max_so_far = e;\n                max_so_far_index = arr.len() - 1;\n\
    \            }\n        }\n        for i in 1..k {\n            ret.append(max_so_far);\n\
    \            max_so_far = arr[max_so_far_index];\n            max_so_far_index\
    \ -= i;\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7szkz90u.rs:18:21\n   |\n\
    18 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7szkz90u.rs:30:20\n   |\n30 |             if e > max_so_far\
    \ {\n   |                    ^^^^^^^^^^\n   |                    |\n   |     \
    \               expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp7szkz90u.rs:31:30\n   |\n27 |         let mut max_so_far = arr[0];\n\
    \   |                              ------ expected due to this value\n...\n31\
    \ |                 max_so_far = e;\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |                 max_so_far = *e;\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7szkz90u.rs:36:24\n   |\n36 |  \
    \           ret.append(max_so_far);\n   |                        ^^^^^^^^^^ expected\
    \ `&mut Vec<isize>`, found `isize`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<isize>`\n                           found type `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7szkz90u.rs:38:33\n   |\n38 |             max_so_far_index\
    \ -= i;\n   |                                 ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot subtract-assign `isize` from `usize`\n  --> /tmp/tmp7szkz90u.rs:38:30\n\
    \   |\n38 |             max_so_far_index -= i;\n   |                         \
    \     ^^ no implementation for `usize -= isize`\n   |\n   = help: the trait `SubAssign<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n           \
    \  <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64\
    \ as SubAssign>\n            "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut len = arr.len();\n    if k > len {\n        k = len;\n    }\n    if k ==\
    \ 0 {\n        vec![]\n    } else if k == 1 {\n        vec![arr.first()]\n   \
    \ } else {\n        let mut max_val = arr.last();\n        for i in 0..k {\n \
    \           max_val = max(max_val, arr[i]);\n        }\n        vec![max_val]\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpzdauhc30.rs:28:23\n\
    \   |\n28 |             max_val = max(max_val, arr[i]);\n   |                \
    \       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzdauhc30.rs:18:12\n   |\n18 |     if k > len {\n   |            ^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     if k >\
    \ len.try_into().unwrap() {\n   |               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzdauhc30.rs:19:13\n   |\n16 | fn maximum(arr:\
    \ Vec<isize>, k: isize) -> Vec<isize> {\n   |                                -----\
    \ expected due to this parameter type\n...\n19 |         k = len;\n   |      \
    \       ^^^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzdauhc30.rs:24:14\n   |\n24 |         vec![arr.first()]\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzdauhc30.rs:28:36\n\
    \   |\n28 |             max_val = max(max_val, arr[i]);\n   |                \
    \                    ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzdauhc30.rs:30:14\n   |\n30 |\
    \         vec![max_val]\n   |              ^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_elements = Vec::with_capacity(k)\n    for i in 0..k {\n        let max_element\
    \ = arr.max_unwrap_or(arr[i]);\n        max_elements.push(max_element);\n    }\n\
    \    max_elements\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpci3nhgdm.rs:17:49\n\
    \   |\n17 |     let mut max_elements = Vec::with_capacity(k)\n   |           \
    \                                      ^ help: add `;` here\n18 |     for i in\
    \ 0..k {\n   |     --- unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpci3nhgdm.rs:17:47\n   |\n17 |     let mut max_elements = Vec::with_capacity(k)\n\
    \   |                                               ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     let mut max_elements = Vec::with_capacity(k.try_into().unwrap())\n\
    \   |                                                ++++++++++++++++++++\n\n\
    error[E0599]: no method named `max_unwrap_or` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpci3nhgdm.rs:19:31\n   |\n19 |         let max_element\
    \ = arr.max_unwrap_or(arr[i]);\n   |                               ^^^^^^^^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpci3nhgdm.rs:19:45\n   |\n19 |         let\
    \ max_element = arr.max_unwrap_or(arr[i]);\n   |                             \
    \                ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![];\n    let mut max_elem = arr.max().unwrap();\n    let mut curr_max\
    \ = max_elem;\n\n    if k == 0 {\n        return vec![];\n    }\n\n    for i in\
    \ 0..k {\n        let max_elem = max(max_elem, arr[i]);\n        if max_elem <\
    \ curr_max {\n            curr_max = max_elem;\n            res[i] = curr_max;\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp39f9qiyb.rs:26:24\n\
    \   |\n26 |         let max_elem = max(max_elem, arr[i]);\n   |              \
    \          ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmp39f9qiyb.rs:18:28\n    |\n18 \
    \ |     let mut max_elem = arr.max().unwrap();\n    |                        \
    \    ^^^- supplied 0 arguments\n    |                            |\n    |    \
    \                        expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `unwrap` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp39f9qiyb.rs:18:34\n   |\n18 |     let mut\
    \ max_elem = arr.max().unwrap();\n   |                                  ^^^^^^\
    \ help: there is an associated function with a similar name: `swap`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp39f9qiyb.rs:26:38\n\
    \   |\n26 |         let max_elem = max(max_elem, arr[i]);\n   |              \
    \                        ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp39f9qiyb.rs:29:13\n   |\n29 |             res[i] = curr_max;\n\
    \   |             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ len = arr.len();\n    if k >= len {\n        return vec![0; k];\n    }\n   \
    \ let mut result = vec![0; k];\n    let mut max_value = arr[k];\n    for i in\
    \ 1..k {\n        if arr[i] > max_value {\n            max_value = arr[i];\n \
    \       }\n        result[i] = max_value;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqaemy5ts.rs:18:13\n   |\n\
    18 |     if k >= len {\n   |             ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if k >= len.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqaemy5ts.rs:19:24\n\
    \   |\n19 |         return vec![0; k];\n   |                        ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         return vec![0;\
    \ k.try_into().unwrap()];\n   |                         ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqaemy5ts.rs:21:30\n   |\n21 |\
    \     let mut result = vec![0; k];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |     let mut result\
    \ = vec![0; k.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqaemy5ts.rs:22:25\n\
    \   |\n22 |     let mut max_value = arr[k];\n   |                         ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqaemy5ts.rs:24:12\n\
    \   |\n24 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // k\
    \ is guaranteed to be in the range [0, len(arr)).\n    let mut maximum = arr.len();\n\
    \    for i in 0..k {\n        if maximum < arr[i] {\n            maximum = arr[i];\n\
    \        }\n    }\n    maximum\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprrpaa5lf.rs:20:22\n\
    \   |\n20 |         if maximum < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprrpaa5lf.rs:21:23\n   |\n21 |  \
    \           maximum = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprrpaa5lf.rs:24:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     maximum\n   |     ^^^^^^^ expected struct `Vec`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort();\n\
    \    arr.windows(k).map(|x| x.max())\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpntsd_ci7.rs:18:17\n   |\n\
    18 |     arr.windows(k).map(|x| x.max())\n   |                 ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     arr.windows(k.try_into().unwrap()).map(|x|\
    \ x.max())\n   |                  ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpntsd_ci7.rs:18:30\n\
    \    |\n18  |     arr.windows(k).map(|x| x.max())\n    |                     \
    \         ^^^- supplied 0 arguments\n    |                              |\n  \
    \  |                              expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpntsd_ci7.rs:18:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n17 |     arr.sort();\n18 |     arr.windows(k).map(|x| x.max())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `Map`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Map<Windows<'_, isize>, [closure@/tmp/tmpntsd_ci7.rs:18:24: 18:35]>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    \n \
    \   let mut arr_max = vec![vec![0]; k]; //[0; k] \n    let mut i = 1;\n    \n\
    \    arr_max.iter_mut().cloned().for_each(|&v| {\n        v.push(*arr);\n    \
    \    *v = *v.max();\n    });\n    \n    for v in arr_max.iter() {\n        if\
    \ (*v > i) {\n            i = *v;\n        }\n    }\n    \n    arr\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp30njye30.rs:27:12\n\
    \   |\n27 |         if (*v > i) {\n   |            ^      ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    27 -         if (*v > i) {\n27 +         if *v > i {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp30njye30.rs:18:37\n   |\n18 |     let mut arr_max = vec![vec![0];\
    \ k]; //[0; k] \n   |                                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     let mut arr_max = vec![vec![0];\
    \ k.try_into().unwrap()]; //[0; k] \n   |                                    \
    \  ++++++++++++++++++++\n\nerror[E0271]: type mismatch resolving `<std::slice::IterMut<'_,\
    \ Vec<{integer}>> as Iterator>::Item == &_`\n    --> /tmp/tmp30njye30.rs:21:24\n\
    \     |\n21   |     arr_max.iter_mut().cloned().for_each(|&v| {\n     |      \
    \                  ^^^^^^ types differ in mutability\n     |\n     = note:   \
    \   expected reference `&_`\n             found mutable reference `&mut Vec<{integer}>`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists\
    \ for struct `Cloned<std::slice::IterMut<'_, Vec<{integer}>>>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmp30njye30.rs:21:33\n    |\n21  |  \
    \     arr_max.iter_mut().cloned().for_each(|&v| {\n    |                     \
    \              ^^^^^^^^ method cannot be called on `Cloned<std::slice::IterMut<'_,\
    \ Vec<{integer}>>>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `<std::slice::IterMut<'_, Vec<{integer}>>\
    \ as Iterator>::Item = &_`\n            which is required by `Cloned<std::slice::IterMut<'_,\
    \ Vec<{integer}>>>: Iterator`\n            `Cloned<std::slice::IterMut<'_, Vec<{integer}>>>:\
    \ Iterator`\n            which is required by `&mut Cloned<std::slice::IterMut<'_,\
    \ Vec<{integer}>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp30njye30.rs:27:18\n\
    \   |\n27 |         if (*v > i) {\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // init\
    \ maximum heap\n    let mut max_heap = BinaryHeap::new();\n    // insert k\n \
    \   max_heap.push(k);\n    // insert arr\n    for (i, &elem) in arr.iter().enumerate()\
    \ {\n        max_heap.push(elem);\n        if i == 0 {\n            // k > 0\n\
    \            if *max_heap.peek() > k {\n                // update k\n        \
    \        k = *max_heap.peek();\n                // remove max elem from heap\n\
    \                max_heap.pop();\n            }\n        }\n    }\n\n    // extract\
    \ k\n    let mut ret_arr = Vec::new();\n    while k > 0 {\n        let elem =\
    \ *max_heap.peek();\n        ret_arr.push(elem);\n        if k > 1 {\n       \
    \     max_heap.pop();\n        } else {\n            break;\n        }\n    }\n\
    \    ret_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n\
    \  --> /tmp/tmp_l6_ajnh.rs:18:24\n   |\n18 |     let mut max_heap = BinaryHeap::new();\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BinaryHeap;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ > arr.len() || k < 0 {\n        panic!(\"k is out of range\");\n    }\n\n  \
    \  let mut max_nums = vec![T::default(); k];\n    let mut max_idx = 0;\n    for\
    \ idx in 0..arr.len() {\n        if idx > max_idx {\n            max_idx = idx;\n\
    \        }\n        if idx > max_idx {\n            max_nums[max_idx] = arr[idx];\n\
    \        }\n    }\n    max_nums\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `T`\n  --> /tmp/tmpwn42qi0y.rs:21:29\n\
    \   |\n21 |     let mut max_nums = vec![T::default(); k];\n   |              \
    \               ^ use of undeclared type `T`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwn42qi0y.rs:17:12\n   |\n17 |     if k > arr.len() || k < 0 {\n\
    \   |            ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     if k > arr.len().try_into().unwrap() || k < 0 {\n   |        \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwn42qi0y.rs:21:43\n\
    \   |\n21 |     let mut max_nums = vec![T::default(); k];\n   |              \
    \                             ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |     let mut max_nums = vec![T::default(); k.try_into().unwrap()];\n\
    \   |                                            ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|a,\
    \ b| {\n        let mut c = a - b;\n        if c > 0 {\n            return c;\n\
    \        }\n        if c < 0 {\n            c += b;\n        }\n        c\n  \
    \  })\n        .take_while(|&x| x != arr.last().unwrap()).take_while(|&x| x <=\
    \ k)\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo542ai1e.rs:20:20\n   |\n\
    20 |             return c;\n   |                    ^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo542ai1e.rs:25:9\n\
    \   |\n25 |         c\n   |         ^ expected enum `std::cmp::Ordering`, found\
    \ `isize`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpo542ai1e.rs:27:10\n\
    \   |\n27 |         .take_while(|&x| x != arr.last().unwrap()).take_while(|&x|\
    \ x <= k)\n   |          ^^^^^^^^^^ `()` is not an iterator\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut i = arr.len() - 1;\n    let mut max_arr = vec![];\n    let mut max_val =\
    \ arr[i];\n    while i >= 0 && k > 0 {\n        if arr[i] > max_val {\n      \
    \      max_val = arr[i];\n            max_arr.push(i);\n        }\n        i -=\
    \ 1;\n        --k;\n    }\n    max_arr.push(i);\n    if k > 0 { max_arr.remove(0)}\n\
    \    return max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpldvuv3qo.rs:29:16\n   |\n\
    29 |     if k > 0 { max_arr.remove(0)}\n   |     -----------^^^^^^^^^^^^^^^^^-\n\
    \   |     |          |\n   |     |          expected `()`, found `usize`\n   |\
    \     expected this to be `()`\n   |\nhelp: consider using a semicolon here\n\
    \   |\n29 |     if k > 0 { max_arr.remove(0);}\n   |                         \
    \        +\nhelp: consider using a semicolon here\n   |\n29 |     if k > 0 { max_arr.remove(0)};\n\
    \   |                                  +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpldvuv3qo.rs:30:12\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n30 |     return max_arr\n   |    \
    \        ^^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ <= arr.len() {\n        let max_num_arr = arr.take(k).max();\n        max_num_arr.to_owned().iter().cloned().take_while(|&x|\
    \ x < 0).collect()\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5_l7ruu1.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmp5_l7ruu1.rs:18:31\n    |\n18  |         \
    \  let max_num_arr = arr.take(k).max();\n    |                               \
    \  ^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    \n \
    \   let mut arr = arr\n        .iter()\n        .cloned()\n        .enumerate()\n\
    \        .map(|(i, el)| {\n            if i == k {\n                el\n     \
    \       } else {\n                el\n            }\n        })\n        .collect::<Vec<_>>();\n\
    \    if arr.is_empty() {\n        arr\n    } else {\n        arr\n    }\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp16x0tdke.rs:23:21\n   |\n\
    23 |             if i == k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |             if i == k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n      \
    \  if i > k {\n            break;\n        }\n        for j in 0..i {\n      \
    \      \n        }\n    }\n    \n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqo_iv4wo.rs:17:32\n   |\n\
    17 |     let mut max = vec![vec![0; k]; arr.len()];\n   |                    \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n17\
    \ |     let mut max = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n   | \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqo_iv4wo.rs:19:16\n   |\n19 |         if i > k {\n   |\
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if i > k.try_into().unwrap() {\n   |                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqo_iv4wo.rs:18:5\n   |\n16 | \
    \  fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |               \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n17 |       let mut max = vec![vec![0; k]; arr.len()];\n18 | /     for\
    \ i in 0..arr.len() {\n19 | |         if i > k {\n20 | |             break;\n\
    21 | |         }\n...  |\n24 | |         }\n25 | |     }\n   | |_____^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_elements = Vec::new();\n    let mut max_size = k;\n\n    for e in arr.iter()\
    \ {\n        if e > max_elements[max_elements.len() - 1] {\n            max_elements.push(e);\n\
    \        } else if e == max_elements[max_elements.len() - 1] {\n            max_elements[max_elements.len()\
    \ - 1] += e;\n        } else {\n            max_elements.pop();\n            max_elements.push(e);\n\
    \        }\n    }\n\n    max_elements.sort_unstable();\n\n    arr\n        .iter()\n\
    \        .take_while(|x| x <= max_elements[max_size])\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmppruzq45p.rs:24:13\n   |\n24 |             max_elements[max_elements.len()\
    \ - 1] += e;\n   |             ------------------------------------^^^^^\n   |\
    \             |\n   |             cannot use `+=` on type `&isize`\n   |\nhelp:\
    \ `+=` can be used on `isize`, you can dereference `max_elements[max_elements.len()\
    \ - 1]`\n   |\n24 |             *max_elements[max_elements.len() - 1] += e;\n\
    \   |             +\n\nerror[E0277]: the type `[&isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmppruzq45p.rs:35:30\n   |\n35 |         .take_while(|x|\
    \ x <= max_elements[max_size])\n   |                              ^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<&isize>`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `&isize`\n    --> /tmp/tmppruzq45p.rs:36:10\n     |\n36   |        \
    \ .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0368.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|a,\
    \ b| a.cmp(b));\n    let mut result: Vec<isize> = vec![];\n    for i in 0..k {\n\
    \        let mut max_value = arr[0];\n        for i in 1..arr.len() {\n      \
    \      if arr[i] > max_value {\n                max_value = arr[i];\n        \
    \    }\n        }\n        result.push(max_value);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmptz5vs4zg.rs:19:9\n   |\n19\
    \ |     for i in 0..k {\n   |         ^ help: if this is intentional, prefix it\
    \ with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by\
    \ default\n\nerror[E0596]: cannot borrow `arr` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmptz5vs4zg.rs:17:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |            --- help: consider changing this\
    \ to be mutable: `mut arr`\n17 |     arr.sort_by(|a, b| a.cmp(b));\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = arr[0];\n    for i in 1..k {\n        if arr[i] > max {\n        \
    \    max = arr[i];\n        }\n    }\n    vec![(max,)]\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpoitb0gko.rs:19:12\n\
    \   |\n19 |         if arr[i] > max {\n   |            ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpoitb0gko.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoitb0gko.rs:23:10\n\
    \   |\n23 |     vec![(max,)]\n   |          ^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `(isize,)`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ans = vec![0isize..k];\n    let mut cur_ans = vec![0isize..k];\n    let\
    \ mut max_ans = vec![0isize..k];\n    for x in arr {\n        if x < ans.len()\
    \ {\n            max_ans[ans[x]] += x;\n        } else {\n            ans[x] +=\
    \ x;\n        }\n    }\n    for x in max_ans {\n        if cur_ans[x] > ans[x]\
    \ {\n            ans[x] = cur_ans[x];\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpelyx9gqj.rs:21:16\n   |\n\
    21 |         if x < ans.len() {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if x < ans.len().try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[std::ops::Range<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmpelyx9gqj.rs:22:21\n\
    \   |\n22 |             max_ans[ans[x]] += x;\n   |                     ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[std::ops::Range<isize>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<std::ops::Range<isize>>`\n\
    \nerror[E0277]: the type `[std::ops::Range<isize>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpelyx9gqj.rs:24:13\n   |\n24 |             ans[x] += x;\n   |  \
    \           ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[std::ops::Range<isize>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<std::ops::Range<isize>>`\n\nerror[E0277]: the type `[std::ops::Range<isize>]`\
    \ cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpelyx9gqj.rs:28:12\n\
    \   |\n28 |         if cur_ans[x] > ans[x] {\n   |            ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[std::ops::Range<isize>]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<std::ops::R"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut arr = arr.to_vec();\n    arr.sort_unstable();\n    if k == 0 {\n       \
    \ return arr;\n    }\n    if k == 1 {\n        return arr[k..k + 1];\n    }\n\
    \    if k >= arr.len() {\n        return arr.to_owned();\n    }\n    if k <= arr.len()\
    \ - 1 {\n        if k == arr.len() - 1 {\n            return arr.to_owned();\n\
    \        }\n        let mut max1 = arr[k..k + 1];\n        let mut max2 = arr[k..k\
    \ + 1];\n        for j in k + k + 1 .. arr.len() {\n            if max1[j] > max2[j]\
    \ {\n                max2 = max1;\n                max1 = arr[j..j + 1].to_owned();\n\
    \            }\n        }\n        return max1 + max2;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmpl8mj74ih.rs:23:16\n   |\n23 |         return arr[k..k + 1];\n \
    \  |                ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `std::ops::Range<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<isize>>` for\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl8mj74ih.rs:25:13\n\
    \   |\n25 |     if k >= arr.len() {\n   |             ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |     if k >= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl8mj74ih.rs:28:13\n   |\n28 |     if k <= arr.len() - 1\
    \ {\n   |             ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |     if k <= (arr.len() - 1).try_into().unwrap() {\n   |    \
    \         +             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl8mj74ih.rs:29:17\n   |\n29 |         if k == arr.len() - 1 {\n\
    \   |                 ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |         if k == (arr.len() - 1).try_into().unwrap() {\n   |\
    \                 +             +++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpl8mj74ih.rs:32:24\n\
    \   |\n32 |         let mut max1 = arr[k..k + 1];\n   |                      \
    \  ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[is"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = arr[0];\n    let mut max_index = arr.iter().position(|x| *x > max);\n\
    \    let mut max_num = std::cmp::max(arr[0], arr[k]);\n    let mut final_result\
    \ = vec![max];\n    for i in 1..k {\n        if arr[i] > max_num {\n         \
    \   max_index = i;\n            max_num = arr[i];\n        }\n        final_result.push(*max_index);\n\
    \        max_index += 1;\n    }\n    final_result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmqw0nh8p.rs:19:45\n\
    \   |\n19 |     let mut max_num = std::cmp::max(arr[0], arr[k]);\n   |       \
    \                                      ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpmqw0nh8p.rs:22:12\n   |\n22 |         if arr[i]\
    \ > max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmqw0nh8p.rs:23:25\n\
    \   |\n18 |     let mut max_index = arr.iter().position(|x| *x > max);\n   | \
    \                        --------------------------------- expected due to this\
    \ value\n...\n23 |             max_index = i;\n   |                         ^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpmqw0nh8p.rs:24:23\n   |\n24 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0614]: type `Option<usize>` cannot\
    \ be dereferenced\n  --> /tmp/tmpmqw0nh8p.rs:26:27\n   |\n26 |         final_result.push(*max_index);\n\
    \   |                           ^^^^^^^^^^\n\nerror[E0368]: binary assignment\
    \ o"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    debug_assert!(arr.len()\
    \ > 0);\n    debug_assert!(k <= arr.len());\n    arr.sort_by(|a, b| {\n      \
    \  if a > b {\n            a\n        } else {\n            b\n        }\n   \
    \ });\n    arr[k..]\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkyrcqyzp.rs:18:24\n   |\n\
    18 |     debug_assert!(k <= arr.len());\n   |                        ^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     debug_assert!(k\
    \ <= arr.len().try_into().unwrap());\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkyrcqyzp.rs:21:13\n   |\n21 |\
    \             a\n   |             ^ expected enum `std::cmp::Ordering`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkyrcqyzp.rs:23:13\n\
    \   |\n23 |             b\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found `&isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmpkyrcqyzp.rs:26:5\n   |\n26 |     arr[k..]\n   |     ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeFrom<usize>\
    \ as SliceIndex<[T]>>\n             <RangeFrom<usize> as SliceIndex<str>>\n  \
    \ = note: required because of the requirements on the impl of `Index<RangeFrom<isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_so_far = arr[k];\n    let mut max_so_far_mut_index = k;\n    let mut\
    \ max_so_far_mut_value = 0;\n    for &ele in &arr {\n        if ele > max_so_far\
    \ {\n            max_so_far_mut_value = ele;\n            max_so_far_mut_index\
    \ = max_so_far_mut_index + 1;\n        }\n        max_so_far_mut_index = max_so_far_mut_index\
    \ - 1;\n    }\n\n    let mut max_so_far_mut_value = max_so_far;\n    let mut max_so_far_mut_index\
    \ = max_so_far_mut_index + 1;\n    for &ele in &arr {\n        if ele > max_so_far\
    \ {\n            max_so_far_mut_value = ele;\n            max_so_far_mut_index\
    \ = max_so_far_mut_index + 1;\n        }\n        max_so_far_mut_index = max_so_far_mut_index\
    \ - 1;\n    }\n\n    vec![max_so_far, max_so_far_mut_value]\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcicbsqu5.rs:17:26\n\
    \   |\n17 |     let mut max_so_far = arr[k];\n   |                          ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut sorted_list = vec![0;k];\n    for num in arr {\n        if num < 0 {\n \
    \           return vec![];\n        }\n        sorted_list[k] = num;\n       \
    \ k -= 1;\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4drzptx4.rs:17:34\n   |\n\
    17 |     let mut sorted_list = vec![0;k];\n   |                              \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut sorted_list = vec![0;k.try_into().unwrap()];\n   |                     \
    \              ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp4drzptx4.rs:22:9\n   |\n22 |         sorted_list[k]\
    \ = num;\n   |         ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ret: Vec<isize> = vec![];\n    let mut max_num = arr[0];\n    let mut i\
    \ = 1;\n    while i < k {\n        if arr[i] > max_num {\n            max_num\
    \ = arr[i];\n        }\n        i += 1;\n    }\n    while i < (arr.len() - k)\
    \ {\n        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n\
    \        i += 1;\n    }\n    ret.push(max_num);\n    for _ in arr[k..] {\n   \
    \     ret.push(max_num);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq6fq3t6d.rs:21:12\n\
    \   |\n21 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpq6fq3t6d.rs:22:23\n   |\n22 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq6fq3t6d.rs:26:28\n\
    \   |\n26 |     while i < (arr.len() - k) {\n   |                            ^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq6fq3t6d.rs:26:15\n\
    \   |\n26 |     while i < (arr.len() - k) {\n   |               ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n26 |     while i\
    \ < ((arr.len() - k)).try_into().unwrap() {\n   |               +            \
    \   +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpq6fq3t6d.rs:26:26\n   |\n26 |     while i < (arr.len() - k) {\n\
    \   |                          ^ no implementation for `usize - isize`\n   |\n\
    \   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max: Vec<isize> = vec![std::i32::MAX;k];\n    let mut idx: usize = 0;\n\
    \    for num in arr {\n        if num > max[k] {\n            max[k] = num;\n\
    \            idx += 1;\n        }\n    }\n    max[k..].clone_from_slice(&arr[idx..k+idx.min(arr.len())]);\n\
    \    max\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiw85klne.rs:17:36\n   |\n\
    17 |     let mut max: Vec<isize> = vec![std::i32::MAX;k];\n   |              \
    \                      ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     let mut max: Vec<isize> = vec![std::i32::MAX.try_into().unwrap();k];\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiw85klne.rs:17:50\n   |\n17 |  \
    \   let mut max: Vec<isize> = vec![std::i32::MAX;k];\n   |                   \
    \                               ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     let mut max: Vec<isize> = vec![std::i32::MAX;k.try_into().unwrap()];\n\
    \   |                                                   ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiw85klne.rs:20:18\n\
    \   |\n20 |         if num > max[k] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiw85klne.rs:21:13\n   |\n21 |            \
    \ max[k] = num;\n   |             ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmpiw85klne.rs:25:5\n   |\n25 |     max[k..].clone_from_slice(&arr[idx..k+idx.min(arr.len())]);\n\
    \   |     ^^^^^^^^ slice indices "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        return vec![];\n    }\n    if k == 0 || arr.len() <= k {\n  \
    \      return vec![arr[0]];\n    }\n    arr.sort_unstable_by(|a, b| b.cmp(&a));\n\
    \    let (max_ele, sub_k) = arr.split_last();\n    maximum(sub_k, k - 1).iter().cloned().chain(vec![max_ele]).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjd39tsoe.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjd39tsoe.rs:20:31\n   |\n20 |     if k == 0 || arr.len()\
    \ <= k {\n   |                               ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |     if k == 0 || arr.len() <= k.try_into().unwrap()\
    \ {\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjd39tsoe.rs:24:9\n   |\n24 |     let (max_ele,\
    \ sub_k) = arr.split_last();\n   |         ^^^^^^^^^^^^^^^^   ----------------\
    \ this expression has type `Option<(&isize, &[isize])>`\n   |         |\n   |\
    \         expected enum `Option`, found tuple\n   |\n   = note: expected enum\
    \ `Option<(&isize, &[isize])>`\n             found tuple `(_, _)`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        arr\n    } else {\n        arr.iter().take(k).max().collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsecyikff.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsecyikff.rs:20:25\n   |\n20 |         arr.iter().take(k).max().collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |         arr.iter().take(k.try_into().unwrap()).max().collect()\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0599]: `Option<&isize>`\
    \ is not an iterator\n   --> /tmp/tmpsecyikff.rs:20:34\n    |\n20  |         \
    \  arr.iter().take(k).max().collect()\n    |                                 \
    \   ^^^^^^^ `Option<&isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<&isize>: Iterator`\n \
    \           which is required by `&mut Option<&isize>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut maximums = Vec::new();\n    let mut max_value = arr[0];\n    for i in 1..k\
    \ {\n        let max_val = max_value.max(&arr[i]);\n        max_value = max_val;\n\
    \        maximums.push(max_val);\n    }\n    maximums\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmojdlv91.rs:20:38\n\
    \   |\n20 |         let max_val = max_value.max(&arr[i]);\n   |              \
    \                        ^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmojdlv91.rs:20:37\n\
    \   |\n20 |         let max_val = max_value.max(&arr[i]);\n   |              \
    \                       ^^^^^^^ expected `isize`, found reference\n   |\n   =\
    \ note:   expected type `isize`\n           found reference `&_`\nhelp: consider\
    \ removing the borrow\n   |\n20 -         let max_val = max_value.max(&arr[i]);\n\
    20 +         let max_val = max_value.max(arr[i]);\n   | \n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result: Vec<isize> = vec![];\n    for i in 0..k {\n        let max_elem\
    \ = arr.iter().max().unwrap();\n        result.append(max_elem);\n        arr.retain(|&elem|\
    \ elem != max_elem);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7djox6s5.rs:20:23\n   |\n\
    20 |         result.append(max_elem);\n   |                       ^^^^^^^^ types\
    \ differ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \                      found reference `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7djox6s5.rs:21:36\n   |\n21 |         arr.retain(|&elem| elem !=\
    \ max_elem);\n   |                                    ^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |  \
    \       arr.retain(|&elem| elem != *max_elem);\n   |                         \
    \           +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ret = vec![arr[0], ..k];\n    for n in arr[k..] {\n        ret.iter().enumerate().find(|&(_,\
    \ v)| v > n).unwrap()\n    }\n    ret\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvoj674f.rs:17:32\n   |\n\
    17 |     let mut ret = vec![arr[0], ..k];\n   |                              \
    \  ^^^ expected `isize`, found struct `RangeTo`\n   |\n   = note: expected type\
    \ `isize`\n            found struct `RangeTo<isize>`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `RangeFrom<isize>`\n  --> /tmp/tmpfvoj674f.rs:18:14\n\
    \   |\n18 |     for n in arr[k..] {\n   |              ^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `RangeFrom<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfvoj674f.rs:19:9\n   |\n19 | \
    \        ret.iter().enumerate().find(|&(_, v)| v > n).unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: consider using a semicolon here: `;`\n   |         |\n   |         expected\
    \ `()`, found tuple\n   |\n   = note: expected unit type `()`\n              \
    \    found tuple `(usize, &isize)`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max: Vec<isize> = vec![0; k];\n    arr.iter().cloned().for_each(|x|{\n \
    \       if x.max() < max.as_slice().max() {\n            max.extend_from_slice(&[x.max()]);\n\
    \        }\n        max.push(x.max());\n    });\n    max\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk86kgww2.rs:17:39\n   |\n\
    17 |     let mut max: Vec<isize> = vec![0; k];\n   |                         \
    \              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max: Vec<isize> = vec![0; k.try_into().unwrap()];\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpk86kgww2.rs:19:14\n\
    \    |\n19  |         if x.max() < max.as_slice().max() {\n    |             \
    \ ^^^- supplied 0 arguments\n    |              |\n    |              expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpk86kgww2.rs:19:37\n\
    \    |\n19  |         if x.max() < max.as_slice().max() {\n    |             \
    \                        ^^^- supplied 0 arguments\n    |                    \
    \                 |\n    |                                     expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk86kgww2.rs:19:22\n   |\n19 |         if x.max() < max.as_slice().max()\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&[isize]`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpk86kgww2.rs:20:39\n    |\n20  |             max.extend_from_slice(&[x.max()]);\n\
    \    |                                       ^^^- supplied 0 arguments\n    |\
    \                                       |\n    |                             \
    \          expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpk86kgww2.rs:22:20\n    |\n22  |         max.push(x.max());\n \
    \   |                    ^^^- supplied 0 arguments\n    |                    |\n\
    \    |                    expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: abortin"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    \n    let mut max = 0;\n    for i in 0..k {\n\
    \        max = max < arr[i] ? max : arr[i];\n        result.push(max);\n    }\n\
    \    \n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `max`\n\
    \  --> /tmp/tmpep0boagb.rs:21:30\n   |\n21 |         max = max < arr[i] ? max\
    \ : arr[i];\n   |                              ^^^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![arr[0]; k];\n    let mut max = arr[0];\n    for i in 1..k\
    \ {\n        if result[i-1] > max {\n            max = result[i-1];\n        }\n\
    \    }\n    for i in 0..k {\n        result[i] = max;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgq_403w2.rs:17:35\n   |\n\
    17 |     let mut result = vec![arr[0]; k];\n   |                             \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![arr[0]; k.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpgq_403w2.rs:20:12\n   |\n20 |         if\
    \ result[i-1] > max {\n   |            ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgq_403w2.rs:21:19\n   |\n21 |            \
    \ max = result[i-1];\n   |                   ^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpgq_403w2.rs:25:9\n   |\n25 |         result[i]\
    \ = max;\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![0]; k]\n    let mut max_num = arr[0]\n    for ele in\
    \ arr {\n        if ele > max_num {\n            for x in max_arr {\n        \
    \        x.push(ele);\n            }\n            max_num = ele;\n        } else\
    \ {\n            for x in max_arr {\n                if ele > x[0] {\n       \
    \             x = vec![x[0], ele];\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].iter().cloned().collect();\n    }\n    return max_arr;\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3ejb_c5s.rs:17:39\n\
    \   |\n17 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                  ^ help: add `;` here\n18 |     let mut max_num = arr[0]\n \
    \  |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  -->\
    \ /tmp/tmp3ejb_c5s.rs:18:29\n   |\n18 |     let mut max_num = arr[0]\n   |   \
    \                          ^ help: add `;` here\n19 |     for ele in arr {\n \
    \  |     --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ejb_c5s.rs:17:37\n\
    \   |\n17 |     let mut max_arr = vec![vec![0]; k]\n   |                     \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_arr = vec![vec![0]; k.try_into().unwrap()]\n   |        \
    \                              ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmp3ejb_c5s.rs:35:9\n\
    \   |\n35 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n   | \
    \        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[Vec<isize>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<isize>>`\n\
    \nerror[E0277]: the type `[Vec<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmp3ejb_c5s.rs:35:22\n\
    \   |\n35 |         max_arr[i] = max_arr[i].iter().cloned().collect();\n   | \
    \                     ^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<isize>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3ejb_c5s.rs:37:12\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \             "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0; k];\n    let mut max_val = arr[0];\n    let mut max_idx\
    \ = 0;\n\n    for i in 0..arr.len() {\n        if arr[i] > max_val {\n       \
    \     max_val = arr[i];\n            max_idx = i;\n        }\n    }\n\n    for\
    \ i in 0..k {\n        result[i] = arr[max_idx];\n        max_idx++;\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_2_2bta0.rs:30:16\n\
    \   |\n30 |         max_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n30 |         { let tmp = max_idx; max_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n30 -  \
    \       max_idx++;\n30 +         max_idx += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_2_2bta0.rs:17:30\n   |\n17 |     let mut result = vec![0;\
    \ k];\n   |                              ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     let mut result = vec![0; k.try_into().unwrap()];\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp_2_2bta0.rs:29:9\n\
    \   |\n29 |         result[i] = arr[max_idx];\n   |         ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.len() == 0 {\n        return arr;\n    }\n    \n    // Get the index\
    \ of the first maximum (if exists) then iterate through the array\n    let mut\
    \ max_idx = 0;\n    let mut max_value = arr[0];\n    for i in 1..k {\n       \
    \ if arr[i] > max_value {\n            max_idx = i;\n            max_value = arr[i];\n\
    \        }\n    }\n    \n    // If no maximum found, return the original array\n\
    \    if max_idx == arr.len() {\n        return arr;\n    }\n    \n    // Return\
    \ the maximum to the end of the array (excluded)\n    let mut res = vec![max_value;\
    \ k - 1];\n    for i in 0..max_idx {\n        res[max_idx - i] = arr[max_idx -\
    \ i];\n    }\n    res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiev3798c.rs:25:12\n\
    \   |\n25 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpiev3798c.rs:27:25\n   |\n27 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiev3798c.rs:32:19\n\
    \   |\n32 |     if max_idx == arr.len() {\n   |                   ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n32 |     if max_idx == arr.len().try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiev3798c.rs:37:35\n   |\n37 |     let mut res = vec![max_value;\
    \ k - 1];\n   |                                   ^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n37 |     let mut res = vec![max_value; (k\
    \ - 1).try_into().unwrap()];\n   |                                   +     +++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiev3798c.rs:39:9\n\
    \   |\n39 |         res[max_idx - i] = arr[max_idx - i];\n   |         ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        arr\n    } else {\n        let mut result = vec![vec![std::i32::MIN;\
    \ k]; arr.len()];\n        let mut max_val = std::i32::MIN;\n\n        for i in\
    \ 0..k {\n            max_val = std::cmp::max(arr[i], max_val);\n            result[i][0]\
    \ = arr[i];\n        }\n\n        for i in 0..(arr.len() - k) {\n            result[i\
    \ + k][0] = std::i32::MAX;\n        }\n\n        arr.iter().enumerate().filter(|&(i,\
    \ v)| v != std::i32::MIN).cloned().for_each(|(i, v)| {\n            result[i][0]\
    \ = v;\n        });\n\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp37qckkee.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp37qckkee.rs:20:51\n   |\n20 |         let mut result =\
    \ vec![vec![std::i32::MIN; k]; arr.len()];\n   |                             \
    \                      ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n20 |         let mut result = vec![vec![std::i32::MIN; k.try_into().unwrap()];\
    \ arr.len()];\n   |                                                    ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp37qckkee.rs:24:37\n\
    \   |\n24 |             max_val = std::cmp::max(arr[i], max_val);\n   |      \
    \                               ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[Vec<i32>]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp37qckkee.rs:25:13\n   |\n25 |             result[i][0]\
    \ = arr[i];\n   |             ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<i32>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<i32>>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmp37qckkee.rs:25:28\n   |\n25 |             result[i][0]\
    \ = arr[i];\n   |                            ^^^^^^ slice indices are of type\
    \ `usize` or ranges o"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.is_empty() {\n        return vec![];\n    }\n\n    if arr.len()\
    \ <= k {\n        return vec![arr.max()];\n    }\n\n    let mut max_value = arr[0];\n\
    \    let mut max_indices = vec![];\n    for i in 1..k {\n        max_value = max(max_value,\
    \ arr[i]);\n        if max_value == arr[i] {\n            max_indices.push(i);\n\
    \        }\n    }\n\n    max_indices.sort_unstable();\n    let mut result = vec![];\n\
    \    for i in max_indices {\n        result.push(arr[i]);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpr0ka429h.rs:28:21\n\
    \   |\n28 |         max_value = max(max_value, arr[i]);\n   |                \
    \     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr0ka429h.rs:21:21\n   |\n21 |     if arr.len() <= k {\n   |        \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n21\
    \ |     if arr.len() <= k.try_into().unwrap() {\n   |                      ++++++++++++++++++++\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpr0ka429h.rs:22:25\n    |\n22  |         return vec![arr.max()];\n\
    \    |                         ^^^- supplied 0 arguments\n    |              \
    \           |\n    |                         expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr0ka429h.rs:22:21\n\
    \   |\n22 |         return vec![arr.max()];\n   |                     ^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpr0ka429h.rs:28:36\n   |\n28 |         max_value\
    \ = max(max_value, arr[i]);\n   |                                    ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpr0ka429h.rs:29:25\n   |\n29 |  \
    \       if max_value == arr[i] {\n   |                         ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut s = arr.clone();\n    s.sort();\n    let mut max = vec![Int::MAX; k];\n\
    \    for i in 0..k {\n        match s[i] {\n            Int::MAX => return vec![],\n\
    \            Int::MIN => {}\n            _ => max[i] = max[i] >= s[i] || max[i]\
    \ < s[i] ? max[i] : s[i],\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `max`\n\
    \  --> /tmp/tmp7p_nr6jb.rs:24:61\n   |\n24 |             _ => max[i] = max[i]\
    \ >= s[i] || max[i] < s[i] ? max[i] : s[i],\n   |               --           \
    \                                 ^^^ expected one of `,`, `.`, `?`, `}`, or an\
    \ operator\n   |               |\n   |               while parsing the `match`\
    \ arm starting here\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `Int`\n  --> /tmp/tmp7p_nr6jb.rs:19:24\n   |\n19 |     let mut max = vec![Int::MAX;\
    \ k];\n   |                        ^^^ use of undeclared type `Int`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Int`\n  --> /tmp/tmp7p_nr6jb.rs:22:13\n\
    \   |\n22 |             Int::MAX => return vec![],\n   |             ^^^ use of\
    \ undeclared type `Int`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Int`\n  --> /tmp/tmp7p_nr6jb.rs:23:13\n   |\n23 |             Int::MIN\
    \ => {}\n   |             ^^^ use of undeclared type `Int`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7p_nr6jb.rs:19:34\n   |\n19 |     let mut max = vec![Int::MAX;\
    \ k];\n   |                                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     let mut max = vec![Int::MAX; k.try_into().unwrap()];\n\
    \   |                                   ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7p_nr6jb.rs:21:15\n\
    \   |\n21 |         match s[i] {\n   |               ^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut len = arr.len();\n    let mut cur_max = arr[0];\n    \n    for i in 1..k\
    \ {\n        let max_i = cur_max;\n        cur_max = arr[i].max();\n        len\
    \ -= 1;\n        if max_i == cur_max {\n            i += 1;\n        }\n     \
    \   arr[i] = max_i;\n    }\n    \n    arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnkgsfte1.rs:22:19\n\
    \   |\n22 |         cur_max = arr[i].max();\n   |                   ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpnkgsfte1.rs:27:9\n   |\n27 |   \
    \      arr[i] = max_i;\n   |         ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![0isize; k as usize];\n    let mut max_value = arr[0];\n    let\
    \ mut j = 0;\n    for ele in arr.iter().cloned() {\n        if ele > max_value\
    \ {\n            j = k;\n            max_value = ele;\n        }\n        j =\
    \ j - 1;\n        if j < k {\n            res[j] = ele;\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp98ceo09c.rs:27:13\n\
    \   |\n27 |             res[j] = ele;\n   |             ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.iter().enumerate().filter_map(|(i,\
    \ n)| {\n        if n > k {\n            None\n        } else {\n            if\
    \ n == k {\n                Some(arr.clone())\n            } else {\n        \
    \        Some(arr.iter().skip(n).take(k - n).cloned())\n            }\n      \
    \  }\n    }).collect()\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpllu2mgdg.rs:18:16\n   |\n\
    18 |         if n > k {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found `isize`\n   |                help: consider\
    \ borrowing here: `&k`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpllu2mgdg.rs:21:18\n   |\n21 |             if n == k {\n   |   \
    \               ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpllu2mgdg.rs:24:38\n   |\n24 |              \
    \   Some(arr.iter().skip(n).take(k - n).cloned())\n   |                      \
    \                ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpllu2mgdg.rs:24:46\n   |\n24 |                 Some(arr.iter().skip(n).take(k\
    \ - n).cloned())\n   |                                              ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |                 Some(arr.iter().skip(n).take((k\
    \ - n).try_into().unwrap()).cloned())\n   |                                  \
    \            +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpllu2mgdg.rs:24:22\n   |\n24 |                 Some(arr.iter().skip(n).take(k\
    \ - n).cloned())\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Cloned<std::iter::Take<Skip<std::slice::Iter<'_,\
    \ isize>>>>`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from\
    \ an iterator over elements of type `Vec<isize>`\n    --> /tmp/tmpllu2mgdg.rs:27:8\n\
    \     |\n27   |     }).collect()\n     |        ^^^^^^^ value of type `Vec<isize>`\
    \ c"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.is_empty()\
    \ || k == 0 {\n        return arr;\n    }\n    if k >= arr.len() {\n        return\
    \ arr;\n    }\n    let mut maximum = arr[0];\n    for i in 1..k {\n        let\
    \ mut current = maximum;\n        if current > arr[i] {\n            maximum =\
    \ arr[i];\n        }\n    }\n    vec![maximum]\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnb1f6apf.rs:20:13\n   |\n\
    20 |     if k >= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if k >= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnb1f6apf.rs:26:22\n  \
    \ |\n26 |         if current > arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpnb1f6apf.rs:27:23\n   |\n27 |  \
    \           maximum = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_val = arr[0]\n    let mut max_idx = 1\n\n    for i in 1..k {\n     \
    \   if max_val > arr[i] {\n            max_val = arr[i]\n            max_idx =\
    \ i\n        }\n    }\n\n    arr[max_idx - 1..]\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpna72pmuj.rs:17:29\n\
    \   |\n17 |     let mut max_val = arr[0]\n   |                             ^ help:\
    \ add `;` here\n18 |     let mut max_idx = 1\n   |     --- unexpected token\n\n\
    error: expected `;`, found keyword `for`\n  --> /tmp/tmpna72pmuj.rs:18:24\n  \
    \ |\n18 |     let mut max_idx = 1\n   |                        ^ help: add `;`\
    \ here\n19 | \n20 |     for i in 1..k {\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found `max_idx`\n  --> /tmp/tmpna72pmuj.rs:22:29\n   |\n22 | \
    \            max_val = arr[i]\n   |                             ^ help: add `;`\
    \ here\n23 |             max_idx = i\n   |             ------- unexpected token\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpna72pmuj.rs:21:22\n\
    \   |\n21 |         if max_val > arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpna72pmuj.rs:22:23\n   |\n22 |  \
    \           max_val = arr[i]\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `RangeFrom<isize>`\n  --> /tmp/tmpna72pmuj.rs:27:5\n   |\n27 |  \
    \   arr[max_idx - 1..]\n   |     ^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `RangeFrom<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    assert!(arr.len()\
    \ >= k, \"k should not be larger than the length of the array.\")\n    if k ==\
    \ 0 || arr.len() == 0 {\n        vec![]\n    } else if k == 1 {\n        vec![arr[0]]\n\
    \    } else {\n        let mut max_element = arr[0]\n        let mut max_index\
    \ = -1\n        for index in 1..arr.len() {\n            if arr[index] > max_element\
    \ {\n                max_element = arr[index]\n                max_index = index\n\
    \            }\n        }\n        vec![max_element]\n    }\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpm67oa4ce.rs:17:84\n\
    \   |\n17 |     assert!(arr.len() >= k, \"k should not be larger than the length\
    \ of the array.\")\n   |                                                     \
    \                               ^ help: add `;` here\n18 |     if k == 0 || arr.len()\
    \ == 0 {\n   |     -- unexpected token\n\nerror: expected `;`, found keyword `let`\n\
    \  --> /tmp/tmpm67oa4ce.rs:23:37\n   |\n23 |         let mut max_element = arr[0]\n\
    \   |                                     ^ help: add `;` here\n24 |         let\
    \ mut max_index = -1\n   |         --- unexpected token\n\nerror: expected `;`,\
    \ found keyword `for`\n  --> /tmp/tmpm67oa4ce.rs:24:31\n   |\n24 |         let\
    \ mut max_index = -1\n   |                               ^ help: add `;` here\n\
    25 |         for index in 1..arr.len() {\n   |         --- unexpected token\n\n\
    error: expected `;`, found `max_index`\n  --> /tmp/tmpm67oa4ce.rs:27:41\n   |\n\
    27 |                 max_element = arr[index]\n   |                          \
    \               ^ help: add `;` here\n28 |                 max_index = index\n\
    \   |                 --------- unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm67oa4ce.rs:17:26\n   |\n17 |     assert!(arr.len() >= k, \"k should\
    \ not be larger than the length of the array.\")\n   |                       \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     assert!(arr.len()\
    \ >= k.try_into().unwrap(), \"k should not be larger than the length of the array.\"\
    )\n   |                           ++++++++++++++++++++\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpm67oa4ce.rs:24:29\n   |\n\
    24 |         let mut max_index = -1\n   |                             ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 o"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // Your\
    \ code here\n    arr.sort_by_key(|x| x.abs()).take(k)\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp_uesdbq1.rs:18:34\n\
    \   |\n18 |     arr.sort_by_key(|x| x.abs()).take(k)\n   |                   \
    \               ^^^^ `()` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    use\
    \ std::cmp::Ordering;\n\n    if arr.len() <= k {\n        return arr\n    }\n\n\
    \    let mut max_nums = vec![std::i32::MAX; k];\n\n    for i in 0..arr.len() {\n\
    \        let mut j = 0;\n\n        // Find the max number\n        while j < k\
    \ && (arr[i] > max_nums[j] || j < k) {\n            j += 1;\n        }\n\n   \
    \     // Add the current number\n        max_nums[j] = arr[i];\n    }\n\n    max_nums\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp9v1aj58z.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9v1aj58z.rs:19:21\n   |\n19 |     if arr.len() <= k {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n19 |     if arr.len() <= k.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9v1aj58z.rs:23:44\n\
    \   |\n23 |     let mut max_nums = vec![std::i32::MAX; k];\n   |             \
    \                               ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |     let mut max_nums = vec![std::i32::MAX; k.try_into().unwrap()];\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[i32]` cannot be indexed by `isize`\n  --> /tmp/tmp9v1aj58z.rs:29:34\n\
    \   |\n29 |         while j < k && (arr[i] > max_nums[j] || j < k) {\n   |   \
    \                               ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<i32>`\n\nerror[E0277]: the type `[i32]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp9v1aj58z.rs:34:9\n   |\n34 |         max_nums[j] =\
    \ arr[i];\n   |         ^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9v1aj58z.rs:37:5\n\
    \   |\n16 | fn maximum(arr: Vec<isiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ > arr.len() {\n        return vec![];\n    }\n    let mut ans = vec![];\n  \
    \  for x in arr {\n        ans.push(x);\n        if ans.len() == k {\n       \
    \     break;\n        }\n    }\n    ans.sort();\n    ans\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeptagli7.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeptagli7.rs:23:25\n   |\n23 |         if ans.len() == k\
    \ {\n   |                         ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |         if ans.len() == k.try_into().unwrap() {\n   |      \
    \                    ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 { \n        vec![] \n    }\n    if k == 1 {\n        arr.iter().take_while(|&x|\
    \ x < 0).collect::<Vec<_>>()\n    }\n    else {\n        arr.iter().take_while(|&x|\
    \ x < 0).take_while((|&x| x < k - 1)).collect::<Vec<_>>()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmprzx5dcw7.rs:24:54\n\
    \   |\n24 |         arr.iter().take_while(|&x| x < 0).take_while((|&x| x < k -\
    \ 1)).collect::<Vec<_>>()\n   |                                              \
    \        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n24 -         arr.iter().take_while(|&x|\
    \ x < 0).take_while((|&x| x < k - 1)).collect::<Vec<_>>()\n24 +         arr.iter().take_while(|&x|\
    \ x < 0).take_while(|&x| x < k - 1).collect::<Vec<_>>()\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprzx5dcw7.rs:18:9\n   |\n17 | /     if k == 0\
    \ { \n18 | |         vec![] \n   | |         ^^^^^^ expected `()`, found struct\
    \ `Vec`\n19 | |     }\n   | |_____- expected this to be `()`\n   |\n   = note:\
    \ expected unit type `()`\n                 found struct `Vec<_>`\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\nhelp: consider using a semicolon here\n   |\n19 |     };\n \
    \  |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzx5dcw7.rs:21:40\n\
    \   |\n21 |         arr.iter().take_while(|&x| x < 0).collect::<Vec<_>>()\n  \
    \ |                                        ^\n   |                           \
    \             |\n   |                                        expected `&isize`,\
    \ found integer\n   |                                        help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzx5dcw7.rs:21:9\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n21 |         arr.iter().take_while(|&x| x < 0).collect::<Vec<_>>()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n            \
    \  found struct `Vec<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzx5dcw7.rs:24:40\n\
    \   |\n24 |         arr.iter().take_while(|&x| x < 0).take_while((|&x| x < k -\
    \ 1)"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ < 0 || k > arr.len() {\n        return vec![];\n    }\n\n    let mut max_arr\
    \ = arr.clone();\n    \n    for i in 0..k {\n        if max_arr[i] > max_arr[i+k]\
    \ {\n            max_arr[i] = max_arr[i+k];\n        }\n    }\n    return max_arr;\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkink9j9y.rs:17:21\n   |\n\
    17 |     if k < 0 || k > arr.len() {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k < 0 || k >\
    \ arr.len().try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkink9j9y.rs:24:12\n\
    \   |\n24 |         if max_arr[i] > max_arr[i+k] {\n   |            ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkink9j9y.rs:24:25\n\
    \   |\n24 |         if max_arr[i] > max_arr[i+k] {\n   |                     \
    \    ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkink9j9y.rs:25:13\n\
    \   |\n25 |             max_arr[i] = max_arr[i+k];\n   |             ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkink9j9y.rs:25:26\n\
    \   |\n25 |             max_arr[i] = max_arr[i+k];\n   |                     \
    \     ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut vec = vec![];\n    let mut cur\
    \ = arr.clone();\n    let mut cur_max = cur[0].clone();\n    for i in 1..k {\n\
    \        let max_element = &mut cur[i - 1].clone();\n        for v in cur.iter_mut().skip(i)\
    \ {\n            if v > max_element {\n                *v = *max_element;\n  \
    \          }\n        }\n        vec.push(max_element);\n    }\n\n    vec\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4wz7e8gb.rs:25:32\n\
    \   |\n25 |         let max_element = &mut cur[i - 1].clone();\n   |         \
    \                       ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4wz7e8gb.rs:26:38\n\
    \   |\n26 |         for v in cur.iter_mut().skip(i) {\n   |                  \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    26 |         for v in cur.iter_mut().skip(i.try_into().unwrap()) {\n   |     \
    \                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4wz7e8gb.rs:34:5\n   |\n16 | fn maximum(arr: Vec<isize>,\
    \ k: isize) -> Vec<isize> {\n   |                                          ----------\
    \ expected `Vec<isize>` because of return type\n...\n34 |     vec\n   |     ^^^\
    \ expected `isize`, found `&mut isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&mut isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![0; k];\n    arr.sort_by(|a, b| b.cmp(a));\n    for &x in arr\
    \ {\n        res[k] = x;\n        k += 1;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3atzn_ee.rs:17:27\n   |\n\
    17 |     let mut res = vec![0; k];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut res = vec![0;\
    \ k.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3atzn_ee.rs:19:9\n   |\n19 | \
    \    for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3atzn_ee.rs:20:9\n   |\n20 |   \
    \      res[k] = x;\n   |         ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![];\n    if arr.len() == 0 {\n        return res;\n    }\n   \
    \ if k == 0 {\n        for ele in arr {\n            res.push(ele);\n        }\n\
    \        return res;\n    }\n    let mut max_element = arr[0];\n    for ele in\
    \ arr {\n        if ele > max_element {\n            max_element = ele;\n    \
    \    }\n    }\n    let mut current_max = max_element;\n    let mut max_element\
    \ = max_element;\n    for ele in arr {\n        if ele != current_max && ele >\
    \ max_element {\n            current_max = ele;\n        }\n        if ele ==\
    \ current_max {\n            max_element = ele;\n        }\n    }\n    let mut\
    \ current_max_idx = 1;\n    let mut max_element = max_element;\n    for ele in\
    \ arr {\n        if ele == current_max && ele < max_element {\n            max_element\
    \ = ele;\n        }\n        if ele == max_element {\n            res.push(ele);\n\
    \        }\n        if ele > max_element {\n            if current_max_idx < k\
    \ {\n                current_max_idx += 1;\n            }\n            current_max_idx\
    \ = current_max_idx;\n            max_element = ele;\n        }\n    }\n    return\
    \ res;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmpo8mvbs5_.rs:35:16\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \         --- move occurs because `arr` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n28  |     for ele in arr {\n    |         \
    \       --- `arr` moved due to this implicit call to `.into_iter()`\n...\n35 \
    \ |     for ele in arr {\n    |                ^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `arr`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n28  |     for ele in &arr {\n    |\
    \                +\n\nerror[E0382]: use of moved value: `arr`\n  --> /tmp/tmpo8mvbs5_.rs:45:16\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \      --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n35 |     for ele in arr {\n   |                --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n45 |     for ele in\
    \ arr {\n   |                ^^^ value used here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n   |\n35 |     for ele in &arr {\n   |                +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        let mut a = vec![None; k];\n        for (i, &i) in arr.iter().enumerate()\
    \ {\n            a[i] = Some(i);\n        }\n        a\n    } else {\n       \
    \ let mut a = vec![None; k];\n        for (i, &i) in arr.iter().enumerate() {\n\
    \            a[i] = Some(i);\n            if i == 0 || a[i.max(0)].is_some() {\n\
    \                a[i.max(0)] = Some(i);\n            }\n        }\n        a\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0416]: identifier `i` is bound more than once in the same pattern\n\
    \  --> /tmp/tmp42eebw_h.rs:19:18\n   |\n19 |         for (i, &i) in arr.iter().enumerate()\
    \ {\n   |                  ^ used in a pattern more than once\n\nerror[E0416]:\
    \ identifier `i` is bound more than once in the same pattern\n  --> /tmp/tmp42eebw_h.rs:25:18\n\
    \   |\n25 |         for (i, &i) in arr.iter().enumerate() {\n   |            \
    \      ^ used in a pattern more than once\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp42eebw_h.rs:17:20\n   |\n17 |     if arr.len() < k {\n   |    \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     if arr.len() < k.try_into().unwrap() {\n   |                     ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp42eebw_h.rs:18:32\n   |\n18 |\
    \         let mut a = vec![None; k];\n   |                                ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |         let mut a =\
    \ vec![None; k.try_into().unwrap()];\n   |                                 ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Option<_>]` cannot be indexed by `isize`\n  --> /tmp/tmp42eebw_h.rs:20:13\n\
    \   |\n20 |             a[i] = Some(i);\n   |             ^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Option<_>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Option<_>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp42eebw_h.rs:22:9\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize) ->\
    \ Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n22 |         a\n   |         ^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<_>>`\n\nerror["
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    use\
    \ std::cmp::Ordering;\n    let mut max_num = arr.to_vec();\n    max_num.sort();\n\
    \    if k > max_num.len() {\n        let mut tmp_num = max_num.clone();\n    \
    \    tmp_num.truncate(k);\n        max_num = tmp_num;\n    }\n    max_num\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpclzhq3j6.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpclzhq3j6.rs:20:12\n   |\n20 |     if k > max_num.len()\
    \ {\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     if k > max_num.len().try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpclzhq3j6.rs:22:26\n   |\n22 |         tmp_num.truncate(k);\n   |   \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n22 |         tmp_num.truncate(k.try_into().unwrap());\n   |           \
    \                ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![arr[0]; k];\n    for i in 0..arr.len() {\n        for j in\
    \ 0..k {\n            if arr[i] > result[j] {\n                result[j] = arr[i];\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1k4bxf4w.rs:17:35\n   |\n\
    17 |     let mut result = vec![arr[0]; k];\n   |                             \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![arr[0]; k.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp1k4bxf4w.rs:20:25\n   |\n20 |         \
    \    if arr[i] > result[j] {\n   |                         ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1k4bxf4w.rs:21:17\n   |\n21 |            \
    \     result[j] = arr[i];\n   |                 ^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // \u6700\
    \u5927\u7684k\u4E2A\u6570\n    let mut max = arr[0];\n    for ele in arr {\n \
    \       if ele > max {\n            max = ele;\n        }\n    }\n    let mut\
    \ result = Vec::new();\n    for i in 0..k {\n        if max <= arr[i] {\n    \
    \        result.push(max);\n        } else {\n            result.push(arr[i]);\n\
    \        }\n        max -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmps4m20s34.rs:26:19\n\
    \   |\n26 |         if max <= arr[i] {\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmps4m20s34.rs:29:25\n   |\n29 |            \
    \ result.push(arr[i]);\n   |                         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ > k {\n        let max_value = arr[arr.len() - k..].iter().max().unwrap();\n\
    \        arr.iter_mut().cloned().filter_map(|x| *x >= max_value).collect::<Vec<_>>()\n\
    \    } else {\n        arr\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpco1__g_a.rs:17:20\n   |\n\
    17 |     if arr.len() > k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() > k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpco1__g_a.rs:18:41\n   |\n18 |         let max_value = arr[arr.len()\
    \ - k..].iter().max().unwrap();\n   |                                        \
    \ ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmpco1__g_a.rs:18:39\n   |\n18 |         let max_value =\
    \ arr[arr.len() - k..].iter().max().unwrap();\n   |                          \
    \             ^ no implementation for `usize - isize`\n   |\n   = help: the trait\
    \ `Sub<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ isize as Sub<isize>>\n           and 48 others\n\nerror[E0271]: type mismatch\
    \ resolving `<std::slice::IterMut<'_, isize> as Iterator>::Item == &_`\n    -->\
    \ /tmp/tmpco1__g_a.rs:19:24\n     |\n19   |         arr.iter_mut().cloned().filter_map(|x|\
    \ *x >= max_value).collect::<Vec<_>>()\n     |                        ^^^^^^ types\
    \ differ in mutability\n     |\n     = note:      expected reference `&_`\n  \
    \           found mutable reference `&mut isize`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `filter_map` exists for struct `Cloned<std::slice::IterMut<'_,\
    \ isize>>`, but its trait bounds were not satisfied\n   --> /tmp/tmpco1__g_a.rs:19:33\n\
    \    |\n19  |           arr.iter_mut().cloned().filter_map(|x| *x >= max_value).collect::<Vec<_>>()\n\
    \    |                                   ^^^^^^^^^^ method cannot be called on\
    \ `Cloned<st"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ <= arr.len() {\n        arr.iter().take(k).collect()\n    } else {\n       \
    \ let mut max_max_value = arr[0];\n        let mut max_value = arr[0];\n     \
    \   for i in arr.iter() {\n            if max_value == i {\n                max_max_value\
    \ = i;\n                max_value = i;\n                continue;\n          \
    \  }\n            if max_value > i {\n                max_max_value = i;\n   \
    \             max_value = i;\n            }\n        }\n        vec![max_max_value]\
    \ + maximum(arr.iter().skip(k).take(k - 1).collect(), k - 1);\n    }\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpivh3g7fg.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpivh3g7fg.rs:18:25\n   |\n18 |         arr.iter().take(k).collect()\n\
    \   |                         ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         arr.iter().take(k.try_into().unwrap()).collect()\n \
    \  |                          ++++++++++++++++++++\n\nerror[E0277]: a value of\
    \ type `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmpivh3g7fg.rs:18:28\n     |\n18   |         arr.iter().take(k).collect()\n\
    \     |                            ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpivh3g7fg.rs:23:29\n\
    \   |\n23 |             if max_value == i {\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |             if max_value == *i {\n   |                           \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpivh3g7fg.rs:24:33\n   |\n\
    20 |         let mut max_max_value = arr[0];\n   |                           \
    \      ------ expected due to this value\n...\n24 |                 max_max_value\
    \ = i;\n   |                                 ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |                 max_max_value\
    \ = *i;\n   |                                 +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpivh3g7fg.rs:25:29\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_value = arr[0];\n    let mut max_index = arr.iter().skip(1).count();\n\
    \    for index in 1..k {\n        if arr[index] > arr[index - 1] {\n         \
    \   max_value = arr[index];\n            max_index = index;\n        }\n    }\n\
    \    let mut final_array = vec![];\n    \n    for i in 0..max_index {\n      \
    \  final_array.append(max_value);\n    }\n    \n    return final_array;\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6226kxcx.rs:20:12\n\
    \   |\n20 |         if arr[index] > arr[index - 1] {\n   |            ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6226kxcx.rs:20:25\n\
    \   |\n20 |         if arr[index] > arr[index - 1] {\n   |                   \
    \      ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6226kxcx.rs:21:25\n\
    \   |\n21 |             max_value = arr[index];\n   |                        \
    \ ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6226kxcx.rs:22:25\n   |\n18 |\
    \     let mut max_index = arr.iter().skip(1).count();\n   |                  \
    \       -------------------------- expected due to this value\n...\n22 |     \
    \        max_index = index;\n   |                         ^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6226kxcx.rs:28:28\n\
    \   |\n28 |         final_array.append(max_value);\n   |                     \
    \       ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<_>`\n                           found type `isize`\n\
    \nerror: "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 { return vec![] }\n    let mut max_i = 0..arr.len();\n    let mut max_value\
    \ = arr[0];\n    for i in 0..k {\n        if arr[i] > max_value {\n          \
    \  max_value = arr[i];\n            max_i = i;\n        }\n    }\n    vec![max_value]\
    \ + arr[max_i..arr.len()]\n}\n\nfn main() {\n    let candidate = maximum;\n  \
    \  assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbo8r777m.rs:21:12\n\
    \   |\n21 |         if arr[i] > max_value {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpbo8r777m.rs:22:25\n   |\n22 |            \
    \ max_value = arr[i];\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbo8r777m.rs:23:21\n\
    \   |\n18 |     let mut max_i = 0..arr.len();\n   |                     ------------\
    \ expected due to this value\n...\n23 |             max_i = i;\n   |         \
    \            ^ expected struct `std::ops::Range`, found `isize`\n   |\n   = note:\
    \ expected struct `std::ops::Range<usize>`\n                found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbo8r777m.rs:26:34\n   |\n26 |\
    \     vec![max_value] + arr[max_i..arr.len()]\n   |                          \
    \        ^^^^^^^^^ expected struct `std::ops::Range`, found `usize`\n   |\n  \
    \ = note: expected struct `std::ops::Range<usize>`\n                found type\
    \ `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `std::ops::Range<std::ops::Range<usize>>`\n\
    \  --> /tmp/tmpbo8r777m.rs:26:23\n   |\n26 |     vec![max_value] + arr[max_i..arr.len()]\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `std::ops::Range<std::ops::Range<usize>>`\n   = help: the following\
    \ other types implement"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    \n \
    \   let mut min_arr = arr;\n    min_arr.sort();\n\n    let mut ans: Vec<isize>\
    \ = vec![];\n    let mut max_val = max_val_iter(&min_arr);\n    let mut current_idx\
    \ = 0;\n    while current_idx < k {\n        ans.push(max_val.unwrap());\n   \
    \     current_idx += 1;\n    }\n\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max_val_iter` in this scope\n  -->\
    \ /tmp/tmpl65dv_ca.rs:22:23\n   |\n22 |     let mut max_val = max_val_iter(&min_arr);\n\
    \   |                       ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    let mut max_so_far = vec![vec![0]; k];\n    for i\
    \ in 0..arr.len() {\n        let current = arr[i];\n        max_arr[i] = if current\
    \ > max_so_far[i - 1].unwrap().unwrap() {\n            max_so_far[i - 1].unwrap().unwrap()\n\
    \        } else {\n            max_so_far[i - 1].unwrap().unwrap() + 1\n     \
    \   };\n    }\n    for i in 0..k {\n        max_arr[i] = max_so_far[i].unwrap().unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * i).abs()).unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].checked_add((-1000 + 1000 * arr.len() - i).abs()).unwrap();\n \
    \   }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * arr.len() - k + i).abs()).unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].checked_add((-1000 + 1000 * k + i).abs()).unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * arr.len() - k + i).abs()).unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].checked_add((-1000 + 1000 * arr.len() - k + i).abs()).unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * arr.len() - k + i).abs()).unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].checked_add((-1000 + 1000 * arr.len() - k + i).abs()).unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * k + i).abs()).unwrap();\n    }\n    for i in 0..k {\n        max_arr[i]\
    \ = max_arr[i].checked_add((-1000 + 1000 * arr.len() - k + i).abs()).unwrap();\n\
    \    }\n    for i in 0..k {\n        max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * arr.len() - k + i).abs()).unwrap();\n    }\n    for i in 0..k {\n \
    \       max_arr[i] = max_arr[i].checked_add((-1000 + 1000 * arr.len() - k + i).abs()).unwrap();\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmz6oe2sf.rs:80:3\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                               - unclosed delimiter\n...\n63\
    \ |     for i in 0..k {\n   |                   - this delimiter might not be\
    \ properly closed...\n64 |         max_arr[i] = max_arr[i].checked_add((-1000\
    \ + 1000 * arr.len() - k + i).abs()).unwrap();\n65 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n80 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmz6oe2sf.rs:18:40\n   |\n18 |     let mut max_so_far\
    \ = vec![vec![0]; k];\n   |                                        ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     let mut max_so_far\
    \ = vec![vec![0]; k.try_into().unwrap()];\n   |                              \
    \           ++++++++++++++++++++\n\nerror[E0599]: no method named `unwrap` found\
    \ for struct `Vec<{integer}>` in the current scope\n  --> /tmp/tmpmz6oe2sf.rs:21:53\n\
    \   |\n21 |         max_arr[i] = if current > max_so_far[i - 1].unwrap().unwrap()\
    \ {\n   |                                                     ^^^^^^ help: there\
    \ is an associated function with a similar name: `swap`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `Vec<{integer}>` in the current scope\n  -->\
    \ /tmp/tmpmz6oe2sf.rs:22:31\n   |\n22 |             max_so_far[i - 1].unwrap().unwrap()\n\
    \   |                               ^^^^^^ help: there is an associated function\
    \ with a similar name: `swap`\n\nerror[E0599]: no method named `unwrap` found\
    \ for struct `Vec<{integer}>` in the current scope\n  --> /tmp/tmpmz6oe2sf.rs:24:31\n\
    \   |\n24 |             max_so_far[i - 1].unwrap().unwrap() + 1\n   |        \
    \                       ^^^^^^ help: there is an associated function with a similar\
    \ name: `swap`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpmz6oe2sf.rs:28:9\n   |\n28 |         max_arr[i] = max_so_far[i].unwrap().unwrap();\n\
    \   |         ^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut new_arr = vec![T::default(); k]\n    \n    for i in 0..k {\n        let\
    \ max = arr.iter().max().unwrap();\n        new_arr[i] = max;\n    }\n\n    new_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpwi1xsx17.rs:17:44\n\
    \   |\n17 |     let mut new_arr = vec![T::default(); k]\n   |                \
    \                            ^ help: add `;` here\n18 |     \n19 |     for i in\
    \ 0..k {\n   |     --- unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `T`\n  --> /tmp/tmpwi1xsx17.rs:17:28\n   |\n17 |     let\
    \ mut new_arr = vec![T::default(); k]\n   |                            ^ use of\
    \ undeclared type `T`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwi1xsx17.rs:17:42\n\
    \   |\n17 |     let mut new_arr = vec![T::default(); k]\n   |                \
    \                          ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     let mut new_arr = vec![T::default(); k.try_into().unwrap()]\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpwi1xsx17.rs:21:9\n\
    \   |\n21 |         new_arr[i] = max;\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut m = vec![vec![vec![0]; k]; arr.len()+1];\n    for i in 0..arr.len() {\n\
    \        for j in 0..k {\n            m[i][arr[i]][j] = max(m[i][arr[i]][j], arr[i]\
    \ - k + j);\n        }\n        m[i][arr[i]][k] = arr[i];\n    }\n    let mut\
    \ result = vec![vec![0]; k+1];\n    for i in 0..k+1 {\n        result[i] = m[i][0][k];\n\
    \    }\n    for i in 1..arr.len() {\n        result[0][i] = max(m[0][i][k], arr[i]\
    \ - k + i);\n        for i in 1..k+1 {\n            result[i][i] = max(m[i][i][k],\
    \ arr[i] - k + i);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmplhjz8yse.rs:20:31\n\
    \   |\n20 |             m[i][arr[i]][j] = max(m[i][arr[i]][j], arr[i] - k + j);\n\
    \   |                               ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmplhjz8yse.rs:29:24\n\
    \   |\n29 |         result[0][i] = max(m[0][i][k], arr[i] - k + i);\n   |    \
    \                    ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmplhjz8yse.rs:31:28\n   |\n31 |  \
    \           result[i][i] = max(m[i][i][k], arr[i] - k + i);\n   |            \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplhjz8yse.rs:17:36\n   |\n17 |     let mut m = vec![vec![vec![0];\
    \ k]; arr.len()+1];\n   |                                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     let mut m = vec![vec![vec![0];\
    \ k.try_into().unwrap()]; arr.len()+1];\n   |                                \
    \     ++++++++++++++++++++\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmplhjz8yse.rs:20:13\n   |\n20 |         \
    \    m[i][arr[i]][j] = max(m[i][arr[i]][j], arr[i] - k + j);\n   |           \
    \  ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmplhjz8yse.rs:20:35\n   |\n20 |             m[i][arr[i]][j] = max(m[i][arr[i]][j],\
    \ arr[i] - k + j);\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_num = arr[0];\n    let mut max_idx = 1;\n    let mut max_idx2 = 1;\n\
    \    let mut max_idx = 1;\n    let mut max_idx2 = 1;\n    let mut max_idx = 1;\n\
    \    let mut max_idx2 = 1;\n    let mut max_idx = 1;\n    let mut max_idx2 = 1;\n\
    \    for &ele in &arr {\n        if ele > max_num {\n            max_num = ele;\n\
    \            max_idx2 = max_idx;\n            max_idx = max_idx2;\n        }\n\
    \        max_idx2 = max_idx;\n        if max_idx2 > k {\n            max_idx2\
    \ = k;\n        }\n        max_idx = max_idx2;\n    }\n    return arr.iter().cloned().take_while(|&ele|\
    \ ele != max_num).collect();\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-3, -4]`,\n right: `[-4, -3, 5]`', /tmp/tmpoj649vu4.rs:43:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.len() <= k {\n        return arr\n    }\n    let mut ret: Vec<isize>\
    \ = vec![arr[0]];\n    let mut max_value: isize = arr[0];\n    for v in arr.iter().skip(1)\
    \ {\n        if v > max_value {\n            max_value = v;\n        }\n     \
    \   ret.push(v);\n        if ret.len() == k {\n            break;\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnpj1czji.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnpj1czji.rs:23:16\n   |\n23 |\
    \         if v > max_value {\n   |                ^^^^^^^^^\n   |            \
    \    |\n   |                expected `&isize`, found `isize`\n   |           \
    \     help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnpj1czji.rs:24:25\n   |\n21 |     let mut max_value: isize\
    \ = arr[0];\n   |                        ----- expected due to this type\n...\n\
    24 |             max_value = v;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \           max_value = *v;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnpj1czji.rs:26:18\n   |\n26 |         ret.push(v);\n  \
    \ |                  ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n26 |         ret.push(*v);\n   |           \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnpj1czji.rs:27:25\n\
    \   |\n27 |         if ret.len() == k {\n   |                         ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n27 |         if ret.len()\
    \ == k.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    use\
    \ std::cmp::Ordering;\n    let mut max_arr = vec![arr[0]; k];\n    for i in 1..k\
    \ {\n        max_arr[i] = max_arr[i-1].max();\n    }\n    arr.iter().cloned().take(k).sort_by(|a,\
    \ b| b.partial_cmp(a).unwrap()).collect::<Vec<_>>()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpcitgrrs7.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcitgrrs7.rs:18:36\n   |\n18 |     let mut max_arr = vec![arr[0];\
    \ k];\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     let mut max_arr = vec![arr[0]; k.try_into().unwrap()];\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcitgrrs7.rs:20:9\n\
    \   |\n20 |         max_arr[i] = max_arr[i-1].max();\n   |         ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcitgrrs7.rs:20:22\n\
    \   |\n20 |         max_arr[i] = max_arr[i-1].max();\n   |                   \
    \   ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcitgrrs7.rs:22:30\n   |\n22 |\
    \     arr.iter().cloned().take(k).sort_by(|a, b| b.partial_cmp(a).unwrap()).collect::<Vec<_>>()\n\
    \   |                              ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n22 |     arr.iter().cloned().take(k.try_into().unwrap()).sort_by(|a,\
    \ b| b.partial_cmp(a).unwrap()).collect::<Vec<_>>()\n   |                    \
    \        "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        panic!(\"length should be less than or equal to\")\n    }\n\n\
    \    let mut max_size = k;\n    let mut max_num: isize = std::i32::MAX;\n\n  \
    \  for elem in arr {\n        if elem > max_num {\n            max_num = elem;\n\
    \        }\n        if elem == max_num {\n            max_size -= 1;\n       \
    \ }\n    }\n\n    arr.drain(..max_size)\n}\n\nfn main() {\n    let candidate =\
    \ maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxt3qh7vx.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxt3qh7vx.rs:22:30\n   |\n22 |     let mut max_num: isize\
    \ = std::i32::MAX;\n   |                      -----   ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |                      |\n   |                      expected\
    \ due to this\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n22 |     let mut max_num: isize = std::i32::MAX.try_into().unwrap();\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0277]:\
    \ the trait bound `RangeTo<isize>: RangeBounds<usize>` is not satisfied\n    -->\
    \ /tmp/tmpxt3qh7vx.rs:33:15\n     |\n33   |     arr.drain(..max_size)\n     |\
    \         ----- ^^^^^^^^^^ the trait `RangeBounds<usize>` is not implemented for\
    \ `RangeTo<isize>`\n     |         |\n     |         required by a bound introduced\
    \ by this call\n     |\n     = help: the following other types implement trait\
    \ `RangeBounds<T>`:\n               RangeTo<&T>\n               RangeTo<T>\nnote:\
    \ required by a bound in `Vec::<T, A>::drain`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxt3qh7vx.rs:33:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n33 |     arr.drain(..max_size)\n \
    \  |     ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `std::vec::Drain`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `std::vec::Drain<'_,\
    \ isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // Do\
    \ not write main() function.\n    // Do not read input, instead use the arguments\
    \ to the function.\n\n    // Write your code here.\n    let mut max_vec: Vec<isize>\
    \ = vec![];\n    let mut max_num: isize = 0;\n\n    for i in arr.iter() {\n  \
    \      let num = *i;\n        if num > max_num {\n            max_num = num;\n\
    \        }\n    }\n    for i in 0..k {\n        max_vec.push(max_num);\n    }\n\
    \    return max_vec;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 5]`,\n right: `[-4, -3, 5]`', /tmp/tmpmyvp8f0g.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 {\n        return vec![];\n    }\n    let mut result: Vec<isize> = vec![];\n\
    \    let mut maximum: isize = 0;\n    for i in 0..arr.len() {\n        if maximum\
    \ < arr[i] {\n            maximum = arr[i];\n        }\n        if i >= k {\n\
    \            result.push(maximum);\n            maximum = 0;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqfy28r8b.rs:26:17\n   |\n\
    26 |         if i >= k {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |         if i >= k.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut arr = arr.to_owned();\n    if k <= arr.len() {\n        let mut max = arr[0];\n\
    \        let mut max_idx = 1;\n        for i in 1..arr.len() {\n            if\
    \ arr[i] > max {\n                max = arr[i];\n                max_idx = i;\n\
    \            }\n        }\n        arr.swap(0, max_idx);\n        arr.remove(0);\n\
    \        return arr.take(k);\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5343q1xu.rs:18:13\n   |\n\
    18 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmp5343q1xu.rs:29:20\n    |\n29  |         \
    \  return arr.take(k);\n    |                      ^^^^ `Vec<isize>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // write\
    \ your code here\n    if arr.len() < k {\n        return vec![None];\n    }\n\
    \    let mut max: isize;\n    arr.iter().for_each(|&e| {\n        if *e > max\
    \ {\n            max = e;\n        }\n    });\n    return arr.iter().take(k).collect();\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6932n8zx.rs:18:20\n   |\n\
    18 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6932n8zx.rs:19:21\n   |\n19 |         return vec![None];\n\
    \   |                     ^^^^ expected `isize`, found enum `Option`\n   |\n \
    \  = note: expected type `isize`\n              found enum `Option<_>`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp6932n8zx.rs:23:12\n   |\n\
    23 |         if *e > max {\n   |            ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6932n8zx.rs:27:28\n   |\n27 |     return arr.iter().take(k).collect();\n\
    \   |                            ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |     return arr.iter().take(k.try_into().unwrap()).collect();\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmp6932n8zx.rs:27:31\n     |\n27   |     return arr.iter().take(k).collect();\n\
    \     |                               ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ans = Vec::new();\n    let mut maxi = arr.iter().cmp(&arr.iter().max()).unwrap();\n\
    \    for i in 0..k {\n        ans.push(maxi);\n        let max_idx = maxi.iter().filter(|&elem|\
    \ *elem >= 0).next().unwrap();\n        maxi = max_idx.iter().filter(|&elem| *elem\
    \ > 0).next().unwrap();\n    }\n    ans.sort();\n    return ans\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<&Option<&isize> as IntoIterator>::Item\
    \ == &isize`\n    --> /tmp/tmphed2a7en.rs:18:31\n     |\n18   |     let mut maxi\
    \ = arr.iter().cmp(&arr.iter().max()).unwrap();\n     |                      \
    \         ^^^ expected `isize`, found `&isize`\n     |\n     = note: expected\
    \ reference `&isize`\n                found reference `&&isize`\nnote: required\
    \ by a bound in `std::iter::Iterator::cmp`\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmphed2a7en.rs:18:54\n\
    \   |\n18 |     let mut maxi = arr.iter().cmp(&arr.iter().max()).unwrap();\n \
    \  |                                                      ^^^^^^ method not found\
    \ in `std::cmp::Ordering`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0271, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut maxs = arr.clone();\n    let mut res = arr.clone();\n\n    for _ in 0..k\
    \ {\n        let max_index = arr.iter().max_by_key(|x| x).unwrap();\n        res.swap(0,\
    \ max_index);\n        maxs.swap(0, max_index);\n    }\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmy6a2554.rs:22:21\n   |\n\
    22 |         res.swap(0, max_index);\n   |                     ^^^^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmy6a2554.rs:23:22\n\
    \   |\n23 |         maxs.swap(0, max_index);\n   |                      ^^^^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result: Vec<isize> = vec![];\n    let mut min_value = i32::MAX;\n    for\
    \ x in arr.iter() {\n        if x < min_value {\n            min_value = x;\n\
    \        }\n        if k == 0 {\n            result.push(x);\n        } else {\n\
    \            if x < result[k] {\n                result.swap(k, result.iter().filter(|&x|\
    \ x < x).count());\n            }\n            if x == result[k] {\n         \
    \       result[k]++;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_xze8cac.rs:30:26\n\
    \   |\n30 |                 result[k]++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |       \
    \          { let tmp = result[k]; result[k] += 1; tmp };\n   |               \
    \  +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n30 -                 result[k]++;\n\
    30 +                 result[k] += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_xze8cac.rs:20:16\n   |\n20 |         if x < min_value {\n   |\
    \                ^^^^^^^^^ expected `&isize`, found `i32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_xze8cac.rs:21:25\n   |\n18 |     let mut min_value = i32::MAX;\n\
    \   |                         -------- expected due to this value\n...\n21 | \
    \            min_value = x;\n   |                         ^ expected `i32`, found\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_xze8cac.rs:24:25\n\
    \   |\n24 |             result.push(x);\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    24 |             result.push(*x);\n   |                         +\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp_xze8cac.rs:26:20\n\
    \   |\n26 |             if x < result[k] {\n   |                    ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_xze8cac.rs:27:29\n   |\n27 |              \
    \   result.swap(k, result.iter().filter(|&x| x < x).count());\n   |          \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    27 |                 result.swap(k.try_into().unwrap(), result.iter().filter(|&x|\
    \ x < x).count());\n   |                          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max = arr[0];\n    for i in 1..k {\n        if max < arr[i] {\n        \
    \    max = arr[i];\n        }\n    }\n    let mut max = vec![max];\n    for i\
    \ in 1..k {\n        for j in 0..i {\n            max.push(max[j]);\n        }\n\
    \    }\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1vgn91mn.rs:19:18\n\
    \   |\n19 |         if max < arr[i] {\n   |                  ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1vgn91mn.rs:20:19\n   |\n20 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp1vgn91mn.rs:26:22\n   |\n26 |            \
    \ max.push(max[j]);\n   |                      ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    assert!(k\
    \ <= arr.len(), \"Invalid k value\");\n    if k == 1 {\n        return arr;\n\
    \    }\n    let mut max: isize = 0;\n    let mut max_idx = 0;\n    for &num in\
    \ arr {\n        if num > max {\n            max = num;\n            max_idx =\
    \ arr.iter().position(|&num| num == max);\n        }\n    }\n    let mut max_list\
    \ = Vec::new();\n    for &num in arr {\n        if num != max {\n            max_list.push(num);\n\
    \        }\n    }\n    max_list = max_list.iter().take(k - 1).cloned().collect();\n\
    \    max.cmp(&arr[max_idx]) < 0 &&\n    max_list.iter().cloned().collect::<Vec<_>>().append(max)\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7a_jxqco.rs:17:18\n   |\n\
    17 |     assert!(k <= arr.len(), \"Invalid k value\");\n   |                 \
    \ ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n17 |     assert!(k\
    \ <= arr.len().try_into().unwrap(), \"Invalid k value\");\n   |              \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7a_jxqco.rs:23:9\n\
    \   |\n23 |     for &num in arr {\n   |         ^^^^    --- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7a_jxqco.rs:26:23\n   |\n22 |     let mut max_idx\
    \ = 0;\n   |                       - expected due to this value\n...\n26 |   \
    \          max_idx = arr.iter().position(|&num| num == max);\n   |           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7a_jxqco.rs:30:9\n\
    \   |\n30 |     for &num in arr {\n   |         ^^^^    --- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7a_jxqco.rs:35:37\n   |\n35 |     max_list =\
    \ max_list.iter().take(k - 1).cloned().collect();\n   |                      \
    \               ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    35 |     max_list = max_list.iter().take((k - 1).try_into().unwrap()).cloned().collect();\n\
    \   |                                     +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mis"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.len() <= k {\n        return arr;\n    }\n    let mut result = Vec::new();\n\
    \    let mut largest = arr[0];\n    let mut index = 0;\n    for i in arr {\n \
    \       if i > largest {\n            largest = i;\n        }\n        if i ==\
    \ largest {\n            result.push(largest);\n            index += 1\n     \
    \   }\n    }\n    \n    let mut left = 0;\n    let mut right = k - 1;\n    \n\
    \    loop {\n        if left > right {\n            break;\n        }\n      \
    \  let mid = (left + right) / 2;\n        if result[mid] > largest{\n        \
    \    right = mid;\n        } else {\n            left = mid + 1;\n        }\n\
    \    }\n    \n    result.push(*largest);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpijb0qqdm.rs:17:31\n   |\n\
    17 |     if k == 0 || arr.len() <= k {\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len()\
    \ <= k.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpijb0qqdm.rs:41:12\n\
    \   |\n41 |         if result[mid] > largest{\n   |            ^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpijb0qqdm.rs:48:17\n   |\n48 |     result.push(*largest);\n\
    \   |                 ^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort();\n\
    \    arr.take(k).collect()\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmps7wg4oru.rs:18:9\n\
    \    |\n18  |       arr.take(k).collect()\n    |           ^^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_k = isize::MAX;\n    let mut max_element = isize::MAX;\n\n    for i\
    \ in 0..k {\n        max_element = arr[max_k];\n\n        for i in 1..arr.len()\
    \ {\n            if arr[i] > max_element {\n                max_element = arr[i];\n\
    \            }\n        }\n\n        max_k = max_element;\n    }\n\n    vec![max_element]\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpi02c1k_q.rs:21:23\n\
    \   |\n21 |         max_element = arr[max_k];\n   |                       ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut arr = arr.to_vec();\n    arr.sort();\n    \n    if arr.len() > k {\n   \
    \     arr[0..k]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq8ted2p4.rs:20:20\n   |\n\
    20 |     if arr.len() > k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if arr.len() > k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmpq8ted2p4.rs:21:9\n\
    \   |\n21 |         arr[0..k]\n   |         ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `std::ops::Range<isize>`\n   = help: the following other\
    \ types implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize>\
    \ as SliceIndex<[T]>>\n             <std::ops::Range<usize> as SliceIndex<str>>\n\
    \   = note: required because of the requirements on the impl of `Index<std::ops::Range<isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k || k <= 0 || k > arr.len() {\n        return vec![];\n    }\n    let mut\
    \ result = vec![];\n    for i in 0..k {\n        let tmp = arr[0];\n        let\
    \ max_idx = arr.iter().enumerate().filter(|&(_, i2)| i2 == i).max().unwrap();\n\
    \        if max_idx < i {\n            continue;\n        }\n        let mut cur\
    \ = max_idx;\n        while cur < i {\n            result.push((arr[cur], cur));\n\
    \            cur += 1;\n        }\n        result.push((tmp, cur));\n    }\n \
    \   result.sort_by_key(|&(a, b)| b.0);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptrbv5ivl.rs:17:20\n   |\n\
    17 |     if arr.len() < k || k <= 0 || k > arr.len() {\n   |                 \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     if\
    \ arr.len() < k.try_into().unwrap() || k <= 0 || k > arr.len() {\n   |       \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrbv5ivl.rs:17:39\n\
    \   |\n17 |     if arr.len() < k || k <= 0 || k > arr.len() {\n   |          \
    \                             ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     if arr.len() < k || k <= 0 || k > arr.len().try_into().unwrap()\
    \ {\n   |                                                ++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmptrbv5ivl.rs:23:67\n\
    \   |\n23 |         let max_idx = arr.iter().enumerate().filter(|&(_, i2)| i2\
    \ == i).max().unwrap();\n   |                                                \
    \                   ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptrbv5ivl.rs:24:22\n   |\n24 |\
    \         if max_idx < i {\n   |                      ^ expected tuple, found\
    \ `isize`\n   |\n   = note: expected tuple `(usize, &isize)`\n               found\
    \ type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrbv5ivl.rs:28:21\n\
    \   |\n28 |         while cur < i {\n   |                     ^ expected tuple,\
    \ found `isize`\n   |\n   = note: expected tuple `(usize, &isize)`\n         \
    \      found type `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `(usize, &isize)`\n  --> /tmp/tmptrbv5ivl.rs:29:26"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n    arr.slice_iter(k..).collect()\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `slice_iter` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp6yued4xq.rs:18:9\n   |\n18 |     arr.slice_iter(k..).collect()\n\
    \   |         ^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut new_arr = vec![0; k]\n    \n    for i in 0..arr.len() {\n        if new_arr.len()\
    \ < k {\n            new_arr.push(*arr[i] - 1)\n        } else {\n           \
    \ let index = new_arr.iter().position(|&elt| *elt > *arr[i]).unwrap();\n     \
    \       new_arr[index] = *arr[i];\n        }\n    }\n    \n    new_arr.iter().cloned().sorted().collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpva3t3oq0.rs:17:33\n\
    \   |\n17 |     let mut new_arr = vec![0; k]\n   |                           \
    \      ^ help: add `;` here\n18 |     \n19 |     for i in 0..arr.len() {\n   |\
    \     --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpva3t3oq0.rs:17:31\n\
    \   |\n17 |     let mut new_arr = vec![0; k]\n   |                           \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut new_arr = vec![0; k.try_into().unwrap()]\n   |                         \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpva3t3oq0.rs:20:28\n\
    \   |\n20 |         if new_arr.len() < k {\n   |                            ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n20 |         if\
    \ new_arr.len() < k.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpva3t3oq0.rs:21:26\n\
    \   |\n21 |             new_arr.push(*arr[i] - 1)\n   |                      \
    \    ^^^^^^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpva3t3oq0.rs:23:56\n\
    \   |\n23 |             let index = new_arr.iter().position(|&elt| *elt > *arr[i]).unwrap();\n\
    \   |                                                        ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpva3t3oq0.rs:23:63\n   |\n\
    23 |             let index = new_arr.iter().position(|&elt| *elt > *arr[i]).unwrap();\n\
    \   |                                                               ^^^^^^^\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpva3t3oq0.rs:24:30\n\
    \   |\n24 |             new_arr[index] = *arr[i];\n   |                      \
    \        ^^^^^^^\n\nerror[E0599]: no method named `sorted` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpva3t3oq0.rs:28:29\n   |\n28 |     new_arr.iter().cloned().sorted().collect()\n\
    \   |             "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    \n \
    \   arr.sort_by(|a, b| a.cmp(b).unwrap());\n    let result = vec![];\n\n    for\
    \ i in 0..k {\n        result.push(arr.pop());\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpz7u368_q.rs:18:33\n   |\n18 |     arr.sort_by(|a,\
    \ b| a.cmp(b).unwrap());\n   |                                 ^^^^^^ method not\
    \ found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz7u368_q.rs:25:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|&x,\
    \ &y| {\n        if x != y {\n            -x cmp -y\n        } else {\n      \
    \      x\n        }\n    });\n\n    let mut max_num = arr[0];\n    for i in 1..k\
    \ {\n        if arr[i] > max_num {\n            max_num = arr[i];\n        }\n\
    \    }\n    max_num\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `cmp`\n  --> /tmp/tmp6he3vzm0.rs:19:16\n   |\n19 |             -x cmp\
    \ -y\n   |                ^^^ expected one of 8 possible tokens\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6he3vzm0.rs:21:13\n   |\n21 |             x\n\
    \   |             ^ expected enum `std::cmp::Ordering`, found `isize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6he3vzm0.rs:27:12\n\
    \   |\n27 |         if arr[i] > max_num {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6he3vzm0.rs:28:23\n   |\n28 |            \
    \ max_num = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6he3vzm0.rs:31:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n31 |     max_num\n   |     ^^^^^^^ expected struct `Vec`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        return arr\n    }\n\n    let mut max_idx = Vec::new();\n   \
    \ let mut max_value = -std::i32::MAX;\n\n    for &i in &arr {\n        if i >\
    \ max_value {\n            max_idx = max_idx.iter().cloned().collect();\n    \
    \        max_value = i;\n        }\n\n        if i == max_value {\n          \
    \  max_idx.push(i);\n        }\n    }\n\n    for i in 0..k - 1 {\n        arr.remove(&max_idx[i]);\n\
    \    }\n\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbmk7a9aj.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbmk7a9aj.rs:25:16\n   |\n25 |         if i > max_value\
    \ {\n   |                ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         if i > max_value.try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbmk7a9aj.rs:27:25\n   |\n22 |     let mut max_value = -std::i32::MAX;\n\
    \   |                         -------------- expected due to this value\n...\n\
    27 |             max_value = i;\n   |                         ^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmk7a9aj.rs:30:17\n\
    \   |\n30 |         if i == max_value {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n30 |         if i == max_value.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbmk7a9aj.rs:36:21\n  \
    \ |\n36 |         arr.remove(&max_idx[i]);\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbmk7a9aj.rs:36:20\n   |\n36 |         arr.remove(&max_idx[i]);\n\
    \   |                    ^^^^^^^^^^^ expected `usize`, found reference\n   |\n\
    \   = note:   expected type `usiz"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    for i in 0..k {\n        if i < arr.len() {\n    \
    \        result = result.push(-arr[i])\n        }\n    }\n    result.sort_unstable();\n\
    \    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbgz7f7f.rs:19:16\n   |\n\
    19 |         if i < arr.len() {\n   |                ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         if i < arr.len().try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpcbgz7f7f.rs:20:35\n  \
    \ |\n20 |             result = result.push(-arr[i])\n   |                    \
    \               ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcbgz7f7f.rs:20:22\n   |\n17 |\
    \     let mut result = vec![];\n   |                      ------ expected due\
    \ to this value\n...\n20 |             result = result.push(-arr[i])\n   |   \
    \                   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n \
    \  |\n   = note: expected struct `Vec<_>`\n           found unit type `()`\nnote:\
    \ method `push` modifies its receiver in-place\n  --> /tmp/tmpcbgz7f7f.rs:20:29\n\
    \   |\n20 |             result = result.push(-arr[i])\n   |                  \
    \    ------ ^^^^ this call modifies `result` in-place\n   |                  \
    \    |\n   |                      you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || k > arr.len() {\n        return vec![];\n    }\n    \n    let mut result\
    \ = vec![];\n    \n    if k == 1 {\n        result.append(&arr[0]);\n        return\
    \ result;\n    }\n    \n    for i in 1..k {\n        let j = i - 1;\n        let\
    \ mut max_elem = &arr[i - 1];\n        let max_idx = i;\n        while j >= 0\
    \ && arr[j] > &max_elem {\n            max_elem = &arr[j];\n            max_idx\
    \ = j;\n            j -= 1;\n        }\n        result.push(max_elem);\n    }\n\
    \    \n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xsy27g0.rs:17:22\n   |\n\
    17 |     if k == 0 || k > arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k == 0 || k\
    \ > arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3xsy27g0.rs:24:23\n   |\n24 |\
    \         result.append(&arr[0]);\n   |                       ^^^^^^^ types differ\
    \ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n \
    \                     found reference `&isize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp3xsy27g0.rs:30:29\n   |\n30 |  \
    \       let mut max_elem = &arr[i - 1];\n   |                             ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3xsy27g0.rs:32:25\n\
    \   |\n32 |         while j >= 0 && arr[j] > &max_elem {\n   |               \
    \          ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3xsy27g0.rs:33:25\n\
    \   |\n33 |             max_elem = &arr[j];\n   |                         ^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements o"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.is_empty() {\n        return vec![]\n    }\n    let mut sorted_arr\
    \ = vec![];\n    let mut max = -std::i32::MAX;\n    let mut min_value = arr.first().unwrap();\n\
    \    for i in 1..arr.len() {\n        if arr[i] > max {\n            max = arr[i];\n\
    \        }\n        if arr[i] < min_value {\n            min_value = arr[i];\n\
    \        }\n    }\n    for i in 1..k {\n        sorted_arr.push(max_value);\n\
    \    }\n    for i in 1..k {\n        sorted_arr.push(min_value);\n    }\n    sorted_arr\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `max_value` in this scope\n  --> /tmp/tmpnt1u9n0x.rs:32:25\n\
    \   |\n32 |         sorted_arr.push(max_value);\n   |                        \
    \ ^^^^^^^^^ help: a local variable with a similar name exists: `min_value`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnt1u9n0x.rs:24:21\n   |\n24 |  \
    \       if arr[i] > max {\n   |                     ^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |         if arr[i] > max.try_into().unwrap() {\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnt1u9n0x.rs:25:19\n   |\n21 |     let mut max = -std::i32::MAX;\n\
    \   |                   -------------- expected due to this value\n...\n25 | \
    \            max = arr[i];\n   |                   ^^^^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnt1u9n0x.rs:27:21\n\
    \   |\n27 |         if arr[i] < min_value {\n   |                     ^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n27 |         if arr[i] < *min_value {\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnt1u9n0x.rs:28:25\n   |\n22 |     let mut min_value\
    \ = arr.first().unwrap();\n   |                         -------------------- expected\
    \ due to this value\n...\n28 |             min_value = arr[i];\n   |         \
    \                ^^^^^^\n   |                         |\n   |                \
    \         expected `&isize`, found `isize`\n   |                         help:\
    \ consider borrowing here: `&arr[i]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnt1u9n0x.rs:37:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize) ->\
    \ Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n37 |     sorted_arr\n   |     ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detai"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut sorted_arr = arr.to_vec();\n    sorted_arr.sort();\n    let mut max_element:\
    \ Vec<isize> = Vec::new();\n    for i in 0..k {\n        if max_element.len()\
    \ < i {\n            max_element.resize(i, 0);\n        }\n        max_element[i]\
    \ = sorted_arr[i];\n    }\n    max_element\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc19q_vim.rs:21:32\n   |\n\
    21 |         if max_element.len() < i {\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n21 |         if\
    \ max_element.len() < i.try_into().unwrap() {\n   |                          \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc19q_vim.rs:22:32\n\
    \   |\n22 |             max_element.resize(i, 0);\n   |                      \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n22 |      \
    \       max_element.resize(i.try_into().unwrap(), 0);\n   |                  \
    \               ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc19q_vim.rs:24:9\n   |\n24 |         max_element[i]\
    \ = sorted_arr[i];\n   |         ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpc19q_vim.rs:24:26\n   |\n24 |         max_element[i]\
    \ = sorted_arr[i];\n   |                          ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.is_empty() {\n        return vec![];\n    }\n    \n    let mut max_val\
    \ = arr[0];\n    let mut max_idx = 1;\n\n    for i in 1..k {\n        if arr[i]\
    \ > max_val {\n            max_val = arr[i];\n            max_idx = i;\n     \
    \   }\n    }\n\n    max_idx.step().cloned().take(k).cloned()\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphx_olayz.rs:25:12\n\
    \   |\n25 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmphx_olayz.rs:26:23\n   |\n26 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0599]: no method named `step` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmphx_olayz.rs:31:13\n   |\n\
    31 |     max_idx.step().cloned().take(k).cloned()\n   |             ^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k { \n        vec![]\n    }\n    else {\n        let mut new_max = arr[0];\n\
    \        let mut max = vec![new_max];\n        for i in 1..k {\n            if\
    \ arr[i] > new_max {\n                new_max = arr[i];\n            }\n     \
    \       else {\n                max.push(new_max);\n                new_max =\
    \ arr[i];\n            }\n        }\n        max.push(new_max);\n        max\n\
    \    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp49jqgli1.rs:17:20\n   |\n\
    17 |     if arr.len() < k { \n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ { \n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp49jqgli1.rs:24:16\n  \
    \ |\n24 |             if arr[i] > new_max {\n   |                ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp49jqgli1.rs:25:27\n   |\n25 |  \
    \               new_max = arr[i];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp49jqgli1.rs:29:27\n   |\n29 |  \
    \               new_max = arr[i];\n   |                           ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut arr: Vec<isize> = arr.to_vec();\n    let len = arr.len();\n    if k > len\
    \ {\n        vec![vec![0; k]]\n    } else {\n        for mut max in 0..k {\n \
    \           let min_idx = max.min(len);\n            let mut temp_arr: Vec<isize>\
    \ = arr\n                .iter()\n                .take(min_idx)\n           \
    \     .cloned()\n                .collect();\n            temp_arr.sort_unstable_by_key(|x|\
    \ *x);\n            arr[k] = temp_arr[k];\n            k += 1;\n        }\n  \
    \  }\n    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb_xeddmo.rs:19:12\n   |\n\
    19 |     if k > len {\n   |            ^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if k > len.try_into().unwrap() {\n   |   \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb_xeddmo.rs:20:22\n\
    \   |\n20 |         vec![vec![0; k]]\n   |                      ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         vec![vec![0; k.try_into().unwrap()]]\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb_xeddmo.rs:20:9\n   |\n19 | /     if k > len {\n20 | |       \
    \  vec![vec![0; k]]\n   | |         ^^^^^^^^^^^^^^^^ expected `()`, found struct\
    \ `Vec`\n21 | |     } else {\n22 | |         for mut max in 0..k {\n...  |\n32\
    \ | |         }\n33 | |     }\n   | |     -- help: consider using a semicolon\
    \ here\n   | |_____|\n   |       expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                 found struct `Vec<Vec<{integer}>>`\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb_xeddmo.rs:23:35\n\
    \   |\n23 |             let min_idx = max.min(len);\n   |                    \
    \               ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    23 |             let min_idx = max.min(len.try_into().unwrap());\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb_xeddmo.rs:26:23\n   |\n26 |                 .take(min_idx)\n\
    \   |                       ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |                 .take(min_idx.try_into().unwrap())\n   |   \
    \                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k { k } else { k }\n\n    let mut max_heap = VecDeque::new();\n    let mut\
    \ temp: Vec<isize> = vec![];\n\n    let mut min_heap = VecDeque::new();\n    let\
    \ mut min_heap_head: Vec<isize> = vec![];\n\n    for i in 0..arr.len() {\n   \
    \     temp.push(arr[i]);\n        max_heap.push_back(temp);\n        min_heap.push_back(temp);\n\
    \    }\n\n    for i in (0..k).rev() {\n        while min_heap.len() > 0 {\n  \
    \          let mut min_val = min_heap.pop_front().unwrap();\n\n            while\
    \ max_heap.len() > 0 &&\n                max_heap.peek_front() < min_val {\n \
    \               max_heap.pop_front();\n            }\n            \n         \
    \   min_heap.push_back(min_val);\n        }\n    }\n\n    min_heap.push_back(max_heap.peek_front());\n\
    \n    for i in (0..k).rev() {\n        while min_heap_head.len() > 0 {\n     \
    \       let mut min_val = min_heap_head.pop_front().unwrap();\n\n            while\
    \ max_heap.len() > 0 &&\n                max_heap.peek_front() < min_val {\n \
    \               max_heap.pop_front();\n            }\n            \n         \
    \   min_heap_head.push_back(min_val);\n        }\n    }\n\n    min_heap_head.push_back(max_heap.peek_front());\n\
    \n    for i in (0..k).rev() {\n        heap::max_heapify(min_heap.iter().cloned(),\
    \ i);\n        heap::max_heapify(min_heap_head.iter().cloned(), i);\n    }\n\n\
    \    for i in min_heap.iter().cloned() {\n        heap::pop_heap(min_heap.iter().cloned(),\
    \ i);\n    }\n\n    for i in min_heap_head.iter().cloned() {\n        heap::pop_heap(min_heap_head.iter().cloned(),\
    \ i);\n    }\n\n    min_heap.clear();\n    min_heap_head.clear();\n\n    for i\
    \ in max_heap.iter().cloned() {\n        heap::pop_heap(max_heap.iter().cloned(),\
    \ i);\n    }\n\n    max_heap.clear();\n    max_heap.push_back(temp);\n    max_heap.push_back(temp);\n\
    \    max_heap.push_back(temp);\n\n    for i in max_heap.iter().cloned() {\n  \
    \      heap::push_heap(max_heap.iter().cloned(), i);\n    }\n\n    return max_heap.into_iter().cloned().collect();\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `heap`\n\
    \  --> /tmp/tmp9rs4tn7f.rs:62:9\n   |\n62 |         heap::max_heapify(min_heap.iter().cloned(),\
    \ i);\n   |         ^^^^ use of undeclared crate or module `heap`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `heap`\n  --> /tmp/tmp9rs4tn7f.rs:63:9\n\
    \   |\n63 |         heap::max_heapify(min_heap_head.iter().cloned(), i);\n   |\
    \         ^^^^ use of undeclared crate or module `heap`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `heap`\n  --> /tmp/tmp9rs4tn7f.rs:67:9\n\
    \   |\n67 |         heap::pop_heap(min_heap.iter().cloned(), i);\n   |       \
    \  ^^^^ use of undeclared crate or module `heap`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `heap`\n  --> /tmp/tmp9rs4tn7f.rs:71:9\n \
    \  |\n71 |         heap::pop_heap(min_heap_head.iter().cloned(), i);\n   |   \
    \      ^^^^ use of undeclared crate or module `heap`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared crate or module `heap`\n  --> /tmp/tmp9rs4tn7f.rs:78:9\n\
    \   |\n78 |         heap::pop_heap(max_heap.iter().cloned(), i);\n   |       \
    \  ^^^^ use of undeclared crate or module `heap`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `heap`\n  --> /tmp/tmp9rs4tn7f.rs:87:9\n \
    \  |\n87 |         heap::push_heap(max_heap.iter().cloned(), i);\n   |       \
    \  ^^^^ use of undeclared crate or module `heap`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `VecDeque`\n  --> /tmp/tmp9rs4tn7f.rs:19:24\n   |\n19\
    \ |     let mut max_heap = VecDeque::new();\n   |                        ^^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::VecDeque;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `VecDeque`\n  --> /tmp/tmp9rs4tn7f.rs:22:24\n   |\n22\
    \ |     let mut min_heap = VecDeque::new();\n   |                        ^^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::VecDeque;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9rs4tn7f.rs:17:20\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.len() <= k { return arr; }\n    let mut max_idx = k;\n    let mut\
    \ max_value = arr[0];\n    let mut j = 0;\n    for i in 1..arr.len() {\n     \
    \   if arr[i] > max_value {\n            max_value = arr[i];\n        }\n    \
    \    if i - j < max_idx {\n            max_idx = i - j;\n        }\n        j++;\n\
    \    }\n    max_idx -= 1;\n    if k - max_idx < arr.len() {\n        max_idx +=\
    \ k;\n    }\n    return arr.split_at_mut(max_idx);\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpl92ecm_n.rs:28:10\n\
    \   |\n28 |         j++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n28 |         { let tmp = j; j += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n28 -         j++;\n28 +         j +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl92ecm_n.rs:17:31\n\
    \   |\n17 |     if k == 0 || arr.len() <= k { return arr; }\n   |            \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     if k == 0 || arr.len() <= k.try_into().unwrap() { return arr; }\n   |\
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl92ecm_n.rs:25:20\n   |\n25 |         if i - j < max_idx\
    \ {\n   |                    ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         if i - j < max_idx.try_into().unwrap() {\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl92ecm_n.rs:26:23\n   |\n18 |     let mut max_idx = k;\n   |  \
    \                     - expected due to this value\n...\n26 |             max_idx\
    \ = i - j;\n   |                       ^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl92ecm_n.rs:31:22\n   |\n31 |\
    \     if k - max_idx < arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |     if k - max_idx\
    \ < arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl92ecm_n.rs:34:29\n   |\n34 |\
    \     return arr.split_at_mut(max_idx);\n   |                             ^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n34 |  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ len = arr.len();\n    let mut max_len = k;\n    let mut max_element = arr[0];\n\
    \    let mut result = Vec::with_capacity(max_len);\n    for i in 1..len {\n  \
    \      if arr[i-1] > max_element {\n            max_element = arr[i-1];\n    \
    \    }\n        result[max_len-=1] += max_element;\n        max_len -= 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5udheau.rs:20:41\n   |\n\
    20 |     let mut result = Vec::with_capacity(max_len);\n   |                 \
    \                        ^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     let mut result = Vec::with_capacity(max_len.try_into().unwrap());\n\
    \   |                                                ++++++++++++++++++++\n\n\
    error[E0277]: the type `[_]` cannot be indexed by `()`\n  --> /tmp/tmpp5udheau.rs:25:9\n\
    \   |\n25 |         result[max_len-=1] += max_element;\n   |         ^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `()`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `(Bound<usize>, Bound<usize>)`\n   = note: required because\
    \ of the requirements on the impl of `Index<()>` for `Vec<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.truncate(k);\n    return arr;\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxz9qulel.rs:19:18\n   |\n\
    19 |     arr.truncate(k);\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     arr.truncate(k.try_into().unwrap());\n   |\
    \                   ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 {\n        return arr\n    }\n    if k <= arr.len() {\n        let mut\
    \ max = arr[k - 1];\n        for &i in arr[k..] {\n            if i > max {\n\
    \                max = i;\n            }\n        }\n        vec![max]\n    }\
    \ else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwtxnq5js.rs:20:13\n   |\n\
    20 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwtxnq5js.rs:21:23\n  \
    \ |\n21 |         let mut max = arr[k - 1];\n   |                       ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `RangeFrom<isize>`\n  --> /tmp/tmpwtxnq5js.rs:22:19\n\
    \   |\n22 |         for &i in arr[k..] {\n   |                   ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `RangeFrom<isize>`\n   = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n             <RangeFrom<usize>\
    \ as SliceIndex<[T]>>\n             <RangeFrom<usize> as SliceIndex<str>>\n  \
    \ = note: required because of the requirements on the impl of `Index<RangeFrom<isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 {\n        return arr.clone(); // arr is a copy of the array\n    }\n \
    \   if k == 1 {\n        return arr.iter().max_by_key(|x| x).unwrap(); // only\
    \ need k-1 numbers\n    }\n    if k > arr.len() {\n        return vec![];\n  \
    \  }\n    if arr.len() == 0 {\n        return vec![];\n    }\n    \n    let mut\
    \ sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.max_by_key(|x|\
    \ x).unwrap(); // remove k-1 max numbers\n    if k == sorted_arr.len() {\n   \
    \     return sorted_arr.clone();\n    }\n    sorted_arr.split_off(k)\n       \
    \ .iter()\n        .fold(vec![], |mut acc, x| acc.push(x));\n    sorted_arr.clone()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpepwbwb0c.rs:21:16\n   |\n\
    16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |             \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n21 |         return arr.iter().max_by_key(|x| x).unwrap(); // only\
    \ need k-1 numbers\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpepwbwb0c.rs:23:12\n   |\n23 |     if k > arr.len() {\n   |         \
    \   ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     if\
    \ k > arr.len().try_into().unwrap() {\n   |                     ++++++++++++++++++++\n\
    \nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpepwbwb0c.rs:32:16\n\
    \    |\n32  |       sorted_arr.max_by_key(|x| x).unwrap(); // remove k-1 max numbers\n\
    \    |                  ^^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n  \
    \  = note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepwbwb0c.rs:33:13\n\
    \   |\n33 |     if k == sorted_arr.len() {\n   |             ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n33 |     if k ==\
    \ sorted_arr.len().try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpepwbwb0c.rs:36:26\n   |\n36 |\
    \     sorted_arr.split_off(k)\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n36 |     sorted_arr.split_off(k.try_into().unwrap())\n\
    \   |                  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![0; k];\n    for ele in arr.iter().enumerate().take(k) {\n   \
    \     if ele > res.len() {\n            for mut ele in res.iter_mut() {\n    \
    \            if *ele > ele {\n                    *ele = *ele;\n             \
    \   }\n            }\n        }\n        *ele = ele.1;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprmz7vvdr.rs:17:27\n   |\n\
    17 |     let mut res = vec![0; k];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut res = vec![0;\
    \ k.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprmz7vvdr.rs:18:44\n   |\n18 |\
    \     for ele in arr.iter().enumerate().take(k) {\n   |                      \
    \                      ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     for ele in arr.iter().enumerate().take(k.try_into().unwrap())\
    \ {\n   |                                             ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprmz7vvdr.rs:19:18\n   |\n19 |  \
    \       if ele > res.len() {\n   |                  ^^^^^^^^^ expected tuple,\
    \ found `usize`\n   |\n   = note: expected tuple `(usize, &isize)`\n         \
    \      found type `usize`\n\nerror[E0277]: can't compare `{integer}` with `&mut\
    \ {integer}`\n  --> /tmp/tmprmz7vvdr.rs:21:25\n   |\n21 |                 if *ele\
    \ > ele {\n   |                         ^ no implementation for `{integer} < &mut\
    \ {integer}` and `{integer} > &mut {integer}`\n   |\n   = help: the trait `PartialOrd<&mut\
    \ {integer}>` is not implemented for `{integer}`\n   = help: the following other\
    \ types implement trait `PartialOrd<Rhs>`:\n             f32\n             f64\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n           and 6 others\n\nerror[E0614]: type\
    \ `(usize, &isize)` cannot be dereferenced\n  --> /tmp/tmprmz7vvdr.rs:26:9\n \
    \  |\n26 |         *ele = ele.1;\n   |         ^^^^\n   |\nhelp: parentheses are\
    \ required to parse this as an expression\n   |\n19 ~         (if ele > res.len()\
    \ {\n20 |             for mut ele in res.iter_mut() {\n21 |                 if\
    \ *ele > ele {\n22 |                     *ele = *ele;\n23 |                 }\n\
    24 "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by(|&a|\
    \ a.cmp(&a.max()))\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n\
    \  --> /tmp/tmpw0dsh1v0.rs:17:9\n   |\n17 |     arr.sort_by(|&a| a.cmp(&a.max()))\n\
    \   |         ^^^^^^^ ---- takes 1 argument\n   |         |\n   |         expected\
    \ closure that takes 2 arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw0dsh1v0.rs:17:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n17 |     arr.sort_by(|&a| a.cmp(&a.max()))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0593.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    if k > arr.len() {\n        return\
    \ vec![];\n    }\n\n    if k == 1 {\n        return vec![arr[0]];\n    }\n\n \
    \   let mut ans = vec![];\n    let mut max = arr[0];\n\n    for i in 1..k {\n\
    \        if arr[i] > max {\n            max = arr[i];\n        }\n    }\n\n  \
    \  for i in 0..k {\n        ans.push(max);\n        max = max if i < k else arr[i];\n\
    \    }\n\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmp6mf1gmh_.rs:40:19\n   |\n40 |         max\
    \ = max if i < k else arr[i];\n   |                   ^^ expected one of 8 possible\
    \ tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6mf1gmh_.rs:21:12\n\
    \   |\n21 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp6mf1gmh_.rs:33:12\n   |\n33 |  \
    \       if arr[i] > max {\n   |            ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp6mf1gmh_.rs:34:19\n   |\n34 |            \
    \ max = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max: Vec<isize> = vec![Vec::new(); k];\n    let mut i: isize = 0;\n    while\
    \ i < arr.len() {\n        max[i / k].push(arr[i]);\n        i += 1;\n    }\n\
    \    max\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9mn505l.rs:17:36\n   |\n\
    17 |     let mut max: Vec<isize> = vec![Vec::new(); k];\n   |                \
    \                    ^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected type `isize`\n            found struct `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt9mn505l.rs:17:48\n   |\n17 |     let mut max:\
    \ Vec<isize> = vec![Vec::new(); k];\n   |                                    \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n17\
    \ |     let mut max: Vec<isize> = vec![Vec::new(); k.try_into().unwrap()];\n \
    \  |                                                 ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpt9mn505l.rs:19:15\n   |\n19 |  \
    \   while i < arr.len() {\n   |               ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     while i < arr.len().try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt9mn505l.rs:20:9\n   |\n\
    20 |         max[i / k].push(arr[i]);\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpt9mn505l.rs:20:25\n   |\n20 |         max[i\
    \ / k].push(arr[i]);\n   |                         ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: abortin"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_unstable();\n\
    \    let mut result = vec![0; k];\n    for e in arr.iter().cloned().take(k) {\n\
    \        result[e as usize - 1] = max(result[e as usize - 1], e);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpfoveb7yd.rs:20:34\n\
    \   |\n20 |         result[e as usize - 1] = max(result[e as usize - 1], e);\n\
    \   |                                  ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfoveb7yd.rs:18:30\n   |\n18 |     let mut result\
    \ = vec![0; k];\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     let mut result = vec![0; k.try_into().unwrap()];\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfoveb7yd.rs:19:39\n   |\n19 |     for e in arr.iter().cloned().take(k)\
    \ {\n   |                                       ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     for e in arr.iter().cloned().take(k.try_into().unwrap())\
    \ {\n   |                                        ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max: isize = arr[0];\n    for i in 1..k {\n        if max < arr[i] {\n \
    \           max = arr[i];\n        }\n    }\n    vec.iter().filter(|x| x == max).collect()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpfynn2ya3.rs:23:5\n\
    \   |\n23 |     vec.iter().filter(|x| x == max).collect()\n   |     ^^^ not a\
    \ value\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpfynn2ya3.rs:19:18\n   |\n19 |         if max < arr[i] {\n   |      \
    \            ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfynn2ya3.rs:20:19\n\
    \   |\n20 |             max = arr[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if k <= arr.len() {\n        result.resize(arr.len());\n\
    \        for element in arr.iter() {\n            if element > result.last().unwrap()\
    \ {\n                result.push(-element);\n            }\n            if result.len()\
    \ == k {\n                break;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpccjfkzt0.rs:18:13\n   |\n\
    18 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmpccjfkzt0.rs:19:16\n\
    \     |\n19   |         result.resize(arr.len());\n     |                ^^^^^^\
    \ --------- supplied 1 argument\n     |                |\n     |             \
    \   expected 2 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpccjfkzt0.rs:24:32\n   |\n24 |             if\
    \ result.len() == k {\n   |                                ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |             if result.len() ==\
    \ k.try_into().unwrap() {\n   |                                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![0isize; k];\n    let len = arr.len();\n    let max_num = arr[len\
    \ - 1];\n\n    for i in 0..k {\n        let max_index = max_num.saturating_sub(i).wrapping_sub(i);\n\
    \        result[i] = arr[i];\n        max_num = arr[i];\n    }\n\n    result[k]\
    \ = max_num;\n\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpur5gyb9p.rs:17:35\n   |\n\
    17 |     let mut result = vec![0isize; k];\n   |                             \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     let\
    \ mut result = vec![0isize; k.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpur5gyb9p.rs:23:9\n   |\n23 |         result[i]\
    \ = arr[i];\n   |         ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpur5gyb9p.rs:23:21\n   |\n23 |         result[i] = arr[i];\n   |\
    \                     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpur5gyb9p.rs:24:19\n\
    \   |\n24 |         max_num = arr[i];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpur5gyb9p.rs:27:5\n   |\n27 |     result[k]\
    \ = max_num;\n   |     ^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        return arr\n    }\n    let mut max_arr = vec![vec!(0i32)] *\
    \ (arr.len() + 1);\n    for i in 0..k {\n        let mut max_val = arr[0];\n \
    \       for v in arr.iter_mut() {\n            if v > max_val {\n            \
    \    max_val = v;\n            }\n        }\n        max_arr[i] = max_val;\n \
    \   }\n    let mut ans = vec![0i32] * (arr.len() + 1);\n    for i in 0..k {\n\
    \        for v in max_arr.iter_mut() {\n            if v > i {\n             \
    \   *v = *v;\n            }\n        }\n        for v in arr.iter_mut() {\n  \
    \          if v > i {\n                *v = *v;\n            }\n        }\n  \
    \  }\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvis_yvi1.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0369]: cannot multiply\
    \ `Vec<Vec<i32>>` by `usize`\n  --> /tmp/tmpvis_yvi1.rs:20:40\n   |\n20 |    \
    \ let mut max_arr = vec![vec!(0i32)] * (arr.len() + 1);\n   |                \
    \       ---------------- ^ --------------- usize\n   |                       |\n\
    \   |                       Vec<Vec<i32>>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvis_yvi1.rs:24:20\n   |\n24 |             if v > max_val {\n  \
    \ |                    ^^^^^^^\n   |                    |\n   |              \
    \      expected `&mut isize`, found `isize`\n   |                    help: consider\
    \ mutably borrowing here: `&mut max_val`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpvis_yvi1.rs:25:27\n   |\n22 |         let mut max_val = arr[0];\n\
    \   |                           ------ expected due to this value\n...\n25 | \
    \                max_val = v;\n   |                           ^ expected `isize`,\
    \ found `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n25\
    \ |                 max_val = *v;\n   |                           +\n\nerror[E0369]:\
    \ cannot multiply `Vec<i32>` by `usize`\n  --> /tmp/tmpvis_yvi1.rs:30:30\n   |\n\
    30 |     let mut ans = vec![0i32] * (arr.len() + 1);\n   |                   ----------\
    \ ^ --------------- usize\n   |                   |\n   |                   Vec<i32>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvis_yvi1.rs:38:20\n   |\n38 |\
    \             if v > i {\n   |                    ^\n   |                    |\n\
    \   |                    expected `&mut isize`, found `isize`\n   |          \
    \          help: consider mutably borrowing here: `&mut i`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut maxs = Vec::<isize>::new();\n    let mut max_i = 0;\n    let mut max_val\
    \ = arr[0];\n    let mut cur_val = 0;\n    let mut i = 0;\n    while i < k {\n\
    \        if max_val < arr[i] {\n            max_val = arr[i];\n            max_i\
    \ = i;\n        }\n        cur_val += arr[i];\n        if cur_val > max_val {\n\
    \            max_val = cur_val;\n            max_i = i;\n        }\n        i\
    \ += 1;\n    }\n    maxs.push(max_i);\n    \n    maxs\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpytt8yolf.rs:23:22\n\
    \   |\n23 |         if max_val < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpytt8yolf.rs:24:23\n   |\n24 |  \
    \           max_val = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpytt8yolf.rs:27:20\n   |\n27 |         cur_val\
    \ += arr[i];\n   |                    ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_idx = 0\n    let mut max_val = arr[0]\n    let mut max_pos = 0\n   \
    \ for &idx in arr.iter() {\n        if *idx > max_val {\n            max_val =\
    \ *idx\n            max_idx = idx\n        }\n        if *idx == max_val {\n \
    \           max_pos += 1\n        }\n    }\n\n    let mut max_mut_pos = max_pos\n\
    \    let mut max_mut_idx = max_idx\n    while max_mut_pos > k {\n        max_mut_pos\
    \ -= k\n        max_mut_idx += k\n    }\n\n    if max_mut_pos > k {\n        let\
    \ mut max_mut_val = max_mut_pos\n        let mut max_mut_idx = max_mut_idx\n \
    \       while max_mut_pos > k {\n            max_mut_pos -= k\n            max_mut_idx\
    \ += k\n        }\n\n        max_mut_idx += k\n        max_mut_idx += k\n    \
    \    vec![max_mut_val]\n    } else {\n        vec![max_mut_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3rrrly75.rs:17:24\n\
    \   |\n17 |     let mut max_idx = 0\n   |                        ^ help: add `;`\
    \ here\n18 |     let mut max_val = arr[0]\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `let`\n  --> /tmp/tmp3rrrly75.rs:18:29\n   |\n18\
    \ |     let mut max_val = arr[0]\n   |                             ^ help: add\
    \ `;` here\n19 |     let mut max_pos = 0\n   |     --- unexpected token\n\nerror:\
    \ expected `;`, found keyword `for`\n  --> /tmp/tmp3rrrly75.rs:19:24\n   |\n19\
    \ |     let mut max_pos = 0\n   |                        ^ help: add `;` here\n\
    20 |     for &idx in arr.iter() {\n   |     --- unexpected token\n\nerror: expected\
    \ `;`, found `max_idx`\n  --> /tmp/tmp3rrrly75.rs:22:27\n   |\n22 |          \
    \   max_val = *idx\n   |                           ^ help: add `;` here\n23 |\
    \             max_idx = idx\n   |             ------- unexpected token\n\nerror:\
    \ expected `;`, found keyword `let`\n  --> /tmp/tmp3rrrly75.rs:30:34\n   |\n30\
    \ |     let mut max_mut_pos = max_pos\n   |                                  ^\
    \ help: add `;` here\n31 |     let mut max_mut_idx = max_idx\n   |     --- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp3rrrly75.rs:31:34\n\
    \   |\n31 |     let mut max_mut_idx = max_idx\n   |                          \
    \        ^ help: add `;` here\n32 |     while max_mut_pos > k {\n   |     -----\
    \ unexpected token\n\nerror: expected `;`, found `max_mut_idx`\n  --> /tmp/tmp3rrrly75.rs:33:25\n\
    \   |\n33 |         max_mut_pos -= k\n   |                         ^ help: add\
    \ `;` here\n34 |         max_mut_idx += k\n   |         ----------- unexpected\
    \ token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp3rrrly75.rs:38:42\n\
    \   |\n38 |         let mut max_mut_val = max_mut_pos\n   |                  \
    \                        ^ help: add `;` here\n39 |         let mut max_mut_idx\
    \ = max_mut_idx\n   |         --- unexpected token\n\nerror: expected `;`, found\
    \ keyword `while`\n  --> /tmp/tmp3rrrly75.rs:39:42\n   |\n39 |         let mut\
    \ max_mut_idx = max_mut_idx\n   |                      "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_heap = Vec::new();\n    \n    for i in 0..arr.len() {\n        max_heap.push(arr[i]);\n\
    \        if max_heap.len() > k {\n            max_heap.pop();\n        }\n   \
    \ }\n    \n    max_heap.shrink_to_fit();\n    max_heap\n}\n\nfn main() {\n   \
    \ let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf04m99tt.rs:21:29\n   |\n\
    21 |         if max_heap.len() > k {\n   |                             ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |         if max_heap.len()\
    \ > k.try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut res = vec![0isize; k];\n    for i in 0..k {\n        res.iter_mut().enumerate().for_each(|(idx,\
    \ &element)| {\n            if element >= arr[i] {\n                res.get_mut(idx)\
    \ = element;\n            }\n        });\n    }\n    res.iter_mut().enumerate().for_each(|(idx,\
    \ &element)| {\n        if idx == k {\n            return;\n        }\n      \
    \  if element < arr[idx + 1] {\n            idx *= 2;\n        }\n        if idx\
    \ == k {\n            return;\n        }\n        res[idx] = element;\n    });\n\
    \    res\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptsuhob5a.rs:17:32\n   |\n\
    17 |     let mut res = vec![0isize; k];\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n17 |     let mut\
    \ res = vec![0isize; k.try_into().unwrap()];\n   |                           \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptsuhob5a.rs:19:52\n\
    \   |\n19 |         res.iter_mut().enumerate().for_each(|(idx, &element)| {\n\
    \   |                                                    ^^^^^^^^- expected due\
    \ to this\n   |                                                    |\n   |   \
    \                                                 types differ in mutability\n\
    \   |                                                    help: you can probably\
    \ remove the explicit borrow: `element`\n   |\n   = note: expected mutable reference\
    \ `&mut isize`\n                      found reference `&_`\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptsuhob5a.rs:20:27\n\
    \   |\n20 |             if element >= arr[i] {\n   |                         \
    \  ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmptsuhob5a.rs:21:34\n   |\n\
    21 |                 res.get_mut(idx) = element;\n   |                 ----------------\
    \ ^\n   |                 |\n   |                 cannot assign to this expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptsuhob5a.rs:25:48\n   |\n25 |\
    \     res.iter_mut().enumerate().for_each(|(idx, &element)| {\n   |          \
    \                                      ^^^^^^^^- expected due to this\n   |  \
    \                                              |\n   |                       \
    \                         types differ in mu"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr\n\
    \        .into_iter()\n        .enumerate()\n        .filter_map(|(idx, elem)|\
    \ if idx < k { Some(elem) } else { None })\n        .collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkguq6yaq.rs:20:44\n   |\n\
    20 |         .filter_map(|(idx, elem)| if idx < k { Some(elem) } else { None })\n\
    \   |                                            ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         .filter_map(|(idx, elem)| if idx < k.try_into().unwrap()\
    \ { Some(elem) } else { None })\n   |                                        \
    \     ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // code\
    \ here\n    let mut res : Vec<isize> = vec![];\n    for i in 0..k {\n        let\
    \ mut max = (arr.iter().max().unwrap() + (arr.len() - i));\n        res.push(max);\n\
    \    }\n    return res;\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpwrjwqvob.rs:20:23\n\
    \   |\n20 |         let mut max = (arr.iter().max().unwrap() + (arr.len() - i));\n\
    \   |                       ^                                           ^\n  \
    \ |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n20 -         let mut max = (arr.iter().max().unwrap() + (arr.len() - i));\n\
    20 +         let mut max = arr.iter().max().unwrap() + (arr.len() - i);\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwrjwqvob.rs:20:65\n   |\n\
    20 |         let mut max = (arr.iter().max().unwrap() + (arr.len() - i));\n  \
    \ |                                                                 ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpwrjwqvob.rs:20:63\n   |\n20 |         let mut max = (arr.iter().max().unwrap()\
    \ + (arr.len() - i));\n   |                                                  \
    \             ^ no implementation for `usize - isize`\n   |\n   = help: the trait\
    \ `Sub<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwrjwqvob.rs:20:52\n   |\n20 |         let mut max = (arr.iter().max().unwrap()\
    \ + (arr.len() - i));\n   |                                                  \
    \  ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot add\
    \ `usize` to `&isize`\n  --> /tmp/tmpwrjwqvob.rs:20:50\n   |\n20 |         let\
    \ mut max = (arr.iter().max().unwrap() + (arr.len() - i));\n   |             \
    \                                     ^ no implementation for `&isize + usize`\n\
    \   |\n   = help: the trait `Add<usize>` is not implemented for `&isize`\n   =\
    \ help: the following other types"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    for e in arr.iter().enumerate().skip(k) {\n      \
    \  result.push(*e.1);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wx36pva.rs:18:42\n   |\n\
    18 |     for e in arr.iter().enumerate().skip(k) {\n   |                     \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    18 |     for e in arr.iter().enumerate().skip(k.try_into().unwrap()) {\n   | \
    \                                          ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ > arr.len() {\n        return vec![None; k];\n    }\n\n    let mut l = arr.len()\
    \ - k;\n    let mut res = vec![None; k];\n\n    while l > 0 {\n        res[l]\
    \ = Some(arr[l]);\n        res.swap(l-1, l);\n        l--;\n    }\n\n    res\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp1erekkk6.rs:27:12\n\
    \   |\n27 |         l--;\n   |            ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1erekkk6.rs:17:12\n   |\n17 |     if k > arr.len()\
    \ {\n   |            ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     if k > arr.len().try_into().unwrap() {\n   |           \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1erekkk6.rs:18:21\n\
    \   |\n18 |         return vec![None; k];\n   |                     ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1erekkk6.rs:18:27\n\
    \   |\n18 |         return vec![None; k];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |         return vec![None;\
    \ k.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1erekkk6.rs:21:29\n   |\n21 |\
    \     let mut l = arr.len() - k;\n   |                             ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmp1erekkk6.rs:21:27\n   |\n21 |     let mut l = arr.len() - k;\n\
    \   |                           ^ no implementation for `usize - isize`\n   |\n\
    \   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1erekkk6.rs:22:30\n   |\n22 |     let mut res = vec![None;\
    \ k];\n   |                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = arr;\n    let mut max_pos = k;\n    loop {\n        if max_pos\
    \ == 0 {\n            break;\n        }\n        max_arr[max_pos] =\n        \
    \    std::cmp::max(max_arr[max_pos], max_arr[max_pos - 1]);\n        max_pos -=\
    \ 1;\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n   \
    \ assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8f7d9g7f.rs:23:9\n\
    \   |\n23 |         max_arr[max_pos] =\n   |         ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp8f7d9g7f.rs:24:27\n   |\n24 |            \
    \ std::cmp::max(max_arr[max_pos], max_arr[max_pos - 1]);\n   |               \
    \            ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8f7d9g7f.rs:24:45\n\
    \   |\n24 |             std::cmp::max(max_arr[max_pos], max_arr[max_pos - 1]);\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_val: isize = 0;\n    let mut max_pos = 0;\n    for i in 0..k {\n   \
    \     if arr[i] > max_val {\n            max_pos = i;\n            max_val = arr[i];\n\
    \        }\n    }\n    \n    let mut res = vec![max_val];\n    for i in 0..k-1\
    \ {\n        if arr[i] == max_val {\n            res[i] = max_pos;\n        }\
    \ else {\n            res[i] = i;\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptd3bnld4.rs:20:12\n\
    \   |\n20 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmptd3bnld4.rs:22:23\n   |\n22 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmptd3bnld4.rs:28:12\n   |\n28 |         if arr[i]\
    \ == max_val {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmptd3bnld4.rs:29:13\n   |\n29 |             res[i] = max_pos;\n \
    \  |             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptd3bnld4.rs:31:13\n\
    \   |\n31 |             res[i] = i;\n   |             ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![];\n    max_arr.push(arr[0]);\n    max_arr.push(arr[1]);\n\
    \    for i in 2..arr.len() {\n        if arr[i] > max_arr[k] {\n            max_arr.push(arr[i]);\n\
    \        }\n        if max_arr[k] < arr[i] {\n            max_arr[k] = arr[i];\n\
    \        }\n    }\n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbgrgx9t8.rs:21:21\n\
    \   |\n21 |         if arr[i] > max_arr[k] {\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbgrgx9t8.rs:24:12\n\
    \   |\n24 |         if max_arr[k] < arr[i] {\n   |            ^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbgrgx9t8.rs:25:13\n   |\n25 |  \
    \           max_arr[k] = arr[i];\n   |             ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.len() < k {\n        vec![]\n    } else {\n        let mut result\
    \ = vec![Int::MAX; (k - 1).min(arr.len())]\n        .into_iter()\n        .zip(arr.iter())\n\
    \        .map(|(max, _)| max);\n        result.extend(arr.iter().take(k - 1).collect::<Vec<_>>());\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Int`\n  --> /tmp/tmp_gmka0y4.rs:20:31\n\
    \   |\n20 |         let mut result = vec![Int::MAX; (k - 1).min(arr.len())]\n\
    \   |                               ^^^ use of undeclared type `Int`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_gmka0y4.rs:17:30\n   |\n17 |     if k == 0\
    \ || arr.len() < k {\n   |                              ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k == 0 || arr.len() < k.try_into().unwrap()\
    \ {\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_gmka0y4.rs:20:53\n   |\n20 |         let mut\
    \ result = vec![Int::MAX; (k - 1).min(arr.len())]\n   |                      \
    \                               ^^^^^^^^^ expected `isize`, found `usize`\n  \
    \ |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         let mut result = vec![Int::MAX; (k - 1).min(arr.len().try_into().unwrap())]\n\
    \   |                                                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_gmka0y4.rs:20:41\n   |\n20 |\
    \         let mut result = vec![Int::MAX; (k - 1).min(arr.len())]\n   |      \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |         let mut result = vec![Int::MAX;\
    \ (k - 1).min(arr.len()).try_into().unwrap()]\n   |                          \
    \                                     ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `extend` found for struct `Map` in the current scope\n  --> /tmp/tmp_gmka0y4.rs:24:16\n\
    \   |\n24 |         result.extend(arr.iter().take(k - 1).collect::<Vec<_>>());\n\
    \   |                ^^^^^^ method not found in `Map<Zip<std::vec::IntoIter<_>,\
    \ std::slice::Iter<'_, isize>>, [closure@/tmp/tmp_gmka0y4.rs:23:14: 23:28]>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ <= arr.len() {\n        let mut ans = vec![None;k];\n        let mut len = 0;\n\
    \        for elem in arr.iter() {\n            ans[len] = if elem > ans[len] {\n\
    \                elem\n            } else {\n                ans[len]\n      \
    \      };\n            len += 1;\n        }\n        ans[len..].sort();\n    \
    \    ans.iter().cloned().collect()\n    } else {\n        vec![None;k]\n    }\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpezqlbcie.rs:17:13\n   |\n\
    17 |     if k <= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k <= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpezqlbcie.rs:18:33\n   |\n18 |         let mut ans = vec![None;k];\n\
    \   |                                 ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |         let mut ans = vec![None;k.try_into().unwrap()];\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpezqlbcie.rs:21:34\n   |\n21 |             ans[len] = if\
    \ elem > ans[len] {\n   |                                  ^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&isize`\n        \
    \           found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpezqlbcie.rs:22:17\n\
    \   |\n22 |                 elem\n   |                 ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<_>`\n           found\
    \ reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n22 |\
    \                 Some(elem)\n   |                 +++++    +\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `Option<_>`\n    --> /tmp/tmpezqlbcie.rs:29:29\n     |\n29   |     \
    \    ans.iter().cloned().collect()\n     |                             ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=Option<_>>`\n\
    \     |\n     = help: the trait `FromIterator<Option<_>>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpezqlbcie.rs:31:14\n   |\n31 |         vec![None;k]\n   |           \
    \   ^^^^ expect"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut l = arr.len();\n    let mut max_so_far = arr.clone();\n    max_so_far.sort_unstable();\n\
    \    for i in 0..k {\n        if i >= l { break; }\n        max_so_far.pop();\n\
    \    }\n    max_so_far\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b6ti_xp.rs:21:17\n   |\n\
    21 |         if i >= l { break; }\n   |                 ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |         if i >= l.try_into().unwrap()\
    \ { break; }\n   |                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut l = arr.len() - k;\n    let mut ans = vec![None; k];\n    for i in (0..k).rev()\
    \ {\n        let j = l;\n        while j > 0 {\n            ans[i] = if arr[j]\
    \ > arr[j - 1] { arr[j] } else { arr[j - 1] };\n            j -= 1;\n        }\n\
    \    }\n    ans.sort_unstable();\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqk7zxsic.rs:17:29\n   |\n\
    17 |     let mut l = arr.len() - k;\n   |                             ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpqk7zxsic.rs:17:27\n   |\n17 |     let mut l = arr.len() - k;\n\
    \   |                           ^ no implementation for `usize - isize`\n   |\n\
    \   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqk7zxsic.rs:18:30\n   |\n18 |     let mut ans = vec![None;\
    \ k];\n   |                              ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     let mut ans = vec![None; k.try_into().unwrap()];\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[Option<_>]` cannot be indexed by `isize`\n  --> /tmp/tmpqk7zxsic.rs:22:13\n\
    \   |\n22 |             ans[i] = if arr[j] > arr[j - 1] { arr[j] } else { arr[j\
    \ - 1] };\n   |             ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Option<_>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Option<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqk7zxsic.rs:27:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n27 |     ans\n   |     ^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Vec<i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ >= arr.len() {\n        return vec![];\n    }\n    let mut max_val = arr[k];\n\
    \    let mut max_idx = k;\n    for (i, &elt) in arr.iter().enumerate() {\n   \
    \     if elt > max_val {\n            max_val = elt;\n            max_idx = i;\n\
    \        }\n    }\n    if max_idx < k {\n        max_val = arr[k];\n    } else\
    \ {\n        max_val\n    }\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwnl082hu.rs:17:13\n   |\n\
    17 |     if k >= arr.len() {\n   |             ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k >= arr.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwnl082hu.rs:20:23\n  \
    \ |\n20 |     let mut max_val = arr[k];\n   |                       ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwnl082hu.rs:25:23\n   |\n21 |     let mut max_idx = k;\n   |  \
    \                     - expected due to this value\n...\n25 |             max_idx\
    \ = i;\n   |                       ^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpwnl082hu.rs:29:19\n\
    \   |\n29 |         max_val = arr[k];\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwnl082hu.rs:28:20\n\
    \   |\n28 |       if max_idx < k {\n   |  ____________________^\n29 | |      \
    \   max_val = arr[k];\n30 | |     } else {\n   | |_____^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwnl082hu.rs:31:9\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ < 0 || k > arr.len() {\n        return vec![];\n    }\n    let mut maximum =\
    \ arr[0];\n    for i in 1..k {\n        if maximum < arr[i] {\n            maximum\
    \ = arr[i];\n        }\n    }\n    return vec![maximum];\n}\n\nfn main() {\n \
    \   let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxng570yj.rs:17:21\n   |\n\
    17 |     if k < 0 || k > arr.len() {\n   |                     ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if k < 0 || k >\
    \ arr.len().try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxng570yj.rs:22:22\n\
    \   |\n22 |         if maximum < arr[i] {\n   |                      ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpxng570yj.rs:23:23\n   |\n23 |  \
    \           maximum = arr[i];\n   |                       ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        return vec![];\n    }\n    let mut max_val = arr[0];\n    let\
    \ mut max_idx = arr.iter().cloned().take(k).collect::<Vec<_>>();\n    for i in\
    \ arr.iter().skip(1).take(k) {\n        if *i > max_val {\n            max_val\
    \ = *i;\n            max_idx = max_idx.iter().cloned().take(1).collect::<Vec<_>>();\n\
    \        }\n    }\n    max_idx.append(&max_val);\n    max_idx\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqz2bz9_f.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqz2bz9_f.rs:21:48\n   |\n21 |     let mut max_idx = arr.iter().cloned().take(k).collect::<Vec<_>>();\n\
    \   |                                                ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     let mut max_idx = arr.iter().cloned().take(k.try_into().unwrap()).collect::<Vec<_>>();\n\
    \   |                                                 ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqz2bz9_f.rs:22:38\n   |\n22 |  \
    \   for i in arr.iter().skip(1).take(k) {\n   |                              \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n22 |     for\
    \ i in arr.iter().skip(1).take(k.try_into().unwrap()) {\n   |                \
    \                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqz2bz9_f.rs:28:20\n   |\n28 |     max_idx.append(&max_val);\n \
    \  |                    ^^^^^^^^ types differ in mutability\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<isize>`\n                      found reference\
    \ `&isize`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    use\
    \ std::cmp::Ordering;\n\n    let mut min = arr[0];\n    let mut max = arr[0];\n\
    \n    for num in arr.iter_mut() {\n        if num > max {\n            max = num;\n\
    \        } else if num < min {\n            min = num;\n        }\n    }\n\n \
    \   let mut result = Vec::new();\n    if min <= k {\n        for num in arr.iter_mut()\
    \ {\n            if num > min {\n                result.push(*num);\n        \
    \    }\n        }\n        result.push(min);\n    }\n    if result.len() < k {\n\
    \        result.extend(&mut vec![max] * (k - result.len()));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpj1fk5d2s.rs:17:9\n\
    \   |\n17 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj1fk5d2s.rs:23:18\n   |\n23 |         if num > max {\n\
    \   |                  ^^^\n   |                  |\n   |                  expected\
    \ `&mut isize`, found `isize`\n   |                  help: consider mutably borrowing\
    \ here: `&mut max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1fk5d2s.rs:24:19\n\
    \   |\n20 |     let mut max = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n24 |             max = num;\n   |                  \
    \ ^^^ expected `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |             max = *num;\n   |                   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj1fk5d2s.rs:25:25\n   |\n25 |  \
    \       } else if num < min {\n   |                         ^^^\n   |        \
    \                 |\n   |                         expected `&mut isize`, found\
    \ `isize`\n   |                         help: consider mutably borrowing here:\
    \ `&mut min`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1fk5d2s.rs:26:19\n\
    \   |\n19 |     let mut min = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n26 |             min = num;\n   |                  \
    \ ^^^ expected `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |             min = *num;\n   |                   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj1fk5d2s.rs:33:22\n   |\n33 |  \
    \           if num > min {\n   |                      ^^^\n   |              \
    \        |\n   |                      expected `&mut isize`, found `isize`\n \
    \  |                      help: consider mutably borrowing here: `&mut min`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj1fk5d2s.rs:39:23\n   |\n39 |  \
    \   if result.len() < k {\n   |                       ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted valu"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut maximum = vec![Vec::new(); k];\n\n    for i in 0..arr.len() {\n        if\
    \ maximum[i] < arr[i] {\n            maximum[i] = arr[i];\n        }\n    }\n\n\
    \    for i in 0..k {\n        maximum[i] = maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] = maximum[i] + arr[i];\n   \
    \ }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().unwrap();\n\
    \    }\n\n    for i in 0..k {\n        maximum[i] += maximum[i].iter().max().\n\
    }\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphdso7m8y.rs:130:3\n\
    \    |\n16  | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    113 |     for i in 0..k {\n    |                   - this delimiter might not\
    \ be properly closed...\n114 |         maximum[i] += maximum[i].iter().max().\n\
    115 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    130 | }\n    |   ^\n\nerror: unexpected token: `}`\n   --> /tmp/tmphdso7m8y.rs:115:1\n\
    \    |\n115 | }\n    | ^\n\nerror[E0434]: can't capture dynamic environment in\
    \ a fn item\n   --> /tmp/tmphdso7m8y.rs:118:21\n    |\n118 |     let candidate\
    \ = maximum;\n    |                     ^^^^^^^\n    |\n    = help: use the `||\
    \ { ... }` closure form instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphdso7m8y.rs:17:40\n\
    \   |\n17 |     let mut maximum = vec![Vec::new(); k];\n   |                 \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n17 |     let mut maximum = vec![Vec::new(); k.try_into().unwrap()];\n \
    \  |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphdso7m8y.rs:20:25\n   |\n20 |         if maximum[i]\
    \ < arr[i] {\n   |                         ^^^^^^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<_>`\n                found type\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphdso7m8y.rs:21:26\n\
    \   |\n21 |             maximum[i] = arr[i];\n   |             ----------   ^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\n   = note: expected struct `Vec<_>`\n\
    \                found type `isize`\n\nerror[E0277]: the type `[Vec<_>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmphdso7m8y.rs:26:9\n   |\n26 |         maximum[i]\
    \ = maximum[i].iter().max().unwrap();\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    use\
    \ std::cmp::Ordering;\n    arr.sort_by(|a, b| Ordering::<usize>::cmp(b, a));\n\
    \    let mut max = vec![0; k as usize];\n    for i in 0..k {\n        max[i] =\
    \ arr[i];\n    }\n    max\n}\n\nfn main() {\n    let candidate = maximum;\n  \
    \  assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0107]: this enum takes 0 generic arguments but 1 generic argument\
    \ was supplied\n  --> /tmp/tmpm3jta36u.rs:18:24\n   |\n18 |     arr.sort_by(|a,\
    \ b| Ordering::<usize>::cmp(b, a));\n   |                        ^^^^^^^^---------\
    \ help: remove these generics\n   |                        |\n   |           \
    \             expected 0 generic arguments\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm3jta36u.rs:18:47\n   |\n18 |     arr.sort_by(|a, b| Ordering::<usize>::cmp(b,\
    \ a));\n   |                                               ^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n   |\n   = note: expected reference `&std::cmp::Ordering`\n \
    \             found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm3jta36u.rs:18:50\n   |\n18 |     arr.sort_by(|a, b| Ordering::<usize>::cmp(b,\
    \ a));\n   |                                                  ^ expected enum\
    \ `std::cmp::Ordering`, found `isize`\n   |\n   = note: expected reference `&std::cmp::Ordering`\n\
    \              found reference `&isize`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpm3jta36u.rs:21:9\n   |\n21 |   \
    \      max[i] = arr[i];\n   |         ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpm3jta36u.rs:21:18\n   |\n21 |         max[i]\
    \ = arr[i];\n   |                  ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0107, E0277, E0308.\nFor more information about\
    \ an erro"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = Vec::new();\n    for i in 0..arr.len() {\n        let cur_max\
    \ = max_arr\n            .iter()\n            .filter(|&x| x == i)\n         \
    \   .max();\n\n        if cur_max == i {\n            max_arr.append(arr[i]);\n\
    \        } else {\n            max_arr.remove(max_arr.iter().find(|&x| x == i).unwrap());\n\
    \            max_arr.push(i);\n        }\n    }\n    max_arr[k..].sort();\n}\n\
    \nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&_` with `usize`\n  --> /tmp/tmpbmrmol1e.rs:21:28\n\
    \   |\n21 |             .filter(|&x| x == i)\n   |                           \
    \ ^^ no implementation for `&_ == usize`\n   |\n   = help: the trait `PartialEq<usize>`\
    \ is not implemented for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmrmol1e.rs:24:23\n\
    \   |\n24 |         if cur_max == i {\n   |                       ^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<&_>`\n     \
    \         found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmrmol1e.rs:25:28\n\
    \   |\n25 |             max_arr.append(arr[i]);\n   |                        \
    \    ^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]:\
    \ can't compare `&_` with `usize`\n  --> /tmp/tmpbmrmol1e.rs:27:55\n   |\n27 |\
    \             max_arr.remove(max_arr.iter().find(|&x| x == i).unwrap());\n   |\
    \                                                       ^^ no implementation for\
    \ `&_ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmrmol1e.rs:27:28\n\
    \   |\n27 |             max_arr.remove(max_arr.iter().find(|&x| x == i).unwrap());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found reference\n   |\n   = note:   expected type `usize`\n       \
    \    found reference `&_`\nhelp: consider dereferencing the borrow\n   |\n27 |\
    \             max_arr.remove(*max_arr.iter().find(|&x| x == i).unwrap());\n  \
    \ |                            +\n\nerror[E0277]: the type `[usize]` cannot be\
    \ indexed by `RangeFrom<isize>`\n  --> /tmp/tmpbmrmol1e.rs:31:5\n   |\n31 |  \
    \   max_arr[k..].sort();\n   |     ^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>` is not\
    \ implemented for `RangeFrom<isize>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ > arr.len() {\n        return vec![];\n    }\n\n    if k == 0 {\n        return\
    \ vec![arr[0]];\n    }\n\n    let mut ret = vec![];\n    let mut max_val = 0;\n\
    \n    for v in arr.iter() {\n        if v > max_val {\n            max_val = v;\n\
    \        }\n    }\n\n    for i in 0..k {\n        if arr[i] > max_val {\n    \
    \        ret.push(max_val);\n            max_val = arr[i];\n        }\n    }\n\
    \n    ret.push(max_val);\n    ret\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprsm3il50.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprsm3il50.rs:29:16\n   |\n29 |         if v > max_val {\n\
    \   |                ^^^^^^^\n   |                |\n   |                expected\
    \ `&isize`, found integer\n   |                help: consider borrowing here:\
    \ `&max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprsm3il50.rs:30:23\n\
    \   |\n26 |     let mut max_val = 0;\n   |                       - expected due\
    \ to this value\n...\n30 |             max_val = v;\n   |                    \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n30 |             max_val = *v;\n   |                       +\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprsm3il50.rs:35:12\n\
    \   |\n35 |         if arr[i] > max_val {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmprsm3il50.rs:37:23\n   |\n37 |            \
    \ max_val = arr[i];\n   |                       ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // Your\
    \ code here\n    \n    let mut max = 0usize;\n    for i in 0..arr.len() {\n  \
    \      if max == 0 || max == arr[i] {\n            max = arr[i];\n        }\n\
    \    }\n    let mut arr1 = vec![];\n    for i in 0..k {\n        arr1.push(max);\n\
    \    }\n    for i in 0..arr.len() {\n        if arr[i] > max {\n            max\
    \ = arr[i];\n        }\n    }\n    for i in 0..k {\n        arr1.push(arr[i]);\n\
    \    }\n    arr1\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbiprf_uz.rs:21:31\n   |\n\
    21 |         if max == 0 || max == arr[i] {\n   |                            \
    \   ^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |      \
    \   if max == 0 || max == arr[i].try_into().unwrap() {\n   |                 \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbiprf_uz.rs:22:19\n   |\n19 |     let mut max = 0usize;\n   | \
    \                  ------ expected due to this value\n...\n22 |             max\
    \ = arr[i];\n   |                   ^^^^^^ expected `usize`, found `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbiprf_uz.rs:30:21\n   |\n30 |  \
    \       if arr[i] > max {\n   |                     ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n30 |         if arr[i] > max.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbiprf_uz.rs:31:19\n   |\n19 |     let mut max = 0usize;\n\
    \   |                   ------ expected due to this value\n...\n31 |         \
    \    max = arr[i];\n   |                   ^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbiprf_uz.rs:35:19\n\
    \   |\n35 |         arr1.push(arr[i]);\n   |                   ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbiprf_uz.rs:37:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \                                    ---------- expected `Vec<isize>` because\
    \ of return type\n...\n37 |     arr1\n   |     ^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note:"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![-1000, 1000][..k]];\n    for ele in arr {\n        let\
    \ mut maxv = -1000isize;\n        for i in 0..k {\n            if result[i][ele]\
    \ > maxv {\n                maxv = result[i][ele];\n            }\n        }\n\
    \        result[k] = maxv;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmppfz3_6mq.rs:17:27\n   |\n17 |     let mut result = vec![vec![-1000,\
    \ 1000][..k]];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `RangeTo<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeTo<usize> as SliceIndex<[T]>>\n\
    \             <RangeTo<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeTo<isize>>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmppfz3_6mq.rs:21:16\n\
    \   |\n21 |             if result[i][ele] > maxv {\n   |                ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmppfz3_6mq.rs:22:24\n\
    \   |\n22 |                 maxv = result[i][ele];\n   |                     \
    \   ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmppfz3_6mq.rs:25:9\n\
    \   |\n25 |         result[k] = maxv;\n   |         ^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\n\
    Fo"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut ans = vec![std::i32::MAX;];\n    ans.sort_unstable_by_key(|x| if x < 0 {\
    \ std::i32::MAX - x } else { x });\n    let maxnum = ans[k..].iter().max().unwrap();\n\
    \    ans[k..].iter().filter(|x| x > maxnum).cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected end of macro invocation\n  --> /tmp/tmpcq7qasx_.rs:17:38\n\
    \   |\n17 |     let mut ans = vec![std::i32::MAX;];\n   |                    \
    \                  ^ missing tokens in macro arguments\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_num = vec![0; k];\n\n    for &i in arr {\n        if i >= 0 {\n    \
    \        max_num[k] = i;\n            k += 1;\n        }\n    }\n\n    for i in\
    \ 0..k {\n        max_num[i] = max_num[k];\n    }\n\n    max_num\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprw6wk_e0.rs:17:31\n   |\n\
    17 |     let mut max_num = vec![0; k];\n   |                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     let mut max_num\
    \ = vec![0; k.try_into().unwrap()];\n   |                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprw6wk_e0.rs:19:9\n   |\n19 | \
    \    for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprw6wk_e0.rs:21:13\n   |\n21 |  \
    \           max_num[k] = i;\n   |             ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprw6wk_e0.rs:27:9\n   |\n27 |   \
    \      max_num[i] = max_num[k];\n   |         ^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmprw6wk_e0.rs:27:22\n   |\n27 |  \
    \       max_num[i] = max_num[k];\n   |                      ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ < k {\n        return vec![];\n    }\n    let mut maxs = vec![];\n    let max_idx\
    \ = arr.len() - k;\n    for i in 0..max_idx {\n        if arr[i] > maxs.last()\
    \ {\n            maxs.push(arr[i]);\n        }\n    }\n    maxs\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1zfmoj2x.rs:17:20\n   |\n\
    17 |     if arr.len() < k {\n   |                    ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() < k.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1zfmoj2x.rs:21:31\n   |\n21 |     let max_idx = arr.len()\
    \ - k;\n   |                               ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmp1zfmoj2x.rs:21:29\n\
    \   |\n21 |     let max_idx = arr.len() - k;\n   |                           \
    \  ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zfmoj2x.rs:23:21\n\
    \   |\n23 |         if arr[i] > maxs.last() {\n   |                     ^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&_>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ > arr.len() {\n        return vec![];\n    }\n    let mut max_num = arr[0];\n\
    \    let mut max_num = max_num.max();\n    let mut max_index: isize = 0;\n   \
    \ for i in 0..(k - 1) {\n        if arr[i] > max_num {\n            max_num =\
    \ arr[i];\n            max_index = i;\n        }\n    }\n    let mut ret: Vec<isize>\
    \ = vec![max_num];\n    for i in k..arr.len() {\n        if arr[i] > arr[k] {\n\
    \            ret[k] = max_num;\n            break;\n        }\n        ret.push(max_num);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeeet5gh5.rs:17:12\n   |\n\
    17 |     if k > arr.len() {\n   |            ^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if k > arr.len().try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpeeet5gh5.rs:21:31\n\
    \    |\n21  |     let mut max_num = max_num.max();\n    |                    \
    \           ^^^- supplied 0 arguments\n    |                               |\n\
    \    |                               expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpeeet5gh5.rs:24:12\n   |\n24 |         if arr[i] >\
    \ max_num {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpeeet5gh5.rs:25:23\n   |\n25 |             max_num = arr[i];\n \
    \  |                       ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeeet5gh5.rs:30:17\n\
    \   |\n30 |     for i in k..arr.len() {\n   |                 ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpeeet5gh5.rs:31:12\n   |\n31 |         if arr[i] >\
    \ arr[k] {\n   |            ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr\n\
    \        .iter()\n        .enumerate()\n        .map(|(idx, x)| {\n          \
    \  let max = (*x).abs().max();\n            let max_idx = idx;\n            Some(max\
    \ as isize, max_idx)\n        })\n        .filter_map(|(max, idx)| {\n       \
    \     if max == 0 {\n                None\n            } else {\n            \
    \    if *idx > k {\n                    None\n                } else {\n     \
    \               Some(max as isize, idx)\n                }\n            }\n  \
    \      })\n        .collect()\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpccr6bw19.rs:21:34\n    |\n21  |             let max = (*x).abs().max();\n\
    \    |                                  ^^^- supplied 0 arguments\n    |     \
    \                             |\n    |                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0061]: this\
    \ enum variant takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpccr6bw19.rs:23:13\n\
    \   |\n23 |             Some(max as isize, max_idx)\n   |             ^^^^ ------------\
    \  ------- supplied 2 arguments\n   |             |\n   |             expected\
    \ 1 argument\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpccr6bw19.rs:25:22\n\
    \   |\n25 |         .filter_map(|(max, idx)| {\n   |                      ^^^^^^^^^-\n\
    \   |                      |        |\n   |                      |        expected\
    \ due to this\n   |                      expected enum `Option`, found tuple\n\
    \   |\n   = note: expected enum `Option<_>`\n             found tuple `(_, _)`\n\
    help: try wrapping the pattern in `Some`\n   |\n25 |         .filter_map(|Some((max,\
    \ idx))| {\n   |                      +++++          +\n\nerror[E0061]: this enum\
    \ variant takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpccr6bw19.rs:32:21\n\
    \   |\n32 |                     Some(max as isize, idx)\n   |                \
    \     ^^^^ ------------  --- supplied 2 arguments\n   |                     |\n\
    \   |                     expected 1 argument\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.is_empty() {\n        return vec![];\n    }\n\n    let mut res =\
    \ vec![vec![-1]; k];\n    let mut idx = k - 1;\n\n    let mut max_num: isize;\n\
    \    let mut max_idx = 0;\n    for num in arr {\n        if *num > max_num {\n\
    \            max_num = *num;\n            max_idx = idx;\n        }\n        if\
    \ *num ==  max_num {\n            res[max_idx].push(*num);\n            idx--;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = maximum;\n \
    \   assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpbre274v0.rs:33:18\n\
    \   |\n33 |             idx--;\n   |                  ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbre274v0.rs:21:34\n   |\n21 |  \
    \   let mut res = vec![vec![-1]; k];\n   |                                  ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n21 |     let mut\
    \ res = vec![vec![-1]; k.try_into().unwrap()];\n   |                         \
    \          ++++++++++++++++++++\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpbre274v0.rs:27:12\n   |\n27 |         if *num > max_num {\n   |\
    \            ^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  -->\
    \ /tmp/tmpbre274v0.rs:28:23\n   |\n28 |             max_num = *num;\n   |    \
    \                   ^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpbre274v0.rs:31:12\n   |\n31 |         if *num ==  max_num {\n \
    \  |            ^^^^\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpbre274v0.rs:32:13\n   |\n32 |             res[max_idx].push(*num);\n\
    \   |             ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpbre274v0.rs:32:31\n   |\n32 |             res[max_idx].push(*num);\n\
    \   |                               ^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpbre274v0.rs:36:5\n   |\n16 | fn maximum(arr: Vec<isize>, k: isize)\
    \ -> Vec<isize> {\n   |                                          ---------- expected\
    \ `Vec<isize>` because of return type\n...\n36 |     res\n   |     ^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Vec<{integer}>>`\n\nerror"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ >= arr.len() {\n        vec![arr[k]]\n    } else {\n        let mut max_heap\
    \ = Heap::new(arr.len() - k + 1);\n        for ele in arr.iter().rev() {\n   \
    \         if ele > max_heap.peek().unwrap() {\n                max_heap.insert(ele);\n\
    \            }\n        }\n        max_heap.extract().unwrap()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4,\
    \ 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
    \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Heap`\n  --> /tmp/tmpqyg675ph.rs:20:28\n\
    \   |\n20 |         let mut max_heap = Heap::new(arr.len() - k + 1);\n   |   \
    \                         ^^^^ use of undeclared type `Heap`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqyg675ph.rs:17:13\n   |\n17 |     if k >= arr.len()\
    \ {\n   |             ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     if k >= arr.len().try_into().unwrap() {\n   |          \
    \            ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpqyg675ph.rs:18:14\n   |\n18 |         vec![arr[k]]\n\
    \   |              ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqyg675ph.rs:20:50\n   |\n20 |\
    \         let mut max_heap = Heap::new(arr.len() - k + 1);\n   |             \
    \                                     ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmpqyg675ph.rs:20:48\n   |\n\
    20 |         let mut max_heap = Heap::new(arr.len() - k + 1);\n   |          \
    \                                      ^ no implementation for `usize - isize`\n\
    \   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Sub<Rhs>`:\n             <&'a\
    \ f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128\
    \ as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as\
    \ Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0433.\nFor more "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![Int::MAX; k as usize];\n    let mut last_num = vec![Int::MAX;\
    \ k as usize];\n\n    for i in 0..arr.len() {\n        let num = arr[i];\n   \
    \     if last_num[i] > num {\n            last_num[i] = num;\n        }\n    }\n\
    \n    for i in 0..k {\n        result[i] = last_num[i];\n    }\n\n    for i in\
    \ 0..k {\n        if result[i] == Int::MAX {\n            return vec![];\n   \
    \     }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Int`\n  --> /tmp/tmpt1mrca52.rs:17:27\n\
    \   |\n17 |     let mut result = vec![Int::MAX; k as usize];\n   |           \
    \                ^^^ use of undeclared type `Int`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Int`\n  --> /tmp/tmpt1mrca52.rs:18:29\n   |\n18 |  \
    \   let mut last_num = vec![Int::MAX; k as usize];\n   |                     \
    \        ^^^ use of undeclared type `Int`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Int`\n  --> /tmp/tmpt1mrca52.rs:32:25\n   |\n32 |  \
    \       if result[i] == Int::MAX {\n   |                         ^^^ use of undeclared\
    \ type `Int`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpt1mrca52.rs:28:9\n   |\n28 |         result[i] = last_num[i];\n   |\
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpt1mrca52.rs:28:21\n\
    \   |\n28 |         result[i] = last_num[i];\n   |                     ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpt1mrca52.rs:32:12\n\
    \   |\n32 |         if result[i] == Int::MAX {\n   |            ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<_>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSo"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_k = vec![vec![0; k]; arr.len()];\n    for i in 0..arr.len() {\n    \
    \    for j in 0..k {\n            if arr[i] > max_k[j][j] { \n               \
    \ max_k[j][j] = arr[i];\n            }\n        }\n    }\n    for j in 0..k {\n\
    \        max_k[j].sort();\n    }\n    max_k\n}\n\nfn main() {\n    let candidate\
    \ = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n\
    \    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0y6cyepd.rs:17:34\n   |\n\
    17 |     let mut max_k = vec![vec![0; k]; arr.len()];\n   |                  \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max_k = vec![vec![0; k.try_into().unwrap()]; arr.len()];\n  \
    \ |                                   ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[Vec<{integer}>]` cannot be indexed by `isize`\n  --> /tmp/tmp0y6cyepd.rs:20:25\n\
    \   |\n20 |             if arr[i] > max_k[j][j] { \n   |                     \
    \    ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp0y6cyepd.rs:21:17\n   |\n21 |                 max_k[j][j] = arr[i];\n\
    \   |                 ^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp0y6cyepd.rs:26:9\n   |\n26 |         max_k[j].sort();\n\
    \   |         ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0y6cyepd.rs:28:5\n\
    \   |\n16 | fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n   |      \
    \          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    // sort\n\
    \    arr.sort_by_key(|x| -x);\n    \n    // return the max\n    let mut max_idx\
    \ = arr.len() - k;\n    let mut max_val = arr[max_idx];\n    while max_idx >=\
    \ 0 {\n        if max_val > arr[max_idx] {\n            max_val = arr[max_idx];\n\
    \            max_idx--;\n        }\n        \n        // if out of range skip\
    \ to next element\n        if max_idx < 0 {\n            break;\n        }\n \
    \   }\n    \n    vec![max_val]\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpadjr9lj_.rs:26:22\n\
    \   |\n26 |             max_idx--;\n   |                      ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpadjr9lj_.rs:21:35\n   |\n21 |\
    \     let mut max_idx = arr.len() - k;\n   |                                 \
    \  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpadjr9lj_.rs:21:33\n   |\n21 |     let mut max_idx\
    \ = arr.len() - k;\n   |                                 ^ no implementation for\
    \ `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut max = arr[0];\n    let mut max_index = 0;\n\
    \    for element in &arr {\n        if element > max {\n            max = element;\n\
    \            max_index = 0;\n        } else {\n            max = element;\n  \
    \          max_index = 1;\n        }\n        if max_index == k {\n          \
    \  result.push(max);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmm128ct_.rs:21:22\n   |\n\
    21 |         if element > max {\n   |                      ^^^\n   |         \
    \             |\n   |                      expected `&isize`, found `isize`\n\
    \   |                      help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmm128ct_.rs:22:19\n   |\n18 |     let mut max\
    \ = arr[0];\n   |                   ------ expected due to this value\n...\n22\
    \ |             max = element;\n   |                   ^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \           max = *element;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmm128ct_.rs:25:19\n   |\n18 |     let mut max = arr[0];\n\
    \   |                   ------ expected due to this value\n...\n25 |         \
    \    max = element;\n   |                   ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n25 |             max = *element;\n\
    \   |                   +\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_arr = vec![vec![-1000, 1000]];\n    for i in 0..k {\n        let mut\
    \ max_num = -1000;\n        for j in 0..arr.len() {\n            if arr[j] > max_num\
    \ {\n                max_num = arr[j];\n            }\n        }\n        max_arr[i]\
    \ = vec![max_num];\n    }\n\n    for i in 0..k {\n        for j in 0..arr.len()\
    \ {\n            max_arr[i][j] = max(max_arr[i][j], arr[j]);\n        }\n    }\n\
    \n    for i in 0..k {\n        max_arr[i][0] = max(max_arr[i][0], max_arr[i][1]);\n\
    \    }\n\n    for i in 0..k {\n        max_arr[i][0] = -max_arr[i][0];\n    }\n\
    \n    max_arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2g6e1xwo.rs:30:29\n\
    \   |\n30 |             max_arr[i][j] = max(max_arr[i][j], arr[j]);\n   |    \
    \                         ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmp2g6e1xwo.rs:35:25\n   |\n35 |  \
    \       max_arr[i][0] = max(max_arr[i][0], max_arr[i][1]);\n   |             \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp2g6e1xwo.rs:25:9\n   |\n25 |   \
    \      max_arr[i] = vec![max_num];\n   |         ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<{integer}>>`\n\nerror[E0277]: the type `[Vec<{integer}>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp2g6e1xwo.rs:30:13\n   |\n30 |  \
    \           max_arr[i][j] = max(max_arr[i][j], arr[j]);\n   |             ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[Vec<{integer}>]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<Vec<{integer}>>`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp2g6e1xwo.rs:30:33\n   |\n30 |             max_arr[i][j] = max(max_arr[i][j],\
    \ arr[j]);\n   |                                 ^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.sort_by_key(|&x|\
    \ -x)\n        .take_while(|&x| *x > k)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp7wjvx0xt.rs:18:10\n\
    \   |\n18 |         .take_while(|&x| *x > k)\n   |          ^^^^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![vec![-1000, 1000]];\n    for i in 0..(k - 1) {\n        let\
    \ mut max_i = result.iter().max().unwrap();\n        result[k] = vec![-1000, 1000];\n\
    \        for i in 0..result.len() {\n            let mut x = result[i].iter().max().unwrap();\n\
    \            if x > max_i {\n                max_i = x;\n            }\n     \
    \   }\n        result[k - 1] = max_i;\n    }\n    result[k - 1]\n}\n\nfn main()\
    \ {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3),\
    \ vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n\
    \    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123,\
    \ -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpe0sacmt5.rs:20:9\n   |\n20 |         result[k] = vec![-1000, 1000];\n\
    \   |         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{integer}>>`\n\nerror[E0277]: can't compare `{integer}` with `Vec<{integer}>`\n\
    \  --> /tmp/tmpe0sacmt5.rs:23:18\n   |\n23 |             if x > max_i {\n   |\
    \                  ^ no implementation for `{integer} < Vec<{integer}>` and `{integer}\
    \ > Vec<{integer}>`\n   |\n   = help: the trait `PartialOrd<Vec<{integer}>>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialOrd<&Vec<{integer}>>` for `&{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe0sacmt5.rs:24:25\n   |\n19 |         let mut\
    \ max_i = result.iter().max().unwrap();\n   |                         ----------------------------\
    \ expected due to this value\n...\n24 |                 max_i = x;\n   |     \
    \                    ^ expected struct `Vec`, found integer\n   |\n   = note:\
    \ expected reference `&Vec<{integer}>`\n              found reference `&{integer}`\n\
    \nerror[E0277]: the type `[Vec<{integer}>]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpe0sacmt5.rs:27:9\n   |\n27 |         result[k - 1] = max_i;\n   |  \
    \       ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<{integer}>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<{in"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    arr.reserve(k);\n\
    \    let mut max_value: isize = arr[0];\n    let mut index = 0;\n    for (i, val)\
    \ in arr.iter().enumerate() {\n        if max_value < val {\n            max_value\
    \ = val;\n            index = i;\n        }\n    }\n    arr.swap(0, index);\n\
    \    arr\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz72aqeba.rs:17:17\n   |\n\
    17 |     arr.reserve(k);\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     arr.reserve(k.try_into().unwrap());\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpz72aqeba.rs:21:24\n   |\n21 |         if max_value < val {\n   |   \
    \                     ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |         if max_value < *val {\n   |   \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz72aqeba.rs:22:25\n\
    \   |\n18 |     let mut max_value: isize = arr[0];\n   |                     \
    \   ----- expected due to this type\n...\n22 |             max_value = val;\n\
    \   |                         ^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n22 |             max_value = *val;\n\
    \   |                         +\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut arr2 = arr.clone();\n    let mut res = vec![0isize; k];\n\n    while arr2.len()\
    \ > 0 {\n        res.swap(0, arr2.iter().max().unwrap() as usize);\n        arr2.remove(&mut\
    \ arr[arr2.iter().max().unwrap()]);\n    }\n\n    res\n}\n\nfn main() {\n    let\
    \ candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvao_s2mi.rs:18:32\n   |\n\
    18 |     let mut res = vec![0isize; k];\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n18 |     let mut\
    \ res = vec![0isize; k.try_into().unwrap()];\n   |                           \
    \      ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpvao_s2mi.rs:22:26\n   |\n22 |         arr2.remove(&mut\
    \ arr[arr2.iter().max().unwrap()]);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvao_s2mi.rs:22:21\n   |\n22 |         arr2.remove(&mut\
    \ arr[arr2.iter().max().unwrap()]);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&mut _`\n   |\n   = note:           expected type `usize`\n\
    \           found mutable reference `&mut _`\nhelp: consider removing the borrow\n\
    \   |\n22 -         arr2.remove(&mut arr[arr2.iter().max().unwrap()]);\n22 + \
    \        arr2.remove(arr[arr2.iter().max().unwrap()]);\n   | \n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpvao_s2mi.rs:21:21\n  \
    \ |\n21 |         res.swap(0, arr2.iter().max().unwrap() as usize);\n   |    \
    \                 --------------------------^^^^^^^^^\n   |                  \
    \   |\n   |                     cannot cast `&isize` as `usize`\n   |        \
    \             help: dereference the expression: `*arr2.iter().max().unwrap()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max_vec = vec![];\n    let mut pos = 0;\n    while pos + k <= arr.len()\
    \ {\n        let pos = pos + k;\n        let max = if arr[k] > arr[k + 1] {\n\
    \            arr[k]\n        } else {\n            arr[k + 1]\n        };\n  \
    \      max_vec.push(max);\n    }\n    if max_vec.len() == 0 {\n        max_vec.push(arr.first());\n\
    \    }\n    max_vec\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3v4cdvy9.rs:19:22\n   |\n\
    19 |     while pos + k <= arr.len() {\n   |                      ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |     while pos + k <=\
    \ arr.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3v4cdvy9.rs:21:22\n\
    \   |\n21 |         let max = if arr[k] > arr[k + 1] {\n   |                 \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3v4cdvy9.rs:21:31\n\
    \   |\n21 |         let max = if arr[k] > arr[k + 1] {\n   |                 \
    \              ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3v4cdvy9.rs:22:13\n\
    \   |\n22 |             arr[k]\n   |             ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp3v4cdvy9.rs:24:13\n   |\n24 |            \
    \ arr[k + 1]\n   |             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut max: usize = 0;\n    for i in 0..k {\n        max = max > arr[i] ? max :\
    \ arr[i];\n    }\n    vec![max]\n}\n\nfn main() {\n    let candidate = maximum;\n\
    \    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4,\
    \ -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2,\
    \ 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3],\
    \ 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3],\
    \ 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8,\
    \ 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0,\
    \ 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `max`\n\
    \  --> /tmp/tmppwaf6h60.rs:19:30\n   |\n19 |         max = max > arr[i] ? max\
    \ : arr[i];\n   |                              ^^^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppwaf6h60.rs:21:10\n\
    \   |\n21 |     vec![max]\n   |          ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     vec![max.try_into().unwrap()]\n   |      \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if arr.len()\
    \ <= k {\n        return arr\n    }\n    let mut ret = arr\n    .chunks(k)\n \
    \   .map(|chunk| chunk.max())\n    .collect();\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4,\
    \ -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3,\
    \ 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123,\
    \ 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123,\
    \ 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5,\
    \ 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1,\
    \ 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7],\
    \ 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n   \
    \ assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3wk8rnz5.rs:17:21\n   |\n\
    17 |     if arr.len() <= k {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     if arr.len() <= k.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3wk8rnz5.rs:21:13\n   |\n21 |     .chunks(k)\n   |    \
    \         ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |     .chunks(k.try_into().unwrap())\n\
    \   |              ++++++++++++++++++++\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n   --> /tmp/tmp3wk8rnz5.rs:22:24\n \
    \   |\n22  |     .map(|chunk| chunk.max())\n    |                        ^^^-\
    \ supplied 0 arguments\n    |                        |\n    |                \
    \        expected 1 argument\n    |\nnote: associated function defined here\n\n\
    error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator over\
    \ elements of type `&[isize]`\n    --> /tmp/tmp3wk8rnz5.rs:23:6\n     |\n23  \
    \ |     .collect();\n     |      ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&[isize]>`\n     |\n     = help: the trait\
    \ `FromIterator<&[isize]>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    if k\
    \ == 0 || arr.is_empty() {\n        return vec![];\n    }\n    if k == 1 {\n \
    \       return vec![];\n    }\n\n    let mut max_k = -std::i32::MAX;\n    for\
    \ i in 0..k {\n        if arr[i] > max_k {\n            max_k = arr[i];\n    \
    \    }\n    }\n    let mut ans = vec![0; k];\n    for i in 0..k {\n        let\
    \ index = max_k - arr[i];\n        ans[i] = arr[index];\n        max_k -= arr[i];\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp83inwhk3.rs:26:12\n\
    \   |\n26 |         if arr[i] > max_k {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp83inwhk3.rs:27:21\n   |\n27 |            \
    \ max_k = arr[i];\n   |                     ^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83inwhk3.rs:30:27\n\
    \   |\n30 |     let mut ans = vec![0; k];\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n30 |     let mut ans = vec![0;\
    \ k.try_into().unwrap()];\n   |                            ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp83inwhk3.rs:32:29\n\
    \   |\n32 |         let index = max_k - arr[i];\n   |                        \
    \     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n  \
    \ = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   =\
    \ help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp83inwhk3.rs:33:9\n\
    \   |\n33 |         ans[i] = arr[index];\n   |         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented f"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array arr of integers and a positive integer k, return a\
    \ sorted list \n/// of length k with the maximum k numbers in arr.\n/// Example\
    \ 1:\n/// Input: arr = [-3, -4, 5], k = 3\n/// Output: [-4, -3, 5]\n/// Example\
    \ 2:\n/// Input: arr = [4, -4, 4], k = 2\n/// Output: [4, 4]\n/// Example 3:\n\
    /// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n/// Output: [2]\n/// Note:\n\
    /// 1. The length of the array will be in the range of [1, 1000].\n/// 2. The\
    \ elements in the array will be in the range of [-1000, 1000].\n/// 3. 0 <= k\
    \ <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let\
    \ mut new_arr = arr.clone();\n    let mut ans = new_arr;\n    new_arr.sort();\n\
    \    while new_arr.len() > k {\n        ans.remove(&new_arr[k]);\n        new_arr.remove(&new_arr[k]);\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
    \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2),\
    \ vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n\
    \    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
    \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
    \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0,\
    \ 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3,\
    \ 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
    \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
    \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqnx6dduz.rs:20:27\n   |\n\
    20 |     while new_arr.len() > k {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     while new_arr.len()\
    \ > k.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqnx6dduz.rs:21:21\n\
    \   |\n21 |         ans.remove(&new_arr[k]);\n   |                     ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqnx6dduz.rs:21:20\n   |\n21 |         ans.remove(&new_arr[k]);\n\
    \   |                    ^^^^^^^^^^^ expected `usize`, found reference\n   |\n\
    \   = note:   expected type `usize`\n           found reference `&_`\nhelp: consider\
    \ removing the borrow\n   |\n21 -         ans.remove(&new_arr[k]);\n21 +     \
    \    ans.remove(new_arr[k]);\n   | \n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpqnx6dduz.rs:22:25\n   |\n22 |         new_arr.remove(&new_arr[k]);\n\
    \   |                         ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqnx6dduz.rs:22:24\n\
    \   |\n22 |         new_arr.remove(&new_arr[k]);\n   |                       \
    \ ^^^^^^^^^^^ expected `usize`, found reference\n   |\n   = note:   expected type\
    \ `usize`\n           found reference `&_`\nhelp: consider removing the borrow\n\
    \   |\n22 -         new_arr.remove(&new_arr[k]);\n22 +         new"
  exit_code: 1
  status: SyntaxError
