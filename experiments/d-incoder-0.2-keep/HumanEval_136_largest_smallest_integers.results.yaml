name: HumanEval_136_largest_smallest_integers
language: humaneval_to_dlang.py
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < smallest) {\n            smallest = Nullable!(long);\n\
    \        }\n        if (lst[i] > largest) {\n            largest = Nullable!(long);\n\
    \        }\n        if (lst[i] < 0 && lst[i] > largest) {\n            largest\
    \ = Nullable!(long);\n        }\n        if (lst[i] > 0 && lst[i] < smallest)\
    \ {\n            smallest = Nullable!(long);\n        }\n        i += 1;\n   \
    \ }\n    return (largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkcm2zz4g.d(18): Error: undefined identifier `var`\\n/tmp/tmpkcm2zz4g.d(18):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmpkcm2zz4g.d(19): Error: undefined\
    \ identifier `var`\\n/tmp/tmpkcm2zz4g.d(19): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmpkcm2zz4g.d(20): Error: undefined identifier `var`\\n/tmp/tmpkcm2zz4g.d(21):\
    \ Error: undefined identifier `var`\\n/tmp/tmpkcm2zz4g.d(22): Error: undefined\
    \ identifier `var`\\n/tmp/tmpkcm2zz4g.d(23): Error: undefined identifier `var`\\\
    n/tmp/tmpkcm2zz4g.d(23): Error: no property `len` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkcm2zz4g.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptbykstji.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptbykstji.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47uzebry.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47uzebry.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < 0) {\n            largest = Nullable!(long);\n\
    \            smallest = Nullable!(long);\n            while (j < n) {\n      \
    \          if (lst[j] < 0) {\n                    largest = Nullable!(long);\n\
    \                    smallest = Nullable!(long);\n                    while (k\
    \ < n) {\n                        if (lst[k] < 0) {\n                        \
    \    largest = Nullable!(long);\n                            smallest = Nullable!(long);\n\
    \                            while (k < n) {\n                               \
    \ if (lst[k] < 0) {\n                                    largest = Nullable!(long);\n\
    \                                    smallest = Nullable!(long);\n           \
    \                         while (k < n) {\n                                  \
    \      if (lst[k] < 0) {\n                                            largest\
    \ = Nullable!(long);\n                                            smallest = Nullable!(long);\n\
    \                                            while (k < n) {\n               \
    \                                 if (lst[k] < 0) {\n                        \
    \                            largest = Nullable!(long);\n                    \
    \                                smallest = Nullable!(long);\n               \
    \                                     while (k < n) {\n                      \
    \                                  if (lst[k] < 0) {\n                       \
    \                                     largest = Nullable!(long);\n           \
    \                                                 smallest = Nullable!(long);\n\
    \                                                            while (k < n) {\n\
    \                                                                if (lst[k] <\
    \ 0) {\n                                                                    largest\
    \ = Nullable!(long);\n                                                       \
    \             smallest = Nullable!(long);\n                                  \
    \                                  while (k < n) {\n                         \
    \                                               if (lst[k] < 0) {\n          \
    \                                                                  largest = Nullable!(long);\n\
    \                                                                            smallest\
    \ = Nullable!(long);\n                                                       \
    \                     while (k < n) {\n                                      \
    \                                          if (lst[k] < 0) {\n               \
    \                                                                     largest\
    \ = Nullable!(long);\n                                                       \
    \                             smallest = Nullable!(long);\n                  \
    \                                                                  while (k <\
    \ n) {\n                                                                     \
    \                   if (lst[k] < 0) {\n                                      \
    \                                                      largest = Nullable!(long);\n\
    \                                                                            \
    \                smallest = Nullable!(long);\n                               \
    \                                                             while (k < n) {\n\
    \                                                                            \
    \                    if (lst[k] < 0) {\n                                     \
    \                                                               largest = Nullable!(long);\n\
    \                                                                            \
    \                        smallest = Nullable!(long);\n                       \
    \                                                                            \
    \ while (k < n) {\n                                                          \
    \                                              if (lst[k] < 0) {\n           \
    \                                                                            \
    \                     largest = Nullable!(long);\n                           \
    \                                                                            \
    \     smallest = Nullable!(long);\n                                          \
    \                                                                  while (k <\
    \ n) {\n                                                                     \
    \                                           if (lst[k] < 0) {\n              \
    \                                                                            \
    \                          largest = Nullable!(long);\n                      \
    \                                                                            \
    \                  smallest = Nullable!(long);\n                             \
    \                                                                            \
    \           while (k < n) {\n                                                \
    \                                                                        if (lst[k]\
    \ < 0) {\n                                                                   \
    \                                                         largest = Null\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpigosu4jl.d(83): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmpigosu4jl.d(154): Error: found `End\
    \ of File` when expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154): Error:\
    \ found `End of File` when expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154): Error:\
    \ found `End of File` when expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154): Error:\
    \ found `End of File` when expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpigosu4jl.d(154): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154): Error:\
    \ found `End of File` when expecting `}` following compound statement\\n/tmp/tmpigosu4jl.d(154):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        if hd < 0L then hd\n        else if hd > 0L then tl |> List.head |> long\n\
    \        else (None, None)\n    )\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppgi0ammw.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmppgi0ammw.d(19): Error: found `|` when expecting `(`\\n/tmp/tmppgi0ammw.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmppgi0ammw.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmppgi0ammw.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmppgi0ammw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcv296_2w.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcv296_2w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            result.a = x;\n \
    \       }\n        else if (x > 0)\n        {\n            result.b = x;\n   \
    \     }\n        else\n        {\n            result.a = null;\n            result.b\
    \ = null;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyurm1pei.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpyurm1pei.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpyurm1pei.d(37): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyurm1pei.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Some(-1) else Some(-1) and Some(-1) and Some(tl) \n    | _ => (None,\
    \ None)\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi5grwygz.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpi5grwygz.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpi5grwygz.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpi5grwygz.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpi5grwygz.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpi5grwygz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long largest = lst.iter().max().unwrap();\n\
    \    long smallest = lst.iter().min().unwrap();\n    \n    if (largest < 0)\n\
    \    {\n        result.a = null;\n        result.b = smallest;\n    }\n    else\n\
    \    {\n        result.a = largest;\n        result.b = smallest;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp96wshi4r.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmp96wshi4r.d(23): Error: no property `iter` for type `long[]`\\n/tmp/tmp96wshi4r.d(24):\
    \ Error: no property `iter` for type `long[]`\\n/tmp/tmp96wshi4r.d(28): Error:\
    \ no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp96wshi4r.d(29):\
    \ Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp96wshi4r.d(33):\
    \ Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp96wshi4r.d(34):\
    \ Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp96wshi4r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst, \n        largest = max!(largest, i);\n        smallest\
    \ = min!(smallest, i);\n    );\n    return Tuple!(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2we4y0zf.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp2we4y0zf.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp2we4y0zf.d(21): Error: found `;`\
    \ when expecting `)`\\n/tmp/tmp2we4y0zf.d(23): Error: found `)` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2we4y0zf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n\
    \        } else if (x > 0) {\n            result.b = x;\n        }\n    }\n  \
    \  \n    if (result.a == null) {\n        result.a = result.b;\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprnhyp3aq.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmprnhyp3aq.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmprnhyp3aq.d(29): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmprnhyp3aq.d(29): Error: found `==` when expecting\
    \ `)`\\n/tmp/tmprnhyp3aq.d(29): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmprnhyp3aq.d(29): Error: found `null` when expecting `;` following statement\\\
    n/tmp/tmprnhyp3aq.d(29): Error: found `)` instead of statement\\n/tmp/tmprnhyp3aq.d(33):\
    \ Error: declaration expected, not `return`\\n/tmp/tmprnhyp3aq.d(34): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprnhyp3aq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            result.a = x;\n \
    \           result.b = null;\n        }\n        else\n        {\n           \
    \ result.a = null;\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3eonaihu.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp3eonaihu.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp3eonaihu.d(34): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3eonaihu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpne74iv7u.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpne74iv7u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max,min) = if hd < 0 then hd else hd ; min <- min(tl);\n        (max,min)\n\
    end\nend\n</cell>\n<code language=julia-1.5>\n@assert largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]) == (None, None)\n@assert largest_smallest_integers([]) == (None,\
    \ None)\n@assert largest_smallest_integers([0]) == (None, None)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that returns the largest and smallest integers in\
    \ a list.\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n\
    \        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp61_kb4qd.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp61_kb4qd.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp61_kb4qd.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp61_kb4qd.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp61_kb4qd.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp61_kb4qd.d(23): Error: found `end`\
    \ when expecting `;` following statement\\n/tmp/tmp61_kb4qd.d(25): Error: expression\
    \ expected, not `/`\\n/tmp/tmp61_kb4qd.d(25): Error: found `cell` when expecting\
    \ `;` following statement\\n/tmp/tmp61_kb4qd.d(25): Error: found `>` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp61_kb4qd.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var max: long = lst.max;\n    var min: long = lst.min;\n    if\
    \ (max == min) return (null, null);\n    if (max < 0) return (null, max);\n  \
    \  if (min > 0) return (min, null);\n    return (max, min);\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu7xvavyq.d(18): Error: found `max` when expecting `;` following\
    \ statement\\n/tmp/tmpu7xvavyq.d(18): Error: found `:` instead of statement\\\
    n/tmp/tmpu7xvavyq.d(19): Error: found `min` when expecting `;` following statement\\\
    n/tmp/tmpu7xvavyq.d(19): Error: found `:` instead of statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu7xvavyq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while(i\
    \ < n && j < n) {\n        if(lst[i] < lst[j]) {\n            smallest = Nullable!(long);\n\
    \            smallest = lst[i];\n            i++;\n        } else {\n        \
    \    largest = Nullable!(long);\n            largest = lst[j];\n            j++;\n\
    \        }\n    }\n    if(i < n) {\n        smallest = Nullable!(long);\n    \
    \    smallest = lst[i];\n    }\n    if(j < n) {\n        largest = Nullable!(long);\n\
    \        largest = lst[j];\n    }\n    return Tuple!(largest, smallest);\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpet82emrk.d(18): Error: undefined identifier `var`\\n/tmp/tmpet82emrk.d(18):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmpet82emrk.d(19): Error: undefined\
    \ identifier `var`\\n/tmp/tmpet82emrk.d(19): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmpet82emrk.d(20): Error: undefined identifier `var`\\n/tmp/tmpet82emrk.d(21):\
    \ Error: undefined identifier `var`\\n/tmp/tmpet82emrk.d(22): Error: undefined\
    \ identifier `var`\\n/tmp/tmpet82emrk.d(23): Error: undefined identifier `var`\\\
    n/tmp/tmpet82emrk.d(23): Error: no property `len` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpet82emrk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst)\n    {\n        if(x < 0)\n        {\n            result.a\
    \ = x;\n            result.b = null;\n        }\n        else\n        {\n   \
    \         result.a = null;\n            result.b = x;\n        }\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0qifbf82.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmp0qifbf82.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp0qifbf82.d(35): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qifbf82.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0)\n            result.a = e;\n        else\
    \ if (e > 0)\n            result.b = e;\n        else\n            result.a =\
    \ e;\n        result.b = e;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo0qavmj6.d(20): Error: no identifier for declarator `e`\\n/tmp/tmpo0qavmj6.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpo0qavmj6.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmpo0qavmj6.d(20): Error: found `lst` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo0qavmj6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd + 1; \n        (max_int,\
    \ min_int)\n        | _ => (None, None)\nend\n    \n/*\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo6zh1kgi.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpo6zh1kgi.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpo6zh1kgi.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpo6zh1kgi.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpo6zh1kgi.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpo6zh1kgi.d(24): Error: found `end`\
    \ when expecting `;` following statement\\n/tmp/tmpo6zh1kgi.d(26): Error: unterminated\
    \ /* */ comment\\n/tmp/tmpo6zh1kgi.d(98): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpo6zh1kgi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (smallest, largest) = if hd < 0L then \n            (Nullable!(long),\
    \ Nullable!(long))\n        else \n            (Nullable!(long), Nullable!(long))\n\
    \        smallest_smallest_integers(tl, smallest, largest)\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoxk61cdy.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpoxk61cdy.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpoxk61cdy.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpoxk61cdy.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpoxk61cdy.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpoxk61cdy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2b53ygdk.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2b53ygdk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (smallest, largest) = largest_smallest_integers(tl)\n        if smallest\
    \ < hd then (smallest, hd)\n        else (largest, hd)\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfzdn3lu_.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpfzdn3lu_.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpfzdn3lu_.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpfzdn3lu_.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpfzdn3lu_.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfzdn3lu_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | x::xs => (\n \
    \       if x < 0 then (None, x)\n        else (Some(x), xs)\n    )\nend\n</cell>\n\
    <code language=julia-1.5>\n@test largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, None)\n@test largest_smallest_integers([]) == (None, None)\n@test\
    \ largest_smallest_integers([0]) == (None, None)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the sum of the integers in a list.\nIf there are\
    \ no integers, return 0.\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdbwzoxei.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpdbwzoxei.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpdbwzoxei.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpdbwzoxei.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpdbwzoxei.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpdbwzoxei.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) (\n                ifelse(i < 0, None,\
    \ i),\n                ifelse(i > 0, None, i)\n            )\n    )\n    {\n \
    \       result = ifelse(\n            Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n                ifelse(result.a > t.a, result.a, t.a),\n                ifelse(result.b\
    \ < t.b, result.b, t.b)\n            ),\n            Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n                ifelse(result.a > t.a, t.a, result.a),\n                ifelse(result.b\
    \ < t.b, t.b, result.b)\n            ),\n            result\n        );\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcpk8v_c1.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpcpk8v_c1.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpcpk8v_c1.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmpcpk8v_c1.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpcpk8v_c1.d(41): Error: declaration expected, not `return`\\n/tmp/tmpcpk8v_c1.d(42):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcpk8v_c1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n\
    \            result.b = null;\n        } else {\n            result.a = null;\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ekykkzj.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmp5ekykkzj.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp5ekykkzj.d(31): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ekykkzj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0L then \n                    (Some(hd), None) \n                else \n \
    \                   (None, Some(hd))\n    end\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp19tuh_1z.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp19tuh_1z.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp19tuh_1z.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp19tuh_1z.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp19tuh_1z.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp19tuh_1z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ > 0 then Some((hd, tl)) else None\n    | hd::tl => if hd < 0 then Some((hd,\
    \ tl)) else None\n    | _ => None\n    end\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb73qx6j5.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpb73qx6j5.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpb73qx6j5.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpb73qx6j5.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpb73qx6j5.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpb73qx6j5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd \n                 \
    \           (max_int, min_int) \n                            in \n           \
    \                 let (max_int, min_int) = if min_int > hd then min_int else hd\
    \ \n                            (max_int, min_int) \n                        \
    \    in \n                            let (max_int, min_int) = if max_int < min_int\
    \ then max_int else min_int \n                            (max_int, min_int) \n\
    \                            in \n                            (max_int, min_int)\n\
    end\nend\n</code>\n<|/ a tags=ocaml,functional-programming |>\n<| a |>\n<code>\n\
    let rec max_min lst = \n    match lst with\n    | [] -> (None, None)\n    | hd::tl\
    \ ->\n        let (max_int, min_int) = if hd < 0 then hd else hd \n          \
    \                  (max_int, min_int) \n                            in \n    \
    \                        let (max_int, min_int) = if min_int > hd then min_int\
    \ else hd \n                            (max_int, min_int) \n                \
    \            in \n                            let (max_int, min_int) = if max_int\
    \ < min_int then max_int else min_int \n                            (max_int,\
    \ min_int)\n</code>\n<|/ a tags=ocaml,functional-programming dscore=2 |>\n<| a\
    \ dscore=2 |>\n<code>\nlet rec max_min lst = \n    match lst with\n    | [] ->\
    \ (None, None)\n    | hd::tl ->\n        let (max_int, min_int) = if hd < 0 then\
    \ hd else hd \n                            (max_int, min_int) \n             \
    \               in \n                            let (max_int, min_int) = if min_int\
    \ > hd then min_int else hd \n                            (max_int, min_int) \n\
    \                            in \n                            let (max_int, min_int)\
    \ = if max_int < min_int then max_int else min_int \n                        \
    \    (max_int, min_int)\n</code>\n<|/ a tags=ocaml,functional-programming |>\n\
    <| a tags=ocaml,functional-programming |>\n<code>\nlet rec max_min lst = \n  \
    \  match lst with\n    | [] -> (None, None)\n    | hd::tl ->\n        let (max_int,\
    \ min_int) = if hd < 0 then hd else hd \n                            (max_int,\
    \ min_int) \n                            in \n                            let\
    \ (max_int, min_int) = if min_int > hd then min_int else h\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpru990e3p.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpru990e3p.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpru990e3p.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpru990e3p.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpru990e3p.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpru990e3p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppii980in.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppii980in.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0) Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) \n                else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n                    if(i>0) Tuple!(Nullable!(long), Nullable!(long))\
    \ (None,None) \n                    else Tuple!(Nullable!(long), Nullable!(long))\
    \ (i, None)\n                )\n            )\n    )\n    \n    foreach(t : result,\
    \ \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n            Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n                if((t.f0.isSome) && (t.f0.isSome)) (\n \
    \                   if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n       \
    \                 if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n         \
    \                   if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n       \
    \                         if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n \
    \                                   if((t.f0.get().isSome) && (t.f0.get().isSome))\
    \ (\n                                        if((t.f0.get().isSome) && (t.f0.get().isSome))\
    \ (\n                                            if((t.f0.get().isSome) && (t.f0.get().isSome))\
    \ (\n                                                if((t.f0.get().isSome) &&\
    \ (t.f0.get().isSome)) (\n                                                   \
    \ if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n                         \
    \                               if((t.f0.get().isSome) && (t.f0.get().isSome))\
    \ (\n                                                            if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                                \
    \                if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n          \
    \                                                          if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                                \
    \                        if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n  \
    \                                                                          if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp435fggbn.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp435fggbn.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp435fggbn.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmp435fggbn.d(21): Error: found `=` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp435fggbn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6lesm_ev.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6lesm_ev.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp456d3uk3.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmp456d3uk3.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp456d3uk3.d(33): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp456d3uk3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = None;\n        result.second\
    \ = None;\n        return result;\n    }\n    \n    long smallest = lst.min();\n\
    \    long largest = lst.max();\n    \n    if (smallest < 0)\n    {\n        result.first\
    \ = None;\n        result.second = None;\n        return result;\n    }\n    \n\
    \    if (largest > 0)\n    {\n        result.first = largest;\n        result.second\
    \ = smallest;\n        return result;\n    }\n    \n    result.first = None;\n\
    \    result.second = None;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5x2gid9_.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmp5x2gid9_.d(22): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp5x2gid9_.d(22): Error: undefined identifier `None`,\
    \ did you mean struct `No`?\\n/tmp/tmp5x2gid9_.d(23): Error: no property `second`\
    \ for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp5x2gid9_.d(23): Error:\
    \ undefined identifier `None`, did you mean struct `No`?\\n/tmp/tmp5x2gid9_.d(27):\
    \ Error: no property `min` for type `long[]`\\n/tmp/tmp5x2gid9_.d(28): Error:\
    \ no property `max` for type `long[]`\\n/tmp/tmp5x2gid9_.d(32): Error: no property\
    \ `first` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp5x2gid9_.d(32):\
    \ Error: undefined identifier `None`, did you mean struct `No`?\\n/tmp/tmp5x2gid9_.d(33):\
    \ Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmp5x2gid9_.d(33): Error: undefined identifier `None`, did you mean struct\
    \ `No`?\\n/tmp/tmp5x2gid9_.d(39): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp5x2gid9_.d(40): Error: no property `second` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp5x2gid9_.d(44): Error: no property\
    \ `first` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp5x2gid9_.d(44):\
    \ Error: undefined identifier `None`, did you mean struct `No`?\\n/tmp/tmp5x2gid9_.d(45):\
    \ Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmp5x2gid9_.d(45): Error: undefined identifier `None`, did you mean struct\
    \ `No`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5x2gid9_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    \n    var i = 0;\n    var j = 0;\n    \n    while (i < lst.len) {\n     \
    \   \n        if (lst[i] < smallest) {\n            smallest = lst[i];\n     \
    \   }\n        \n        if (lst[i] > largest) {\n            largest = lst[i];\n\
    \        }\n        \n        i += 1;\n        j += 1;\n    }\n    \n    return\
    \ (largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcy0m5txg.d(19): Error: undefined identifier `var`\\n/tmp/tmpcy0m5txg.d(19):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmpcy0m5txg.d(20): Error: undefined\
    \ identifier `var`\\n/tmp/tmpcy0m5txg.d(20): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmpcy0m5txg.d(22): Error: undefined identifier `var`\\n/tmp/tmpcy0m5txg.d(23):\
    \ Error: undefined identifier `var`\\n/tmp/tmpcy0m5txg.d(25): Error: no property\
    \ `len` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpcy0m5txg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    bool isNegative = false;\n    long max = 0;\n    long min\
    \ = 0;\n    foreach(long i in lst)\n    {\n        if (i < 0)\n        {\n   \
    \         isNegative = true;\n        }\n        if (i > max)\n        {\n   \
    \         max = i;\n        }\n        if (i < min)\n        {\n            min\
    \ = i;\n        }\n    }\n    if (isNegative)\n    {\n        return (None, max);\n\
    \    }\n    else\n    {\n        return (Some(min), max);\n    }\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps748w3ec.d(22): Error: found `in` when expecting `;`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps748w3ec.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst) {\n        if(i < 0) {\n            largest = i;\n     \
    \   } else {\n            smallest = i;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9wbz_bz4.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp9wbz_bz4.d(20):\
    \ Error: found `:` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9wbz_bz4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) \n            ((std.math.max(std.math.min(i),\
    \ std.math.max(i)), std.math.min(i)));\n        result = std.tuple.unsafeAppend(result,\
    \ t);\n    );\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyczadvc4.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpyczadvc4.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpyczadvc4.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmpyczadvc4.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpyczadvc4.d(25): Error: found `)` instead of statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyczadvc4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if (i < 0) result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           else if (i > 0) result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           else result = Tuple!(Nullable!(long), Nullable!(long)));\n    \n \
    \   return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpamrxqw3p.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpamrxqw3p.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpamrxqw3p.d(21): Error: expression\
    \ expected, not `if`\\n/tmp/tmpamrxqw3p.d(21): Error: found `result` when expecting\
    \ `)`\\n/tmp/tmpamrxqw3p.d(21): Error: found `=` instead of statement\\n/tmp/tmpamrxqw3p.d(22):\
    \ Error: found `else` without a corresponding `if`, `version` or `debug` statement\\\
    n/tmp/tmpamrxqw3p.d(23): Error: found `else` without a corresponding `if`, `version`\
    \ or `debug` statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpamrxqw3p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            result.a = x;\n \
    \           result.b = Nullable!(long);\n        }\n        else\n        {\n\
    \            result.b = x;\n            result.a = Nullable!(long);\n        }\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmlwkk6yl.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpmlwkk6yl.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpmlwkk6yl.d(34): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmlwkk6yl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt2z27534.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt2z27534.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_val, min_val) = if hd < 0 then hd else hd ; min_val = hd\n   \
    \     (max_val, min_val) :: largest_smallest_integers(tl)\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt44589ds.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpt44589ds.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpt44589ds.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpt44589ds.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpt44589ds.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpt44589ds.d(22): Error: found `:` when\
    \ expecting `;` following statement\\n/tmp/tmpt44589ds.d(22): Error: found `:`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpt44589ds.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < smallest) {\n            smallest = lst[i];\n\
    \        }\n        if (lst[i] > largest) {\n            largest = lst[i];\n \
    \       }\n        i += 1;\n    }\n    if (smallest == Nullable!(long)) {\n  \
    \      return (None, Nullable!(long));\n    }\n    if (largest == Nullable!(long))\
    \ {\n        return (smallest, None);\n    }\n    while (j < n) {\n        if\
    \ (lst[j] > largest) {\n            largest = lst[j];\n        }\n        j +=\
    \ 1;\n    }\n    while (k < n) {\n        if (lst[k] < smallest) {\n         \
    \   smallest = lst[k];\n        }\n        k += 1;\n    }\n    return (smallest,\
    \ largest);\n}\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxeg57fth.d(53): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxeg57fth.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0L then hd::(-1L, hd) else hd::(0L, hd);\n\
    \        Tuple!(max_int, min_int) largest_smallest_integers(tl)\n    end;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuf49p5_1.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpuf49p5_1.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpuf49p5_1.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpuf49p5_1.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpuf49p5_1.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpuf49p5_1.d(22): Error: found `largest_smallest_integers`\
    \ when expecting `;` following statement\\n/tmp/tmpuf49p5_1.d(23): Error: C style\
    \ cast illegal, use `cast(tl)end`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpuf49p5_1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgfkss6t4.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpgfkss6t4.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpgfkss6t4.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgfkss6t4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0L then Some((hd, tl.min)) else Some((tl.max, hd))\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp67k092ej.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp67k092ej.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp67k092ej.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp67k092ej.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp67k092ej.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp67k092ej.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ghysniq.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ghysniq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Some(None) else None\n                 else if hd > 0 then Some(Some(Long.MinValue))\
    \ else None\n                 else largest_smallest_integers(tl)\n    end;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphuvm156l.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmphuvm156l.d(19): Error: found `|` when expecting `(`\\n/tmp/tmphuvm156l.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmphuvm156l.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmphuvm156l.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmphuvm156l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max,min) = if hd < 0 then hd else hd ; min\n        (\n          \
    \  if max < min then \n                (max, min) \n            else \n      \
    \          (min, max) \n        )\n    end\n}\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgqn7m5tl.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpgqn7m5tl.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpgqn7m5tl.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpgqn7m5tl.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpgqn7m5tl.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpgqn7m5tl.d(23): Error: expression expected,\
    \ not `if`\\n/tmp/tmpgqn7m5tl.d(23): Error: found `max` when expecting `,`\\n/tmp/tmpgqn7m5tl.d(23):\
    \ Error: expression expected, not `<`\\n/tmp/tmpgqn7m5tl.d(23): Error: found `min`\
    \ when expecting `,`\\n/tmp/tmpgqn7m5tl.d(25): Error: found `else` when expecting\
    \ `,`\\n/tmp/tmpgqn7m5tl.d(28): Error: found `end` when expecting `;` following\
    \ statement\\n/tmp/tmpgqn7m5tl.d(30): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgqn7m5tl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(i : lst, \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpewbzoq0y.d(21): Error: no identifier for declarator `i`\\n/tmp/tmpewbzoq0y.d(21):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpewbzoq0y.d(264): Error: expression\
    \ expected, not `unittest`\\n/tmp/tmpewbzoq0y.d(265): Error: found `{` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpewbzoq0y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd + 1\n        (max_int,\
    \ min_int)\n        | _ => (None, None)\nend;\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0uuvhv4d.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp0uuvhv4d.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp0uuvhv4d.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp0uuvhv4d.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp0uuvhv4d.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp0uuvhv4d.d(25): Error: unterminated\
    \ /* */ comment\\n/tmp/tmp0uuvhv4d.d(97): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmp0uuvhv4d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb09x_u5s.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb09x_u5s.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       let (max_val, min_val) = hd.max(), hd.min()\n        match max_val, min_val\
    \ with\n        | None, None => (None, None)\n        | None, Some(None) => (None,\
    \ None)\n        | Some(None), None => (None, None)\n        | Some(None), Some(None)\
    \ => (None, None)\n        | Some(Some(max_val)), Some(Some(min_val)) => \n  \
    \          let (max_val, min_val) = max_val, min_val\n            match max_val,\
    \ min_val with\n            | None, None => (None, None)\n            | None,\
    \ Some(None) => (None, None)\n            | Some(None), None => (None, None)\n\
    \            | Some(None), Some(None) => (None, None)\n            | Some(Some(max_val)),\
    \ Some(Some(min_val)) => \n                let (max_val, min_val) = max_val, min_val\n\
    \                match max_val, min_val with\n                | None, None =>\
    \ (None, None)\n                | None, Some(None) => (None, None)\n         \
    \       | Some(None), None => (None, None)\n                | Some(None), Some(None)\
    \ => (None, None)\n                | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n                    let (max_val, min_val) = max_val, min_val\n       \
    \             match max_val, min_val with\n                    | None, None =>\
    \ (None, None)\n                    | None, Some(None) => (None, None)\n     \
    \               | Some(None), None => (None, None)\n                    | Some(None),\
    \ Some(None) => (None, None)\n                    | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n                        let (max_val, min_val) = max_val, min_val\n   \
    \                     match max_val, min_val with\n                        | None,\
    \ None => (None, None)\n                        | None, Some(None) => (None, None)\n\
    \                        | Some(None), None => (None, None)\n                \
    \        | Some(None), Some(None) => (None, None)\n                        | Some(Some(max_val)),\
    \ Some(Some(min_val)) => \n                            let (max_val, min_val)\
    \ = max_val, min_val\n                            match max_val, min_val with\n\
    \                            | None, None => (None, None)\n                  \
    \          | None, Some(None) => (None, None)\n                            | Some(None),\
    \ None => (None, None)\n                            | Some(None), Some(None) =>\
    \ (None, None)\n                            | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n                                let (max_val, min_val) = max_val, min_val\n\
    \                                match max_val, min_val with\n               \
    \                 | None, None => (None, None)\n                             \
    \   | None, Some(None\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptq58k8jx.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmptq58k8jx.d(19): Error: found `|` when expecting `(`\\n/tmp/tmptq58k8jx.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmptq58k8jx.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmptq58k8jx.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptq58k8jx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4i6o0hk3.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp4i6o0hk3.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp4i6o0hk3.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4i6o0hk3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    bool isNegative = false;\n    long largest = Long.MinValue;\n\
    \    long smallest = Long.MaxValue;\n    \n    for (long i : lst)\n    {\n   \
    \     if (i < 0)\n        {\n            isNegative = true;\n        }\n     \
    \   if (i > 0)\n        {\n            if (isNegative)\n            {\n      \
    \          largest = i;\n            }\n            else\n            {\n    \
    \            smallest = i;\n            }\n        }\n    }\n    \n    return\
    \ Tuple!(Nullable!(long), Nullable!(long))(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp1il3zxl.d(23): Error: semicolon expected, not `:`\\n/tmp/tmpp1il3zxl.d(23):\
    \ Error: expression expected, not `:`\\n/tmp/tmpp1il3zxl.d(23): Error: found `lst`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpp1il3zxl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var smallest = Long.min;\n    var largest = Long.max;\n    foreach\
    \ (x in lst) {\n        if (x < smallest) smallest = x;\n        if (x > largest)\
    \ largest = x;\n    }\n    return Tuple!(Nullable!(long), Nullable!(long))(Nullable!(long),\
    \ Nullable!(long))(smallest, largest);\n}\nunittest\n{\n    alias candidate =\
    \ largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps1cjid8s.d(20): Error: no identifier for declarator `x`\\n/tmp/tmps1cjid8s.d(20):\
    \ Error: found `in` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmps1cjid8s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphfukaf87.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphfukaf87.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | _ =>\n       \
    \ let mutable smallest = Long.MinValue;\n        let mutable largest = Long.MaxValue;\n\
    \        for elt in lst do\n            if elt < smallest then\n             \
    \   smallest = elt\n            elseif elt > largest then\n                largest\
    \ = elt\n            else\n                None\n        end\n        (smallest,\
    \ largest)\nend\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwrilzmk.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpbwrilzmk.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpbwrilzmk.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpbwrilzmk.d(21): Error: found\
    \ `mutable` when expecting `;` following statement\\n/tmp/tmpbwrilzmk.d(22): Error:\
    \ found `mutable` when expecting `;` following statement\\n/tmp/tmpbwrilzmk.d(23):\
    \ Error: found `elt` when expecting `(`\\n/tmp/tmpbwrilzmk.d(23): Error: found\
    \ `in` instead of statement\\n/tmp/tmpbwrilzmk.d(43): Error: found `{` when expecting\
    \ `;` following `for` condition\\n/tmp/tmpbwrilzmk.d(44): Error: expression expected,\
    \ not `auto`\\n/tmp/tmpbwrilzmk.d(44): Error: found `result` when expecting `)`\\\
    n/tmp/tmpbwrilzmk.d(44): Error: found `=` instead of statement\\n/tmp/tmpbwrilzmk.d(49):\
    \ Error: declaration expected, not `{`\\n/tmp/tmpbwrilzmk.d(51): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpbwrilzmk.d(52): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpbwrilzmk.d(53): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwrilzmk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf4v2i13z.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpf4v2i13z.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpf4v2i13z.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf4v2i13z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0L then \n                    (Some(hd), None) \n                else\n  \
    \                  (None, Some(tl))\n    end\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpik_nrc4c.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpik_nrc4c.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpik_nrc4c.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpik_nrc4c.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpik_nrc4c.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpik_nrc4c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (isneg, imin) = if hd < 0 then Some(True, 0) else Some(False, hd)\n\
    \        match largest_smallest_integers(tl) with\n        | None => (None, imin)\n\
    \        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) =>\
    \ (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy69r29ro.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpy69r29ro.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpy69r29ro.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpy69r29ro.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpy69r29ro.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpy69r29ro.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        if hd < 0L then Some(hd, 0L) else Some(hd, tl.max())\n    )\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, None)\n@assert largest_smallest_integers([]) == (None, None)\n@assert\
    \ largest_smallest_integers([0]) == (None, None)\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a list and a predicate as arguments, and returns a new\
    \ list with the elements that satisfy the predicate.\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx2t51_yc.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpx2t51_yc.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpx2t51_yc.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpx2t51_yc.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpx2t51_yc.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpx2t51_yc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) tuple = \n       \
    \     Tuple!(Nullable!(long), Nullable!(long)) \n                largest_smallest_integers(\n\
    \                    Array!(int) \n                        {\n               \
    \             i\n                        }\n                )\n        )\n   \
    \ {\n        result = tuple;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc704hqr5.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpc704hqr5.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpc704hqr5.d(21): Error: found `tuple`\
    \ when expecting `)`\\n/tmp/tmpc704hqr5.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpc704hqr5.d(28): Error: declaration expected, not `)`\\n/tmp/tmpc704hqr5.d(32):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc704hqr5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, &lst) {\n        if (i < 0) {\n            result.a = i;\n            result.b\
    \ = null;\n        } else {\n            result.a = null;\n            result.b\
    \ = i;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj2y_3yic.d(20): Error: basic type expected, not `&`\\n/tmp/tmpj2y_3yic.d(20):\
    \ Error: no identifier for declarator `_error_`\\n/tmp/tmpj2y_3yic.d(20): Error:\
    \ found `&` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpj2y_3yic.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then Some(-1L, hd) else Some(hd, 0L);\n\
    \        Tuple!(max_int, min_int) largest_smallest_integers(tl);\n    | _ => unreachable!();\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz86n76ye.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpz86n76ye.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpz86n76ye.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpz86n76ye.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpz86n76ye.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpz86n76ye.d(23): Error: found `|` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz86n76ye.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd \n                 \
    \           (max_int, min_int)\n            in \n                let (max_int,\
    \ min_int) = if min_int < 0 then min_int else min_int \n                     \
    \               (max_int, min_int)\n                in \n                    let\
    \ (max_int, min_int) = if max_int < 0 then max_int else max_int \n           \
    \                             (max_int, min_int)\n                    in \n  \
    \                      (max_int, min_int)\nend\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ocaml,functional-programming |>\n<code>\nlet rec largest_smallest_integers\
    \ lst =\n  match lst with\n  | [] -> (None, None)\n  | hd::tl ->\n    let (max_int,\
    \ min_int) = if hd < 0 then hd else hd in\n    let (max_int, min_int) = if min_int\
    \ < 0 then min_int else min_int in\n    let (max_int, min_int) = if max_int <\
    \ 0 then max_int else max_int in\n    (max_int, min_int)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nlet rec largest_smallest_integers lst =\n  match\
    \ lst with\n  | [] -> (None, None)\n  | hd::tl ->\n    let (max_int, min_int)\
    \ = if hd < 0 then hd else hd in\n    let (max_int, min_int) = if min_int < 0\
    \ then min_int else min_int in\n    let (max_int, min_int) = if max_int < 0 then\
    \ max_int else max_int in\n    (max_int, min_int)\n</code>\n<|/ a tags=ocaml,functional-programming\
    \ |>\n<| a dscore=0 |>\n<code>\nlet rec largest_smallest_integers lst =\n  match\
    \ lst with\n  | [] -> (None, None)\n  | hd::tl ->\n    let (max_int, min_int)\
    \ = if hd < 0 then hd else hd in\n    let (max_int, min_int) = if min_int < 0\
    \ then min_int else min_int in\n    let (max_int, min_int) = if max_int < 0 then\
    \ max_int else max_int in\n    (max_int, min_int)\n</code>\n<|/ a tags=ocaml,functional-programming\
    \ |>\n<| a |>\n<code>\nlet rec largest_smallest_integers lst =\n\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpknzsemx0.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpknzsemx0.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpknzsemx0.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpknzsemx0.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpknzsemx0.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpknzsemx0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe107jgs2.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpe107jgs2.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpe107jgs2.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe107jgs2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        match hd with\n        | None => (None, None)\n        | Some x => (\n\
    \            match tl with\n            | [] => (None, None)\n            | hd::tl\
    \ => (\n                match hd with\n                | None => (None, None)\n\
    \                | Some y => (\n                    match tl with\n          \
    \          | [] => (None, None)\n                    | hd::tl => (\n         \
    \               match hd with\n                        | None => (None, None)\n\
    \                        | Some z => (\n                            match tl with\n\
    \                            | [] => (None, None)\n                          \
    \  | hd::tl => (\n                                match hd with\n            \
    \                    | None => (None, None)\n                                |\
    \ Some a => (\n                                    match tl with\n           \
    \                         | [] => (None, None)\n                             \
    \       | hd::tl => (\n                                        match hd with\n\
    \                                        | None => (None, None)\n            \
    \                            | Some b => (\n                                 \
    \           match tl with\n                                            | [] =>\
    \ (None, None)\n                                            | hd::tl => (\n  \
    \                                              match hd with\n               \
    \                                 | None => (None, None)\n                   \
    \                             | Some c => (\n                                \
    \                    match tl with\n                                         \
    \           | [] => (None, None)\n                                           \
    \         | hd::tl => (\n                                                    \
    \    match hd with\n                                                        |\
    \ None => (None, None)\n                                                     \
    \   | Some d => (\n                                                          \
    \  match tl with\n                                                           \
    \ | [] => (None, None)\n                                                     \
    \       | hd::tl => (\n                                                      \
    \          match hd with\n                                                   \
    \             | None => (None, None)\n                                       \
    \                         | Some e => (\n                                    \
    \                                match tl with\n                             \
    \                                       | [] => (None, None)\n               \
    \                                                     | hd::tl => (\n        \
    \                                                                match hd with\n\
    \                                                                        | None\
    \ => (None, None)\n                                                          \
    \              | Some f => (\n                                               \
    \                             match tl with\n                                \
    \                                            | [] => (None, None)\n          \
    \                                                                  | hd::tl =>\
    \ (\n                                                                        \
    \        match hd with\n                                                     \
    \                           | None => (None, None)\n                         \
    \                                                       | Some g => (\n      \
    \                                                                            \
    \  match tl with\n                                                           \
    \                         | [] => (None, None)\n                             \
    \                                                       | hd::tl => (\n      \
    \                                                                            \
    \      match hd with\n                                                       \
    \                                 | None => (None, None)\n                   \
    \                                                                     | Some h\
    \ => (\n                                                                     \
    \                       match tl with\n                                      \
    \                                                      | [] => (None, None)\n\
    \                                                                            \
    \                | hd::tl => (\n                                             \
    \                                                   match hd with\n          \
    \                                                                            \
    \          | None => (None, None)\n                                          \
    \                                                      | Some i => (\n       \
    \                                                                            \
    \                 match tl with\n                                            \
    \                                                        | [] => (None, None)\n\
    \                                                                            \
    \                        | hd::tl => (\n                                     \
    \                                                                   match hd with\n\
    \                                                                            \
    \                            | None \nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4vi4wyzn.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp4vi4wyzn.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp4vi4wyzn.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp4vi4wyzn.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp4vi4wyzn.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4vi4wyzn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Some(Some(hd), None) else Some(None, Some(tl))\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpllsy3fwi.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpllsy3fwi.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpllsy3fwi.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpllsy3fwi.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpllsy3fwi.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpllsy3fwi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var max: long = Long.min;\n    var min: long = Long.max;\n   \
    \ foreach(i : lst, \n    {\n        if (i < min)\n        {\n            min =\
    \ i;\n        }\n        if (i > max)\n        {\n            max = i;\n     \
    \   }\n    });\n    return Tuple!(Nullable!(long), Nullable!(long))(max, min);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps77b9_pc.d(18): Error: found `max` when expecting `;` following\
    \ statement\\n/tmp/tmps77b9_pc.d(18): Error: found `:` instead of statement\\\
    n/tmp/tmps77b9_pc.d(19): Error: found `min` when expecting `;` following statement\\\
    n/tmp/tmps77b9_pc.d(19): Error: found `:` instead of statement\\n/tmp/tmps77b9_pc.d(20):\
    \ Error: no identifier for declarator `i`\\n/tmp/tmps77b9_pc.d(20): Error: found\
    \ `:` when expecting `;`\\n/tmp/tmps77b9_pc.d(30): Error: use `{ }` for an empty\
    \ statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps77b9_pc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if(x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if(result.a == null) {\n\
    \        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpquwmzzwd.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpquwmzzwd.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpquwmzzwd.d(28): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmpquwmzzwd.d(28): Error: found `==` when expecting\
    \ `)`\\n/tmp/tmpquwmzzwd.d(28): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpquwmzzwd.d(28): Error: found `null` when expecting `;` following statement\\\
    n/tmp/tmpquwmzzwd.d(28): Error: found `)` instead of statement\\n/tmp/tmpquwmzzwd.d(32):\
    \ Error: declaration expected, not `return`\\n/tmp/tmpquwmzzwd.d(33): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpquwmzzwd.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = None;\n        result.second\
    \ = None;\n    }\n    else\n    {\n        auto min_value = lst.min();\n     \
    \   auto max_value = lst.max();\n        \n        if (min_value < 0)\n      \
    \  {\n            result.first = None;\n            result.second = None;\n  \
    \      }\n        else if (max_value > 0)\n        {\n            result.first\
    \ = max_value;\n            result.second = min_value;\n        }\n        else\n\
    \        {\n            result.first = max_value;\n            result.second =\
    \ None;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg70vlu8k.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmpg70vlu8k.d(22): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmpg70vlu8k.d(22): Error: undefined identifier `None`,\
    \ did you mean struct `No`?\\n/tmp/tmpg70vlu8k.d(23): Error: no property `second`\
    \ for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpg70vlu8k.d(23): Error:\
    \ undefined identifier `None`, did you mean struct `No`?\\n/tmp/tmpg70vlu8k.d(27):\
    \ Error: no property `min` for type `long[]`\\n/tmp/tmpg70vlu8k.d(28): Error:\
    \ no property `max` for type `long[]`\\n/tmp/tmpg70vlu8k.d(32): Error: no property\
    \ `first` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpg70vlu8k.d(32):\
    \ Error: undefined identifier `None`, did you mean struct `No`?\\n/tmp/tmpg70vlu8k.d(33):\
    \ Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmpg70vlu8k.d(33): Error: undefined identifier `None`, did you mean struct\
    \ `No`?\\n/tmp/tmpg70vlu8k.d(37): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmpg70vlu8k.d(38): Error: no property `second` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpg70vlu8k.d(42): Error: no property\
    \ `first` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpg70vlu8k.d(43):\
    \ Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmpg70vlu8k.d(43): Error: undefined identifier `None`, did you mean struct\
    \ `No`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg70vlu8k.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    bool positive = true;\n    long max = 0;\n    long min =\
    \ 0;\n    \n    for (long i : lst) {\n        if (i < 0) {\n            positive\
    \ = false;\n        }\n        if (i > max) {\n            max = i;\n        }\n\
    \        if (i < min) {\n            min = i;\n        }\n    }\n    \n    if\
    \ (positive && max > min) {\n        return (max, min);\n    }\n    \n    if (positive\
    \ && !max && min > 0) {\n        return (min, 0);\n    }\n    \n    if (positive\
    \ && !max && !min) {\n        return (null, null);\n    }\n    \n    return (null,\
    \ null);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwu765i4k.d(23): Error: semicolon expected, not `:`\\n/tmp/tmpwu765i4k.d(23):\
    \ Error: expression expected, not `:`\\n/tmp/tmpwu765i4k.d(23): Error: found `lst`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwu765i4k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0)\n            result.a = e;\n        else\
    \ if (e > 0)\n            result.b = e;\n        else\n            result.a =\
    \ e;\n        result.b = e;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpupls0993.d(20): Error: no identifier for declarator `e`\\n/tmp/tmpupls0993.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpupls0993.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmpupls0993.d(20): Error: found `lst` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpupls0993.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n            if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \            else result = Tuple!(Nullable!(long), Nullable!(long));\n    );\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg1_s6tua.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpg1_s6tua.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpg1_s6tua.d(21): Error: expression\
    \ expected, not `if`\\n/tmp/tmpg1_s6tua.d(21): Error: found `result` when expecting\
    \ `)`\\n/tmp/tmpg1_s6tua.d(21): Error: found `=` instead of statement\\n/tmp/tmpg1_s6tua.d(22):\
    \ Error: found `else` without a corresponding `if`, `version` or `debug` statement\\\
    n/tmp/tmpg1_s6tua.d(23): Error: found `)` instead of statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg1_s6tua.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n            result.b\
    \ = Nullable!(long);\n        } else {\n            result.b = x;\n          \
    \  result.a = Nullable!(long);\n        }\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdczy54yz.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpdczy54yz.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpdczy54yz.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdczy54yz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst) {\n        if (i < 0) {\n            largest = i;\n    \
    \    } else {\n            smallest = i;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6qf9oq0e.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp6qf9oq0e.d(20):\
    \ Error: found `:` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6qf9oq0e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp06hq3607.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp06hq3607.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv9evv3es.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpv9evv3es.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpv9evv3es.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv9evv3es.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let a = if hd < 0 then None else Some(hd)\n        let b = if hd > 0 then\
    \ None else Some(hd)\n        Tuple!(a, b)\nend;\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9pkdy0xm.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp9pkdy0xm.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp9pkdy0xm.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp9pkdy0xm.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp9pkdy0xm.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp9pkdy0xm.d(25): Error: unterminated\
    \ /* */ comment\\n/tmp/tmp9pkdy0xm.d(97): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmp9pkdy0xm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst)\n    {\n        if(x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu_td0g4u.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmpu_td0g4u.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpu_td0g4u.d(33): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu_td0g4u.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppbre6so7.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppbre6so7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqhmvo5jn.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqhmvo5jn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | x::xs => (\n \
    \       if x < 0 then Some(None) \n        else if x > 0 then Some(x) \n     \
    \   else largest_smallest_integers(xs)\n        )\n    end\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpddivx4ff.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpddivx4ff.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpddivx4ff.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpddivx4ff.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpddivx4ff.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpddivx4ff.d(27): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpddivx4ff.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst, \n        largest = i if i > largest, \n        smallest\
    \ = i if i < smallest);\n    return Tuple!(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi_07gmci.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpi_07gmci.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpi_07gmci.d(21): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmpi_07gmci.d(22): Error: found `if` when expecting\
    \ `;` following statement\\n/tmp/tmpi_07gmci.d(22): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpi_07gmci.d(22): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpi_07gmci.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp612auw8d.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmp612auw8d.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp612auw8d.d(33): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp612auw8d.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None, None)\n           \
    \      else if hd > 0 then Tuple!(Nullable!(long), Nullable!(long)) (hd, None)\n\
    \                 else if hd == 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n                 else Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n    end;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpet29bofg.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpet29bofg.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpet29bofg.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpet29bofg.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpet29bofg.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpet29bofg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       match hd with\n        | None => (None, None)\n        | Some(None) =>\
    \ (None, None)\n        | Some(Some(None)) => (None, None)\n        | Some(Some(Some(None)))\
    \ => (None, None)\n        | Some(Some(Some(Some(None)))) => (None, None)\n  \
    \      | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphm_eqxvr.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmphm_eqxvr.d(19): Error: found `|` when expecting `(`\\n/tmp/tmphm_eqxvr.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmphm_eqxvr.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmphm_eqxvr.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmphm_eqxvr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    bool isNegative = false;\n    long max = 0;\n    long min\
    \ = 0;\n    \n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n \
    \           isNegative = true;\n        }\n        if (i > 0)\n        {\n   \
    \         if (isNegative)\n            {\n                if (max < i)\n     \
    \           {\n                    max = i;\n                }\n            }\n\
    \            else\n            {\n                if (min > i)\n             \
    \   {\n                    min = i;\n                }\n            }\n      \
    \  }\n    }\n    \n    if (isNegative)\n    {\n        return (None, max);\n \
    \   }\n    else\n    {\n        return (Some(min), None);\n    }\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjmxd_ro2.d(23): Error: semicolon expected, not `:`\\n/tmp/tmpjmxd_ro2.d(23):\
    \ Error: expression expected, not `:`\\n/tmp/tmpjmxd_ro2.d(23): Error: found `lst`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjmxd_ro2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) result.a = x;\n        if (x > 0) result.b = x;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl18_hqzg.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpl18_hqzg.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpl18_hqzg.d(25): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl18_hqzg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyd8t77fi.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyd8t77fi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7cf7uprl.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp7cf7uprl.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp7cf7uprl.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7cf7uprl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3bipm9gb.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3bipm9gb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd;\n        (max_int,\
    \ min_int) :: largest_smallest_integers(tl);\n    | _ => unreachable!();\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpborslli1.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpborslli1.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpborslli1.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpborslli1.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpborslli1.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpborslli1.d(22): Error: found `:` when\
    \ expecting `;` following statement\\n/tmp/tmpborslli1.d(22): Error: found `:`\
    \ instead of statement\\n/tmp/tmpborslli1.d(23): Error: found `|` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpborslli1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_val, min_val) = if hd < 0L then hd::(-1L, hd) else hd::(hd, 0L);\n\
    \        (max_val, min_val) ||> List.fold_left((max_val, min_val), |(max_val,\
    \ min_val), x| \n            if x < 0L then max_val\n            else min_val)\n\
    \    end\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu5wp7c_v.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpu5wp7c_v.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpu5wp7c_v.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpu5wp7c_v.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpu5wp7c_v.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpu5wp7c_v.d(22): Error: expression expected,\
    \ not `>`\\n/tmp/tmpu5wp7c_v.d(22): Error: found `List` when expecting `;` following\
    \ statement\\n/tmp/tmpu5wp7c_v.d(22): Error: expression expected, not `|`\\n/tmp/tmpu5wp7c_v.d(23):\
    \ Error: expression expected, not `if`\\n/tmp/tmpu5wp7c_v.d(23): Error: found\
    \ `x` when expecting `,`\\n/tmp/tmpu5wp7c_v.d(23): Error: expression expected,\
    \ not `<`\\n/tmp/tmpu5wp7c_v.d(23): Error: found `0L` when expecting `,`\\n/tmp/tmpu5wp7c_v.d(23):\
    \ Error: found `max_val` when expecting `,`\\n/tmp/tmpu5wp7c_v.d(24): Error: expression\
    \ expected, not `else`\\n/tmp/tmpu5wp7c_v.d(24): Error: found `min_val` when expecting\
    \ `,`\\n/tmp/tmpu5wp7c_v.d(25): Error: found `end` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu5wp7c_v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var max: long = 0;\n    var min: long = 0;\n    foreach (var i\
    \ in lst) {\n        if (i < 0) {\n            max = i;\n        } else {\n  \
    \          min = i;\n        }\n    }\n    return Tuple!(Nullable!(long), Nullable!(long));\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2uyxl_cy.d(18): Error: found `max` when expecting `;` following\
    \ statement\\n/tmp/tmp2uyxl_cy.d(18): Error: found `:` instead of statement\\\
    n/tmp/tmp2uyxl_cy.d(19): Error: found `min` when expecting `;` following statement\\\
    n/tmp/tmp2uyxl_cy.d(19): Error: found `:` instead of statement\\n/tmp/tmp2uyxl_cy.d(20):\
    \ Error: found `in` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2uyxl_cy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    if (lst.is_empty)\n    {\n        result.first = null;\n        result.second\
    \ = null;\n    }\n    else\n    {\n        auto largest = std.math.to.max(lst);\n\
    \        auto smallest = std.math.to.min(lst);\n        result.first = largest;\n\
    \        result.second = smallest;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcfkp9k1o.d(21): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmpcfkp9k1o.d(23): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmpcfkp9k1o.d(24): Error: no property `second` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpcfkp9k1o.d(28): Error: undefined\
    \ identifier `to` in module `std.math`\\n/tmp/tmpcfkp9k1o.d(29): Error: undefined\
    \ identifier `to` in module `std.math`\\n/tmp/tmpcfkp9k1o.d(30): Error: no property\
    \ `first` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpcfkp9k1o.d(31):\
    \ Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcfkp9k1o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst, \n        largest = max!(largest, i);\n        smallest\
    \ = min!(smallest, i));\n    return Tuple!(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnfk28y8h.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpnfk28y8h.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpnfk28y8h.d(21): Error: found `;`\
    \ when expecting `)`\\n/tmp/tmpnfk28y8h.d(22): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpnfk28y8h.d(22): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpnfk28y8h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n\
    \        } else {\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkhtlexi7.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmpkhtlexi7.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpkhtlexi7.d(29): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkhtlexi7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0)\n            result.a = e;\n        else\n\
    \            result.b = e;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd70uupuk.d(20): Error: no identifier for declarator `e`\\n/tmp/tmpd70uupuk.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpd70uupuk.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmpd70uupuk.d(20): Error: found `lst` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd70uupuk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) result.a = x;\n        if (x > 0) result.b = x;\n\
    \    }\n    \n    if (result.a == null && result.b == null)\n        return result;\n\
    \    \n    return Tuple!(Nullable!(long), Nullable!(long));\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_rdjstei.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp_rdjstei.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp_rdjstei.d(25): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmp_rdjstei.d(26): Error: found `return` when expecting\
    \ `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp_rdjstei.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        match hd with\n        | None => (None, None)\n        | Some(None) =>\
    \ (None, None)\n        | Some(Some(None)) => (None, None)\n        | Some(Some(Some(None)))\
    \ => (None, None)\n        | Some(Some(Some(Some(None)))) => (None, None)\n  \
    \      | Some(Some(Some(Some(Some(Some(None))))) => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(None)))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsfn9z4ym.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpsfn9z4ym.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpsfn9z4ym.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpsfn9z4ym.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpsfn9z4ym.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpsfn9z4ym.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst, \n        largest = max!(largest, i);\n        smallest\
    \ = min!(smallest, i));\n    return Tuple!(largest, smallest);\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbcvdjio1.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpbcvdjio1.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpbcvdjio1.d(21): Error: found `;`\
    \ when expecting `)`\\n/tmp/tmpbcvdjio1.d(22): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpbcvdjio1.d(22): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\n/tmp/tmpbcvdjio1.d(25): Error: unterminated /*\
    \ */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbcvdjio1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let a = if hd < 0 then None else Some(hd)\n        let b = if hd > 0 then\
    \ None else Some(hd)\n        (a, b)\nend\n    \n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjt1i7cl4.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpjt1i7cl4.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpjt1i7cl4.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpjt1i7cl4.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpjt1i7cl4.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpjt1i7cl4.d(26): Error: unterminated\
    \ /* */ comment\\n/tmp/tmpjt1i7cl4.d(98): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpjt1i7cl4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, x) in lst {\n        if x < 0 {\n            result.0 = x;\n           \
    \ result.1 = i;\n        }\n    }\n    \n    if result.0 == null && result.1 ==\
    \ null {\n        return Tuple!(Nullable!(long), Nullable!(long));\n    }\n  \
    \  \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_98tknt4.d(20): Error: no identifier for declarator `x`\\n/tmp/tmp_98tknt4.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp_98tknt4.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmp_98tknt4.d(20): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmp_98tknt4.d(21): Error: found `x` when expecting `(`\\n/tmp/tmp_98tknt4.d(21):\
    \ Error: expression expected, not `<`\\n/tmp/tmp_98tknt4.d(21): Error: found `0`\
    \ when expecting `)`\\n/tmp/tmp_98tknt4.d(22): Error: found `0.00000` when expecting\
    \ `;` following statement\\n/tmp/tmp_98tknt4.d(22): Error: found `=` instead of\
    \ statement\\n/tmp/tmp_98tknt4.d(23): Error: found `0.1` when expecting `;` following\
    \ statement\\n/tmp/tmp_98tknt4.d(23): Error: found `=` instead of statement\\\
    n/tmp/tmp_98tknt4.d(27): Error: found `result` when expecting `(`\\n/tmp/tmp_98tknt4.d(27):\
    \ Error: found `0.1` when expecting `)`\\n/tmp/tmp_98tknt4.d(27): Error: found\
    \ `==` instead of statement\\n/tmp/tmp_98tknt4.d(31): Error: declaration expected,\
    \ not `return`\\n/tmp/tmp_98tknt4.d(32): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_98tknt4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> None\n    | hd::tl -> if hd < 0 then\
    \ Some(-1 * hd) else Some(hd)\n    \n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp81378wrd.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp81378wrd.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp81378wrd.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmp81378wrd.d(19): Error: found `None`\
    \ when expecting `)`\\n/tmp/tmp81378wrd.d(20): Error: found `|` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp81378wrd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if (i < 0) \n           {\n               result.a = i;\n\
    \               result.b = null;\n           }\n           else \n           {\n\
    \               result.a = null;\n               result.b = i;\n           }\n\
    \    );\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp00du7rj9.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp00du7rj9.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp00du7rj9.d(21): Error: expression\
    \ expected, not `if`\\n/tmp/tmp00du7rj9.d(22): Error: found `{` when expecting\
    \ `)`\\n/tmp/tmp00du7rj9.d(26): Error: declaration expected, not `else`\\n/tmp/tmp00du7rj9.d(29):\
    \ Error: no identifier for declarator `result.b`\\n/tmp/tmp00du7rj9.d(29): Error:\
    \ declaration expected, not `=`\\n/tmp/tmp00du7rj9.d(30): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp00du7rj9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        if hd < 0L then hd\n        else if hd > 0L then tl |> List.head |> long\n\
    \        else (None, None)\n    )\nend;\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd87bg8e8.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpd87bg8e8.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpd87bg8e8.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpd87bg8e8.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpd87bg8e8.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpd87bg8e8.d(26): Error: unterminated\
    \ /* */ comment\\n/tmp/tmpd87bg8e8.d(98): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpd87bg8e8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        if hd < 0L then Some(hd, 0L)\n        else Some(hd, tl.min())\n    )\n\
    end;\n</cell>\n<code language=ocaml-jupyter>\nlet _ = \n    Printf.printf \"(%s,\
    \ %s)\\n\" (\n        largest_smallest_integers([2, 4, 1, 3, 5, 7]).0;\n     \
    \   largest_smallest_integers([]).0;\n        largest_smallest_integers([0]).0;\n\
    \    );;\n</cell>\n<text>\nExercise: Write a function that takes a list and returns\
    \ a tuple where the first element is the sum of the elements in the list, and\
    \ the second element is the product of the elements in the list.\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4oqo10a8.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp4oqo10a8.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp4oqo10a8.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp4oqo10a8.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp4oqo10a8.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp4oqo10a8.d(25): Error: found `<` instead\
    \ of statement\\n/tmp/tmp4oqo10a8.d(30): Error: found `0.00000` when expecting\
    \ `;` following statement\\n/tmp/tmp4oqo10a8.d(30): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\n/tmp/tmp4oqo10a8.d(31): Error: found `0.00000`\
    \ when expecting `;` following statement\\n/tmp/tmp4oqo10a8.d(31): Deprecation:\
    \ use `{ }` for an empty statement, not `;`\\n/tmp/tmp4oqo10a8.d(32): Error: found\
    \ `)` instead of statement\\n/tmp/tmp4oqo10a8.d(32): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\n/tmp/tmp4oqo10a8.d(33): Error: found `<` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4oqo10a8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None, None)\n           \
    \        else if hd > 0 then Tuple!(Nullable!(long), Nullable!(long)) (hd, None)\n\
    \                   else if hd == 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n                   else Tuple!(Nullable!(long), Nullable!(long))\
    \ (hd, hd)\n    end;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeaqaxskv.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpeaqaxskv.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpeaqaxskv.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpeaqaxskv.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpeaqaxskv.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpeaqaxskv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    while(i < lst.len) {\n        if(lst[i] < 0 && largest ==\
    \ Nullable!(long)) {\n            largest = Nullable!(long);\n        }\n    \
    \    if(lst[i] > 0 && smallest == Nullable!(long)) {\n            smallest = Nullable!(long);\n\
    \        }\n        if(largest == Nullable!(long) && smallest == Nullable!(long))\
    \ {\n            break;\n        }\n        if(lst[i] < 0 && largest == Nullable!(long))\
    \ {\n            largest = Nullable!(long);\n        }\n        if(lst[i] > 0\
    \ && smallest == Nullable!(long)) {\n            smallest = Nullable!(long);\n\
    \        }\n        i += 1;\n    }\n    return (largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ii2ydaq.d(18): Error: undefined identifier `var`\\n/tmp/tmp0ii2ydaq.d(18):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmp0ii2ydaq.d(19): Error: undefined\
    \ identifier `var`\\n/tmp/tmp0ii2ydaq.d(19): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmp0ii2ydaq.d(20): Error: undefined identifier `var`\\n/tmp/tmp0ii2ydaq.d(21):\
    \ Error: no property `len` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0ii2ydaq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max,min) = largest_smallest_integers(tl)\n        if max > hd then\
    \ Some(max,hd)\n        elif min < hd then Some(min,hd)\n        else None\n \
    \   end\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4_6m9n5d.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp4_6m9n5d.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp4_6m9n5d.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp4_6m9n5d.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp4_6m9n5d.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4_6m9n5d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0L then \n                    let (a, b) = (hd, hd - 1L) \n              \
    \      else \n                    let (a, b) = (hd + 1L, hd)\n               \
    \     (a, b) \n    | _ => (None, None)\n}\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvfqvvl31.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpvfqvvl31.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpvfqvvl31.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpvfqvvl31.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpvfqvvl31.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpvfqvvl31.d(27): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvfqvvl31.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       let a = if hd < 0 then None else Some(hd)\n        let b = if hd > 0 then\
    \ None else Some(hd)\n        (a, b)\n    | _ => (None, None)\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi7qqz1l5.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpi7qqz1l5.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpi7qqz1l5.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpi7qqz1l5.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpi7qqz1l5.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpi7qqz1l5.d(26): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi7qqz1l5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    bool isNegative = true;\n    long max = 0;\n    long min\
    \ = 0;\n    \n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n \
    \           isNegative = false;\n        }\n        \n        if (i > max)\n \
    \       {\n            max = i;\n        }\n        \n        if (i < min)\n \
    \       {\n            min = i;\n        }\n    }\n    \n    if (isNegative)\n\
    \    {\n        return (None, max);\n    }\n    else\n    {\n        return (min,\
    \ None);\n    }\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbk4zleck.d(23): Error: semicolon expected, not `:`\\n/tmp/tmpbk4zleck.d(23):\
    \ Error: expression expected, not `:`\\n/tmp/tmpbk4zleck.d(23): Error: found `lst`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbk4zleck.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       match hd with\n        | None => (None, None)\n        | Some x => \n\
    \            match tl with\n            | [] => (None, None)\n            | hd::tl\
    \ => \n                match hd with\n                | None => (None, None)\n\
    \                | Some y => \n                    if x < y then (x, y)\n    \
    \                else (None, None)\n            end\n        end\n    end\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7pws7jwq.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp7pws7jwq.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp7pws7jwq.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp7pws7jwq.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp7pws7jwq.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp7pws7jwq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach (i, el) in lst {\n        if (el < 0) largest = el;\n        else\
    \ if (el > 0) smallest = el;\n    }\n    return Tuple!(largest, smallest);\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpokwsghhc.d(20): Error: no identifier for declarator `el`\\n/tmp/tmpokwsghhc.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpokwsghhc.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmpokwsghhc.d(20): Error: found `lst` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpokwsghhc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi5_nhc1y.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpi5_nhc1y.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpi5_nhc1y.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi5_nhc1y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (smallest, largest) = largest_smallest_integers(tl)\n        if smallest\
    \ < hd then (smallest, hd)\n        else (largest, hd)\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2rtfc3o6.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp2rtfc3o6.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp2rtfc3o6.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp2rtfc3o6.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp2rtfc3o6.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp2rtfc3o6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < 0) {\n            if (largest == Nullable!(long))\
    \ {\n                largest = Nullable!(long);\n                smallest = Nullable!(long);\n\
    \            }\n            largest = Nullable!(long);\n            smallest =\
    \ Nullable!(long);\n        } else if (lst[i] > 0) {\n            if (smallest\
    \ == Nullable!(long)) {\n                largest = Nullable!(long);\n        \
    \        smallest = Nullable!(long);\n            }\n            largest = Nullable!(long);\n\
    \            smallest = Nullable!(long);\n        } else {\n            if (largest\
    \ == Nullable!(long)) {\n                largest = Nullable!(long);\n        \
    \        smallest = Nullable!(long);\n            }\n            largest = Nullable!(long);\n\
    \            smallest = Nullable!(long);\n        }\n        i++;\n    }\n   \
    \ return Tuple!(largest, smallest);\n}\n/*\nunittest\n{\n    alias candidate =\
    \ largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnj0im_xh.d(51): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnj0im_xh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        if hd < 0L then hd\n        else if hd > 0L then tl |> List.head |> long\n\
    \        else (None, None)\n    )\nend\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.3>\nlargest_smallest_integers([0])\n</cell>\n\
    <text>\nExercise: Write a function that takes a string and returns the number\
    \ of vowels in it.\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkezd1ivd.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpkezd1ivd.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpkezd1ivd.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpkezd1ivd.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpkezd1ivd.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpkezd1ivd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> None\n    | hd::tl -> \n        let\
    \ (smallest, largest) = if hd < 0 then Some(hd, -hd) else None\n        smallest,\
    \ largest\nend;\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp17nqz9m1.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp17nqz9m1.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp17nqz9m1.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmp17nqz9m1.d(19): Error: found `None`\
    \ when expecting `)`\\n/tmp/tmp17nqz9m1.d(20): Error: found `|` instead of statement\\\
    n/tmp/tmp17nqz9m1.d(24): Error: unterminated /* */ comment\\n/tmp/tmp17nqz9m1.d(96):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp17nqz9m1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9sk23bpm.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9sk23bpm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long, Nullable!(long)))\n\
    \    | _ -> let mutable smallest = Long.MinValue; mutable largest = Long.MaxValue;\n\
    \        for n in lst do\n            if n < smallest then smallest = n\n    \
    \        if n > largest then largest = n\n    \n    Tuple!(Nullable!(long), Nullable!(long))(smallest,\
    \ largest)\nend\n</cell>\n<code language=julia-1.3>\n@code_warntype largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\n@code_warntype largest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.3>\n@code_warntype largest_smallest_integers([0])\n\
    </cell>\n<text>\nExercise: Write a function that takes a list as input and returns\
    \ a tuple where the first element is the sum of the positive integers in the list,\
    \ and the second element is the sum of the negative integers in the list.\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgmng2qge.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpgmng2qge.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpgmng2qge.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmpgmng2qge.d(19): Error: found `Nullable`\
    \ when expecting `)`\\n/tmp/tmpgmng2qge.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpgmng2qge.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpgmng2qge.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpgmng2qge.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpgmng2qge.d(19):\
    \ Error: found `)` when expecting `.` following long\\n/tmp/tmpgmng2qge.d(19):\
    \ Error: found `)` when expecting identifier following `long`.\\n/tmp/tmpgmng2qge.d(20):\
    \ Error: use `.` for member lookup, not `->`\\n/tmp/tmpgmng2qge.d(20): Error:\
    \ found `mutable` when expecting `,`\\n/tmp/tmpgmng2qge.d(20): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpgmng2qge.d(20): Error: found `largest` when expecting\
    \ `,`\\n/tmp/tmpgmng2qge.d(20): Error: expression expected, not `=`\\n/tmp/tmpgmng2qge.d(20):\
    \ Error: found `Long` when expecting `,`\\n/tmp/tmpgmng2qge.d(20): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmpgmng2qge.d(21): Error: expression expected,\
    \ not `for`\\n/tmp/tmpgmng2qge.d(21): Error: found `n` when expecting `,`\\n/tmp/tmpgmng2qge.d(21):\
    \ Error: expression expected, not `in`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpgmng2qge.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0) \n               {\n      \
    \             result.a = i;\n                   result.b = null;\n           \
    \    }\n               else \n               {\n                   result.a =\
    \ null;\n                   result.b = i;\n               }\n           });\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9ocnzt4l.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp9ocnzt4l.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp9ocnzt4l.d(32): Error: use `{\
    \ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9ocnzt4l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    long a = null;\n    long b = null;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            a = x;\n        }\n\
    \        else if (x > 0)\n        {\n            b = x;\n        }\n    }\n  \
    \  \n    return Tuple!(a, b);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu65m0o3n.d(22): Error: no identifier for declarator `lst`\\n/tmp/tmpu65m0o3n.d(22):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpu65m0o3n.d(34): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu65m0o3n.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (hd, tl.min())\n    end;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw9jeakol.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpw9jeakol.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpw9jeakol.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpw9jeakol.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpw9jeakol.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpw9jeakol.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var max: long = Long.min;\n    var min: long = Long.max;\n   \
    \ var i: long = 0;\n    while (i<lst.len) {\n        if (lst[i] < min) {\n   \
    \         min = lst[i];\n        }\n        if (lst[i] > max) {\n            max\
    \ = lst[i];\n        }\n        i += 1;\n    }\n    return (max, min);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcvt1664n.d(18): Error: found `max` when expecting `;` following\
    \ statement\\n/tmp/tmpcvt1664n.d(18): Error: found `:` instead of statement\\\
    n/tmp/tmpcvt1664n.d(19): Error: found `min` when expecting `;` following statement\\\
    n/tmp/tmpcvt1664n.d(19): Error: found `:` instead of statement\\n/tmp/tmpcvt1664n.d(20):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpcvt1664n.d(20):\
    \ Error: found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpcvt1664n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = null;\n        result.second\
    \ = null;\n        return result;\n    }\n    \n    long largest = lst.max();\n\
    \    long smallest = lst.min();\n    \n    if (largest < 0)\n    {\n        result.first\
    \ = null;\n        result.second = null;\n        return result;\n    }\n    \n\
    \    if (smallest > 0)\n    {\n        result.first = smallest;\n        result.second\
    \ = largest;\n        return result;\n    }\n    \n    result.first = null;\n\
    \    result.second = null;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2epgr_qy.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmp2epgr_qy.d(22): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp2epgr_qy.d(23): Error: no property `second` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp2epgr_qy.d(27): Error: no property\
    \ `max` for type `long[]`\\n/tmp/tmp2epgr_qy.d(28): Error: no property `min` for\
    \ type `long[]`\\n/tmp/tmp2epgr_qy.d(32): Error: no property `first` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp2epgr_qy.d(33): Error: no property\
    \ `second` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp2epgr_qy.d(39):\
    \ Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmp2epgr_qy.d(40): Error: no property `second` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp2epgr_qy.d(44): Error: no property `first` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp2epgr_qy.d(45): Error: no property\
    \ `second` for type `Tuple!(Nullable!long, Nullable!long)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2epgr_qy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.a = result.b = null;\n        return\
    \ result;\n    }\n    \n    long max_negative = lst.iter().max().unwrap();\n \
    \   long min_positive = lst.iter().min().unwrap();\n    \n    if (max_negative\
    \ < 0)\n    {\n        result.a = null;\n        result.b = max_negative;\n  \
    \  }\n    else if (min_positive > 0)\n    {\n        result.a = min_positive;\n\
    \        result.b = null;\n    }\n    else\n    {\n        result.a = max_negative;\n\
    \        result.b = min_positive;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0y_ylppy.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmp0y_ylppy.d(22): Error: no property `a` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(22): Error: no property `b` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(26): Error: no property `iter` for type\
    \ `long[]`\\n/tmp/tmp0y_ylppy.d(27): Error: no property `iter` for type `long[]`\\\
    n/tmp/tmp0y_ylppy.d(31): Error: no property `a` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(32): Error: no property `b` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(36): Error: no property `a` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(37): Error: no property `b` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(41): Error: no property `a` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp0y_ylppy.d(42): Error: no property `b` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0y_ylppy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.Length;\n   \
    \ while (i < n) {\n        if (lst[i] < 0) {\n            if (largest == Nullable!(long))\
    \ {\n                largest = Nullable!(long);\n                smallest = Nullable!(long);\n\
    \            }\n            largest = Nullable!(long);\n            smallest =\
    \ Nullable!(long);\n        }\n        else if (lst[i] > 0) {\n            if\
    \ (smallest == Nullable!(long)) {\n                largest = Nullable!(long);\n\
    \                smallest = Nullable!(long);\n            }\n            largest\
    \ = Nullable!(long);\n            smallest = Nullable!(long);\n        }\n   \
    \     else {\n            if (largest == Nullable!(long)) {\n                largest\
    \ = Nullable!(long);\n                smallest = Nullable!(long);\n          \
    \  }\n            largest = Nullable!(long);\n            smallest = Nullable!(long);\n\
    \        }\n        i++;\n    }\n    if (largest == Nullable!(long)) {\n     \
    \   return (Nullable!(long), Nullable!(long));\n    }\n    if (smallest == Nullable!(long))\
    \ {\n        return (Nullable!(long), Nullable!(long));\n    }\n    return (largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa4yznyfs.d(18): Error: undefined identifier `var`\\n/tmp/tmpa4yznyfs.d(18):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmpa4yznyfs.d(19): Error: undefined\
    \ identifier `var`\\n/tmp/tmpa4yznyfs.d(19): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmpa4yznyfs.d(20): Error: undefined identifier `var`\\n/tmp/tmpa4yznyfs.d(21):\
    \ Error: undefined identifier `var`\\n/tmp/tmpa4yznyfs.d(22): Error: undefined\
    \ identifier `var`\\n/tmp/tmpa4yznyfs.d(23): Error: undefined identifier `var`\\\
    n/tmp/tmpa4yznyfs.d(23): Error: no property `Length` for type `long[]`\\n/tmp/tmpa4yznyfs.d(52):\
    \ Error: Using the result of a comma expression is not allowed\\n/tmp/tmpa4yznyfs.d(55):\
    \ Error: Using the result of a comma expression is not allowed\\n/tmp/tmpa4yznyfs.d(52):\
    \ Error: cannot implicitly convert expression `inout(long)` of type `inout(long)`\
    \ to `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpa4yznyfs.d(55): Error: cannot\
    \ implicitly convert expression `inout(long)` of type `inout(long)` to `Tuple!(Nullable!long,\
    \ Nullable!long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa4yznyfs.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       let (max_int, min_int) = largest_smallest_integers(tl)\n        match\
    \ max_int with\n        | None => (None, None)\n        | Some x => \n       \
    \     if x < 0 then \n                (Some(max_int), Some(min_int))\n       \
    \     else\n                (Some(x), None)\n        end\n    end\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3aj8gqf9.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp3aj8gqf9.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp3aj8gqf9.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp3aj8gqf9.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp3aj8gqf9.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp3aj8gqf9.d(32): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3aj8gqf9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0)\n            result.a = e;\n        else\n\
    \            result.b = e;\n    }\n    \n    if (result.a == result.b)\n     \
    \   return result;\n    else\n        return Tuple!(Nullable!(long), Nullable!(long));\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkvyvz3s.d(20): Error: no identifier for declarator `e`\\n/tmp/tmpqkvyvz3s.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpqkvyvz3s.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmpqkvyvz3s.d(20): Error: found `lst` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqkvyvz3s.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    bool negative = false;\n    long max = 0;\n    long min\
    \ = 0;\n    \n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n \
    \           negative = true;\n        }\n        \n        if (i > max)\n    \
    \    {\n            max = i;\n        }\n        \n        if (i < min)\n    \
    \    {\n            min = i;\n        }\n    }\n    \n    if (negative == false)\n\
    \    {\n        return (max, min);\n    }\n    else\n    {\n        return (None,\
    \ None);\n    }\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprae4no7y.d(23): Error: semicolon expected, not `:`\\n/tmp/tmprae4no7y.d(23):\
    \ Error: expression expected, not `:`\\n/tmp/tmprae4no7y.d(23): Error: found `lst`\
    \ when expecting `;` following `for` condition\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprae4no7y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Some(Some(hd), None) else Some(None, Some(tl))\n    end;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5o213z4l.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp5o213z4l.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp5o213z4l.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp5o213z4l.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp5o213z4l.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5o213z4l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (isNegative, smallest) = largest_smallest_integers(tl)\n        if\
    \ isNegative then (hd, smallest)\n        else (smallest, hd)\n    end\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5d837jor.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp5d837jor.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp5d837jor.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp5d837jor.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp5d837jor.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5d837jor.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(i : lst, \n           {\n               if (i < 0) \n           \
    \    {\n                   result.a = i;\n                   result.b = null;\n\
    \               }\n               else\n               {\n                   result.a\
    \ = null;\n                   result.b = i;\n               }\n           });\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvs6u_or_.d(21): Error: no identifier for declarator `i`\\n/tmp/tmpvs6u_or_.d(21):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpvs6u_or_.d(33): Error: use `{\
    \ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpvs6u_or_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4o1mbrwa.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4o1mbrwa.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    \n    while (i < lst.len) {\n        if (lst[i]\
    \ < 0)\n            smallest = Nullable!(long);\n        else\n            smallest\
    \ = Nullable!(long);\n        \n        while (j < lst.len) {\n            if\
    \ (lst[j] > 0)\n                largest = Nullable!(long);\n            else\n\
    \                largest = Nullable!(long);\n            \n            if (largest\
    \ != Nullable!(long) && smallest != Nullable!(long))\n                break;\n\
    \            \n            if (lst[j] < 0)\n                smallest = Nullable!(long);\n\
    \            else\n                smallest = Nullable!(long);\n            \n\
    \            j++;\n        }\n        \n        if (largest != Nullable!(long)\
    \ && smallest != Nullable!(long))\n            break;\n        \n        i++;\n\
    \    }\n    \n    return Tuple!(largest, smallest);\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn50r8v_6.d(18): Error: undefined identifier `var`\\n/tmp/tmpn50r8v_6.d(18):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmpn50r8v_6.d(19): Error: undefined\
    \ identifier `var`\\n/tmp/tmpn50r8v_6.d(19): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmpn50r8v_6.d(20): Error: undefined identifier `var`\\n/tmp/tmpn50r8v_6.d(21):\
    \ Error: undefined identifier `var`\\n/tmp/tmpn50r8v_6.d(23): Error: no property\
    \ `len` for type `long[]`\\n/tmp/tmpn50r8v_6.d(29): Error: no property `len` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn50r8v_6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integer(i))\
    \ {\n        result = t if t.a > result.a else result;\n    }\n    \n    result.a\
    \ = result.a if result.a != None else None;\n    result.b = result.b if result.b\
    \ != None else None;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy9tdxvea.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpy9tdxvea.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpy9tdxvea.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmpy9tdxvea.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpy9tdxvea.d(25): Error: no identifier for declarator `result.a`\\n/tmp/tmpy9tdxvea.d(25):\
    \ Error: declaration expected, not `=`\\n/tmp/tmpy9tdxvea.d(26): Error: no identifier\
    \ for declarator `result.b`\\n/tmp/tmpy9tdxvea.d(26): Error: declaration expected,\
    \ not `=`\\n/tmp/tmpy9tdxvea.d(28): Error: declaration expected, not `return`\\\
    n/tmp/tmpy9tdxvea.d(29): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpy9tdxvea.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max,min) = if hd < 0 then (None,None) else (Some(hd),Some(tl))\n \
    \       (Some(max), Some(min))\nend\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_wf9sdlq.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp_wf9sdlq.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp_wf9sdlq.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp_wf9sdlq.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp_wf9sdlq.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_wf9sdlq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprlx6k0v6.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprlx6k0v6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integers([i]))\n\
    \    {\n        result = max!(result, t);\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsv0ktztn.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpsv0ktztn.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpsv0ktztn.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmpsv0ktztn.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpsv0ktztn.d(26): Error: declaration expected, not `return`\\n/tmp/tmpsv0ktztn.d(27):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpsv0ktztn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       let (small, large) = largest_smallest_integers(tl)\n        match small,\
    \ large with\n        | None, None => (None, None)\n        | None, hd::tl =>\
    \ (None, hd)\n        | hd::small, None => (hd, None)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::small, hd)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small, hd::large => (hd, hd::small)\n    \
    \    | hd::small, hd::large => (hd::large, hd)\n        | hd::small, hd::large\
    \ => (hd, hd::large)\n        | hd::small\nunittest\n{\n    alias candidate =\
    \ largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkz_hp2a.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpqkz_hp2a.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpqkz_hp2a.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpqkz_hp2a.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpqkz_hp2a.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpqkz_hp2a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then (None, hd) else (Some(hd), Some(tl))\n    end\n}\nunittest\n{\n   \
    \ alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpelyg7tk3.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpelyg7tk3.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpelyg7tk3.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpelyg7tk3.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpelyg7tk3.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpelyg7tk3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,Some(hd))\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) else Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n    | hd::tl\
    \ => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else\
    \ Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n    | hd::tl => if\
    \ hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,Some(hd))\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) else Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n    | hd::tl\
    \ => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else\
    \ Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n    | hd::tl => if\
    \ hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,Some(hd))\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) else Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj8hyes4s.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpj8hyes4s.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpj8hyes4s.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpj8hyes4s.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpj8hyes4s.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpj8hyes4s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cnzxgp2.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp5cnzxgp2.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp5cnzxgp2.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5cnzxgp2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (smallest, largest) = if hd < 0 then hd else hd :: tl in\n        (smallest,\
    \ largest)\nend;\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgqc5xgy_.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpgqc5xgy_.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpgqc5xgy_.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpgqc5xgy_.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpgqc5xgy_.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpgqc5xgy_.d(24): Error: unterminated\
    \ /* */ comment\\n/tmp/tmpgqc5xgy_.d(96): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpgqc5xgy_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0) \n               {\n      \
    \             result.a = i;\n                   result.b = null;\n           \
    \    }\n               else if (i > 0) \n               {\n                  \
    \ result.a = null;\n                   result.b = i;\n               }\n     \
    \          else \n               {\n                   result.a = null;\n    \
    \               result.b = null;\n               }\n           });\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2l19ep18.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp2l19ep18.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp2l19ep18.d(37): Error: use `{\
    \ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2l19ep18.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let a = if hd < 0 then None else Some(hd)\n        let b = if hd > 0 then\
    \ None else Some(hd)\n        Tuple!(a, b)\nend\n</cell>\n<code language=julia-1.3>\n\
    largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\n\
    largest_smallest_integers([])\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([0])\n\
    </cell>\n<text>\nExercise: Write a function that takes a vector of integers and\
    \ returns a tuple where the first element is the sum of the positive integers\
    \ in the vector, and the second element is the sum of the negative integers in\
    \ the vector.\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpevswqd6_.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpevswqd6_.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpevswqd6_.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpevswqd6_.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpevswqd6_.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpevswqd6_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t : Tuple!(Nullable!(long),\
    \ Nullable!(long))) \n    {\n        if (t.0 == null || t.1 == null) \n      \
    \  {\n            result = t;\n        }\n        else if (t.0 < 0 && t.1 < 0)\
    \ \n        {\n            result = t;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphcy3wrc1.d(20): Error: no identifier for declarator `i`\\n/tmp/tmphcy3wrc1.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmphcy3wrc1.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmphcy3wrc1.d(21): Error: found `:` instead of statement\\\
    n/tmp/tmphcy3wrc1.d(27): Error: declaration expected, not `else`\\n/tmp/tmphcy3wrc1.d(30):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmphcy3wrc1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0s6w5_11.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp0s6w5_11.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp0s6w5_11.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0s6w5_11.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if(x < 0)\n        {\n            result.a = x;\n  \
    \          result.b = null;\n        }\n        else\n        {\n            result.b\
    \ = x;\n            result.a = null;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkvz2jdxk.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpkvz2jdxk.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpkvz2jdxk.d(34): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvz2jdxk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach (i, x) in lst {\n        if x < 0 {\n            largest = x;\n \
    \       } else {\n            smallest = x;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2vip9njv.d(20): Error: no identifier for declarator `x`\\n/tmp/tmp2vip9njv.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp2vip9njv.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmp2vip9njv.d(20): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmp2vip9njv.d(21): Error: found `x` when expecting `(`\\n/tmp/tmp2vip9njv.d(21):\
    \ Error: expression expected, not `<`\\n/tmp/tmp2vip9njv.d(21): Error: found `0`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2vip9njv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Null\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkhc7oqba.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpkhc7oqba.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpkhc7oqba.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmpkhc7oqba.d(19): Error: found `Nullable`\
    \ when expecting `)`\\n/tmp/tmpkhc7oqba.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpkhc7oqba.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpkhc7oqba.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpkhc7oqba.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpkhc7oqba.d(19):\
    \ Error: found `,` when expecting `.` following long\\n/tmp/tmpkhc7oqba.d(19):\
    \ Error: found `!` when expecting `)`\\n/tmp/tmpkhc7oqba.d(19): Error: found `,`\
    \ when expecting `.` following long\\n/tmp/tmpkhc7oqba.d(19): Error: found `!`\
    \ when expecting `,`\\n/tmp/tmpkhc7oqba.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpkhc7oqba.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpkhc7oqba.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpkhc7oqba.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpkhc7oqba.d(19):\
    \ Error: found `,` when expecting `.` following long\\n/tmp/tmpkhc7oqba.d(19):\
    \ Error: found `!` when expecting `)`\\n/tmp/tmpkhc7oqba.d(19): Error: found `,`\
    \ when expecting `.` following long\\n/tmp/tmpkhc7oqba.d(19): Error: found `!`\
    \ when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkhc7oqba.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n\
    \        if hd < 0L then hd\n        else if hd > 0L then tl |> List.head |> long\n\
    \        else (None, None)\n    )\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp56ijy50q.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp56ijy50q.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp56ijy50q.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp56ijy50q.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp56ijy50q.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp56ijy50q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Some(Some(hd), None) else Some(None, Some(tl))\n    end;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjcrtkaf6.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpjcrtkaf6.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpjcrtkaf6.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpjcrtkaf6.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpjcrtkaf6.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpjcrtkaf6.d(23): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjcrtkaf6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd + 1\n        (max_int,\
    \ min_int)\n        |> List.foldBack((max_int, min_int), tl, fun (max_int, min_int)\
    \ (x) -> if x < 0 then max_int else min_int)\n        |> fst\n        |> Some\n\
    \    | _ => (None, None)\n}\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7j5mwjry.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp7j5mwjry.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp7j5mwjry.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp7j5mwjry.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp7j5mwjry.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp7j5mwjry.d(28): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7j5mwjry.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (isNegative, smallest) = largest_smallest_integers(tl)\n        if\
    \ isNegative then\n            (Some(hd), smallest)\n        else\n          \
    \  (None, Some(hd))\n    end\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0so4rnhu.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp0so4rnhu.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp0so4rnhu.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp0so4rnhu.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp0so4rnhu.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp0so4rnhu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let a = if hd < 0 then None else Some(hd)\n        let b = if hd > 0 then\
    \ None else Some(hd)\n        (a, b)\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<text>\n\
    Exercise: Write a function that returns the largest and smallest numbers in a\
    \ list.\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n\
    \        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpydh8tcok.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpydh8tcok.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpydh8tcok.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpydh8tcok.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpydh8tcok.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpydh8tcok.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var n = lst.len();\n    while (i < n) {\n\
    \        if (lst[i] < 0)\n            smallest = Nullable!(long);\n        else\n\
    \            largest = Nullable!(long);\n        j = 0;\n        while (j < i)\
    \ {\n            if (lst[j] > 0)\n                smallest = Nullable!(long);\n\
    \            else\n                largest = Nullable!(long);\n            if\
    \ (largest < smallest)\n                largest = Nullable!(long);\n         \
    \   else\n                smallest = Nullable!(long);\n            j++;\n    \
    \    }\n        i++;\n    }\n    return Tuple!(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps_0uwq7v.d(18): Error: undefined identifier `var`\\n/tmp/tmps_0uwq7v.d(18):\
    \ Error: type `inout(long)` has no value\\n/tmp/tmps_0uwq7v.d(19): Error: undefined\
    \ identifier `var`\\n/tmp/tmps_0uwq7v.d(19): Error: type `inout(long)` has no\
    \ value\\n/tmp/tmps_0uwq7v.d(20): Error: undefined identifier `var`\\n/tmp/tmps_0uwq7v.d(21):\
    \ Error: undefined identifier `var`\\n/tmp/tmps_0uwq7v.d(22): Error: undefined\
    \ identifier `var`\\n/tmp/tmps_0uwq7v.d(22): Error: no property `len` for type\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps_0uwq7v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let a = if hd < 0 then None else Some(hd)\n        let b = if hd > 0 then\
    \ None else Some(hd)\n        (a, b)\nend\n</cell>\n<code language=julia-1.3>\n\
    largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\n\
    largest_smallest_integers([])\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([0])\n\
    </cell>\n<text>\nExercise: Write a function that takes a vector of integers and\
    \ returns a tuple where the first element is the sum of the positive integers\
    \ and the second element is the sum of the negative integers. If the vector is\
    \ empty, return (None, None). Otherwise, return (sum_positive_integers(v), sum_negative_integers(v)).\
    \ Test your function with various inputs. What happens when you pass in an empty\
    \ vector?\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n\
    \        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjl_nncdh.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpjl_nncdh.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpjl_nncdh.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpjl_nncdh.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpjl_nncdh.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpjl_nncdh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Some(Some(hd), None) else None\n                 |> List.foldBack((Some(Some(-1)),\
    \ None))\n                 |> fst\n                 |> Some\n                \
    \ |> Some\n                 |> fst\n                 |> Some\n               \
    \  |> Some\n                 |> fst\n                 |> Some\n              \
    \   |> Some\n                 |> Some\n                 |> Some\n            \
    \     |> Some\n                 |> Some\n                 |> Some\n          \
    \       |> Some\n                 |> Some\n                 |> Some\n        \
    \         |> Some\n                 |> Some\n                 |> Some\n      \
    \           |> Some\n                 |> Some\n                 |> Some\n    \
    \             |> Some\n                 |> Some\n                 |> Some\n  \
    \               |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |>\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4m4rvhfn.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp4m4rvhfn.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp4m4rvhfn.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp4m4rvhfn.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp4m4rvhfn.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4m4rvhfn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n\
    \        } else {\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphd5gvasl.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmphd5gvasl.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmphd5gvasl.d(29): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphd5gvasl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | x::xs => {\n \
    \       let (smallest, largest) = largest_smallest_integers(xs);\n        if smallest\
    \ < x && largest > x then (smallest, largest)\n        else (None, None)\n   \
    \ }\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n \
    \       auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps1se1kgv.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmps1se1kgv.d(19): Error: found `|` when expecting `(`\\n/tmp/tmps1se1kgv.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmps1se1kgv.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmps1se1kgv.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmps1se1kgv.d(22): Error: found `smallest`\
    \ when expecting `(`\\n/tmp/tmps1se1kgv.d(22): Error: expression expected, not\
    \ `<`\\n/tmp/tmps1se1kgv.d(22): Error: found `x` when expecting `)`\\n/tmp/tmps1se1kgv.d(22):\
    \ Error: found `&&` instead of statement\\n/tmp/tmps1se1kgv.d(25): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps1se1kgv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvtkgd4ym.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvtkgd4ym.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Null\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa_f_4574.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpa_f_4574.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpa_f_4574.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmpa_f_4574.d(19): Error: found `Nullable`\
    \ when expecting `)`\\n/tmp/tmpa_f_4574.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpa_f_4574.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpa_f_4574.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpa_f_4574.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpa_f_4574.d(19):\
    \ Error: found `,` when expecting `.` following long\\n/tmp/tmpa_f_4574.d(19):\
    \ Error: found `!` when expecting `)`\\n/tmp/tmpa_f_4574.d(19): Error: found `,`\
    \ when expecting `.` following long\\n/tmp/tmpa_f_4574.d(19): Error: found `!`\
    \ when expecting `,`\\n/tmp/tmpa_f_4574.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpa_f_4574.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpa_f_4574.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpa_f_4574.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpa_f_4574.d(19):\
    \ Error: found `,` when expecting `.` following long\\n/tmp/tmpa_f_4574.d(19):\
    \ Error: found `!` when expecting `)`\\n/tmp/tmpa_f_4574.d(19): Error: found `,`\
    \ when expecting `.` following long\\n/tmp/tmpa_f_4574.d(19): Error: found `!`\
    \ when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa_f_4574.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst, \n    {\n        if (i.isNegative)\n        {\n        \
    \    if (largest == Nullable!(long))\n                largest = i;\n         \
    \   else\n                smallest = i;\n        }\n        else\n        {\n\
    \            if (smallest == Nullable!(long))\n                smallest = i;\n\
    \            else\n                largest = i;\n        }\n    });\n    return\
    \ Tuple!(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqb0iiz9u.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpqb0iiz9u.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpqb0iiz9u.d(36): Error: use `{\
    \ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpqb0iiz9u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvi6fq_0d.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvi6fq_0d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            result.a = x;\n \
    \           result.b = Nullable!(long);\n        }\n        else\n        {\n\
    \            result.b = x;\n            result.a = Nullable!(long);\n        }\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ulw0jn7.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp4ulw0jn7.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp4ulw0jn7.d(34): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ulw0jn7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd > 0 then Some(hd, -hd) else None;\n    \
    \    let (max_int, min_int) = if min_int > 0 then Some(max_int, min_int) else\
    \ None;\n        largest_smallest_integers(tl);\n        (max_int, min_int)\n\
    \    end;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3dd4hm56.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp3dd4hm56.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp3dd4hm56.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp3dd4hm56.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp3dd4hm56.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp3dd4hm56.d(22): Error: expression expected,\
    \ not `if`\\n/tmp/tmp3dd4hm56.d(22): Error: found `min_int` when expecting `;`\
    \ following statement\\n/tmp/tmp3dd4hm56.d(22): Error: found `>` instead of statement\\\
    n/tmp/tmp3dd4hm56.d(25): Error: found `end` when expecting `;` following statement\\\
    n/tmp/tmp3dd4hm56.d(25): Deprecation: use `{ }` for an empty statement, not `;`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3dd4hm56.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0) \n               {\n      \
    \             result.a = i;\n                   result.b = null;\n           \
    \    }\n               else \n               {\n                   result.a =\
    \ null;\n                   result.b = i;\n               }\n           });\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpms0is2qt.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpms0is2qt.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpms0is2qt.d(32): Error: use `{\
    \ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpms0is2qt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then hd else hd \n                 \
    \              (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else hd) \n   \
    \                            (if hd < 0 then hd else hd) \n                  \
    \             (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else hd) \n   \
    \                            (if hd < 0 then hd else hd) \n                  \
    \             (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else hd) \n   \
    \                            (if hd < 0 then hd else hd) \n                  \
    \             (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else hd) \n   \
    \                            (if hd < 0 then hd else hd) \n                  \
    \             (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else hd) \n   \
    \                            (if hd < 0 then hd else hd) \n                  \
    \             (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else hd) \n   \
    \                            (if hd < 0 then hd else hd) \n                  \
    \             (if hd < 0 then hd else hd) \n                               (if\
    \ hd < 0 then hd else hd) \n                               (if hd < 0 then hd\
    \ else hd) \n                               (if hd < 0 then hd else \nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcoiw6epa.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpcoiw6epa.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpcoiw6epa.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpcoiw6epa.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpcoiw6epa.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcoiw6epa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | x::xs => (if x\
    \ < 0 then x else None, if x > 0 then x else None)\n    end;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk1pm8g3x.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpk1pm8g3x.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpk1pm8g3x.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpk1pm8g3x.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpk1pm8g3x.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpk1pm8g3x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkzj0ys9o.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpkzj0ys9o.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpkzj0ys9o.d(28): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkzj0ys9o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0L then Some((hd, 0L)) else Some((0L, hd))\n                 |> List.maxBy(fun\
    \ (a, b) -> b)\n                 |> Some\n    | _ => (None, None)\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5hz_fkoy.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp5hz_fkoy.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp5hz_fkoy.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp5hz_fkoy.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp5hz_fkoy.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmp5hz_fkoy.d(25): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5hz_fkoy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (small, large) = largest_smallest_integers(tl)\n        match small\
    \ with\n        | None => (hd, large)\n        | Some small' => (small', large)\n\
    \    end\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpisnout5e.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpisnout5e.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpisnout5e.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpisnout5e.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpisnout5e.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpisnout5e.d(24): Error: unterminated\
    \ character constant\\n/tmp/tmpisnout5e.d(24): Error: unterminated character constant\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpisnout5e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = null;\n        result.second\
    \ = null;\n    }\n    else\n    {\n        auto largest = std.math::max_element(lst);\n\
    \        auto smallest = std.math::min_element(lst);\n        result.first = largest;\n\
    \        result.second = smallest;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9wtjr59a.d(27): Error: semicolon expected following auto declaration,\
    \ not `:`\\n/tmp/tmp9wtjr59a.d(27): Error: found `:` instead of statement\\n/tmp/tmp9wtjr59a.d(28):\
    \ Error: semicolon expected following auto declaration, not `:`\\n/tmp/tmp9wtjr59a.d(28):\
    \ Error: found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp9wtjr59a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> None\n    | h::t -> if h < 0 then\
    \ None else if h > 0 then Some(h, t) else largest_smallest_integers(t)\nend\n\
    \    \n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n\
    \        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplnr7g9nq.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmplnr7g9nq.d(19): Error: found `|` when expecting `(`\\n/tmp/tmplnr7g9nq.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmplnr7g9nq.d(19): Error: found `None`\
    \ when expecting `)`\\n/tmp/tmplnr7g9nq.d(20): Error: found `|` instead of statement\\\
    n/tmp/tmplnr7g9nq.d(23): Error: unterminated /* */ comment\\n/tmp/tmplnr7g9nq.d(95):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplnr7g9nq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t : Tuple!(Nullable!(long),\
    \ Nullable!(long))) \n    {\n        if (t.0 == null || t.1 == null) \n      \
    \  {\n            result.0 = t.0;\n            result.1 = t.1;\n        }\n  \
    \      else if (t.0 < 0 && t.1 < 0) \n        {\n            result.0 = t.0;\n\
    \            result.1 = t.1;\n        }\n        else if (t.0 < 0 && t.1 > 0)\
    \ \n        {\n            result.0 = t.0;\n            result.1 = t.1;\n    \
    \    }\n        else if (t.0 > 0 && t.1 < 0) \n        {\n            result.0\
    \ = t.0;\n            result.1 = t.1;\n        }\n        else if (t.0 > 0 &&\
    \ t.1 > 0) \n        {\n            result.0 = t.0;\n            result.1 = t.1;\n\
    \        }\n        else \n        {\n            result.0 = null;\n         \
    \   result.1 = null;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg3q9s4sy.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpg3q9s4sy.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpg3q9s4sy.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmpg3q9s4sy.d(21): Error: found `:` instead of statement\\\
    n/tmp/tmpg3q9s4sy.d(26): Error: found `0.1` when expecting `;` following statement\\\
    n/tmp/tmpg3q9s4sy.d(26): Error: found `=` instead of statement\\n/tmp/tmpg3q9s4sy.d(28):\
    \ Error: declaration expected, not `else`\\n/tmp/tmpg3q9s4sy.d(31): Error: no\
    \ identifier for declarator `result`\\n/tmp/tmpg3q9s4sy.d(31): Error: declaration\
    \ expected, not `0.1`\\n/tmp/tmpg3q9s4sy.d(32): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg3q9s4sy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => \n \
    \       let (max_int, min_int) = if hd < 0 then \n            (Nullable!(long),\
    \ Nullable!(long))\n            else \n            (Nullable!(long), Nullable!(long))\n\
    \        in \n            match max_int with\n            | None => \n       \
    \         let (max_int, min_int) = if min_int < 0 then \n                    (Nullable!(long),\
    \ Nullable!(long))\n                    else \n                    (Nullable!(long),\
    \ Nullable!(long))\n                in \n                    match min_int with\n\
    \                    | None => \n                        let (max_int, min_int)\
    \ = if hd < 0 then \n                            (Nullable!(long), Nullable!(long))\n\
    \                            else \n                            (Nullable!(long),\
    \ Nullable!(long))\n                        in \n                            match\
    \ max_int with\n                            | None => \n                     \
    \           let (max_int, min_int) = if min_int < 0 then \n                  \
    \                  (Nullable!(long), Nullable!(long))\n                      \
    \              else \n                                    (Nullable!(long), Nullable!(long))\n\
    \                                in \n                                    match\
    \ min_int with\n                                    | None => \n             \
    \                           let (max_int, min_int) = if hd < 0 then \n       \
    \                                     (Nullable!(long), Nullable!(long))\n   \
    \                                         else \n                            \
    \                (Nullable!(long), Nullable!(long))\n                        \
    \                in \n                                            match max_int\
    \ with\n                                            | None => \n             \
    \                                   let (max_int, min_int) = if min_int < 0 then\
    \ \n                                                    (Nullable!(long), Nullable!(long))\n\
    \                                                    else \n                 \
    \                                   (Nullable!(long), Nullable!(long))\n     \
    \                                           in \n                            \
    \                        match min_int with\n                                \
    \                    | None => \n                                            \
    \            let (max_int, min_int) = if hd < 0 then \n                      \
    \                                      (Nullable!(long), Nullable!(long))\n  \
    \                                                          else \n           \
    \                                                 (Nullable!(long), Nullable!(long))\n\
    \                                                        in \n               \
    \                                             match max_int with\n           \
    \                                                 | None => \n               \
    \                                                 let (max_int, min_int) = if\
    \ min_int < 0 then \n                                                        \
    \            (Nullable!(long), Nullable!(long))\n                            \
    \                                        else \n                             \
    \                                       (Nullable!(long), Nullable!(long))\n \
    \                                                               in \n        \
    \                                                            match min_int with\n\
    \                                                                    | None =>\
    \ \n                                                                        let\
    \ (max_int, min_int) = if hd < 0 then \n                                     \
    \                                       (Nullable!(long), Nullable!(long))\n\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9pkz29g8.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmp9pkz29g8.d(19): Error: found `|` when expecting `(`\\n/tmp/tmp9pkz29g8.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmp9pkz29g8.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmp9pkz29g8.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9pkz29g8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0) Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) \n                else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,i)\n            )\n    )\n    \n    result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n        Tuple!(Nullable!(long), Nullable!(long)) (\n   \
    \         if((result.f0.f0 != None) && (result.f0.f0 > result.f1.f0)) result.f0\
    \ \n            else result.f1\n        ),\n        Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n            if((result.f0.f0 != None) && (result.f0.f0 < result.f1.f0)) result.f1\
    \ \n            else result.f0\n        )\n    );\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6l2okme5.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp6l2okme5.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp6l2okme5.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmp6l2okme5.d(21): Error: found `=` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6l2okme5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if(x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if(result.a == null) {\n\
    \        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoznv1uw8.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmpoznv1uw8.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpoznv1uw8.d(28): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmpoznv1uw8.d(28): Error: found `==` when expecting\
    \ `)`\\n/tmp/tmpoznv1uw8.d(28): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpoznv1uw8.d(28): Error: found `null` when expecting `;` following statement\\\
    n/tmp/tmpoznv1uw8.d(28): Error: found `)` instead of statement\\n/tmp/tmpoznv1uw8.d(32):\
    \ Error: declaration expected, not `return`\\n/tmp/tmpoznv1uw8.d(33): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoznv1uw8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd\
    \ < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None, None)\n           \
    \        else if hd > 0 then Tuple!(Nullable!(long), Nullable!(long)) (hd, None)\n\
    \                   else Tuple!(Nullable!(long), Nullable!(long)) (None, None)\n\
    \    end;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptwj42sln.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmptwj42sln.d(19): Error: found `|` when expecting `(`\\n/tmp/tmptwj42sln.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmptwj42sln.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmptwj42sln.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptwj42sln.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = null;\n        result.second\
    \ = null;\n    }\n    else\n    {\n        long a = lst.min();\n        long b\
    \ = lst.max();\n        if ((a < 0) && (b > 0))\n        {\n            result.first\
    \ = null;\n            result.second = null;\n        }\n        else if ((a >\
    \ 0) && (b < 0))\n        {\n            result.first = a;\n            result.second\
    \ = b;\n        }\n        else\n        {\n            result.first = a;\n  \
    \          result.second = b;\n        }\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp377ybkmn.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmp377ybkmn.d(22): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp377ybkmn.d(23): Error: no property `second` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp377ybkmn.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmp377ybkmn.d(28): Error: no property `max` for\
    \ type `long[]`\\n/tmp/tmp377ybkmn.d(31): Error: no property `first` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp377ybkmn.d(32): Error: no property\
    \ `second` for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp377ybkmn.d(36):\
    \ Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmp377ybkmn.d(37): Error: no property `second` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmp377ybkmn.d(41): Error: no property `first` for type\
    \ `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmp377ybkmn.d(42): Error: no property\
    \ `second` for type `Tuple!(Nullable!long, Nullable!long)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp377ybkmn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(i : lst, \n           if(i < 0) result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n           else result = Tuple!(Nullable!(long), Nullable!(long)));\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0y0mami1.d(21): Error: no identifier for declarator `i`\\n/tmp/tmp0y0mami1.d(21):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp0y0mami1.d(22): Error: expression\
    \ expected, not `if`\\n/tmp/tmp0y0mami1.d(22): Error: found `result` when expecting\
    \ `)`\\n/tmp/tmp0y0mami1.d(22): Error: found `=` instead of statement\\n/tmp/tmp0y0mami1.d(23):\
    \ Error: found `else` without a corresponding `if`, `version` or `debug` statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0y0mami1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach (i, el) in lst {\n        if el < 0 {\n            largest = el;\n\
    \        } else {\n            smallest = el;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf9910fe9.d(20): Error: no identifier for declarator `el`\\n/tmp/tmpf9910fe9.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpf9910fe9.d(20): Error: expression\
    \ expected, not `in`\\n/tmp/tmpf9910fe9.d(20): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpf9910fe9.d(21): Error: found `el` when expecting `(`\\n/tmp/tmpf9910fe9.d(21):\
    \ Error: expression expected, not `<`\\n/tmp/tmpf9910fe9.d(21): Error: found `0`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9910fe9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max,min) = hd.max() in \n        let (max,min) = min.max() in \n \
    \       (max, min)\nend\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxb2okzw5.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpxb2okzw5.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpxb2okzw5.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpxb2okzw5.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpxb2okzw5.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpxb2okzw5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n\
    \        } else {\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcyzfquhp.d(21): Error: no identifier for declarator `lst`\\n/tmp/tmpcyzfquhp.d(21):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpcyzfquhp.d(29): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyzfquhp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if (i < 0) \n           {\n               result.a = i;\n\
    \               result.b = Nullable!(long);\n           }\n           else\n \
    \          {\n               result.a = Nullable!(long);\n               result.b\
    \ = i;\n           }\n    );\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43tj4qb0.d(20): Error: no identifier for declarator `i`\\n/tmp/tmp43tj4qb0.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp43tj4qb0.d(21): Error: expression\
    \ expected, not `if`\\n/tmp/tmp43tj4qb0.d(22): Error: found `{` when expecting\
    \ `)`\\n/tmp/tmp43tj4qb0.d(26): Error: declaration expected, not `else`\\n/tmp/tmp43tj4qb0.d(29):\
    \ Error: no identifier for declarator `result.b`\\n/tmp/tmp43tj4qb0.d(29): Error:\
    \ declaration expected, not `=`\\n/tmp/tmp43tj4qb0.d(30): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43tj4qb0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) tuple = \n       \
    \     Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0) Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) \n                else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n                    if(i>0) Tuple!(Nullable!(long), Nullable!(long))\
    \ (None,None) \n                    else Tuple!(Nullable!(long), Nullable!(long))\
    \ (i, None) \n                )\n            )\n    )\n    \n    result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n        Tuple!(Nullable!(long), Nullable!(long)) (\n   \
    \         ifelse(result.f0.f0 > result.f0.f1, result.f0, result.f1),\n       \
    \     ifelse(result.f0.f0 > result.f0.f1, result.f1, result.f0)\n        )\n \
    \   );\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxuoel5uc.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpxuoel5uc.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpxuoel5uc.d(21): Error: found `tuple`\
    \ when expecting `)`\\n/tmp/tmpxuoel5uc.d(21): Error: found `=` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxuoel5uc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if(x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if(!result.a && !result.b)\
    \ {\n        return result;\n    } else {\n        return Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6an6n0jk.d(20): Error: no identifier for declarator `lst`\\n/tmp/tmp6an6n0jk.d(20):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp6an6n0jk.d(28): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmp6an6n0jk.d(28): Error: basic type expected, not\
    \ `!`\\n/tmp/tmp6an6n0jk.d(28): Error: found `!` when expecting `)`\\n/tmp/tmp6an6n0jk.d(28):\
    \ Error: missing `{ ... }` for function literal\\n/tmp/tmp6an6n0jk.d(28): Error:\
    \ found `result` when expecting `;` following statement\\n/tmp/tmp6an6n0jk.d(28):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmp6an6n0jk.d(30):\
    \ Error: found `else` without a corresponding `if`, `version` or `debug` statement\\\
    n/tmp/tmp6an6n0jk.d(33): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp6an6n0jk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | x::xs => (\n \
    \       if x < 0 then (None, x)\n        else (Some(x), xs)\n    )\nend\n</cell>\n\
    <code language=julia-1.5>\n@assert largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, None)\n@assert largest_smallest_integers([]) == (None, None)\n@assert\
    \ largest_smallest_integers([0]) == (None, None)\n</cell>\n<text>\nExercise\n\
    Write a function that returns the largest and smallest numbers in a list.\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvanekoin.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpvanekoin.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpvanekoin.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpvanekoin.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpvanekoin.d(20): Error:\
    \ found `:` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpvanekoin.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpubynwd9o.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpubynwd9o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = None;\n        result.second\
    \ = None;\n    }\n    else\n    {\n        long largest = std.math.to.max(lst);\n\
    \        long smallest = std.math.to.min(lst);\n        result.first = None;\n\
    \        result.second = None;\n        if (largest < smallest)\n        {\n \
    \           result.first = largest;\n            result.second = smallest;\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpailde7ux.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmpailde7ux.d(22): Error: no property `first` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmpailde7ux.d(22): Error: undefined identifier `None`,\
    \ did you mean struct `No`?\\n/tmp/tmpailde7ux.d(23): Error: no property `second`\
    \ for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpailde7ux.d(23): Error:\
    \ undefined identifier `None`, did you mean struct `No`?\\n/tmp/tmpailde7ux.d(27):\
    \ Error: undefined identifier `to` in module `std.math`\\n/tmp/tmpailde7ux.d(28):\
    \ Error: undefined identifier `to` in module `std.math`\\n/tmp/tmpailde7ux.d(29):\
    \ Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\\\
    n/tmp/tmpailde7ux.d(29): Error: undefined identifier `None`, did you mean struct\
    \ `No`?\\n/tmp/tmpailde7ux.d(30): Error: no property `second` for type `Tuple!(Nullable!long,\
    \ Nullable!long)`\\n/tmp/tmpailde7ux.d(30): Error: undefined identifier `None`,\
    \ did you mean struct `No`?\\n/tmp/tmpailde7ux.d(33): Error: no property `first`\
    \ for type `Tuple!(Nullable!long, Nullable!long)`\\n/tmp/tmpailde7ux.d(34): Error:\
    \ no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpailde7ux.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n  \
    \      let (max_int, min_int) = if hd < 0 then \n            (Nullable!(hd), Nullable!(hd))\n\
    \        else \n            (Nullable!(hd), Nullable!(tl))\n        \n       \
    \ (max_int, min_int)\nend\n    \n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwcdtgfhs.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpwcdtgfhs.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpwcdtgfhs.d(19):\
    \ Error: found `=>` when expecting `)`\\n/tmp/tmpwcdtgfhs.d(20): Error: found\
    \ `:` when expecting `;` following statement\\n/tmp/tmpwcdtgfhs.d(20): Error:\
    \ found `:` instead of statement\\n/tmp/tmpwcdtgfhs.d(29): Error: unterminated\
    \ /* */ comment\\n/tmp/tmpwcdtgfhs.d(101): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpwcdtgfhs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmc1mrrg_.d(274): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmc1mrrg_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integers(i))\n\
    \    {\n        if(!t.v1)\n        {\n            result.v1 = null;\n        \
    \    result.v2 = t.v2;\n        }\n        else if(t.v1 > result.v1)\n       \
    \ {\n            result.v1 = t.v1;\n            result.v2 = t.v2;\n        }\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqbz9q_a_.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpqbz9q_a_.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpqbz9q_a_.d(21): Error: found `t`\
    \ when expecting `)`\\n/tmp/tmpqbz9q_a_.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpqbz9q_a_.d(28): Error: declaration expected, not `else`\\n/tmp/tmpqbz9q_a_.d(31):\
    \ Error: no identifier for declarator `result.v2`\\n/tmp/tmpqbz9q_a_.d(31): Error:\
    \ declaration expected, not `=`\\n/tmp/tmpqbz9q_a_.d(32): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqbz9q_a_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Null\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzw1kg6an.d(18): Error: found `lst` when expecting `;` following\
    \ statement\\n/tmp/tmpzw1kg6an.d(19): Error: found `|` when expecting `(`\\n/tmp/tmpzw1kg6an.d(19):\
    \ Error: expression expected, not `>`\\n/tmp/tmpzw1kg6an.d(19): Error: found `Nullable`\
    \ when expecting `)`\\n/tmp/tmpzw1kg6an.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpzw1kg6an.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpzw1kg6an.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpzw1kg6an.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpzw1kg6an.d(19):\
    \ Error: found `,` when expecting `.` following long\\n/tmp/tmpzw1kg6an.d(19):\
    \ Error: found `!` when expecting `)`\\n/tmp/tmpzw1kg6an.d(19): Error: found `,`\
    \ when expecting `.` following long\\n/tmp/tmpzw1kg6an.d(19): Error: found `!`\
    \ when expecting `,`\\n/tmp/tmpzw1kg6an.d(19): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmpzw1kg6an.d(19): Error: found `!` when expecting\
    \ `)`\\n/tmp/tmpzw1kg6an.d(19): Error: found `,` when expecting `.` following\
    \ long\\n/tmp/tmpzw1kg6an.d(19): Error: found `!` when expecting `,`\\n/tmp/tmpzw1kg6an.d(19):\
    \ Error: found `,` when expecting `.` following long\\n/tmp/tmpzw1kg6an.d(19):\
    \ Error: found `!` when expecting `)`\\n/tmp/tmpzw1kg6an.d(19): Error: found `,`\
    \ when expecting `.` following long\\n/tmp/tmpzw1kg6an.d(19): Error: found `!`\
    \ when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzw1kg6an.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long a = lst.iter().max().unwrap();\n\
    \    long b = lst.iter().min().unwrap();\n    \n    if (a < 0)\n        return\
    \ result;\n    \n    if (b > 0)\n        return result;\n    \n    return Tuple!(Nullable!(long),\
    \ Nullable!(long));\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxb1y8mu1.d(20): Error: no property `is_empty` for type `long[]`\\\
    n/tmp/tmpxb1y8mu1.d(23): Error: no property `iter` for type `long[]`\\n/tmp/tmpxb1y8mu1.d(24):\
    \ Error: no property `iter` for type `long[]`\\n/tmp/tmpxb1y8mu1.d(32): Error:\
    \ cannot implicitly convert expression `tuple(__expand_field_0, __expand_field_1)`\
    \ of type `(Nullable!long, Nullable!long)` to `Tuple!(Nullable!long, Nullable!long)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxb1y8mu1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([])\
    \ == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    \n\
    */\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) tuple = \n       \
    \     Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0) None\
    \ else Some(i), \n                if(i>0) None else Some(i)));\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) tuple = \n       \
    \     Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0) None\
    \ else Some(i), \n                if(i>0) None else Some(i)));\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpknu6u87s.d(20): Error: no identifier for declarator `i`\\n/tmp/tmpknu6u87s.d(20):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpknu6u87s.d(21): Error: found `tuple`\
    \ when expecting `)`\\n/tmp/tmpknu6u87s.d(21): Error: found `=` instead of statement\\\
    n/tmp/tmpknu6u87s.d(26): Error: no identifier for declarator `i`\\n/tmp/tmpknu6u87s.d(26):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpknu6u87s.d(27): Error: found `tuple`\
    \ when expecting `)`\\n/tmp/tmpknu6u87s.d(27): Error: found `=` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknu6u87s.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
