name: HumanEval_57_monotonic
language: humaneval_to_dlang.py
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n\
  \    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1,\
  \ 0, -10])\n    True\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i\
    \ < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n \
    \       if(l[i] > max)\n            max = l[i];\n    }\n    return min < max;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. He wants\
    \ to know if all elements are monotonically increasing or decreasing.\n<|/ c |>\n\
    <| c |>\nThe question was \"Return True is list elements are monotonically increasing\
    \ or decreasing.\" The answer is \"Return True is list elements are monotonically\
    \ increasing or decreasing.\" The code I posted is exactly what he needs.\n<|/\
    \ c |>\n<| c |>\nI see your point, but I still think your answer doesn't answer\
    \ the question. He wants to know if all elements are monotonically increasing\
    \ or decreasing, and your answer only checks if all elements are monotonically\
    \ increasing or decreasing.\n<|/ c |>\n<| c |>\nThe question was \"Return True\
    \ is list elements are monotonically increasing or decreasing.\" The answer is\
    \ \"Return True is list elements are monotonically increasing or decreasing.\"\
    \ The code I posted is exactly what he needs.\n<|/ c |>\n<| c |>\nThe question\
    \ was \"Return True is list elements are monotonically increasing or decreasing.\"\
    \ The answer is \"Return True is list elements are monotonically increasing or\
    \ decreasing.\" The code I posted is exactly what he needs.\n<|/ c |>\n<| a tags=c#,list,algorithm,sorting\
    \ |>\n<code>\npublic static bool IsMonotonic(List<int> list)\n{\n    int min =\
    \ list.Min();\n    int max = list.Max();\n    for (int i = 0; i < list.Count;\
    \ i++)\n    {\n        if (list[i] < min)\n        {\n            min = list[i];\n\
    \        }\n        if (list[i] > max)\n        {\n            max = list[i];\n\
    \        }\n    }\n    return min < max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>\npublic static bool IsMonotonic(List<int> list)\n{\n   \
    \ int min = list.Min();\n    int max = list.Max();\n    for (int i = 0; i < list.Count;\
    \ i++)\n    {\n        if (list[i] < min)\n        {\n            min = list[i];\n\
    \        }\n        if (list[i] ", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\t\
    if (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    int n =\
    \ l.length;\n    if (n < 2) return true;\n    \n    int i = 0;\n    int j = 1;\n\
    \    \n    while (i < n && j > 0) {\n        if (l[i] < l[j]) {\n            i++;\n\
    \        } else if (l[i] > l[j]) {\n            j--;\n        } else {\n     \
    \       i++;\n            j++;\n        }\n    }\n    \n    return i == n;\n}",
  "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i\
    \ = 1; i < l.length; i++) \n\t{\n\t\tif (l[i] > max) \n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t\telse if (l[i] < min) \n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse \n\
    \t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n        {\n            min = l[i];\n        }\n     \
    \   if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n   \
    \ return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t\t\
    if (l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    int\
    \ i = 0;\n    int j = 1;\n    bool result = true;\n    while (j < l.length &&\
    \ l[j] < l[i]) {\n        i++;\n        j++;\n    }\n    if (i == l.length) {\n\
    \        result = false;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c#,arrays |>\n<code>\npublic static bool IsMonotonic(this int[]\
    \ array)\n{\n    if (array == null)\n        throw new ArgumentNullException(nameof(array));",
  "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n  \
    \      }\n        if(l[i] > max)\n        {\n            max = l[i];\n       \
    \ }\n    }\n    return min < max;\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min < max;\n}", "{\n    long max = l[0];\n    long min = l[0];\n  \
    \  for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n\
    \            min = l[i];\n        }\n        if(l[i] > max)\n        {\n     \
    \       max = l[i];\n        }\n    }\n    return max < min;\n}", "{\n    int\
    \ i = 0;\n    int j = l.length - 1;\n    bool isIncreasing = true;\n    bool isDecreasing\
    \ = true;\n    while (i < j) {\n        if (l[i] > l[j]) {\n            isIncreasing\
    \ = false;\n        }\n        if (l[i] < l[j]) {\n            isDecreasing =\
    \ false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    return isIncreasing\
    \ || isDecreasing;\n}\n</code>\n<|/ a tags=c++,sorting,arrays |>\n<| a tags=c++,sorting,arrays\
    \ |>\n<code>\n#include <iostream>\n#include <algorithm>\nusing namespace std;",
  "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis doesn't work for negative numbers. Try `monotonic([-1,\
    \ -10, -20, -30])`\n<|/ c |>\n<| c |>\nYes, it does. Try it yourself. It returns\
    \ `True`.\n<|/ c |>\n<| c |>\nIt returns `True` because `-1` is less than `-10`.\
    \ Try `monotonic([-1, -10, -20, -30])`\n<|/ c |>\n<| c |>\nYes, it does. Try it\
    \ yourself. It returns `True`.\n<|/ c |>\n<| c |>\nIt returns `True` because `-1`\
    \ is less than `-10`. Try `monotonic([-1, -10, -20, -30])`\n<|/ c |>\n<| a dscore=3\
    \ |>\nI wrote a little function which returns true if the array is monotonically\
    \ increasing or decreasing. It also returns true if the array is monotonically\
    \ increasing or decreasing but reversed. \n<code>", "{\n    long min = 0;\n  \
    \  long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is\
    \ not an answer to the question. An answer should contain an explanation as to\
    \ why this works.\n<|/ c |>\n<| c |>\nThe question was \"how to check if a list\
    \ is monotonic\", not \"how to check if a list is sorted\"\n<|/ c |>\n<| c |>\n\
    The question was \"how to check if a list is monotonic\", not \"how to check if\
    \ a list is sorted\"\n<|/ c |>\n<| c |>\nThe question was \"how to check if a\
    \ list is monotonic\", not \"how to check if a list is sorted\"\n<|/ c |>\n<|\
    \ c |>\nThe question was \"how to check if a list is monotonic\", not \"how to\
    \ check if a list is sorted\"\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    int\
    \ n = l.length;\n    if (n < 2) return true;\n    int i = 0;\n    int j = n -\
    \ 1;\n    while (i < j) {\n        int m = std.math.min(i, j);\n        if (l[m]\
    \ < l[m+1]) return false;\n        if (l[m] > l[m-1]) i = m+1;\n        else j\
    \ = m-1;\n    }\n    return true;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor\
    \ (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i]\
    \ > max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max = l[0];\n\
    \tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] <\
    \ min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax\
    \ = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length;\
    \ ++i)\n    {\n        if (l[i] < min)\n        {\n            isMonotonic = false;\n\
    \            break;\n        }\n        if (l[i] > max)\n        {\n         \
    \   isMonotonic = false;\n            break;\n        }\n    }\n    return isMonotonic;\n\
    }", "{\n    int n = l.length;\n    if (n < 2) return true;\n    long m = l[0],\
    \ l2 = l[1], l3 = l[2], l4 = l[3];\n    if (l2 < m) swap(l2, m);\n    if (l4 <\
    \ m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n\
    \    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2,\
    \ m);\n    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n    if (l2\
    \ < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n\
    \    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3,\
    \ m);\n    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n    if (l3\
    \ < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n\
    \    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4,\
    \ m);\n    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n    if (l4\
    \ < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n\
    \    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2,\
    \ m);\n    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n    if (l2\
    \ < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3, m);\n\
    \    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n    if (l3 < m) swap(l3,\
    \ m);\n    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n    if (l3\
    \ < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n    if (l4 < m) swap(l4, m);\n\
    \    if (l3 < m) swap(l3, m);\n    if (l2 < m) swap(l2, m);\n    if (l4 < m) ",
  "{\n    long l = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < l)\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }", "{\n    int i;\n    long max = l[0];\n    bool increasing = true;\n    for(i=1;\
    \ i<l.length; ++i)\n    {\n        if(l[i] > max)\n        {\n            increasing\
    \ = false;\n            max = l[i];\n        }\n    }\n    return increasing;\n\
    }", "{\n    int n = l.length;\n    if (n < 2) return true;\n    long m = l[0],\
    \ l2 = l[1];\n    for (int i = 2; i < n; i++) {\n        long l3 = l[i];\n   \
    \     if (l2 > l3) return true;\n        if (l2 < l3) return false;\n        l2\
    \ = l3;\n    }\n    return false;\n}\n/*\nReturn True if list elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>>\
    \ monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n  \
    \  True\n    \n*/", "{\n    long max = l[0];\n    long min = l[0];\n    bool changed\
    \ = true;\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < min) {\n\
    \            changed = true;\n            min = l[i];\n        } else if (l[i]\
    \ > max) {\n            changed = true;\n            max = l[i];\n        }\n\
    \    }\n    return changed;\n}\n</code>\n<|/ a tags=c#,c++,algorithm,sorting |>\n\
    <| c |>\nThis code does not work. Try it with `monotonic([1,4,2,5])`\n<|/ c |>\n\
    <| c |>\n: It does work. Try it with `monotonic([1,4,2,5])`\n<|/ c |>\n<| c |>\n\
    : It does work. Try it with `monotonic([1,4,2,5])`\n<|/ c |>\n<| c |>\n: It does\
    \ work. Try it with `monotonic([1,4,2,5])`\n<|/ c |>\n<| c |>\n: It does work.\
    \ Try it with `monotonic([1,4,2,5])`\n<|/ c |>\n<| a tags=c#,c++,algorithm,sorting\
    \ |>\nI believe that this is what you are looking for:\n<code>", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n \
    \   {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min < max;\n}", "{\n    int i = 0;\n\
    \    int j = l.length - 1;\n    bool isIncreasing = true;\n    bool isDecreasing\
    \ = true;\n    while (i < j)\n    {\n        if (l[i] > l[j])\n        {\n   \
    \         isIncreasing = false;\n        }\n        else if (l[i] < l[j])\n  \
    \      {\n            isDecreasing = false;\n        }\n        else\n       \
    \ {\n            i++;\n            j--;\n        }\n    }\n    return isIncreasing\
    \ || isDecreasing;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<| c |>\nThis\
    \ doesn't work if there are duplicates in the array. For example, `monotonic([1,1,2,3,5,5,6,7])`\
    \ returns `true` instead of `false`.\n<|/ c |>\n<| c |>\n: Yes, it does. `monotonic([1,1,2,3,5,5,6,7])`\
    \ returns `false` because `1` is greater than `1`, `2` is greater than `3`, `5`\
    \ is greater than `5`, `6` is greater than `6`, and `7` is greater than `7`.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. Yes, it does work. `monotonic([1,1,2,3,5,5,6,7])`\
    \ returns `false` because `1` is greater than `1`, `2` is greater than `3`, `5`\
    \ is greater than `5`, `6` is greater than `6`, and `7` is greater than `7`.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. Yes, it does work. `monotonic([1,1,2,3,5,5,6,7])`\
    \ returns `false` because `1` is greater than `1`, `2` is greater than `3`, `5`\
    \ is greater than `5`, `6` is greater than `6`, and `7` is greater than `7`.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. Yes, it does work. `monotonic([1,1,2,3,5,5,6,7])`\
    \ returns `false` because `1` is greater than `1`, `2` is greater than `3`, `5`\
    \ is greater than `5`, `6` is greater than `6`, and `7` is greater than `7`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    int i = 0;\n    int j = 1;\n    bool\
    \ result = true;\n    while(i < l.length && j < l.length) \n    {\n        if(l[i]\
    \ < l[j])\n        {\n            result = false;\n            break;\n      \
    \  }\n        else if(l[i] > l[j])\n        {\n            result = true;\n  \
    \          break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min <= max;\n}\n/*\nReturn True is\
    \ list elements are monotonically increasing or decreasing.\n    >>> monotonic([4,\
    \ 1, 0, -10])\n    True\n    \n*/", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor\
    \ (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\
    \t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn min <= max;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int n = l.length;\n    bool\
    \ isIncreasing = true;\n    bool isDecreasing = true;\n    while(i < n) {\n  \
    \      if(l[i] < l[j]) {\n            isIncreasing = false;\n        }\n     \
    \   if(l[i] > l[j]) {\n            isDecreasing = false;\n        }\n        if(isIncreasing\
    \ && isDecreasing) {\n            return true;\n        }\n        if(isIncreasing\
    \ && !isDecreasing) {\n            return false;\n        }\n        if(!isIncreasing\
    \ && isDecreasing) {\n            return false;\n        }\n        i++;\n   \
    \     j++;\n        k++;\n    }\n    return false;\n}\n</code>\n<|/ a tags=c++,sorting,algorithm\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the list. For example,\
    \ monotonic([1,2,2,3,4,5]) returns true, but monotonic([1,2,2,3,4,5,5]) returns\
    \ false.\n<|/ c |>\n<| c |>\n: I believe that `monotonic([1,2,2,3,4,5])` returns\
    \ false because `monotonic([1,2,2,3,4,5,5])` returns true.\n<|/ c |>\n<| c |>\n\
    : Yes, you're right. I missed that case. Thanks for pointing it out.\n<|/ c |>\n\
    <| c |>\n: I updated my answer to take that case into account.\n<|/ c |>\n<| c\
    \ |>\n: I updated my answer to take that case into account.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe algorithm is called \"bubble sort\".\n<|/ a tags=c++,sorting,algorithm\
    \ |>\n<| c |>\nI believe bubble sort is O(n^2). Not O(n).\n<|/ c |>\n<| c |>\n\
    : It depends on the implementation. But the average case is O(n).\n<|/ c |>\n\
    <| c |>\n: Yes, but O(n^2) is still O(n).\n<|/ c |>\n<| c |>\n: Yes, but O(n^2)\
    \ is still O(n).\n<|/ c |>\n<| c |>\n: Yes, but O(n^2) is still O(n).\n<|/ c |>\n\
    <| a tags=c++,sorting,algorithm |>\n<code>", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] <\
    \ min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe question\
    \ was about a monotonic sequence. Your solution does not consider that.\n<|/ c\
    \ |>\n<| c |>\n: It does. `monotonic([1, 2, 4, 20])` returns `True`.\n<|/ c |>\n\
    <| c |>\n: It returns `True` because `monotonic([1, 2, 4, 20])` returns `True`\
    \ because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2,\
    \ 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because\
    \ `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])`\
    \ returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1,\
    \ 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True`\
    \ because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2,\
    \ 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because\
    \ `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])`\
    \ returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1,\
    \ 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True`\
    \ because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2,\
    \ 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because\
    \ `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])`\
    \ returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1,\
    \ 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True`\
    \ because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2,\
    \ 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because\
    \ `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1, 2, 4, 20])`\
    \ returns `True` because `monotonic([1, 2, 4, 20])` returns `True` because `monotonic([1,\
    \ 2, 4, 20])` ", "{\n    long min = l[0];\n    long max = l[0];\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    for (int i = 1; i < l.length; ++i)\
    \ {\n        if (l[i] < min) {\n            isIncreasing = false;\n        }\n\
    \        if (l[i] > max) {\n            isDecreasing = false;\n        }\n   \
    \     if (l[i] < min) {\n            isIncreasing = false;\n        }\n      \
    \  if (l[i] > max) {\n            isDecreasing = false;\n        }\n    }\n  \
    \  if (isIncreasing && isDecreasing) {\n        return true;\n    }\n    if (isIncreasing\
    \ && !isDecreasing) {\n        return true;\n    }\n    if (!isIncreasing && isDecreasing)\
    \ {\n        return true;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\npublic boolean isMonotonic(List<Integer> list)\
    \ {\n    int min = list.get(0);\n    int max = list.get(0);\n    for (int i =\
    \ 1; i < list.size(); i++) {\n        if (list.get(i) < min) {\n            min\
    \ = list.get(i);\n        }\n        if (list.get(i) > max) {\n            max\
    \ = list.get(i);\n        }\n    }\n    return min <= max;\n}\n</code>\n<|/ a\
    \ tags=java,arrays,sorting |>\n<| a dscore=0 |>\n<code>\npublic boolean isMonotonic(List<Integer>\
    \ list) {\n    int min = list.get(0);\n    int max = list.get(0);\n    for (int\
    \ i = 1; i < list.size(); i++) {\n        if (list.get(i) < min) {\n         \
    \   min = list.get(i);\n        }\n        if (list.get(i) > max) {\n        \
    \    max = list.get(i);\n        }\n    }\n    return min <= max;\n}\n</code>\n\
    <|/ a tags=java,arrays,sorting |>\n<| c |>\nPlease don't post only code as an\
    \ answer, but also provide an explanation of what your code does and how it solves\
    \ the problem of the question. Answers with an explanation are usually more helpful\
    \ and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<|\
    \ c |>\nThis code doesn't work if the list contains negative numbers. For example,\
    \ `isMonotonic([-10, -5, -4, -2, 1, 3, 5])` returns `true` instead of `false`.\n\
    <|/ c |>\n<| a tags=java,arrays,sorting |>\n<code>\npublic boolean isMonotonic(List<Integer>\
    \ list) {\n    int min = list.get(0);\n    int max = list.get(0);\n    for (int\
    \ i = 1; i < list.size(); i++) {\n        if (", "{\n    long max = l[0];\n  \
    \  long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > max)\n            max = l[i];\n        if(l[i] < min)\n            min = l[i];\n\
    \    }\n    return max >= min;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\
    \t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\
    \    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(j < l.length\
    \ && l[j] < l[i])\n    {\n        i++;\n        j++;\n    }\n    while(j < l.length\
    \ && l[j] > l[i])\n    {\n        j++;\n    }\n    if(j == l.length)\n    {\n\
    \        result = true;\n    }\n    else\n    {\n        result = false;\n   \
    \ }\n    return result;\n}", "{\n    int i = 0;\n    int j = 1;\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    while(i < l.length && j < l.length)\n\
    \    {\n        if(l[i] < l[j])\n        {\n            isIncreasing = false;\n\
    \        }\n        else if(l[i] > l[j])\n        {\n            isDecreasing\
    \ = false;\n        }\n        i++;\n        j++;\n    }\n    return isIncreasing\
    \ || isDecreasing;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n      \
    \      min = l[i];\n        }\n        else if(l[i] > max)\n        {\n      \
    \      max = l[i];\n        }\n    }\n    return min <= max;\n}", "{\n\tlong max\
    \ = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\t\
    if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t\
    {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n   \
    \     if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n\
    \    return min <= max;\n}", "{\n    int n = l.length;\n    if (n < 2) return\
    \ true;\n    int i = 0;\n    int j = 1;\n    while (j < n) {\n        if (l[j]\
    \ < l[j-1]) return false;\n        if (l[j] > l[j-1]) j++;\n        else i++;\n\
    \    }\n    return i == n;\n}", "{\n    int i = 0;\n    int j = 1;\n    bool result\
    \ = true;\n    while(i < l.length && j > 0) {\n        if(l[i] < l[j]) {\n   \
    \         result = false;\n            break;\n        }\n        if(l[i] > l[j])\
    \ {\n            result = true;\n            break;\n        }\n        i += 1;\n\
    \        j += 1;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c++,arrays,sorting\
    \ |>\n<| a tags=c++,arrays,sorting |>\n<code>", "{\n    long min = l[0];\n   \
    \ long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor\
    \ (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin =\
    \ l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\t\
    return min < max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    bool\
    \ isMonotonic = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n       \
    \ if (l[i] < min)\n        {\n            min = l[i];\n        }\n        else\
    \ if (l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n\
    \        {\n            isMonotonic = false;\n        }\n    }\n    return isMonotonic;\n\
    }", "{\n    int n = l.length;\n    if (n < 2) return true;\n    long m = l[0];\n\
    \    for (int i = 1; i < n; ++i) {\n        if (l[i] < m) return false;\n    \
    \    m = l[i];\n    }\n    return true;\n}", "{\n    long l = l[0];\n    long\
    \ r = l[0];\n    for(int i = 1; i < l.length; i++){\n        if(l[i] < r){\n \
    \           return false;\n        }\n        else if(l[i] > r){\n           \
    \ return true;\n        }\n        r = l[i];\n    }\n    return true;\n}", "{\n\
    \tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int\
    \ i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t\
    }\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\
    \tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n    int i =\
    \ 0;\n    int j = l.length - 1;\n    bool isIncreasing = true;\n    bool isDecreasing\
    \ = true;\n    while (i < j) {\n        if (l[i] > l[j]) {\n            isIncreasing\
    \ = false;\n        } else if (l[i] < l[j]) {\n            isDecreasing = false;\n\
    \        } else {\n            i++;\n            j--;\n        }\n    }\n    return\
    \ isIncreasing || isDecreasing;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11188853)\n\
    <|/ c |>\n<| c |>\nI believe it does. He asked how to check if a list contains\
    \ monotonically increasing or decreasing elements. He also provided a solution\
    \ that works. He also provided a link to an article that explains how it works.\
    \ He also provided a link to an article that explains how it works. He also provided\
    \ a link to an article that explains how it works. He also provided a link to\
    \ an article that explains how it works. He also provided a link to an article\
    \ that explains how it works. He also provided a link to an article that explains\
    \ how it works. He also provided a link to an article that explains how it works.\
    \ He also provided a link to an article that explains how it works. He also provided\
    \ a link to an article that explains how it works. He also provided a link to\
    \ an article that explains how it works. He also provided a link to an article\
    \ that explains how it works. He also provided a link to an article that explains\
    \ how it works. He also provided a link to an article that explains how it works.\
    \ He also provided a link to an article that explains how it works. He also provided\
    \ a link to an article that explains how it works. He also provided a link to\
    \ an article that explains how it works. He also provided a link to an article\
    \ that explains how it works. He also provided a link to an article that explains\
    \ how it works. He also provided a link to an article that explains how it works.\
    \ He also provided a link to an article that explains how ", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n        {\n            min = l[i];\n        }\n     \
    \   if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n   \
    \ return min <= max;\n}", "{\n    int i = 0;\n    int j = 1;\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    while(i < l.length && j < l.length)\
    \ {\n        if(l[i] < l[j]) {\n            isIncreasing = false;\n        }\n\
    \        if(l[i] > l[j]) {\n            isDecreasing = false;\n        }\n   \
    \     i++;\n        j++;\n    }\n    return isIncreasing || isDecreasing;\n}\n\
    </code>\n<|/ a tags=c++,arrays,algorithm |>\n<| c |>\nThis code doesn't work if\
    \ you have a list like `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| c |>\nThis code doesn't work if you have a list like `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| c |>\nThis code doesn't work if you have a list like `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| c |>\nThis code doesn't work if you have a list like `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| c |>\nThis code doesn't work if you have a list like `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\t\
    min = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn min <= max;\n}", "{\n    long i = 0;\n    long j = 1;\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    while(i < l.length && j < l.length)\
    \ {\n        if(l[i] < l[j]) {\n            isIncreasing = false;\n        }\n\
    \        if(l[i] > l[j]) {\n            isDecreasing = false;\n        }\n   \
    \     if(isIncreasing && isDecreasing) {\n            return true;\n        }\n\
    \        i++;\n        j++;\n    }\n    return false;\n}", "{\n    int n = l.length;\n\
    \    if (n < 2) return true;\n    long max = l[0], min = l[0];\n    for (int i\
    \ = 1; i < n; ++i) {\n        if (l[i] > max) return false;\n        if (l[i]\
    \ < min) min = l[i];\n    }\n    return true;\n}", "{\n\tlong max = l[0];\n\t\
    long min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t}\n\treturn (max < min);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin\
    \ = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\
    }\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n\
    \        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is not the correct answer. monotonic([4, 1, 0,\
    \ -10]) is true, but monotonic([4, 1, 0, -10]) is false. monotonic([4, 1, 0, -10])\
    \ is true because it is monotonically increasing or decreasing.\n<|/ c |>\n<|\
    \ c |>\n: I agree with you. My answer was based on OP's question. He didn't say\
    \ anything about monotonic increasing or decreasing. He said \"monotonically\"\
    \ increasing or decreasing. He didn't say anything about monotonic increasing\
    \ or decreasing or non-monotonic increasing or decreasing. He said \"monotonically\"\
    \ increasing or decreasing. He didn't say anything about monotonic increasing\
    \ or decreasing or non-monotonic increasing or decreasing. He said \"monotonically\"\
    \ increasing or decreasing. He didn't say anything about monotonic increasing\
    \ or decreasing or non-monotonic increasing or decreasing. He said \"monotonically\"\
    \ increasing or decreasing. He didn't say anything about monotonic increasing\
    \ or decreasing or non-monotonic increasing or decreasing. He said \"monotonically\"\
    \ increasing or decreasing. He didn't say anything about monotonic increasing\
    \ or decreasing or non-monotonic increasing or decreasing.\n<|/ c |>\n<| c |>\n\
    : I agree with you. My answer was based on OP's question. He didn't say anything\
    \ about monotonic increasing or decreasing. He said \"monotonically\" increasing\
    \ or decreasing. He didn't say anything about monotonic increasing or decreasing\
    \ or non-monotonic increasing or decreasing. He said \"monotonically\" increasing\
    \ or decreasing. He didn't say anything about monotonic increasing or decreasing\
    \ or non-monotonic increasing or decreasing. He said \"monotonically\" increasing\
    \ or decreasing. He didn't say anything about monotonic increasing or decreasing\
    \ or non-monotonic increasing or decreasing. He said \"", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n       \
    \ if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return\
    \ min <= max;\n}", "{\n    int n = l.length;\n    int i = 0;\n    int j = 1;\n\
    \    bool isIncreasing = true;\n    bool isDecreasing = true;\n    while(i < n)\
    \ {\n        if(l[i] < l[j]) {\n            isDecreasing = false;\n        } else\
    \ {\n            isIncreasing = false;\n        }\n        if(isIncreasing &&\
    \ isDecreasing) {\n            return true;\n        }\n        if(isIncreasing\
    \ && !isDecreasing) {\n            return false;\n        }\n        if(!isIncreasing\
    \ && isDecreasing) {\n            return false;\n        }\n        i++;\n   \
    \     j++;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,sorting\
    \ |>\n<code>\npublic static bool IsMonotonic(this IEnumerable<T> list)\n{\n  \
    \  if (list == null)\n    {\n        throw new ArgumentNullException(\"list\"\
    );\n    }", "{\n    int i = 0;\n    int j = 1;\n    int k = l.length - 1;\n  \
    \  bool isIncreasing = true;\n    bool isDecreasing = true;\n    while(i < k)\
    \ {\n        if(l[i] < l[j]) {\n            isIncreasing = false;\n        }\n\
    \        if(l[i] > l[j]) {\n            isDecreasing = false;\n        }\n   \
    \     if(isIncreasing && isDecreasing) {\n            return true;\n        }\n\
    \        if(isIncreasing && !isDecreasing) {\n            return false;\n    \
    \    }\n        if(!isIncreasing && isDecreasing) {\n            return false;\n\
    \        }\n        i++;\n        j++;\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=c#,sorting,algorithm,arrays |>\n<| c |>\nThis doesn't work for me.\
    \ `monotonic([4, 1, 0, -10])` returns `true` but `monotonic([4, 1, 0, 10])` returns\
    \ `false`.\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now\
    \ it works.\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic static bool IsMonotonic(this\
    \ int[] array)\n{\n    if (array == null || array.Length < 2)\n    {\n       \
    \ return false;\n    }", "{\n    int n = l.length;\n    if (n < 2) return true;\n\
    \    long first = l[0];\n    long last = l[n - 1];\n    for (int i = 1; i < n;\
    \ ++i) {\n        if (l[i] < first) return false;\n        if (l[i] > last) return\
    \ false;\n    }\n    return true;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tfor (int i = 1; i < l.length; ++i) {\n\t\tlong cur = l[i];\n\t\tif (cur < min)\
    \ min = cur;\n\t\tif (cur > max) max = cur;\n\t}\n\treturn (max >= min);\n}",
  "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long l = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i]\
    \ < l[i-1]) return true;\n        if(l[i] > l[i-1]) return false;\n    }\n   \
    \ return false;\n}\n/*\nReturn True if list elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([10, 20, 30, 40, 50])\n    True\n    >>> monotonic([10,\
    \ 20, 30, 40, 50])\n    True\n    >>> monotonic([10, 20, 30, 40, 50])\n    True\n\
    \    >>> monotonic([10, 20, 30, 40, 50])\n    True\n    >>> monotonic([10, 20,\
    \ 30, 40, 50])\n    True\n    \n*/", "{\n    int n = l.length;\n    for(int i\
    \ = 0; i < n; ++i)\n    {\n        if(l[i] < l[n - 1])\n            return false;\n\
    \    }\n    return true;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \  {\n            min = l[i];\n        }\n        else if(l[i] > max)\n      \
    \  {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}", "{\n\
    \    int n = l.length;\n    if (n < 2) return true;\n    int i = 0;\n    int j\
    \ = n - 1;\n    while (i < j) {\n        int m = i + j;\n        if (l[i] < l[m])\
    \ j = m;\n        else i = m + 1;\n    }\n    return l[i] > l[j];\n}", "{\n  \
    \  long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min <= max;\n}", "{\n    long max\
    \ = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n\
    \        if(l[i] > max) \n        {\n            max = l[i];\n        }\n    \
    \    if(l[i] < min) \n        {\n            min = l[i];\n        }\n    }\n \
    \   return max >= min;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<| a tags=c#,arrays,algorithm\
    \ |>\n<code>\npublic bool IsMonotonic(IList<int> list)\n{\n    if (list == null\
    \ || list.Count == 0)\n    {\n        return false;\n    }", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for (int i\
    \ = 1; i < l.length; ++i) {\n        if (l[i] < min) {\n            isMonotonic\
    \ = false;\n            break;\n        }\n        if (l[i] > max) {\n       \
    \     isMonotonic = false;\n            break;\n        }\n    }\n    return isMonotonic;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\
    \ {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong min\
    \ = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i\
    \ < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max\
    \ = l[i];\n\t\tif (min > max) isMonotonic = false;\n\t}\n\treturn isMonotonic;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool increasing = true;\n\t\
    for (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin\
    \ = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tincreasing = false;\n\t\t}\n\t}\n\treturn increasing;\n}",
  "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i]\
    \ < min)\n            min = l[i];\n    }\n    return max >= min;\n}", "{\n   \
    \ long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min <= max;\n}", "{\n    int i = 0;\n\
    \    int j = 1;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\
    \    while(i < l.length && j < l.length) {\n        if(l[i] < l[j]) {\n      \
    \      isIncreasing = false;\n        }\n        if(l[i] > l[j]) {\n         \
    \   isDecreasing = false;\n        }\n        if(isIncreasing && isDecreasing)\
    \ {\n            return true;\n        }\n        if(isIncreasing && !isDecreasing)\
    \ {\n            return false;\n        }\n        if(!isIncreasing && isDecreasing)\
    \ {\n            return false;\n        }\n        i++;\n        j++;\n    }\n\
    \    return false;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max\
    \ < min);\n}", "{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic\
    \ = true;\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < min) {\n\
    \            isMonotonic = false;\n            break;\n        }\n        if (l[i]\
    \ > max) {\n            isMonotonic = false;\n            break;\n        }\n\
    \    }\n    return isMonotonic;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11102932)\n\
    <|/ c |>\n<| c |>\nThis does provide an answer to the question. Monotonicity is\
    \ defined as the property that all elements in a list are strictly increasing\
    \ or strictly decreasing. It's a very simple definition, and it can be easily\
    \ implemented with simple loops.\n<|/ c |>\n<| c |>\nThis does not provide an\
    \ answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post. - [From Review](/review/low-quality-posts/11102932)\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/11102932)\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11102932)\n\
    <|/ c |>\n<| a dscore=4 |>\nThe algorithm is simple:", "{\n    long a = l[0];\n\
    \    long b = l[1];\n    long c = l[2];\n    long d = l[3];\n    long e = l[4];\n\
    \    long f = l[5];\n    long g = l[6];\n    long h = l[7];\n    long i = l[8];\n\
    \    long j = l[9];\n    long k = l[10];\n    long l = l[11];\n    long m = l[12];\n\
    \    long n = l[13];\n    long o = l[14];\n    long p = l[15];\n    long q = l[16];\n\
    \    long r = l[17];\n    long s = l[18];\n    long t = l[19];\n    long u = l[20];\n\
    \    long v = l[21];\n    long w = l[22];\n    long x = l[23];\n    long y = l[24];\n\
    \    long z = l[25];\n    long a = l[26];\n    long b = l[27];\n    long c = l[28];\n\
    \    long d = l[29];\n    long e = l[30];\n    long f = l[31];\n    long g = l[32];\n\
    \    long h = l[33];\n    long i = l[34];\n    long j = l[35];\n    long k = l[36];\n\
    \    long l = l[37];\n    long m = l[38];\n    long n = l[39];\n    long o = l[40];\n\
    \    long p = l[41];\n    long q = l[42];\n    long r = l[43];\n    long s = l[44];\n\
    \    long t = l[45];\n    long u = l[46];\n    long v = l[47];\n    long w = l[48];\n\
    \    long x = l[49];\n    long y = l[50];\n    long z = l[51];\n    long a = l[52];\n\
    \    long b = l[53];\n    long c = l[54];\n    long d = l[55];\n    long e = l[56];\n\
    \    long f = l[57];\n    long g = l[58];\n    long h = l[59];\n    long i = l[60];\n\
    \    long j = l[61];\n    long k = l[62];\n    long l = l[63];\n    long m = l[64];\n\
    \    long n = l[65];\n    long o = ", "{\n    long min = l[0];\n    long max =\
    \ l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    int i = 0;\n    int j = l.length - 1;\n\
    \    bool isIncreasing = true;\n    bool isDecreasing = true;\n    while (i <\
    \ j) {\n        if (l[i] > l[j]) {\n            isIncreasing = false;\n      \
    \  } else if (l[i] < l[j]) {\n            isDecreasing = false;\n        } else\
    \ {\n            i++;\n            j--;\n        }\n    }\n    return isIncreasing\
    \ || isDecreasing;\n}", "{\n    long max = l[0];\n    long min = l[0];\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n        {\n      \
    \      max = l[i];\n        }\n        if(l[i] < min)\n        {\n           \
    \ min = l[i];\n        }\n    }\n    return max < min;\n}", "{\n    long min =\
    \ l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n   \
    \         max = l[i];\n    }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| c |>\nThis code doesn't work for negative numbers. Try it with `monotonic([-10,\
    \ -20, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10,\
    \ -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5,\
    \ -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4,\
    \ -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15,\
    \ -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10,\
    \ -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5,\
    \ -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4,\
    \ -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15,\
    \ -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10,\
    \ -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5,\
    \ -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4,\
    \ -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15, -10, -5, -4, -15,\
    \ -10, -5, -4, -15, -10, -5, -4, ", "{\n    int n = l.length;\n    if (n < 2)\
    \ return true;\n    int i = 0;\n    int j = n - 1;\n    while (i < j) {\n    \
    \    if (l[i] < l[j]) {\n            i++;\n        } else if (l[i] > l[j]) {\n\
    \            j--;\n        } else {\n            return true;\n        }\n   \
    \ }\n    return false;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\t\
    if(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    int\
    \ i = 0;\n    int j = l.length - 1;\n    bool isIncreasing = true;\n    bool isDecreasing\
    \ = true;\n    while (i < j) {\n        if (l[i] > l[j]) {\n            isIncreasing\
    \ = false;\n        }\n        if (l[i] < l[j]) {\n            isDecreasing =\
    \ false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    return isIncreasing\
    \ || isDecreasing;\n}\n</code>\n<|/ a tags=c++,algorithm,sorting |>\n<| c |>\n\
    This doesn't work if you have negative numbers in the array.\n<|/ c |>\n<| c |>\n\
    : It does work if you replace `int` with `long` in the code above. `int` has less\
    \ range than `long`, so `int` values will sort before `long` values.\n<|/ c |>\n\
    <| c |>\n: I see what you mean. Yes, I missed that part. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| c |>\n: I added a version that works with negative numbers.\
    \ I hope it helps.\n<|/ c |>\n<| c |>\n: I added a version that works with negative\
    \ numbers. I hope it helps.\n<|/ c |>\n<| a tags=c++,algorithm,sorting |>\nI believe\
    \ that this is what you are looking for:\n<code>", "{\n\tlong min = l[0];\n\t\
    long max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\
    \t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\
    \t\t}\n\t}\n\treturn min < max;\n}", "{\n    long min = l[0];\n    long max =\
    \ l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n  \
    \  }\n    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) {\n         \
    \   min = l[i];\n        }\n        if(l[i] > max) {\n            max = l[i];\n\
    \        }\n    }\n    return min <= max;\n}", "{\n    int i = 0;\n    int j =\
    \ 1;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    while(i\
    \ < l.length && j < l.length) {\n        if(l[i] < l[j]) {\n            isIncreasing\
    \ = false;\n        }\n        if(l[i] > l[j]) {\n            isDecreasing = false;\n\
    \        }\n        i++;\n        j++;\n    }\n    if(isIncreasing && isDecreasing)\
    \ {\n        return true;\n    }\n    if(isIncreasing && !isDecreasing) {\n  \
    \      return true;\n    }\n    if(!isIncreasing && isDecreasing) {\n        return\
    \ true;\n    }\n    return false;\n}\n</code>\n<|/ a tags=c++,algorithm,sorting\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the list.\
    \ For example, if `l = [1, 4, 2, 3]` then `monotonic(l)` returns `true` but `monotonic([1,\
    \ 1, 4, 2, 3])` returns `false`.\n<|/ c |>\n<| c |>\nYes, I see that now. Thanks\
    \ for pointing that out. I will update my answer.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to include a solution that works with duplicates.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if there are duplicate elements in the list. For example,\
    \ if `l = [1, 4, 2, 3]` then `monotonic(l)` returns `true` but `monotonic([1,\
    \ 1, 4, 2, 3])` returns `false`.\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ a solution that works with duplicates.\n<|/ c |>\n<| a dscore=4 |>\nI believe\
    \ that your algorithm is correct, but your implementation is not. Your algorithm\
    \ is correct, but your implementation is not. Your algorithm is correct, but your\
    \ implementation is not. Your algorithm is correct, but your implementation is\
    \ not. Your algorithm is correct, but your implementation is not. Your algorithm\
    \ is correct, but your implementation is not. Your algorithm is correct, but your\
    \ implementation is not. Your algorithm is correct, but your implementation is\
    \ not. Your algorithm is correct, but your implementation is not. Your algorithm\
    \ is correct, but your implementation is not. Your algorithm is correct, but your\
    \ implementation is not. Your algorithm is correct, but your implementation is\
    \ not. Your algorithm is correct, but your implementation is not. Your algorithm\
    \ is correct, but your implementation is not. Your algorithm is correct, but your\
    \ implementation is not. Your algorithm is correct, but your implementation is\
    \ not. Your algorithm is correct, but your implementation is not. Your algorithm\
    \ is correct, but ", "{\n    int i = 0;\n    int j = 1;\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    while(i < l.length && j > 0) {\n\
    \        if(l[i] < l[j]) {\n            isIncreasing = false;\n        } else\
    \ {\n            isDecreasing = false;\n        }\n        if(isIncreasing &&\
    \ isDecreasing) {\n            return true;\n        }\n        if(isIncreasing\
    \ && !isDecreasing) {\n            return false;\n        }\n        if(!isIncreasing\
    \ && isDecreasing) {\n            return false;\n        }\n        i++;\n   \
    \     j++;\n    }\n    return false;\n}\n</code>\n<|/ a tags=c++,arrays,algorithm\
    \ |>\n<| a tags=c++,arrays,algorithm |>\n<code>", "{\n    int i = 0;\n    int\
    \ j = 1;\n    bool result = true;\n    while(i < l.length && j < l.length) \n\
    \    {\n        if(l[i] < l[j]) {\n            result = false;\n            break;\n\
    \        }\n        else if(l[i] > l[j]) {\n            result = true;\n     \
    \       break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn min <= max;\n}", "{\n\
    \    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ int n = l.length;\n    if (n < 2) return true;\n    \n    int i = 0;\n    int\
    \ j = n - 1;\n    \n    while (i < j) {\n        int m = ((i + j) / 2);\n    \
    \    if (l[m] < l[m+1]) j = m;\n        else i = m + 1;\n    }\n    \n    return\
    \ l[i] < l[j];\n}", "{\n    int i = 0;\n    int j = l.length - 1;\n    bool isIncreasing\
    \ = true;\n    bool isDecreasing = true;\n    while (i < j)\n    {\n        if\
    \ (l[i] < l[j])\n        {\n            isIncreasing = false;\n        }\n   \
    \     else if (l[i] > l[j])\n        {\n            isDecreasing = false;\n  \
    \      }\n        else\n        {\n            i++;\n            j--;\n      \
    \  }\n    }\n    return isIncreasing || isDecreasing;\n}", "{\n\tlong max = l[0];\n\
    \tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max)\n\
    \t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n\
    \tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\
    \t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn\
    \ min <= max;\n}", "{\n    int n = l.length;\n    if (n < 2) return true;\n  \
    \  int i = 0;\n    int j = 1;\n    while (i < n && j < n) {\n        if (l[i]\
    \ < l[j]) {\n            i++;\n        } else if (l[i] > l[j]) {\n           \
    \ j++;\n        } else {\n            return false;\n        }\n    }\n    return\
    \ i == n;\n}", "{\n    long max = l[0];\n    long min = l[0];\n    for(int i =\
    \ 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n\
    \        if(l[i] > max)\n            max = l[i];\n    }\n    return max < min;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max\
    \ = l[i];\n    }\n    return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\
    \t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n \
    \   {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n\
    \        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n\
    \    }\n    return min < max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n\
    <| c |>\nThis doesn't work if you have a list with duplicates. Try it with `[1,\
    \ 1, 2, 3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list with duplicates.\
    \ Try it with `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ a list with duplicates. Try it with `[1, 1, 2, 3]`.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if you have a list with duplicates. Try it with `[1, 1, 2, 3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list with duplicates. Try it\
    \ with `[1, 1, 2, 3]`.\n<|/ c |>\n<| a |>\n<code>\npublic static bool IsMonotonic(this\
    \ IEnumerable<int> list)\n{\n    if (list == null)\n        throw new ArgumentNullException(\"\
    list\");", "{\n    long max = l[0];\n    long min = l[0];\n    bool result = true;\n\
    \    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i] < min)\n      \
    \  {\n            min = l[i];\n        }\n        else if(l[i] > max)\n      \
    \  {\n            max = l[i];\n        }\n        else\n        {\n          \
    \  result = false;\n        }\n    }\n    return result;\n}", "{\n\tlong l = l[0];\n\
    \tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i-1] > l[i])\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}", "{\n    long min = 0;\n    long max = l[0];\n\
    \    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n     \
    \   if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i]\
    \ > max)\n        {\n            max = l[i];\n        }\n    }\n    if(min ==\
    \ max)\n    {\n        result = false;\n    }\n    return result;\n}", "{\n  \
    \  long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n\
    \        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n\
    \    return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n    long max = l[0];\n    long min = l[0];\n \
    \   for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n       \
    \ {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n \
    \           max = l[i];\n        }\n    }\n    return max < min;\n}", "{\n\tlong\
    \ min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\
    \t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t\
    {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n        {\n            min = l[i];\n        }\n     \
    \   if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n   \
    \ return min < max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic\
    \ = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\
    \tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif\
    \ (min > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool first = true;\n\tfor (int\
    \ i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (first)\n\t\
    \t{\n\t\t\tfirst = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (l[i] < min)\n\t\t\
    \t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (l[i] > max)\n\t\t\t{\n\t\t\t\t\
    return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "{\n\tlong min = l[0];\n\
    \tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\
    \ {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\tisMonotonic = false;\n\
    \t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        if(l[i] > max)\n     \
    \   {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}",
  "{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i]\
    \ < min)\n            min = l[i];\n    }\n    return max >= min;\n}", "{\n\tlong\
    \ max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\
    \t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max <= min);\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n        {\n            min = l[i];\n        }\n     \
    \   if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n   \
    \ return min <= max;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code doesn't\
    \ work for `monotonic([1,20,4,10])` - it returns `true` instead of `false`\n<|/\
    \ c |>\n<| c |>\n: Yes, it does. I tested it before posting it, and it works.\
    \ I even tested it on ideone.com before posting it, and it works. I even tested\
    \ it on ideone.com before posting it, and it works. I even tested it on ideone.com\
    \ before posting it, and it works. I even tested it on ideone.com before posting\
    \ it, and it works. I even tested it on ideone.com before posting it, and it works.\
    \ I even tested it on ideone.com before posting it, and it works. I even tested\
    \ it on ideone.com before posting it, and it works. I even tested it on ideone.com\
    \ before posting it, and it works. I even tested it on ideone.com before posting\
    \ it, and it works. I even tested it on ideone.com before posting it, and it works.\
    \ I even tested it on ideone.com before posting it, and it works. I even tested\
    \ it on ideone.com before posting it, and it works. I even tested it on ideone.com\
    \ before posting it, and it works. I even tested it on ideone.com before posting\
    \ it, and it works. I even tested it on ideone.com before posting it, and it works.\
    \ I even tested it on ideone.com before posting it, and it works. I even tested\
    \ it on ideone.com before posting it, and it works. I even tested it on ideone.com\
    \ before posting it, and it works. I even tested it on ideone.com before posting\
    \ it, and it works. I even tested it on ideone.com before posting it, and it works.\
    \ I even tested it on ideone.com before posting it, and it works. I even tested\
    \ it on ideone.com before posting it, and it works. I even tested it on ideone.com\
    \ before posting it, and it works. I even tested it on ideone.com before posting\
    \ it, and ", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1;\
    \ i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n\
    \        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min < max;\n}", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    bool first = true;\n    for(int i = 1;\
    \ i < l.length; i++) \n    {\n        if(l[i] < min) \n        {\n           \
    \ min = l[i];\n        }\n        if(l[i] > max) \n        {\n            max\
    \ = l[i];\n        }\n        if(first) \n        {\n            first = false;\n\
    \        }\n        else \n        {\n            if(l[i] < min) \n          \
    \  {\n                return false;\n            }\n            if(l[i] > max)\
    \ \n            {\n                return false;\n            }\n        }\n \
    \   }\n    return true;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n\
    \        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}", "{\n \
    \   long l = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i]\
    \ < l)\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t\
    }\n\treturn (min <= max);\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\t\
    for(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin =\
    \ l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\
    \treturn (min <= max);\n}", "{\n    long min = l[0];\n    long max = l[0];\n \
    \   for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n       \
    \     min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n  \
    \  return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n  \
    \  for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n\
    \            min = l[i];\n        }\n        if(l[i] > max)\n        {\n     \
    \       max = l[i];\n        }\n    }\n    return min <= max;\n}", "{\n    long\
    \ max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n \
    \   {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n\
    \        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n\
    \    return max >= min;\n}\n</code>\n<|/ a tags=c++,sorting,algorithm |>\n<| c\
    \ |>\nThis doesn't work if there are duplicates in the list. Try it with `monotonic([1,\
    \ 1, 2, 3, 4, 4, 5])`.\n<|/ c |>\n<| c |>\nYes, I see that now. Thanks for pointing\
    \ that out. I've edited my answer to fix it.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the list. Try it with `monotonic([1, 1, 2, 3,\
    \ 4, 4, 5])`.\n<|/ c |>\n<| c |>\nYes, I see that now. Thanks for pointing that\
    \ out. I've edited my answer to fix it.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are duplicates in the list. Try it with `monotonic([1, 1, 2, 3, 4,\
    \ 4, 5])`.\n<|/ c |>\n<| a |>\n<code>", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        if(l[i] > max)\n     \
    \   {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}",
  "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n  \
    \      }\n        if(l[i] > max)\n        {\n            max = l[i];\n       \
    \ }\n    }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,sorting,arrays |>\n\
    <| c |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/10335648)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He asked how to sort\
    \ an array and I provided a solution that does exactly that. He also asked how\
    \ to determine if a list is monotonic and I provided a solution that does exactly\
    \ that. He also asked how to determine if an array is monotonic and I provided\
    \ a solution that does exactly that. He also asked how to determine if an array\
    \ is monotonic and I provided a solution that does exactly that. He also asked\
    \ how to determine if an array is monotonic and I provided a solution that does\
    \ exactly that. He also asked how to determine if an array is monotonic and I\
    \ provided a solution that does exactly that. He also asked how to determine if\
    \ an array is monotonic and I provided a solution that does exactly that. He also\
    \ asked how to determine if an array is monotonic and I provided a solution that\
    \ does exactly that. He also asked how to determine if an array is monotonic and\
    \ I provided a solution that does exactly that. He also asked how to determine\
    \ if an array is monotonic and I provided a solution that does exactly that. He\
    \ also asked how to determine if an array is monotonic and I provided a solution\
    \ that does exactly that. He also asked how to determine if an array is monotonic\
    \ and I provided a solution that does exactly that. He also asked how to determine\
    \ if an array is monotonic and I provided a solution that does exactly that. He\
    \ also asked how to determine if an array is monotonic and I provided a solution\
    \ that does exactly that. He also asked how to determine if an array is monotonic\
    \ and I provided a solution that does exactly that. He also asked how to determine\
    \ if an array is monotonic and I provided a solution that does exactly that. He\
    \ also asked how to determine if an array is monotonic and I provided ", "{\n\t\
    long min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t\
    {\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    int\
    \ i = 0;\n    int j = 0;\n    int k = 0;\n    bool isIncreasing = true;\n    bool\
    \ isDecreasing = true;\n    bool isMonotonic = true;\n    \n    while (i < l.length\
    \ && j < l.length && k < l.length) {\n        if (l[i] < l[j]) {\n           \
    \ isIncreasing = false;\n        }\n        else if (l[i] > l[j]) {\n        \
    \    isDecreasing = false;\n        }\n        else if (l[i] == l[j]) {\n    \
    \        isMonotonic = false;\n        }\n        \n        if (isIncreasing &&\
    \ isDecreasing && isMonotonic) {\n            break;\n        }\n        \n  \
    \      i++;\n        j++;\n        k++;\n    }\n    \n    return isMonotonic;\n\
    }", "{\n    int i = 0;\n    int j = l.length - 1;\n    bool increasing = true;\n\
    \    bool decreasing = true;\n    while(i < j) {\n        if(l[i] < l[j]) {\n\
    \            increasing = false;\n        }\n        else if(l[i] > l[j]) {\n\
    \            decreasing = false;\n        }\n        i++;\n        j--;\n    }\n\
    \    return increasing || decreasing;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\
    \t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max = 0;\n\tlong min = l[0];\n\
    \tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ < min)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\
    \t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}",
  "{\n    long min = l[0];\n    long max = l[0];\n    bool first = true;\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n      \
    \      min = l[i];\n        }\n        if(l[i] > max)\n        {\n           \
    \ max = l[i];\n        }\n        if(!first)\n        {\n            if(min >\
    \ max)\n            {\n                return false;\n            }\n        }\n\
    \        first = false;\n    }\n    return true;\n}", "{\n\tlong min = l[0];\n\
    \tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] <\
    \ min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax\
    \ = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max = l[0];\n\t\
    long min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max)\n\
    \t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}", "{\n\
    \    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max\
    \ = l[i];\n    }\n    return min <= max;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\
    \tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\t\
    return (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int\
    \ i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] >\
    \ max) max = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\t\
    long max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min)\
    \ min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}",
  "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int\
    \ i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t\
    }\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i]\
    \ > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}",
  "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\
    \ {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\
    \t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min <= max;\n}", "{\n    int i = 0;\n    int j = 1;\n    bool\
    \ isIncreasing = true;\n    bool isDecreasing = true;\n    while(i < l.length\
    \ && j < l.length) \n    {\n        if(l[i] < l[j]) {\n            isIncreasing\
    \ = false;\n        }\n        if(l[i] > l[j]) {\n            isDecreasing = false;\n\
    \        }\n        if(isIncreasing && isDecreasing) {\n            return true;\n\
    \        }\n        if(isIncreasing && !isDecreasing) {\n            return false;\n\
    \        }\n        if(!isIncreasing && isDecreasing) {\n            return false;\n\
    \        }\n        i++;\n        j++;\n    }\n    return false;\n}", "{\n   \
    \ int i = 0;\n    int j = 1;\n    int k = 0;\n    bool flag = false;\n    \n \
    \   while (i < l.length && j < l.length) \n    {\n        if (l[i] < l[j]) \n\
    \        {\n            i++;\n        }\n        else if (l[i] > l[j]) \n    \
    \    {\n            j++;\n        }\n        else if (l[i] == l[j]) \n       \
    \ {\n            i++;\n            j++;\n        }\n        else if (l[i] < l[j]\
    \ && l[j] < l[k]) \n        {\n            flag = true;\n        }\n        else\
    \ if (l[i] > l[j] && l[j] > l[k]) \n        {\n            flag = false;\n   \
    \     }\n        k++;\n    }\n    return flag;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n       \
    \ if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return\
    \ min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    for(int\
    \ i = 1; i < l.length; ++i) {\n        if(l[i] < min) {\n            min = l[i];\n\
    \        }\n        if(l[i] > max) {\n            max = l[i];\n        }\n   \
    \ }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<|\
    \ c |>\nThis doesn't work for negative numbers. Try `monotonic([-10, -5, -1, 0])`\n\
    <|/ c |>\n<| c |>\n: It does work for negative numbers. Try `monotonic([-10, -5,\
    \ -1, 0])`\n<|/ c |>\n<| c |>\n: It does work for negative numbers. Try `monotonic([-10,\
    \ -5, -1, 0])`\n<|/ c |>\n<| c |>\n: It does work for negative numbers. Try `monotonic([-10,\
    \ -5, -1, 0])`\n<|/ c |>\n<| c |>\n: It does work for negative numbers. Try `monotonic([-10,\
    \ -5, -1, 0])`\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static bool IsMonotonic(this\
    \ IEnumerable<int> list)\n{\n    int[] array = list.ToArray();\n    if (array.Length\
    \ == 0)\n    {\n        return false;\n    }\n    if (array.Length == 1)\n   \
    \ {\n        return true;\n    }\n    int min = array[0];\n    int max = array[0];\n\
    \    for(int i = 1; i < array.Length; ++i)\n    {\n        if (array[i] < min)\n\
    \        {\n            min = array[i];\n        }\n        if (array[i] > max)\n\
    \        {\n            max = array[i];\n        }\n    }\n    return min <= max;\n\
    }\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<| c |>\nThis doesn't work for\
    \ negative numbers. Try `IsMonotonic([-10, -5, -1, 0])`\n<|/ c |>\n<| c |>\n:\
    \ It does work for negative numbers. Try `IsMonotonic([-10, -5, -1, 0])`\n<|/\
    \ c |>\n<| c |>\n: It does work for negative numbers. Try `IsMonotonic([-10, -5,\
    \ -1, 0])`\n<|/ c |>\n<| c |>\n: It does work for negative numbers. Try `IsMonotonic([-10,\
    \ -5, -1, 0])`\n<|/ c |>\n<| c |>\n: It does work for negative numbers. Try `IsMonotonic([-10,\
    \ -5, -1, 0])", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i\
    \ = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n\
    \        if(l[i] > max)\n            max = l[i];\n    }\n    return min < max;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if\
    \ (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n\
    }", "{\n    int i = 0;\n    int j = l.length - 1;\n    bool isIncreasing = true;\n\
    \    bool isDecreasing = true;\n    while (i < j) {\n        if (l[i] < l[j])\
    \ {\n            isIncreasing = false;\n        }\n        if (l[i] > l[j]) {\n\
    \            isDecreasing = false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    return isIncreasing || isDecreasing;\n}", "{\n    int n = l.length;\n\
    \    for(int i = 0; i < n; ++i) {\n        if(l[i] < l[i - 1]) {\n           \
    \ return false;\n        }\n    }\n    return true;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    bool isMonotonic = true;\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            isMonotonic = false;\n\
    \            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n\
    \            isMonotonic = false;\n            max = l[i];\n        }\n    }\n\
    \    return isMonotonic;\n}", "{\n    long min = l[0];\n    long max = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \      min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n \
    \   return min <= max;\n}", "{\n    long min = l[0];\n    long max = l[0];\n \
    \   for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n       \
    \ {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n \
    \           max = l[i];\n        }\n    }\n    return min <= max;\n}", "{\n  \
    \  long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n      \
    \      min = l[i];\n        }\n        else if(l[i] > max)\n        {\n      \
    \      max = l[i];\n        }\n        else\n        {\n            isMonotonic\
    \ = false;\n        }\n    }\n    return isMonotonic;\n}", "{\n    long min =\
    \ l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n   \
    \         max = l[i];\n    }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting,arrays\
    \ |>\n<| c |>\nThis is not an answer to the question. He wants to know if he can\
    \ sort an array in O(n) time.\n<|/ c |>\n<| c |>\n: I thought he wanted to know\
    \ if he can sort an array in O(n) time. He didn't say he wanted to sort a list\
    \ though.\n<|/ c |>\n<| c |>\n: I thought he wanted to know if he can sort an\
    \ array in O(n) time. He didn't say he wanted to sort a list though.\n<|/ c |>\n\
    <| c |>\n: I thought he wanted to know if he can sort an array in O(n) time. He\
    \ didn't say he wanted to sort a list though.\n<|/ c |>\n<| c |>\n: I thought\
    \ he wanted to know if he can sort an array in O(n) time. He didn't say he wanted\
    \ to sort a list though.\n<|/ c |>\n<| a |>\n<code>\npublic bool IsSorted(int[]\
    \ array)\n{\n    if (array.Length == 0)\n        return true;", "{\n    long l\
    \ = l[0];\n    long r = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n\
    \        if(l[i] < r)\n        {\n            return false;\n        }\n     \
    \   else if(l[i] > r)\n        {\n            return true;\n        }\n    }\n\
    \    return true;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| c |>\nThis\
    \ doesn't work. Try `monotonic([1,3,5,2,4])`\n<|/ c |>\n<| c |>\nIt works fine\
    \ for me. Try it yourself.\n<|/ c |>\n<| c |>\nIt doesn't work for me. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\nIt works for me too. Try it yourself.\n<|/ c |>\n\
    <| c |>\nIt works for me too. Try it yourself.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "{\n    int i = 0;\n    int j = 1;\n    bool isIncreasing = true;\n    bool isDecreasing\
    \ = true;\n    while (i < l.length && j > 0) {\n        if (l[i] < l[j]) {\n \
    \           isIncreasing = false;\n        }\n        else if (l[i] > l[j]) {\n\
    \            isDecreasing = false;\n        }\n        else {\n            i++;\n\
    \            j++;\n        }\n    }\n    return isIncreasing || isDecreasing;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ Try it with `monotonic([-10, -20, -30, -40, -50])`.\n<|/ c |>\n<| c |>\nYes,\
    \ I noticed that and fixed it before I saw your comment. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| a tags=c#,sorting,algorithm |>\nI believe this should work:\n\
    <code>", "{\n    long l = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n\
    \        if(l[i] < l[i-1]) return false;\n    }\n    return true;\n}", "{\n\t\
    long min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t\
    {\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\
    \t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong max\
    \ = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\t\
    if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min)\n\t\t{\n\t\
    \t\tmin = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n\
    \        {\n            max = l[i];\n        }\n    }\n    return min < max;\n\
    }", "{\n    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(i <\
    \ l.length && j < l.length) \n    {\n        if(l[i] < l[j]) {\n            result\
    \ = false;\n            break;\n        }\n        else if(l[i] > l[j]) {\n  \
    \          result = true;\n            break;\n        }\n        i++;\n     \
    \   j++;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This code doesn't work if you pass it an array with negative numbers. `monotonic([-1,\
    \ -10, -20, -30])` returns `true` instead of `false`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for negative numbers. Try it yourself. It returns `true` for `monotonic([-1,\
    \ -10, -20, -30])`.\n<|/ c |>\n<| c |>\nI see it returns `true` for `monotonic([-1,\
    \ -10, -20, -30])` but `false` for `monotonic([-1, -10, -20, -31, -40])`. So it\
    \ seems that it only works for positive numbers.\n<|/ c |>\n<| c |>\nYes, it only\
    \ works for positive numbers. But it also works for negative numbers. Try it yourself.\
    \ It returns `true` for `monotonic([-1, -10, -20, -30])`.\n<|/ c |>\n<| c |>\n\
    I see it returns `true` for `monotonic([-1, -10, -20, -30])` but `false` for `monotonic([-1,\
    \ -10, -20, -31, -40])`. So it seems that it only works for positive numbers.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long min = l[0];\n    long max =\
    \ l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n\
    \        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min <= max;\n}", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n   \
    \         max = l[i];\n    }\n    return min <= max;\n}", "{\n    long max = l[0];\n\
    \    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > max)\n        {\n            max = l[i];\n        }\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n    }\n    return max >= min;\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\
    \    long l = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i]\
    \ < l)\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min < max;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work for negative numbers. `monotonic([-1, -2, -4, -20])`\
    \ returns `true` but should be `false`.\n<|/ c |>\n<| c |>\nI believe that `monotonic([-1,\
    \ -2, -4, -20])` returns `false` because `-1` is less than `-2`, but `-2` is less\
    \ than `-4`, but `-4` is less than `-20`.  `monotonic([-1, -2, -4, 20])` returns\
    \ `true` because `-1` is less than `-2`, but `-2` is less than `-4`, but `-4`\
    \ is less than `20`.  `monotonic([-1, -2, -4, -10])` returns `true` because `-1`\
    \ is less than `-2`, but `-2` is less than `-4`, but `-4` is less than `-10`.\
    \  `monotonic([-1, -2, -4, -10])` returns `false` because `-1` is greater than\
    \ `-2`, but `-2` is greater than `-4`, but `-4` is greater than `-10`.\n<|/ c\
    \ |>\n<| c |>\nI believe that `monotonic([-1, -2, -4, -20])` returns `false` because\
    \ `-1` is less than `-2`, but `-2` is less than `-4`, but `-4` is less than `-20`.\
    \  `monotonic([-1, -2, -4, 20])` returns `true` because `-1` is less than `-2`,\
    \ but `-2` is less than `-4`, but `-4` is less than `20`.  `monotonic([-1, -2,\
    \ -4, -10])` returns `true` because `-1` is less than `-2`, but `-2` is less than\
    \ `-4`, but `-4` is less than `-10`.  `monotonic([-1, -2, -4, -10])` returns `false`\
    \ because `-1` is greater than `-2`, but `-2` is greater than `-4`, but `-4` is\
    \ greater than `-10`.\n<|/ c |>\n<| c |>\nI believe that `monotonic([-1, -2, -4,\
    \ -20])` returns `false` because `-1` is less than `-2`, but `-2` is less than\
    \ `-4`, but `-4` is less than `-20`.  `monotonic([-1, -2, -4, 20])` returns `true`\
    \ because `-1` is less than `-2`, but `-2` is less than `-4", "{\n    long min\
    \ = l[0];\n    long max = l[0];\n    bool result = true;\n    for (int i = 1;\
    \ i < l.length; ++i) {\n        if (l[i] < min) {\n            min = l[i];\n \
    \       }\n        if (l[i] > max) {\n            max = l[i];\n        }\n   \
    \ }\n    if (min > max) {\n        result = false;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,sorting |>\n<code>\npublic\
    \ static bool IsMonotonic(this IEnumerable<int> list)\n{\n    var min = list.First();\n\
    \    var max = list.First();\n    foreach (var item in list)\n    {\n        if\
    \ (item < min)\n        {\n            min = item;\n        }\n        if (item\
    \ > max)\n        {\n            max = item;\n        }\n    }\n    return min\
    \ <= max;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,sorting |>\n\
    <code>\npublic static bool IsMonotonic(this IEnumerable<int> list)\n{\n    var\
    \ min = list.First();\n    var max = list.First();\n    foreach (var item in list)\n\
    \    {\n        if (item < min)\n        {\n            min = item;\n        }\n\
    \        if (item > max)\n        {\n            max = item;\n        }\n    }\n\
    \    return min <= max;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    public static bool IsMonotonic(this IEnumerable<int> list)\n{\n    var min = list.First();\n\
    \    var max = list.First();\n    foreach (var item in list)\n    {\n        if\
    \ (item < min)\n        {\n            min = item;\n        }\n        if (item\
    \ > max)\n        {\n            max = item;\n        }\n    }\n    return min\
    \ <= max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| a dscore=1 |>\n\
    <code>\npublic static bool IsMonotonic(this IEnumerable<int> list)\n{\n    var\
    \ min = list.First();\n    var max = list.First();\n    foreach (var item in list)\n\
    \    {\n        if (item < min)\n        {\n            min = item;\n        }\n\
    \        if (item > max)\n        {\n            max = item;\n        }\n    }\n\
    \    return min <= max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| a\
    \ dscore=1 |>\n<code>\npublic static bool IsMonotonic(this IEnumerable<int> list)\n\
    {\n    var min = list.First();\n    var ", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\
    \t}\n\t}\n\treturn (min <= max);\n}", "{\n    int n = l.length;\n    if (n < 2)\
    \ return true;\n    \n    int i = 0;\n    int j = n - 1;\n    \n    while (i <\
    \ j) {\n        if (l[i] > l[j]) {\n            i++;\n        } else if (l[i]\
    \ < l[j]) {\n            j--;\n        } else {\n            i++;\n          \
    \  j--;\n        }\n    }\n    \n    return i == j;\n}", "{\n    int n = l.length;\n\
    \    if (n == 0) return true;\n    if (n == 1) return l[0] > l[1];\n    \n   \
    \ long m = l[0];\n    long lm = l[1];\n    \n    for (int i = 2; i < n; i++) {\n\
    \        long l = l[i];\n        long lm = lm;\n        \n        if (l > lm)\
    \ lm = l;\n    }\n    \n    return lm > m;\n}", "{\n    long min = l[0];\n   \
    \ long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] <\
    \ min) {\n            min = l[i];\n        }\n        if(l[i] > max) {\n     \
    \       max = l[i];\n        }\n    }\n    return min <= max;\n}", "{\n    int\
    \ i = 0;\n    int j = 1;\n    int k = 0;\n    bool isIncreasing = true;\n    bool\
    \ isDecreasing = true;\n    bool isMonotonic = true;\n    while(j < l.length &&\
    \ isMonotonic)\n    {\n        if(l[j] < l[k])\n        {\n            isIncreasing\
    \ = false;\n        }\n        else\n        {\n            isDecreasing = false;\n\
    \        }\n        if(isIncreasing && isDecreasing)\n        {\n            isMonotonic\
    \ = false;\n        }\n        else if(isIncreasing)\n        {\n            i++;\n\
    \        }\n        else if(isDecreasing)\n        {\n            j++;\n     \
    \   }\n        k++;\n    }\n    return isMonotonic;\n}\n</code>\n<|/ a tags=c++,arrays,sorting\
    \ |>\n<| a tags=c++,arrays,sorting |>\n<code>\n#include <iostream>\n#include <algorithm>\n\
    #include <vector>\nusing namespace std;", "{\n    int i = 0;\n    int j = 1;\n\
    \    int k = 0;\n    while(j < l.length && l[j] < l[k])\n    {\n        j++;\n\
    \        k++;\n    }\n    while(j < l.length)\n    {\n        if(l[j] < l[k])\n\
    \        {\n            return false;\n        }\n        j++;\n        k++;\n\
    \    }\n    return true;\n}", "{\n    int i = 0;\n    int j = 1;\n    bool result\
    \ = true;\n    while(i < l.length && j > 0) {\n        if(l[i] < l[j]) {\n   \
    \         result = false;\n            break;\n        }\n        else if(l[i]\
    \ > l[j]) {\n            result = true;\n            break;\n        }\n     \
    \   else {\n            i++;\n            j++;\n        }\n    }\n    return result;\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n   \
    \ long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++)\
    \ \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n\
    \    }\n    return min <= max;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't\
    \ work if you have a list like `[1, 1, 2, 2, 3, 3]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you have a list like `[1, 1, 2, 2, 3, 3]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you have a list like `[1, 1, 2, 2, 3, 3]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you have a list like `[1, 1, 2, 2, 3, 3]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you have a list like `[1, 1, 2, 2, 3, 3]`\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i]\
    \ > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}", "{\n\
    \    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i]\
    \ > max)\n            max = l[i];\n    }\n    return min <= max;\n}", "{\n\tlong\
    \ min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\t\
    if (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min\
    \ <= max);\n}", "{\n    long a = l[0];\n    long b = l[1];\n    long c = l[2];\n\
    \    long d = l[3];\n    long e = l[4];\n    long f = l[5];\n    long g = l[6];\n\
    \    long h = l[7];\n    long i = l[8];\n    long j = l[9];\n    long k = l[10];\n\
    \    long l = l[11];\n    long m = l[12];\n    long n = l[13];\n    long o = l[14];\n\
    \    long p = l[15];\n    long q = l[16];\n    long r = l[17];\n    long s = l[18];\n\
    \    long t = l[19];\n    long u = l[20];\n    long v = l[21];\n    long w = l[22];\n\
    \    long x = l[23];\n    long y = l[24];\n    long z = l[25];\n    long a = l[0];\n\
    \    long b = l[1];\n    long c = l[2];\n    long d = l[3];\n    long e = l[4];\n\
    \    long f = l[5];\n    long g = l[6];\n    long h = l[7];\n    long i = l[8];\n\
    \    long j = l[9];\n    long k = l[10];\n    long l = l[11];\n    long m = l[12];\n\
    \    long n = l[13];\n    long o = l[14];\n    long p = l[15];\n    long q = l[16];\n\
    \    long r = l[17];\n    long s = l[18];\n    long t = l[19];\n    long u = l[20];\n\
    \    long v = l[21];\n    long w = l[22];\n    long x = l[23];\n    long y = l[24];\n\
    \    long z = l[25];\n    long a = l[0];\n    long b = l[1];\n    long c = l[2];\n\
    \    long d = l[3];\n    long e = l[4];\n    long f = l[5];\n    long g = l[6];\n\
    \    long h = l[7];\n    long i = l[8];\n    long j = l[9];\n    long k = l[10];\n\
    \    long l = l[11];\n    long m = l[12];\n    long n = l[13];\n    long o = l[14];\n\
    \    long p = l[15];\n    long q = l[16];\n    long r = l[17];\n", "{\n\tlong\
    \ max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i\
    \ < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif\
    \ (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] != max && l[i] != min)\
    \ {\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    int i =\
    \ 0;\n    int j = l.length-1;\n    bool result = true;\n    while(i < j)\n   \
    \ {\n        if(l[i] < l[j])\n        {\n            result = false;\n       \
    \     break;\n        }\n        else if(l[i] > l[j])\n        {\n           \
    \ result = true;\n            break;\n        }\n        i++;\n        j--;\n\
    \    }\n    return result;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\t\
    for (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin\
    \ = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\t\
    return (min <= max);\n}", "{\n    long max = l[0];\n    long min = l[0];\n   \
    \ for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n\
    \            min = l[i];\n        }\n        if(l[i] > max)\n        {\n     \
    \       max = l[i];\n        }\n    }\n    return max < min;\n}", "{\n    long\
    \ min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n \
    \   {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n\
    \            max = l[i];\n    }\n    return min <= max;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. Try it with `monotonic([-10,\
    \ -20, -5, -15, -10, -5, -10, -5, -10])`\n<|/ c |>\n<| c |>\nIt works for negative\
    \ numbers, try it with `monotonic([-10, -20, -5, -15, -10, -5, -10, -5, -10])`\n\
    <|/ c |>\n<| c |>\nIt works for negative numbers, try it with `monotonic([-10,\
    \ -20, -5, -15, -10, -5, -10, -5, -10])`\n<|/ c |>\n<| c |>\nIt works for negative\
    \ numbers, try it with `monotonic([-10, -20, -5, -15, -10, -5, -10, -5, -10])`\n\
    <|/ c |>\n<| c |>\nIt works for negative numbers, try it with `monotonic([-10,\
    \ -20, -5, -15, -10, -5, -10, -5, -10])`\n<|/ c |>\n<| a dscore=2 |>\nI wrote\
    \ a solution that works for any type of array and any type of number. \n<code>",
  "{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n  \
    \      }\n        if(l[i] > max)\n        {\n            max = l[i];\n       \
    \ }\n    }\n    return min < max;\n}", "{\n    long min = l[0];\n    long max\
    \ = l[0];\n    bool increasing = true;\n    bool decreasing = true;\n    for(int\
    \ i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n      \
    \      min = l[i];\n        }\n        else if(l[i] > max)\n        {\n      \
    \      max = l[i];\n        }\n        else\n        {\n            increasing\
    \ = false;\n            decreasing = false;\n        }\n    }\n    return increasing\
    \ || decreasing;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution does not\
    \ work for negative numbers. Try it with `monotonic([-10, -5, -1, 0])`\n<|/ c\
    \ |>\n<| c |>\n: It works for negative numbers. Try it with `monotonic([-10, -5,\
    \ -1, 0])`\n<|/ c |>\n<| c |>\nYes, it works. I tested it on `[10, -5, -1, 0]`\
    \ which returns `True`.\n<|/ c |>\n<| c |>\n: I tested it on `[10, -5, -1, 0]`\
    \ which returns `True`.\n<|/ c |>\n<| c |>\n: I tested it on `[10, -5, -1, 0]`\
    \ which returns `True`.\n<|/ c |>\n<| a dscore=4 |>\nI wrote a little library\
    \ to solve this problem:\n<code>\nimport std.stdio;\nimport std.array;\nimport\
    \ std.algorithm;\nimport std.conv;", "{\n    int i = 0;\n    int j = l.length\
    \ - 1;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    while\
    \ (i < j) {\n        if (l[i] > l[j]) {\n            isIncreasing = false;\n \
    \       } else if (l[i] < l[j]) {\n            isDecreasing = false;\n       \
    \ }\n        i += 1;\n        j -= 1;\n    }\n    return isIncreasing || isDecreasing;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "{\n    long max = l[0];\n\
    \    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > max)\n            max = l[i];\n        if(l[i] < min)\n            min = l[i];\n\
    \    }\n    return max > min;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
