name: HumanEval_6_parse_nested_parens
language: humaneval_to_dlang.py
results:
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string.trim();\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long max_level = 0;\n    long level = 0;\n    long level_counter = 0;\n \
    \   long level_counter2 = 0;\n    bool is_open = false;\n    bool is_closed =\
    \ false;\n    bool is_open2 = false;\n    bool is_closed2 = false;\n    bool is_open3\
    \ = false;\n    bool is_closed3 = false;\n    bool is_open4 = false;\n    bool\
    \ is_closed4 = false;\n    bool is_open5 = false;\n    bool is_closed5 = false;\n\
    \    bool is_open6 = false;\n    bool is_closed6 = false;\n    bool is_open7 =\
    \ false;\n    bool is_closed7 = false;\n    bool is_open8 = false;\n    bool is_closed8\
    \ = false;\n    bool is_open9 = false;\n    bool is_closed9 = false;\n    bool\
    \ is_open10 = false;\n    bool is_closed10 = false;\n    bool is_open11 = false;\n\
    \    bool is_closed11 = false;\n    bool is_open12 = false;\n    bool is_closed12\
    \ = false;\n    bool is_open13 = false;\n    bool is_closed13 = false;\n    bool\
    \ is_open14 = false;\n    bool is_closed14 = false;\n    bool is_open15 = false;\n\
    \    bool is_closed15 = false;\n    bool is_open16 = false;\n    bool is_closed16\
    \ = false;\n    bool is_open17 = false;\n    bool is_closed17 = false;\n    bool\
    \ is_open18 = false;\n    bool is_closed18 = false;\n    bool is_open19 = false;\n\
    \    bool is_closed19 = false;\n    bool is_open20 = false;\n    bool is_closed20\
    \ = false;\n    bool is_open21 = false;\n    bool is_closed21 = false;\n    bool\
    \ is_open22 = false;\n    bool is_closed22 = false;\n    bool is_open23 = false;\n\
    \    bool is_closed23 = false;\n    bool is_open24 = false;\n    bool is_closed24\
    \ = false;\n    bool is_open25 = false;\n    bool is_closed25 = false;\n    bool\
    \ is_open26 = false;\n    bool is_closed26 = false;\n    bool is_open27 = false;\n\
    \    bool is_closed27 = false;\n    bool is_open28 = false;\n    bool is_closed28\
    \ = false;\n    bool is_open29 = false;\n    bool is_closed29 = false;\n    bool\
    \ is_open30 = false;\n    bool is_closed30 = false;\n    bool is_open31 = false;\n\
    \    bool is_closed31 = false;\n    bool is_open32 = false;\n    bool is_closed32\
    \ = false;\n    bool is_open33 = false;\n    bool is_closed\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7jpj69co.d(86): Error: semicolon expected, not `unittest`\\n/tmp/tmp7jpj69co.d(86):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7jpj69co.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long current_level = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing = false;\n\
    \    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n    bool\
    \ is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n   \
    \ bool is_opening_paren_or_opening_paren_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6pxwv7jy.d(41): Error: semicolon expected, not `unittest`\\n/tmp/tmp6pxwv7jy.d(41):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6pxwv7jy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n  \
    \          level++;\n        }\n        else if(paren_string[i] == ')') {\n  \
    \          level--;\n        }\n        levels[i] = level;\n    }\n    return\
    \ levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpilrwq2_g.d(14): Error: no property `length` for type `string`\\\
    n/tmp/tmpilrwq2_g.d(16): Error: no property `length` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpilrwq2_g.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n\
    \    long i;\n    long j;\n    long k;\n    long levels_index = 0;\n    long paren_strings_index\
    \ = 0;\n    long paren_chars_index = 0;\n    for(i = 0; i < paren_string.length();\
    \ i++) {\n        paren_char = paren_string[i];\n        levels[levels_index]\
    \ = level;\n        paren_chars[paren_chars_index] = paren_char;\n        paren_strings[paren_strings_index]\
    \ = paren_string;\n        paren_chars_index++;\n        level++;\n        if(paren_char\
    \ == '(') {\n            level++;\n        }\n        if(paren_char == ')') {\n\
    \            level--;\n        }\n        if(level == max_level) {\n         \
    \   max_level = level;\n            levels_index++;\n            paren_strings_index++;\n\
    \            paren_chars_index = 0;\n        }\n    }\n    for(i = 0; i < levels_index;\
    \ i++) {\n        levels[i] = level;\n    }\n    for(i = 0; i < paren_chars_index;\
    \ i++) {\n        paren_chars[i] = paren_chars[paren_chars_index-i-1];\n    }\n\
    \    for(i = 0; i < paren_strings_index; i++) {\n        paren_strings[i] = paren_strings[paren_strings_index-i-1];\n\
    \    }\n    for(i = 0; i < levels_index; i++) {\n        levels[i] = levels[i];\n\
    \    }\n    for(i = 0; i < paren_strings_index; i++) {\n        paren_strings[i]\
    \ = paren_strings[i];\n    }\n    for(i = 0; i < paren_chars_index; i++) {\n \
    \       paren_chars[i] = paren_chars[i];\n    }\n    for(i = 0; i < levels_index;\
    \ i++) {\n        for(j = 0; j < levels[i]; j++) {\n            for(k = 0; k <\
    \ paren_strings[i].length(); k++) {\n                if(paren_chars[i] == paren_strings[i][k])\
    \ {\n                    levels[i] += 1;\n                    break;\n       \
    \         }\n            }\n        }\n    }\n    for(i = 0; i < levels_index;\
    \ i++) {\n        levels[i] = levels[i];\n    }\n    return levels;\n}\n/*\n Input\
    \ to this function is a string represented multiple groups for nested parentheses\
    \ separated by spaces.\n    For each of the group, output the deepest level of\
    \ nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while\
    \ ((())) has three.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn0zc51tx.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpn0zc51tx.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpn0zc51tx.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpn0zc51tx.d(79): Error: unterminated /* */ comment\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn0zc51tx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening\
    \ = false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjc2kjxeq.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpjc2kjxeq.d(63): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpjc2kjxeq.d(63): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjc2kjxeq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,parentheses,language-agnostic,parsing\
    \ |>\n<| c |>\nThis doesn't work for nested parentheses such as `((()))` - it\
    \ returns `[1, 1, 1]`.\n<|/ c |>\n<| c |>\n: It does work for nested parentheses\
    \ such as `((()))` - it returns `[2, 3, 1, 3]`.\n<|/ c |>\n<| c |>\nAh, I missed\
    \ that `()` was a special case. Thanks!\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for nested parentheses such as `((()))` - it returns `[1, 1, 1]`.\n<|/ c |>\n\
    <| c |>\n: It does work for nested parentheses such as `((()))` - it returns `[2,\
    \ 3, 1, 3]`.\n<|/ c |>\n<| a |>\nThe algorithm is simple:\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5el62ce5.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp5el62ce5.d(35): Error: declaration expected,\
    \ not `<`\\n/tmp/tmp5el62ce5.d(38): Error: unterminated character constant\\n/tmp/tmp5el62ce5.d(47):\
    \ Error: unterminated character constant\\n/tmp/tmp5el62ce5.d(58): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmp5el62ce5.d(59): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmp5el62ce5.d(60): Error: declaration expected, not `assert`\\\
    n/tmp/tmp5el62ce5.d(61): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp5el62ce5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_paren = 0;\n    long level_paren\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_paren = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_paren = 0;\n    long paren_level_max_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren = 0;\n    long paren_level_max_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren = 0;\n    long\
    \ paren_level_max_paren_paren_paren_paren_paren_paren = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdako2qwt.d(40): Error: semicolon expected, not `unittest`\\n/tmp/tmpdako2qwt.d(40):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpdako2qwt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_pos = 0;\n    long pos = 0;\n\
    \    long paren_pos = 0;\n    long paren_level = 0;\n    long paren_max_level\
    \ = 0;\n    long paren_max_level_pos = 0;\n    long paren_max_level_pos_neg =\
    \ 0;\n    long paren_max_level_pos_pos_neg = 0;\n    long paren_max_level_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_neg = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_neg = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_neg = 0;\n  \
    \  long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg = 0;\n    long\
    \ paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg =\
    \ 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long paren_max_level_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_neg\
    \ = 0;\n    long \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsvxzpvfu.d(48): Error: no identifier for declarator `long`\\\
    n/tmp/tmpsvxzpvfu.d(48): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsvxzpvfu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    long max_level_count = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma = false;\n    bool in_paren_group_open_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_comma = false;\n    bool in_paren_group_close_brace_or_comma_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma = false;\n\
    \    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm3wgylc0.d(45): Error: semicolon expected, not `unittest`\\n/tmp/tmpm3wgylc0.d(45):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpm3wgylc0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgcybex4u.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpgcybex4u.d(79): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmpgcybex4u.d(79): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgcybex4u.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_nesting = 0;\n    long paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_nesting_levels[] = new long[paren_string.length()];\n    long\
    \ paren_nesting_level = 0;\n    long paren_nesting_nesting = 0;\n    long paren_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_level = 0;\n\
    \    long paren_nesting_nesting_nesting = 0;\n    long paren_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_level\
    \ = 0;\n    long paren_nesting_nesting_nesting_nesting = 0;\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_level\
    \ = 0;\n    long paren_nesting_nesting_nesting_nesting = 0;\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_level\
    \ = 0;\n    long paren_nesting_nesting_nesting_nesting = 0;\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_level\
    \ = 0;\n    long paren_nesting_nesting_nesting_nesting = 0;\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_nesting_nesting_nesting_level\
    \ = 0;\n    long paren_nesting_nesting_nesting_nesting = 0;\n    long paren_nesting_nesting_nesting_levels[]\
    \ = new long[paren_string.length()];\n    long paren_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4o8te6h3.d(18): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] paren_levels`\\n/tmp/tmp4o8te6h3.d(19): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[] paren_nesting_levels`\\n/tmp/tmp4o8te6h3.d(22):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(23): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_nesting_nesting_levels`\\n/tmp/tmp4o8te6h3.d(26): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_nesting_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(27): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_nesting_nesting_nesting_levels`\\n/tmp/tmp4o8te6h3.d(30): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_nesting_nesting_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(31): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_nesting_nesting_nesting_levels`\\n/tmp/tmp4o8te6h3.d(34): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_nesting_nesting_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(35): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_nesting_nesting_nesting_levels`\\n/tmp/tmp4o8te6h3.d(38): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_nesting_nesting_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(39): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_nesting_nesting_nesting_levels`\\n/tmp/tmp4o8te6h3.d(42): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_nesting_nesting_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(43): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_nesting_nesting_nesting_levels`\\n/tmp/tmp4o8te6h3.d(46): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_nesting_nesting_nesting_levels`\\\
    n/tmp/tmp4o8te6h3.d(48): Error: semicolon expected, not `unittest`\\n/tmp/tmp4o8te6h3.d(48):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    \n    for(auto\
    \ c : paren_string)\n    {\n        if(c == '(')\n        {\n            levels[level]\
    \ = level;\n            level++;\n        }\n        else if(c == ')')\n     \
    \   {\n            level--;\n        }\n    }\n    \n    for(auto c : paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            levels[level] = level;\n\
    \            level++;\n        }\n        else if(c == ')')\n        {\n     \
    \       level--;\n        }\n    }\n    \n    for(auto c : paren_string)\n   \
    \ {\n        if(c == '(')\n        {\n            levels[level] = level;\n   \
    \         level++;\n        }\n        else if(c == ')')\n        {\n        \
    \    level--;\n        }\n    }\n    \n    for(auto c : paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            levels[level] = level;\n       \
    \     level++;\n        }\n        else if(c == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(auto c : paren_string)\n    {\n        if(c ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \   }\n    }\n    \n    for(auto c : paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            levels[level] = level;\n            level++;\n       \
    \ }\n        else if(c == ')')\n        {\n            level--;\n        }\n \
    \   }\n    \n    for(auto c : paren_string)\n    {\n        if(c == '(')\n   \
    \     {\n            levels[level] = level;\n            level++;\n        }\n\
    \        else if(c == ')')\n        {\n            level--;\n        }\n    }\n\
    \    \n    for(auto c : paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            levels[level] = level;\n            level++;\n        }\n       \
    \ else if(c == ')')\n        {\n            level--;\n        }\n    }\n    \n\
    \    for(auto c : paren_string)\n    {\n        if(c == '(')\n        {\n    \
    \        levels[level] = level;\n            level++;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n        }\n    }\n    \n    for(auto\
    \ c : paren_string)\n    {\n        if(c == '(')\n        {\n            \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkbh_gvf_.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpkbh_gvf_.d(18): Error: no identifier\
    \ for declarator `c`\\n/tmp/tmpkbh_gvf_.d(18): Error: expression expected, not\
    \ `:`\\n/tmp/tmpkbh_gvf_.d(18): Error: found `paren_string` when expecting `;`\
    \ following `for` condition\\n/tmp/tmpkbh_gvf_.d(31): Error: no identifier for\
    \ declarator `c`\\n/tmp/tmpkbh_gvf_.d(31): Error: expression expected, not `:`\\\
    n/tmp/tmpkbh_gvf_.d(31): Error: found `paren_string` when expecting `;` following\
    \ `for` condition\\n/tmp/tmpkbh_gvf_.d(44): Error: no identifier for declarator\
    \ `c`\\n/tmp/tmpkbh_gvf_.d(44): Error: expression expected, not `:`\\n/tmp/tmpkbh_gvf_.d(44):\
    \ Error: found `paren_string` when expecting `;` following `for` condition\\n/tmp/tmpkbh_gvf_.d(57):\
    \ Error: no identifier for declarator `c`\\n/tmp/tmpkbh_gvf_.d(57): Error: expression\
    \ expected, not `:`\\n/tmp/tmpkbh_gvf_.d(57): Error: found `paren_string` when\
    \ expecting `;` following `for` condition\\n/tmp/tmpkbh_gvf_.d(70): Error: no\
    \ identifier for declarator `c`\\n/tmp/tmpkbh_gvf_.d(70): Error: expression expected,\
    \ not `:`\\n/tmp/tmpkbh_gvf_.d(70): Error: found `paren_string` when expecting\
    \ `;` following `for` condition\\n/tmp/tmpkbh_gvf_.d(83): Error: no identifier\
    \ for declarator `c`\\n/tmp/tmpkbh_gvf_.d(83): Error: expression expected, not\
    \ `:`\\n/tmp/tmpkbh_gvf_.d(83): Error: found `paren_string` when expecting `;`\
    \ following `for` condition\\n/tmp/tmpkbh_gvf_.d(96): Error: no identifier for\
    \ declarator `c`\\n/tmp/tmpkbh_gvf_.d(96): Error: expression expected, not `:`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkbh_gvf_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_strings_temp;\n    string paren_strings_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp;\n    string paren_strings_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp;\n    string paren_strings_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp;\n    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppu3k6987.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmppu3k6987.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppu3k6987.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmppu3k6987.d(44): Error: found `paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_`\
    \ when expecting `;` following statement\\n/tmp/tmppu3k6987.d(45): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmppu3k6987.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_copy = new long[paren_string.length()];\n    long levels_stack_index\
    \ = 0;\n    long levels_stack_index_copy = 0;\n    long levels_copy = 0;\n   \
    \ long levels_copy_index = 0;\n    long levels_copy_index_copy = 0;\n    long\
    \ levels_copy_index2 = 0;\n    long levels_copy_index2_index = 0;\n    long levels_copy_index3_index\
    \ = 0;\n    long levels_copy_index3_index_copy = 0;\n    long levels_copy_index4_index\
    \ = 0;\n    long levels_copy_index4_index_copy = 0;\n    long levels_copy_index5_index\
    \ = 0;\n    long levels_copy_index5_index_copy = 0;\n    long levels_copy_index6_index\
    \ = 0;\n    long levels_copy_index6_index_copy = 0;\n    long levels_copy_index7_index\
    \ = 0;\n    long levels_copy_index7_index_copy = 0;\n    long levels_copy_index8_index\
    \ = 0;\n    long levels_copy_index8_index_copy = 0;\n    long levels_copy_index9_index\
    \ = 0;\n    long levels_copy_index9_index_copy = 0;\n    long levels_copy_index10_index\
    \ = 0;\n    long levels_copy_index10_index_copy = 0;\n    long levels_copy_index11_index\
    \ = 0;\n    long levels_copy_index11_index_copy = 0;\n    long levels_copy_index12_index\
    \ = 0;\n    long levels_copy_index12_index_copy = 0;\n    long levels_copy_index13_index\
    \ = 0;\n    long levels_copy_index13_index_copy = 0;\n    long levels_copy_index14_index\
    \ = 0;\n    long levels_copy_index14_index_copy = 0;\n    long levels_copy_index15_index\
    \ = 0;\n    long levels_copy_index15_index_copy = 0;\n    long levels_copy_index16_index\
    \ = 0;\n    long levels_copy_index16_index_copy = 0;\n    long levels_copy_index17_index\
    \ = 0;\n    long levels_copy_index17_index_copy = 0;\n    long levels_copy_index18_index\
    \ = 0;\n    long levels_copy_index18_index_copy = 0;\n    long levels_copy_index19_index\
    \ = 0;\n    long levels_copy_index19_index_copy = 0;\n    long levels_copy_index20_index\
    \ = 0;\n    long levels_copy_index20_index_copy = 0;\n    long levels_copy_index21_index\
    \ = 0;\n    long levels_copy_index21_index_copy = 0;\n    long levels_copy_index22_index\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfsjil_s6.d(64): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfsjil_s6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuf4vm10t.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpuf4vm10t.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpuf4vm10t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprjiosmma.d(45): Error: semicolon expected, not `unittest`\\n/tmp/tmprjiosmma.d(45):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprjiosmma.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    \n    while(i < paren_string.length())\n    {\n        char\
    \ c = paren_string[i];\n        \n        if(c == '(')\n        {\n          \
    \  level++;\n        }\n        else if(c == ')')\n        {\n            level--;\n\
    \        }\n        \n        if(level > max_level)\n        {\n            max_level\
    \ = level;\n        }\n        \n        levels[i] = level;\n        i++;\n  \
    \  }\n    \n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjc3ltm5x.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpjc3ltm5x.d(16): Error: no property `length`\
    \ for type `string`\\n/tmp/tmpjc3ltm5x.d(19): Error: no property `length` for\
    \ type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjc3ltm5x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_size = 0;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_size = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_size2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_size3 = 0;\n    long paren_levels_index4 = 0;\n    long\
    \ paren_levels_size4 = 0;\n    long paren_levels_index5 = 0;\n    long paren_levels_size5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_size6 = 0;\n\
    \    long paren_levels_index7 = 0;\n    long paren_levels_size7 = 0;\n    long\
    \ paren_levels_index8 = 0;\n    long paren_levels_size8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_size9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_size10 = 0;\n    long paren_levels_index11 = 0;\n    long\
    \ paren_levels_size11 = 0;\n    long paren_levels_index12 = 0;\n    long paren_levels_size12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_size13 = 0;\n\
    \    long paren_levels_index14 = 0;\n    long paren_levels_size14 = 0;\n    long\
    \ paren_levels_index15 = 0;\n    long paren_levels_size15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_size16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_size17 = 0;\n    long paren_levels_index18 = 0;\n    long\
    \ paren_levels_size18 = 0;\n    long paren_levels_index19 = 0;\n    long paren_levels_size19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_size20 = 0;\n\
    \    long paren_levels_index21 = 0;\n    long paren_levels_size21 = 0;\n    long\
    \ paren_levels_index22 = 0;\n    long paren_levels_size22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_size23 = 0;\n    long paren_levels_index24\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ip5b0wm.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp_ip5b0wm.d(20): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_levels`\\n/tmp/tmp_ip5b0wm.d(68):\
    \ Error: semicolon expected, not `unittest`\\n/tmp/tmp_ip5b0wm.d(68): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_ip5b0wm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7p3_ms9k.d(14): Error: no property `length` for type `string`\\\
    n/tmp/tmp7p3_ms9k.d(16): Error: no property `length` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7p3_ms9k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS] = {0};\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkyr7q3zm.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpkyr7q3zm.d(79): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpkyr7q3zm.d(79): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkyr7q3zm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpodpzge1z.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpodpzge1z.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpodpzge1z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] result\
    \ = new long[paren_string.length()];\n    string paren_char;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpts5nff47.d(78): Error: semicolon expected, not `unittest`\\n/tmp/tmpts5nff47.d(78):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpts5nff47.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] result\
    \ = new long[paren_string.length()];\n    stack<int> paren_stack = new stack<int>();\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            paren_stack.push(i);\n        }\n\
    \        else if(c == ')')\n        {\n            int top = paren_stack.top();\n\
    \            if(top < i)\n            {\n                throw new Exception(\"\
    Unbalanced parenthesis\");\n            }\n            paren_stack.pop();\n  \
    \      }\n        else\n        {\n            int top = paren_stack.top();\n\
    \            if(top < i)\n            {\n                throw new Exception(\"\
    Unbalanced parenthesis\");\n            }\n            while(top >= 0 && paren_string[top]\
    \ != c)\n            {\n                top--;\n            }\n            if(paren_string[top]\
    \ == c)\n            {\n                paren_stack.push(top);\n            }\n\
    \            else\n            {\n                throw new Exception(\"Unbalanced\
    \ parenthesis\");\n            }\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            int top = paren_stack.top();\n            while(top >= 0)\n\
    \            {\n                top--;\n                char c_top = paren_string[top];\n\
    \                if(c_top == '(')\n                {\n                    paren_stack.push(top);\n\
    \                    break;\n                }\n                else if(c_top\
    \ == ')')\n                {\n                    paren_stack.pop();\n       \
    \             break;\n                }\n            }\n        }\n    }\n   \
    \ for(int i = 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            int top = paren_stack.top();\n \
    \           while(top >= 0)\n            {\n                top--;\n         \
    \       char c_top = paren_string[top];\n                if(c_top == '(')\n  \
    \              {\n                    paren_stack.push(top);\n               \
    \     break;\n                }\n                else if(c_top == ')')\n     \
    \           {\n                    paren_stack.pop();\n                    break;\n\
    \                }\n            }\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            int top = paren_stack.top();\n            while(top >= 0)\n\
    \            {\n                top--;\n                char c_top = paren_string[top];\n\
    \                if(c_top == '(')\n                {\n                    paren_stack.push(top);\n\
    \                    break;\n                }\n                else if(c_top\
    \ == ')')\n                {\n                    paren_stack.pop();\n       \
    \             break;\n                }\n            }\n        }\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprr_wh9xy.d(15): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmprr_wh9xy.d(15): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmprr_wh9xy.d(15): Error: found `(` when expecting identifier following\
    \ `int`.\\n/tmp/tmprr_wh9xy.d(15): Error: found `)` when expecting `;` following\
    \ statement\\n/tmp/tmprr_wh9xy.d(15): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmprr_wh9xy.d(121): Error: found `unittest` instead of statement\\\
    n/tmp/tmprr_wh9xy.d(129): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprr_wh9xy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_index\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_index\
    \ = 0;\n    long paren_level_count_max2 = 0;\n    long paren_level_count_max2_index\
    \ = 0;\n    long paren_level_count_min2 = 0;\n    long paren_level_count_min2_index\
    \ = 0;\n    long paren_level_count_max3 = 0;\n    long paren_level_count_max3_index\
    \ = 0;\n    long paren_level_count_min3 = 0;\n    long paren_level_count_min3_index\
    \ = 0;\n    long paren_level_count_max4 = 0;\n    long paren_level_count_max4_index\
    \ = 0;\n    long paren_level_count_min4 = 0;\n    long paren_level_count_min4_index\
    \ = 0;\n    long paren_level_count_max5 = 0;\n    long paren_level_count_max5_index\
    \ = 0;\n    long paren_level_count_min5 = 0;\n    long paren_level_count_min5_index\
    \ = 0;\n    long paren_level_count_max6 = 0;\n    long paren_level_count_max6_index\
    \ = 0;\n    long paren_level_count_min6 = 0;\n    long paren_level_count_min6_index\
    \ = 0;\n    long paren_level_count_max7 = 0;\n    long paren_level_count_max7_index\
    \ = 0;\n    long paren_level_count_min7 = 0;\n    long paren_level_count_min7_index\
    \ = 0;\n    long paren_level_count_max8 = 0;\n    long paren_level_count_max8_index\
    \ = 0;\n    long paren_level_count_min8 = 0;\n    long paren_level_count_min8_index\
    \ = 0;\n    long paren_level_count_max9 = 0;\n    long paren_level_count_max9_index\
    \ = 0;\n    long paren_level_count_min9 = 0;\n    long paren_level_count_min9_index\
    \ = 0;\n    long paren_level_count_max10 = 0;\n    long paren_level_count_max10_index\
    \ = 0;\n    long paren_level_count_min10 = 0;\n    long paren_level_count_min10_index\
    \ = 0;\n    long paren_level_count_max11 = 0;\n    long paren_level_count_max11_index\
    \ = 0;\n    long paren_level_count_min11 = 0;\n    long paren_level_count_min11_index\
    \ = 0;\n    long paren_level_count_max12 = 0;\n    long paren_level_count_max12_index\
    \ = 0;\n    long paren_level_count_min12 = 0;\n    long paren\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgopo2wpl.d(66): Error: semicolon expected, not `unittest`\\n/tmp/tmpgopo2wpl.d(66):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgopo2wpl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    while(i < paren_string.length())\n\
    \    {\n        char c = paren_string[i];\n        if(c == '(')\n        {\n \
    \           level++;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n            levels[i++] = level;\n\
    \        }\n        else if(c == ' ')\n        {\n            levels[i++] = level;\n\
    \        }\n        else if(c == '(')\n        {\n            level++;\n     \
    \       levels[i++] = level;\n        }\n        else if(c == ')')\n        {\n\
    \            level--;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == '(')\n        {\n            level++;\n            levels[i++] = level;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \       levels[i++] = level;\n        }\n        else if(c == '(')\n        {\n\
    \            level++;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n            levels[i++] = level;\n\
    \        }\n        else if(c == '(')\n        {\n            level++;\n     \
    \       levels[i++] = level;\n        }\n        else if(c == ')')\n        {\n\
    \            level--;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == '(')\n        {\n            level++;\n            levels[i++] = level;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \       levels[i++] = level;\n        }\n        else if(c == '(')\n        {\n\
    \            level++;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n            levels[i++] = level;\n\
    \        }\n        else if(c == '(')\n        {\n            level++;\n     \
    \       levels[i++] = level;\n        }\n        else if(c == ')')\n        {\n\
    \            level--;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == '(')\n        {\n            level++;\n            levels[i++] = level;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \       levels[i++] = level;\n        }\n        else if(c == '(')\n        {\n\
    \            level++;\n            levels[i++] = level;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n            levels[i++] = level;\n\
    \        }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0gp9glc5.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp0gp9glc5.d(127): Error: found `unittest` instead\
    \ of statement\\n/tmp/tmp0gp9glc5.d(135): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmp0gp9glc5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_counter2 = 0;\n  \
    \  long paren_level_max2 = 0;\n    long paren_level_counter3 = 0;\n    long paren_level_max3\
    \ = 0;\n    long paren_level_counter4 = 0;\n    long paren_level_max4 = 0;\n \
    \   long paren_level_counter5 = 0;\n    long paren_level_max5 = 0;\n    long paren_level_counter6\
    \ = 0;\n    long paren_level_max6 = 0;\n    long paren_level_counter7 = 0;\n \
    \   long paren_level_max7 = 0;\n    long paren_level_counter8 = 0;\n    long paren_level_max8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_max9 = 0;\n \
    \   long paren_level_counter10 = 0;\n    long paren_level_max10 = 0;\n    long\
    \ paren_level_counter11 = 0;\n    long paren_level_max11 = 0;\n    long paren_level_counter12\
    \ = 0;\n    long paren_level_max12 = 0;\n    long paren_level_counter13 = 0;\n\
    \    long paren_level_max13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_max14 = 0;\n    long paren_level_counter15 = 0;\n    long paren_level_max15\
    \ = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_max16 = 0;\n\
    \    long paren_level_counter17 = 0;\n    long paren_level_max17 = 0;\n    long\
    \ paren_level_counter18 = 0;\n    long paren_level_max18 = 0;\n    long paren_level_counter19\
    \ = 0;\n    long paren_level_max19 = 0;\n    long paren_level_counter20 = 0;\n\
    \    long paren_level_max20 = 0;\n    long paren_level_counter21 = 0;\n    long\
    \ paren_level_max21 = 0;\n    long paren_level_counter22 = 0;\n    long paren_level_max22\
    \ = 0;\n    long paren_level_counter23 = 0;\n    long paren_level_max23 = 0;\n\
    \    long paren_level_counter24 = 0;\n    long paren_level_max24 = 0;\n    long\
    \ paren_level_counter25 = 0;\n    long paren_level_max25 = 0;\n    long paren_level_counter26\
    \ = 0;\n    long paren_level_max26 = 0;\n    long paren_level_counter27 = 0;\n\
    \    long paren_level_max27 = 0;\n    long paren_level_counter28 = 0;\n    long\
    \ paren_level_max28\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa2cmvmoj.d(73): Error: semicolon expected, not `unittest`\\n/tmp/tmpa2cmvmoj.d(73):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpa2cmvmoj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long max_level = 0;\n    long current_level\
    \ = 0;\n    long current_paren = 0;\n    long current_paren_level = 0;\n    long\
    \ paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_diff =\
    \ 0;\n    long paren_level_count_diff_max = 0;\n    long paren_level_count_diff_min\
    \ = 0;\n    long paren_level_count_diff_avg = 0;\n    long paren_level_count_diff_sum\
    \ = 0;\n    long paren_level_count_diff_sum2 = 0;\n    long paren_level_count_diff_sum3\
    \ = 0;\n    long paren_level_count_diff_sum4 = 0;\n    long paren_level_count_diff_sum5\
    \ = 0;\n    long paren_level_count_diff_sum6 = 0;\n    long paren_level_count_diff_sum7\
    \ = 0;\n    long paren_level_count_diff_sum8 = 0;\n    long paren_level_count_diff_sum9\
    \ = 0;\n    long paren_level_count_diff_sum10 = 0;\n    long paren_level_count_diff_sum11\
    \ = 0;\n    long paren_level_count_diff_sum12 = 0;\n    long paren_level_count_diff_sum13\
    \ = 0;\n    long paren_level_count_diff_sum14 = 0;\n    long paren_level_count_diff_sum15\
    \ = 0;\n    long paren_level_count_diff_sum16 = 0;\n    long paren_level_count_diff_sum17\
    \ = 0;\n    long paren_level_count_diff_sum18 = 0;\n    long paren_level_count_diff_sum19\
    \ = 0;\n    long paren_level_count_diff_sum20 = 0;\n    long paren_level_count_diff_sum21\
    \ = 0;\n    long paren_level_count_diff_sum22 = 0;\n    long paren_level_count_diff_sum23\
    \ = 0;\n    long paren_level_count_diff_sum24 = 0;\n    long paren_level_count_diff_sum25\
    \ = 0;\n    long paren_level_count_diff_sum26 = 0;\n    long paren_level_count_diff_sum27\
    \ = 0;\n    long paren_level_count_diff_sum28 = 0;\n    long paren_level_count_diff_sum29\
    \ = 0;\n    long paren_level_count_diff_sum30 = 0;\n    long paren_level_count_diff_sum31\
    \ = 0;\n    long paren_level_count_diff_sum32 = 0;\n    long paren_level_count_diff_sum33\
    \ = 0;\n    long paren_level_count_diff_sum34 = 0;\n    long paren_level_count_diff_sum35\
    \ = 0;\n    long paren_level_count_diff_sum36 = 0;\n    long paren_level_count_diff_sum37\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdfbxeimn.d(64): Error: semicolon expected, not `unittest`\\n/tmp/tmpdfbxeimn.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpdfbxeimn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgtfnhgah.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpgtfnhgah.d(16): Error: no property `length`\
    \ for type `string`\\n/tmp/tmpgtfnhgah.d(17): Error: no property `length` for\
    \ type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgtfnhgah.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long level_index\
    \ = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren = false;\n\
    \    bool has_opening_curly_bracket_or_paren = false;\n    bool has_closing_curly_bracket_or_paren\
    \ = false;\n    bool has_opening_square_bracket_or_paren = false;\n    bool has_closing_square_bracket_or_paren\
    \ = false;\n    bool has_opening_curly_bracket_or_paren_or_space = false;\n  \
    \  bool has_closing_curly_bracket_or_paren_or_space = false;\n    bool has_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool has_closing_square_bracket_or_paren_or_space = false;\n \
    \   bool has_opening_curly_bracket_or_paren_or_space = false;\n    bool has_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool has_opening_square_bracket_or_paren_or_space = false;\n \
    \   bool has_closing_square_bracket_or_paren_or_space = false;\n    bool has_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool has_closing_curly_bracket_or_paren_or_space = false;\n  \
    \  bool has_opening_square_bracket_or_paren_or_space = false;\n    bool has_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool has_opening_curly_bracket_or_paren_or_space = false;\n  \
    \  bool has_closing_curly_bracket_or_paren_or_space = false;\n    bool has_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool has_closing_square_bracket_or_paren_or_space = false;\n \
    \   bool has_opening_curly_bracket_or_paren_or_space = false;\n    bool has_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool has_opening_square_bracket_or_paren_or_space = false;\n \
    \   bool has_closing_square_bracket_or_paren_or_space = false;\n    bool has_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool has_closing_curly_bracket_or_paren_or_space = false;\n  \
    \  bool has_opening_square_bracket_or_paren_or_space = false;\n    bool has_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool has_opening_curly_bracket_or_paren_or_space = false;\n  \
    \  bool has_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphy00k5yp.d(50): Error: semicolon expected, not `unittest`\\n/tmp/tmphy00k5yp.d(50):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphy00k5yp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    bool is_open = true;\n    long level\
    \ = 0;\n    long max_level = 0;\n    long max_level_pos = -1;\n    long pos =\
    \ 0;\n    long i = 0;\n    while(pos < paren_string.length())\n    {\n       \
    \ char c = paren_string[pos];\n        if(c == '(')\n        {\n            if(!is_open)\n\
    \            {\n                levels[pos] = level;\n                is_open\
    \ = true;\n                level++;\n            }\n        }\n        else if(c\
    \ == ')')\n        {\n            if(is_open)\n            {\n               \
    \ levels[pos] = level;\n                is_open = false;\n                level--;\n\
    \            }\n        }\n        else if(c == ' ')\n        {\n            if(!is_open)\n\
    \            {\n                levels[pos] = level;\n                is_open\
    \ = true;\n                level++;\n            }\n        }\n        else if(c\
    \ == '(')\n        {\n            if(!is_open)\n            {\n              \
    \  levels[pos] = level;\n                is_open = true;\n                level++;\n\
    \            }\n        }\n        else if(c == ')')\n        {\n            if(is_open)\n\
    \            {\n                levels[pos] = level;\n                is_open\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == '(')\n        {\n            if(!is_open)\n            {\n              \
    \  levels[pos] = level;\n                is_open = true;\n                level++;\n\
    \            }\n        }\n        else if(c == ')')\n        {\n            if(is_open)\n\
    \            {\n                levels[pos] = level;\n                is_open\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == '(')\n        {\n            if(!is_open)\n            {\n              \
    \  levels[pos] = level;\n                is_open = true;\n                level++;\n\
    \            }\n        }\n        else if(c == ')')\n        {\n            if(is_open)\n\
    \            {\n                levels[pos] = level;\n                is_open\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == '(')\n        {\n            if(!is_open)\n            {\n              \
    \  levels[pos] = level;\n                is_open = true;\n                level++;\n\
    \            }\n        }\n        else if(c == ')')\n        {\n            if(is_open)\n\
    \            {\n                levels[pos] = level;\n                is_open\
    \ = false;\n                level--;\n            }\n        }\n        else if(c\
    \ == '(')\n        {\n            if(!is_open)\n            {\n              \
    \  levels[pos] = level;\n                is_open = true;\n                level++;\n\
    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp072m3uky.d(131): Error: found `unittest` instead of statement\\\
    n/tmp/tmp072m3uky.d(139): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmp072m3uky.d(139): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmp072m3uky.d(139): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp072m3uky.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmy7cum19.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpmy7cum19.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpmy7cum19.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(21): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(25): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(27):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(31):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(33): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(35):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(37): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(39):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(41): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(43):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(45): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpmy7cum19.d(47):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpmy7cum19.d(49): Deprecatio"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string.trim();\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer = new\
    \ long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoan7125b.d(34): Error: semicolon expected, not `unittest`\\n/tmp/tmpoan7125b.d(34):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpoan7125b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    long paren_counter = 0;\n    long paren_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counter = 0;\n \
    \   long paren_counters_counters[] = new long[paren_string.length()];\n    long\
    \ paren_counters_counters_counter = 0;\n    long paren_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters[] = new long[paren_string.length()];\n\
    \    long paren_counters_counters_counters_counters_counter = 0;\n    long paren_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long paren_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long paren_counters_counters_counters_counters_counters_counters_counters_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ynugmof.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp4ynugmof.d(19): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] paren_counters`\\n/tmp/tmp4ynugmof.d(21):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(23): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters`\\n/tmp/tmp4ynugmof.d(25): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] paren_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(27): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters_counters_counters`\\n/tmp/tmp4ynugmof.d(29):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(31): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(33): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(35): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(37): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(39): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] paren_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp4ynugmof.d(41): Error: semicolon expected, not `unittest`\\n/tmp/tmp4ynugmof.d(41):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4ynugmof.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long level_counter\
    \ = 0;\n    long level_counters[MAX_LEVELS];\n    string paren_char;\n    string\
    \ paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n    string\
    \ paren_strings_copy;\n    string paren_strings_copy2;\n    string paren_strings_copy3;\n\
    \    string paren_strings_copy4;\n    string paren_strings_copy5;\n    string\
    \ paren_strings_copy6;\n    string paren_strings_copy7;\n    string paren_strings_copy8;\n\
    \    string paren_strings_copy9;\n    string paren_strings_copy10;\n    string\
    \ paren_strings_copy11;\n    string paren_strings_copy12;\n    string paren_strings_copy13;\n\
    \    string paren_strings_copy14;\n    string paren_strings_copy15;\n    string\
    \ paren_strings_copy16;\n    string paren_strings_copy17;\n    string paren_strings_copy18;\n\
    \    string paren_strings_copy19;\n    string paren_strings_copy20;\n    string\
    \ paren_strings_copy21;\n    string paren_strings_copy22;\n    string paren_strings_copy23;\n\
    \    string paren_strings_copy24;\n    string paren_strings_copy25;\n    string\
    \ paren_strings_copy26;\n    string paren_strings_copy27;\n    string paren_strings_copy28;\n\
    \    string paren_strings_copy29;\n    string paren_strings_copy30;\n    string\
    \ paren_strings_copy31;\n    string paren_strings_copy32;\n    string paren_strings_copy33;\n\
    \    string paren_strings_copy34;\n    string paren_strings_copy35;\n    string\
    \ paren_strings_copy36;\n    string paren_strings_copy37;\n    string paren_strings_copy38;\n\
    \    string paren_strings_copy39;\n    string paren_strings_copy40;\n    string\
    \ paren_strings_copy41;\n    string paren_strings_copy42;\n    string paren_strings_copy43;\n\
    \    string paren_strings_copy44;\n    string paren_strings_copy45;\n    string\
    \ paren_strings_copy46;\n    string paren_strings_copy47;\n    string paren_strings_copy48;\n\
    \    string paren_strings_copy49;\n    string paren_strings_copy50;\n    string\
    \ paren_strings_copy51;\n    string paren_strings_copy\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwgl3rpk1.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpwgl3rpk1.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] level_counters`\\n/tmp/tmpwgl3rpk1.d(20):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwgl3rpk1.d(21): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpwgl3rpk1.d(73):\
    \ Error: found `paren_strings_copy` when expecting `;` following statement\\n/tmp/tmpwgl3rpk1.d(74):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwgl3rpk1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_next = 0;\n    long paren_level_prev = 0;\n    long\
    \ paren_level_next2 = 0;\n    long paren_level_prev2 = 0;\n    long paren_level_next3\
    \ = 0;\n    long paren_level_prev3 = 0;\n    long paren_level_next4 = 0;\n   \
    \ long paren_level_prev4 = 0;\n    long paren_level_next5 = 0;\n    long paren_level_prev5\
    \ = 0;\n    long paren_level_next6 = 0;\n    long paren_level_prev6 = 0;\n   \
    \ long paren_level_next7 = 0;\n    long paren_level_prev7 = 0;\n    long paren_level_next8\
    \ = 0;\n    long paren_level_prev8 = 0;\n    long paren_level_next9 = 0;\n   \
    \ long paren_level_prev9 = 0;\n    long paren_level_next10 = 0;\n    long paren_level_prev10\
    \ = 0;\n    long paren_level_next11 = 0;\n    long paren_level_prev11 = 0;\n \
    \   long paren_level_next12 = 0;\n    long paren_level_prev12 = 0;\n    long paren_level_next13\
    \ = 0;\n    long paren_level_prev13 = 0;\n    long paren_level_next14 = 0;\n \
    \   long paren_level_prev14 = 0;\n    long paren_level_next15 = 0;\n    long paren_level_prev15\
    \ = 0;\n    long paren_level_next16 = 0;\n    long paren_level_prev16 = 0;\n \
    \   long paren_level_next17 = 0;\n    long paren_level_prev17 = 0;\n    long paren_level_next18\
    \ = 0;\n    long paren_level_prev18 = 0;\n    long paren_level_next19 = 0;\n \
    \   long paren_level_prev19 = 0;\n    long paren_level_next20 = 0;\n    long paren_level_prev20\
    \ = 0;\n    long paren_level_next21 = 0;\n    long paren_level_prev21 = 0;\n \
    \   long paren_level_next22 = 0;\n    long paren_level_prev22 = 0;\n    long paren_level_next23\
    \ = 0;\n    long paren_level_prev23 = 0;\n    long paren_level_next24 = 0;\n \
    \   long paren_level_prev24 = 0;\n    long paren_level_next25 = 0;\n    long paren_level_prev25\
    \ = 0;\n    long paren_level_next26 = 0;\n    long paren_level_prev26 = 0;\n \
    \   long paren_level_next27 = 0;\n    long paren_level_prev27 = 0;\n    long paren_level_next28\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5svokl7m.d(73): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5svokl7m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_paren = 0;\n    long level_paren\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_paren = 0;\n    long paren_level_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren = 0;\n    long paren_level_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren = 0;\n \
    \   long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp39uou67w.d(39): Error: semicolon expected, not `unittest`\\n/tmp/tmp39uou67w.d(39):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp39uou67w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_group;\n\
    \    long max_level = 0;\n    long level = 0;\n    long levels[MAX_GROUPS];\n\
    \    long max_levels[MAX_GROUPS];\n    long i;\n    long j;\n    long group;\n\
    \    long group_level;\n    long group_level_max;\n    long group_level_min;\n\
    \    long group_level_diff;\n    long group_level_diff_max;\n    long group_level_diff_min;\n\
    \    long group_level_diff_diff;\n    long group_level_diff_diff_max;\n    long\
    \ group_level_diff_diff_min;\n    long group_level_diff_diff_diff;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    long group_level_diff_diff_diff_max;\n\
    \    long group_level_diff_diff_diff_min;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpigw8ym_c.d(17): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_GROUPS] levels`\\n/tmp/tmpigw8ym_c.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_GROUPS] max_levels`\\n/tmp/tmpigw8ym_c.d(71):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpigw8ym_c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long num_parens\
    \ = 0;\n    long num_open = 0;\n    long num_close = 0;\n    long num_opening\
    \ = 0;\n    long num_closing = 0;\n    long num_opening_paren = 0;\n    long num_closing_paren\
    \ = 0;\n    long num_opening_paren_level = 0;\n    long num_closing_paren_level\
    \ = 0;\n    long num_opening_paren_level_open = 0;\n    long num_closing_paren_level_open\
    \ = 0;\n    long num_opening_paren_level_close = 0;\n    long num_closing_paren_level_close\
    \ = 0;\n    long num_opening_paren_level_open_paren = 0;\n    long num_closing_paren_level_open_paren\
    \ = 0;\n    long num_opening_paren_level_close_paren = 0;\n    long num_closing_paren_level_close_paren\
    \ = 0;\n    long num_opening_paren_level_open_paren_paren = 0;\n    long num_closing_paren_level_open_paren_paren\
    \ = 0;\n    long num_opening_paren_level_close_paren_paren = 0;\n    long num_closing_paren_level_close_paren_paren\
    \ = 0;\n    long num_opening_paren_level_open_paren_paren_paren = 0;\n    long\
    \ num_closing_paren_level_open_paren_paren_paren = 0;\n    long num_opening_paren_level_close_paren_paren_paren\
    \ = 0;\n    long num_closing_paren_level_close_paren_paren_paren = 0;\n    long\
    \ num_opening_paren_level_open_paren_paren_paren_paren = 0;\n    long num_closing_paren_level_open_paren_paren_paren_paren\
    \ = 0;\n    long num_opening_paren_level_close_paren_paren_paren_paren = 0;\n\
    \    long num_closing_paren_level_close_paren_paren_paren_paren = 0;\n    long\
    \ num_opening_paren_level_open_paren_paren_paren_paren_paren = 0;\n    long num_closing_paren_level_open_paren_paren_paren_paren_paren\
    \ = 0;\n    long num_opening_paren_level_close_paren_paren_paren_paren_paren =\
    \ 0;\n    long num_closing_paren_level_close_paren_paren_paren_paren_paren = 0;\n\
    \    long num_opening_paren_level_open_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long num_closing_paren_level_open_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long num_opening_paren_level_close_paren_paren_paren_\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppnfaqk7z.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmppnfaqk7z.d(53): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmppnfaqk7z.d(53): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnfaqk7z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack = 0;\n    long level_stack_top\
    \ = 0;\n    long level_count = 0;\n    long level_count_top = 0;\n    long level_count_stack\
    \ = 0;\n    long level_count_stack_top = 0;\n    long level_count_stack_count\
    \ = 0;\n    long level_count_stack_count_top = 0;\n    long level_count_stack_count2\
    \ = 0;\n    long level_count_stack_count_top2 = 0;\n    long level_count_stack_count3\
    \ = 0;\n    long level_count_stack_count_top3 = 0;\n    long level_count_stack_count4\
    \ = 0;\n    long level_count_stack_count_top4 = 0;\n    long level_count_stack_count5\
    \ = 0;\n    long level_count_stack_count_top5 = 0;\n    long level_count_stack_count6\
    \ = 0;\n    long level_count_stack_count_top6 = 0;\n    long level_count_stack_count7\
    \ = 0;\n    long level_count_stack_count_top7 = 0;\n    long level_count_stack_count8\
    \ = 0;\n    long level_count_stack_count_top8 = 0;\n    long level_count_stack_count9\
    \ = 0;\n    long level_count_stack_count_top9 = 0;\n    long level_count_stack_count10\
    \ = 0;\n    long level_count_stack_count_top10 = 0;\n    long level_count_stack_count11\
    \ = 0;\n    long level_count_stack_count_top11 = 0;\n    long level_count_stack_count12\
    \ = 0;\n    long level_count_stack_count_top12 = 0;\n    long level_count_stack_count13\
    \ = 0;\n    long level_count_stack_count_top13 = 0;\n    long level_count_stack_count14\
    \ = 0;\n    long level_count_stack_count_top14 = 0;\n    long level_count_stack_count15\
    \ = 0;\n    long level_count_stack_count_top15 = 0;\n    long level_count_stack_count16\
    \ = 0;\n    long level_count_stack_count_top16 = 0;\n    long level_count_stack_count17\
    \ = 0;\n    long level_count_stack_count_top17 = 0;\n    long level_count_stack_count18\
    \ = 0;\n    long level_count_stack_count_top18 = 0;\n    long level_count_stack_count19\
    \ = 0;\n    long level_count_stack_count_top19 = 0;\n    long level_count_stack_count20\
    \ = 0;\n    long level_count_stack_count_top20 = 0;\n    long level_count_stack_count21\
    \ = 0;\n    long level_count_stack_count_top21 = 0;\n    long level_count_stack_count22\
    \ = 0;\n    long level_count_stack_count_top22 = 0;\n    long level_count_stack_count23\
    \ = 0;\n    long level_count_stack_count_top23 = 0;\n    long level_count_stack_count24\
    \ = 0;\n    long level_count_stack_count_top24 = 0;\n    long level_count_stack_count25\
    \ = 0;\n    long level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbkyjaw71.d(72): Error: semicolon expected, not `unittest`\\n/tmp/tmpbkyjaw71.d(72):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbkyjaw71.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3t1cbbi5.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp3t1cbbi5.d(19): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] paren_levels`\\n/tmp/tmp3t1cbbi5.d(67): Error:\
    \ semicolon expected, not `unittest`\\n/tmp/tmp3t1cbbi5.d(67): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp3t1cbbi5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_string\
    \ = paren_string.trim();\n    string current_paren_string = \"\";\n    string\
    \ next_paren_string = \"\";\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_or_close_paren = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace =\
    \ false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren_or_close_brace_or_close_paren\
    \ = false;\n    bool in_paren_group_open_brace_or_close_paren_or_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo3opdads.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpo3opdads.d(41): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpo3opdads.d(41): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3opdads.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppc9nuwld.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmppc9nuwld.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(21): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(25): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(27):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(31):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(33): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(35):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(37): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(39):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(41): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(43):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(45): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmppc9nuwld.d(47):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmppc9nuwld.d(49): Deprecation: instead of C-style syntax, "
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_max = 0;\n    long paren_level_next2 = 0;\n    long paren_level_next3\
    \ = 0;\n    long paren_level_next4 = 0;\n    long paren_level_next5 = 0;\n   \
    \ long paren_level_next6 = 0;\n    long paren_level_next7 = 0;\n    long paren_level_next8\
    \ = 0;\n    long paren_level_next9 = 0;\n    long paren_level_next10 = 0;\n  \
    \  long paren_level_next11 = 0;\n    long paren_level_next12 = 0;\n    long paren_level_next13\
    \ = 0;\n    long paren_level_next14 = 0;\n    long paren_level_next15 = 0;\n \
    \   long paren_level_next16 = 0;\n    long paren_level_next17 = 0;\n    long paren_level_next18\
    \ = 0;\n    long paren_level_next19 = 0;\n    long paren_level_next20 = 0;\n \
    \   long paren_level_next21 = 0;\n    long paren_level_next22 = 0;\n    long paren_level_next23\
    \ = 0;\n    long paren_level_next24 = 0;\n    long paren_level_next25 = 0;\n \
    \   long paren_level_next26 = 0;\n    long paren_level_next27 = 0;\n    long paren_level_next28\
    \ = 0;\n    long paren_level_next29 = 0;\n    long paren_level_next30 = 0;\n \
    \   long paren_level_next31 = 0;\n    long paren_level_next32 = 0;\n    long paren_level_next33\
    \ = 0;\n    long paren_level_next34 = 0;\n    long paren_level_next35 = 0;\n \
    \   long paren_level_next36 = 0;\n    long paren_level_next37 = 0;\n    long paren_level_next38\
    \ = 0;\n    long paren_level_next39 = 0;\n    long paren_level_next40 = 0;\n \
    \   long paren_level_next41 = 0;\n    long paren_level_next42 = 0;\n    long paren_level_next43\
    \ = 0;\n    long paren_level_next44 = 0;\n    long paren_level_next45 = 0;\n \
    \   long paren_level_next46 = 0;\n    long paren_level_next47 = 0;\n    long paren_level_next48\
    \ = 0;\n    long paren_level_next49 = 0;\n    long paren_level_next50 = 0;\n \
    \   long paren_level_next51 = 0;\n    long paren_level_next52 = 0;\n    long paren_level_next53\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpie1rv597.d(72): Error: semicolon expected, not `unittest`\\n/tmp/tmpie1rv597.d(72):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpie1rv597.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    bool is_open =\
    \ false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n  \
    \  bool is_closing_paren = false;\n    bool is_opening_paren_or_closed = false;\n\
    \    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmper8we4zc.d(40): Error: semicolon expected, not `unittest`\\n/tmp/tmper8we4zc.d(40):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmper8we4zc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long\
    \ paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long paren_level_max3\
    \ = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4 = 0;\n    long\
    \ paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long paren_level_cur5\
    \ = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6 = 0;\n    long\
    \ paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long paren_level_max8\
    \ = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9 = 0;\n    long\
    \ paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long paren_level_cur10\
    \ = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11 = 0;\n   \
    \ long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n    long paren_level_max13\
    \ = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14 = 0;\n   \
    \ long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n    long paren_level_cur15\
    \ = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16 = 0;\n   \
    \ long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n    long paren_level_max18\
    \ = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19 = 0;\n   \
    \ long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n    long paren_level_cur20\
    \ = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21 = 0;\n   \
    \ long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n    long paren_level_max23\
    \ = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24 = 0;\n   \
    \ long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n    long paren_level_cur25\
    \ = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26 = 0;\n   \
    \ long paren_level_max27 = 0;\n    long paren_level_cur27 = 0;\n    long paren_level_max28\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwt7fup9.d(73): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwt7fup9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_max_index = 0;\n    long paren_level_count_min = 0;\n\
    \    long paren_level_count_min_index = 0;\n    long paren_level_count_max2 =\
    \ 0;\n    long paren_level_count_max2_index = 0;\n    long paren_level_count_min2\
    \ = 0;\n    long paren_level_count_min2_index = 0;\n    long paren_level_count_max3\
    \ = 0;\n    long paren_level_count_max3_index = 0;\n    long paren_level_count_min3\
    \ = 0;\n    long paren_level_count_min3_index = 0;\n    long paren_level_count_max4\
    \ = 0;\n    long paren_level_count_max4_index = 0;\n    long paren_level_count_min4\
    \ = 0;\n    long paren_level_count_min4_index = 0;\n    long paren_level_count_max5\
    \ = 0;\n    long paren_level_count_max5_index = 0;\n    long paren_level_count_min5\
    \ = 0;\n    long paren_level_count_min5_index = 0;\n    long paren_level_count_max6\
    \ = 0;\n    long paren_level_count_max6_index = 0;\n    long paren_level_count_min6\
    \ = 0;\n    long paren_level_count_min6_index = 0;\n    long paren_level_count_max7\
    \ = 0;\n    long paren_level_count_max7_index = 0;\n    long paren_level_count_min7\
    \ = 0;\n    long paren_level_count_min7_index = 0;\n    long paren_level_count_max8\
    \ = 0;\n    long paren_level_count_max8_index = 0;\n    long paren_level_count_min8\
    \ = 0;\n    long paren_level_count_min8_index = 0;\n    long paren_level_count_max9\
    \ = 0;\n    long paren_level_count_max9_index = 0;\n    long paren_level_count_min9\
    \ = 0;\n    long paren_level_count_min9_index = 0;\n    long paren_level_count_max10\
    \ = 0;\n    long paren_level_count_max10_index = 0;\n    long paren_level_count_min10\
    \ = 0;\n    long paren_level_count_min10_index = 0;\n    long paren_level_count_max11\
    \ = 0;\n    long paren_level_count_max11_index = 0;\n    long paren_level_count_min11\
    \ = 0;\n    long paren_level_count_min11_index = 0;\n    long paren_level_count_max12\
    \ = 0;\n    long paren_level_count_max12_index = 0;\n    long paren_level_count_min\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn80w8w49.d(65): Error: semicolon expected, not `unittest`\\n/tmp/tmpn80w8w49.d(65):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpn80w8w49.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening\
    \ = false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpymc7298t.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpymc7298t.d(63): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpymc7298t.d(63): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymc7298t.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_index46 = 0;\n    long paren_levels_index47 = 0;\n    long\
    \ paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprj1z_b7x.d(17): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] paren_levels`\\n/tmp/tmprj1z_b7x.d(66): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmprj1z_b7x.d(66): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprj1z_b7x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_current = 0;\n   \
    \ long paren_level_next = 0;\n    long paren_level_next_max = 0;\n    long paren_level_next_current\
    \ = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_max\
    \ = 0;\n    long paren_level_next_next_current = 0;\n    long paren_level_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_max = 0;\n    long paren_level_next_next_next_current\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_current = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_current\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_current = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_current\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_current = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_current\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_current = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_current\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n    long paren_level_next_next_next_next_current = 0;\n    long paren_level_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_max = 0;\n    long paren_level_next_next_next_next_current\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_max\
    \ = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeeonibk0.d(61): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeeonibk0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwj4f2z13.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpwj4f2z13.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(21): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(25): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(27):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(31):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(33): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(35):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(37): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(39):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(41): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(43):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(45): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpwj4f2z13.d(47):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmpwj4f2z13.d(49): Deprecation: instead of C-style syntax, "
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool has_opening_paren = false;\n    bool has_closing_paren = false;\n\
    \    bool is_last_paren = false;\n    bool is_last_group = false;\n    bool is_last_group_opening_paren\
    \ = false;\n    bool is_last_group_closing_paren = false;\n    bool is_last_group_opening_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_paren = false;\n  \
    \  bool is_last_group_opening_closing_closing_closing_paren = false;\n    bool\
    \ is_last_group_opening_closing_closing_closing_closing_paren = false;\n    bool\
    \ is_last_group_opening_closing_closing_closing_closing_closing_paren = false;\n\
    \    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_closing_paren\
    \ = false;\n    bool is_last_group_opening_closing_closing_closing_closing_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpea2en7r4.d(42): Error: semicolon expected, not `unittest`\\n/tmp/tmpea2en7r4.d(42):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpea2en7r4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_string\
    \ = paren_string.trim();\n    string current_paren_string = paren_string;\n  \
    \  string next_paren_string = paren_string;\n    string current_paren_string =\
    \ paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\n    string current_paren_string\
    \ = paren_string;\n    string next_paren_string = paren_string;\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdtr2d596.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpdtr2d596.d(66): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpdtr2d596.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long parens = 0;\n\
    \    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_max_index\
    \ = 0;\n    long parens_level_max_index2 = 0;\n    long parens_level_max_index3\
    \ = 0;\n    long parens_level_max_index4 = 0;\n    long parens_level_max_index5\
    \ = 0;\n    long parens_level_max_index6 = 0;\n    long parens_level_max_index7\
    \ = 0;\n    long parens_level_max_index8 = 0;\n    long parens_level_max_index9\
    \ = 0;\n    long parens_level_max_index10 = 0;\n    long parens_level_max_index11\
    \ = 0;\n    long parens_level_max_index12 = 0;\n    long parens_level_max_index13\
    \ = 0;\n    long parens_level_max_index14 = 0;\n    long parens_level_max_index15\
    \ = 0;\n    long parens_level_max_index16 = 0;\n    long parens_level_max_index17\
    \ = 0;\n    long parens_level_max_index18 = 0;\n    long parens_level_max_index19\
    \ = 0;\n    long parens_level_max_index20 = 0;\n    long parens_level_max_index21\
    \ = 0;\n    long parens_level_max_index22 = 0;\n    long parens_level_max_index23\
    \ = 0;\n    long parens_level_max_index24 = 0;\n    long parens_level_max_index25\
    \ = 0;\n    long parens_level_max_index26 = 0;\n    long parens_level_max_index27\
    \ = 0;\n    long parens_level_max_index28 = 0;\n    long parens_level_max_index29\
    \ = 0;\n    long parens_level_max_index30 = 0;\n    long parens_level_max_index31\
    \ = 0;\n    long parens_level_max_index32 = 0;\n    long parens_level_max_index33\
    \ = 0;\n    long parens_level_max_index34 = 0;\n    long parens_level_max_index35\
    \ = 0;\n    long parens_level_max_index36 = 0;\n    long parens_level_max_index37\
    \ = 0;\n    long parens_level_max_index38 = 0;\n    long parens_level_max_index39\
    \ = 0;\n    long parens_level_max_index40 = 0;\n    long parens_level_max_index41\
    \ = 0;\n    long parens_level_max_index42 = 0;\n    long parens_level_max_index43\
    \ = 0;\n    long parens_level_max_index44 = 0;\n    long parens_level_max_index45\
    \ = 0;\n    long parens_level_max_index46 = 0;\n    long parens_level_max_index47\
    \ = 0;\n    long parens_level_max_index48\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7oriym54.d(67): Error: semicolon expected, not `unittest`\\n/tmp/tmp7oriym54.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7oriym54.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren =\
    \ false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace = false;\n    bool in_group_close_brace_or_open_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace = false;\n\
    \    bool in_group_close_brace_or_open_brace_or_close_brace = false;\n    bool\
    \ in_group_open_brace_or_close_brace_or_open_brace_or_close_brace = false;\n \
    \   bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_b\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy0aj3nah.d(35): Error: semicolon expected, not `unittest`\\n/tmp/tmpy0aj3nah.d(35):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpy0aj3nah.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_diff = 0;\n    long paren_level_diff2 = 0;\n    long paren_level_diff3\
    \ = 0;\n    long paren_level_diff4 = 0;\n    long paren_level_diff5 = 0;\n   \
    \ long paren_level_diff6 = 0;\n    long paren_level_diff7 = 0;\n    long paren_level_diff8\
    \ = 0;\n    long paren_level_diff9 = 0;\n    long paren_level_diff10 = 0;\n  \
    \  long paren_level_diff11 = 0;\n    long paren_level_diff12 = 0;\n    long paren_level_diff13\
    \ = 0;\n    long paren_level_diff14 = 0;\n    long paren_level_diff15 = 0;\n \
    \   long paren_level_diff16 = 0;\n    long paren_level_diff17 = 0;\n    long paren_level_diff18\
    \ = 0;\n    long paren_level_diff19 = 0;\n    long paren_level_diff20 = 0;\n \
    \   long paren_level_diff21 = 0;\n    long paren_level_diff22 = 0;\n    long paren_level_diff23\
    \ = 0;\n    long paren_level_diff24 = 0;\n    long paren_level_diff25 = 0;\n \
    \   long paren_level_diff26 = 0;\n    long paren_level_diff27 = 0;\n    long paren_level_diff28\
    \ = 0;\n    long paren_level_diff29 = 0;\n    long paren_level_diff30 = 0;\n \
    \   long paren_level_diff31 = 0;\n    long paren_level_diff32 = 0;\n    long paren_level_diff33\
    \ = 0;\n    long paren_level_diff34 = 0;\n    long paren_level_diff35 = 0;\n \
    \   long paren_level_diff36 = 0;\n    long paren_level_diff37 = 0;\n    long paren_level_diff38\
    \ = 0;\n    long paren_level_diff39 = 0;\n    long paren_level_diff40 = 0;\n \
    \   long paren_level_diff41 = 0;\n    long paren_level_diff42 = 0;\n    long paren_level_diff43\
    \ = 0;\n    long paren_level_diff44 = 0;\n    long paren_level_diff45 = 0;\n \
    \   long paren_level_diff46 = 0;\n    long paren_level_diff47 = 0;\n    long paren_level_diff48\
    \ = 0;\n    long paren_level_diff49 = 0;\n    long paren_level_diff50 = 0;\n \
    \   long paren_level_diff51 = 0;\n    long paren_level_diff52 = 0;\n    long paren_level_diff53\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuq81mbau.d(72): Error: semicolon expected, not `unittest`\\n/tmp/tmpuq81mbau.d(72):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpuq81mbau.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closed = false;\n  \
    \  bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3_c6oq7d.d(41): Error: semicolon expected, not `unittest`\\n/tmp/tmp3_c6oq7d.d(41):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3_c6oq7d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb39agw9f.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpb39agw9f.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpb39agw9f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] max_levels = new long[paren_string.length()];\n\
    \    long[] current_levels = new long[paren_string.length()];\n    long[] max_levels_index\
    \ = new long[paren_string.length()];\n    long[] current_levels_index = new long[paren_string.length()];\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            current_levels[i] = 1;\n            current_levels_index[i]\
    \ = i;\n        }\n        else if(paren_string[i] == ')') {\n            current_levels[i]--;\n\
    \            if(current_levels[i] < 0) {\n                throw new Exception(\"\
    Invalid nested parenthesis\");\n            }\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            levels[i] = current_levels[i];\n            max_levels[i]\
    \ = current_levels[i];\n            max_levels_index[i] = i;\n        }\n    }\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == ' ') {\n            levels[i] = current_levels[i];\n            max_levels[i]\
    \ = current_levels[i];\n            max_levels_index[i] = i;\n        }\n    }\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            current_levels[i] = 1;\n            current_levels_index[i]\
    \ = i;\n        }\n        else if(paren_string[i] == ')') {\n            current_levels[i]--;\n\
    \            if(current_levels[i] < 0) {\n                throw new Exception(\"\
    Invalid nested parenthesis\");\n            }\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            levels[i] = current_levels[i];\n            max_levels[i]\
    \ = current_levels[i];\n            max_levels_index[i] = i;\n        }\n    }\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            current_levels[i] = 1;\n            current_levels_index[i]\
    \ = i;\n        }\n        else if(paren_string[i] == ')') {\n            current_levels[i]--;\n\
    \            if(current_levels[i] < 0) {\n                throw new Exception(\"\
    Invalid nested parenthesis\");\n            }\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            levels[i] = current_levels[i];\n            max_levels[i]\
    \ = current_levels[i];\n            max_levels_index[i] = i;\n        }\n    }\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            current_levels[i] = 1;\n            current_levels_index[i]\
    \ = i;\n        }\n        else if(paren_string[i] == ')') {\n            current_levels[i]--;\n\
    \            if(current_levels[i] < 0) {\n                throw new Exception(\"\
    Invalid nested parenthesis\");\n            }\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            levels[i] = current_levels[i];\n            max_levels[i]\
    \ = current_levels[i];\n            max_levels_index[i] = i;\n        }\n    }\n\
    \    \n    for(int i = 0; i < paren_string\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwl08oazg.d(101): Error: found `unittest` when expecting `;` following\
    \ `for` condition\\n/tmp/tmpwl08oazg.d(109): Error: found `void` when expecting\
    \ `)`\\n/tmp/tmpwl08oazg.d(109): Error: found `{` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwl08oazg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_sum = 0;\n  \
    \  long paren_level_count_sum_max = 0;\n    long paren_level_count_sum_min = 0;\n\
    \    long paren_level_count_sum_avg = 0;\n    long paren_level_count_sum_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_min = 0;\n    long paren_level_count_sum_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjyp32hwa.d(60): Error: semicolon expected, not `unittest`\\n/tmp/tmpjyp32hwa.d(60):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjyp32hwa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,c#,parentheses,string\
    \ |>\n<| a dscore=0 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpst5u6txt.d(30): Error: declaration expected, not `<`\\n/tmp/tmpst5u6txt.d(35):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmpst5u6txt.d(35): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmpst5u6txt.d(36): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmpst5u6txt.d(36): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmpst5u6txt.d(37): Error: semicolon expected, not `.`\\n/tmp/tmpst5u6txt.d(37):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmpst5u6txt.d(38): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmpst5u6txt.d(38): Error: no identifier for\
    \ declarator `.Text.RegularExpressions`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpst5u6txt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n    long\
    \ level_counter = 0;\n    long level_counters[] = new long[MAX_LEVELS];\n    long\
    \ level_counters_index = 0;\n    long level_counters_index2 = 0;\n    long level_counters_index3\
    \ = 0;\n    long level_counters_index4 = 0;\n    long level_counters_index5 =\
    \ 0;\n    long level_counters_index6 = 0;\n    long level_counters_index7 = 0;\n\
    \    long level_counters_index8 = 0;\n    long level_counters_index9 = 0;\n  \
    \  long level_counters_index10 = 0;\n    long level_counters_index11 = 0;\n  \
    \  long level_counters_index12 = 0;\n    long level_counters_index13 = 0;\n  \
    \  long level_counters_index14 = 0;\n    long level_counters_index15 = 0;\n  \
    \  long level_counters_index16 = 0;\n    long level_counters_index17 = 0;\n  \
    \  long level_counters_index18 = 0;\n    long level_counters_index19 = 0;\n  \
    \  long level_counters_index20 = 0;\n    long level_counters_index21 = 0;\n  \
    \  long level_counters_index22 = 0;\n    long level_counters_index23 = 0;\n  \
    \  long level_counters_index24 = 0;\n    long level_counters_index25 = 0;\n  \
    \  long level_counters_index26 = 0;\n    long level_counters_index27 = 0;\n  \
    \  long level_counters_index28 = 0;\n    long level_counters_index29 = 0;\n  \
    \  long level_counters_index30 = 0;\n    long level_counters_index31 = 0;\n  \
    \  long level_counters_index32 = 0;\n    long level_counters_index33 = 0;\n  \
    \  long level_counters_index34 = 0;\n    long level_counters_index35 = 0;\n  \
    \  long level_counters_index36 = 0;\n    long level_counters_index37 = 0;\n  \
    \  long level_counters_index38 = 0;\n    long level_counters_index39 = 0;\n  \
    \  long level_counters_index40 = 0;\n    long level_counters_index41 = 0;\n  \
    \  long level_counters_index42 = 0;\n    long level_counters_index43 = 0;\n  \
    \  long level_counters_index44 = 0;\n    long level_counters_index45 = 0;\n  \
    \  long level_counters_index46 = 0;\n    long level_counters_index47 = 0;\n  \
    \  long level_counters_index48 = 0;\n    long level_counters_index49 = 0;\n  \
    \  long level_counters_index50 = 0;\n    long level_counters_index51 = 0;\n  \
    \  long level_counters_index52 = 0;\n    long level_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7b4uu7u0.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp7b4uu7u0.d(18): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] level_counters`\\n/tmp/tmp7b4uu7u0.d(72):\
    \ Error: semicolon expected, not `unittest`\\n/tmp/tmp7b4uu7u0.d(72): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp7b4uu7u0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_chars[MAX_LEVELS];\n\
    \    string current_paren_char;\n    string next_paren_char;\n    string next_paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_string;\n    string paren_strings[MAX_LEVELS];\n    string paren_string;\n\
    \    string paren_strings[MAX_LEVELS];\n    string paren_string;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa_dci52o.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpa_dci52o.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpa_dci52o.d(20):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ next_paren_chars`\\n/tmp/tmpa_dci52o.d(22): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpa_dci52o.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(25): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpa_dci52o.d(27):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpa_dci52o.d(31):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(33): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpa_dci52o.d(35):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(37): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpa_dci52o.d(39):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(41): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpa_dci52o.d(43):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(45): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_strings`\\n/tmp/tmpa_dci52o.d(47):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpa_dci52o.d(49): Deprecati"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next = 0;\n    long paren_level_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ng3d7_v.d(50): Error: semicolon expected, not `unittest`\\n/tmp/tmp8ng3d7_v.d(50):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8ng3d7_v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_cur\
    \ = 0;\n    long paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long\
    \ paren_level_max3 = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4\
    \ = 0;\n    long paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long\
    \ paren_level_cur5 = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6\
    \ = 0;\n    long paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long\
    \ paren_level_max8 = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9\
    \ = 0;\n    long paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long\
    \ paren_level_cur10 = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11\
    \ = 0;\n    long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n   \
    \ long paren_level_max13 = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14\
    \ = 0;\n    long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n   \
    \ long paren_level_cur15 = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16\
    \ = 0;\n    long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n   \
    \ long paren_level_max18 = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19\
    \ = 0;\n    long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n   \
    \ long paren_level_cur20 = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21\
    \ = 0;\n    long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n   \
    \ long paren_level_max23 = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24\
    \ = 0;\n    long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n   \
    \ long paren_level_cur25 = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26\
    \ = 0;\n    long paren_level_max27 = 0;\n    long paren_level_cur27 = 0;\n   \
    \ long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4pjk4vuh.d(73): Error: semicolon expected, not `unittest`\\n/tmp/tmp4pjk4vuh.d(73):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4pjk4vuh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    while(i < paren_string.length())\n    {\n        char c\
    \ = paren_string[i];\n        if(c == '(')\n        {\n            level++;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \   }\n        levels[i] = level;\n        i++;\n    }\n    long max_level = levels[0];\n\
    \    for(long i = 1; i < levels.length; i++)\n    {\n        if(levels[i] > max_level)\n\
    \        {\n            max_level = levels[i];\n        }\n    }\n    long[] result\
    \ = new long[max_level + 1];\n    for(long i = 0; i < levels.length; i++)\n  \
    \  {\n        result[levels[i]] = levels[i];\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=parsing,c#,parentheses,string |>\n<| a tags=parsing,c#,parentheses,string\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Text.RegularExpressions;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyen0q4qb.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpyen0q4qb.d(47): Error: declaration expected,\
    \ not `<`\\n/tmp/tmpyen0q4qb.d(52): Error: semicolon expected, not `.`\\n/tmp/tmpyen0q4qb.d(52):\
    \ Error: no identifier for declarator `.Collections.Generic`\\n/tmp/tmpyen0q4qb.d(53):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmpyen0q4qb.d(53): Error: no identifier\
    \ for declarator `.Linq`\\n/tmp/tmpyen0q4qb.d(54): Error: semicolon expected,\
    \ not `.`\\n/tmp/tmpyen0q4qb.d(54): Error: no identifier for declarator `.Text`\\\
    n/tmp/tmpyen0q4qb.d(55): Error: semicolon expected, not `.`\\n/tmp/tmpyen0q4qb.d(55):\
    \ Error: no identifier for declarator `.Text.RegularExpressions`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyen0q4qb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack = new long[paren_groups.length()];\n\
    \    long[] max_levels_stack_pointer = new long[paren_groups.length()];\n    long[]\
    \ max_levels_stack_pointer_pointer = new long[paren_groups.length()];\n    long[]\
    \ max_levels_stack_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] max_levels_stack_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer = new long[paren_groups.length()];\n\
    \    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer =\
    \ new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_\
    \ = new long[paren_groups.length()];\n    long[] max_levels_stack_pointer_pointer_pointer\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkfmhje6h.d(35): Error: semicolon expected, not `unittest`\\n/tmp/tmpkfmhje6h.d(35):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkfmhje6h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_chars[MAX_LEVELS];\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++) {\n        char c =\
    \ paren_string[i];\n        if(c == '(') {\n            levels[level] = level;\n\
    \            level++;\n            paren_chars[level] = c;\n        } else if(c\
    \ == ')') {\n            level--;\n            if(levels[level] == 0) {\n    \
    \            throw runtime_error(\"Unbalanced parenthesis\");\n            }\n\
    \            levels[level] = level;\n            level++;\n            paren_chars[level]\
    \ = c;\n        } else {\n            levels[level] = level;\n            level++;\n\
    \            paren_chars[level] = c;\n        }\n    }\n    \n    for(int i =\
    \ 0; i < level; i++) {\n        max_level = max(max_level, levels[i]);\n    }\n\
    \    \n    long[] result = new long[max_level + 1];\n    for(int i = 0; i < level;\
    \ i++) {\n        result[i] = levels[i];\n    }\n    \n    for(int i = level;\
    \ i < MAX_LEVELS; i++) {\n        result[i] = levels[MAX_LEVELS - 1];\n    }\n\
    \    \n    return result;\n}\n</code>\n<|/ a tags=algorithm,string,c++ |>\n<|\
    \ c |>\nThis looks great, thank you! I haven't had time to test it yet, but I'll\
    \ let you know how it goes.\n<|/ c |>\n<| c |>\nI tested it and it works great!\
    \ I modified it a little bit to make it more efficient and to handle cases where\
    \ there are multiple nested parentheses.\n<|/ c |>\n<| a tags=algorithm,string,c++\
    \ |>\nI wrote a recursive solution in Python, using only basic Python libraries.\n\
    <code>\ndef paren_levels(s):\n    level = 0\n    levels = []\n    stack = []\n\
    \    stack.append(0)\n    levels.append(level)\n    \n    while stack:\n     \
    \   level = stack.pop()\n        \n        if level == 0:\n            levels.append(level)\n\
    \            \n        elif level > 0:\n            stack.append(level - 1)\n\
    \            \n        elif level < len(levels) - 1:\n            stack.append(level\
    \ + 1)\n            \n        else:\n            levels.append(level)\n      \
    \      \n    return levels\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,string,c++\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <vector>\n#include\
    \ <algorithm>\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n   \
    \ assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n  \
    \  assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjp4fbd1m.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpjp4fbd1m.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpjp4fbd1m.d(55):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpjp4fbd1m.d(58): Error: unterminated\
    \ character constant\\n/tmp/tmpjp4fbd1m.d(58): Error: unterminated character constant\\\
    n/tmp/tmpjp4fbd1m.d(101): Error: declaration expected, not `assert`\\n/tmp/tmpjp4fbd1m.d(102):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpjp4fbd1m.d(103): Error:\
    \ declaration expected, not `assert`\\n/tmp/tmpjp4fbd1m.d(104): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjp4fbd1m.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    bool is_open[MAX_LEVELS];\n\
    \    bool is_close[MAX_LEVELS];\n    bool is_open2[MAX_LEVELS];\n    bool is_close2[MAX_LEVELS];\n\
    \    bool is_open3[MAX_LEVELS];\n    bool is_close3[MAX_LEVELS];\n    bool is_open4[MAX_LEVELS];\n\
    \    bool is_close4[MAX_LEVELS];\n    bool is_open5[MAX_LEVELS];\n    bool is_close5[MAX_LEVELS];\n\
    \    bool is_open6[MAX_LEVELS];\n    bool is_close6[MAX_LEVELS];\n    bool is_open7[MAX_LEVELS];\n\
    \    bool is_close7[MAX_LEVELS];\n    bool is_open8[MAX_LEVELS];\n    bool is_close8[MAX_LEVELS];\n\
    \    bool is_open9[MAX_LEVELS];\n    bool is_close9[MAX_LEVELS];\n    bool is_open10[MAX_LEVELS];\n\
    \    bool is_close10[MAX_LEVELS];\n    bool is_open11[MAX_LEVELS];\n    bool is_close11[MAX_LEVELS];\n\
    \    bool is_open12[MAX_LEVELS];\n    bool is_close12[MAX_LEVELS];\n    bool is_open13[MAX_LEVELS];\n\
    \    bool is_close13[MAX_LEVELS];\n    bool is_open14[MAX_LEVELS];\n    bool is_close14[MAX_LEVELS];\n\
    \    bool is_open15[MAX_LEVELS];\n    bool is_close15[MAX_LEVELS];\n    bool is_open16[MAX_LEVELS];\n\
    \    bool is_close16[MAX_LEVELS];\n    bool is_open17[MAX_LEVELS];\n    bool is_close17[MAX_LEVELS];\n\
    \    bool is_open18[MAX_LEVELS];\n    bool is_close18[MAX_LEVELS];\n    bool is_open19[MAX_LEVELS];\n\
    \    bool is_close19[MAX_LEVELS];\n    bool is_open20[MAX_LEVELS];\n    bool is_close20[MAX_LEVELS];\n\
    \    bool is_open21[MAX_LEVELS];\n    bool is_close21[MAX_LEVELS];\n    bool is_open22[MAX_LEVELS];\n\
    \    bool is_close22[MAX_LEVELS];\n    bool is_open23[MAX_LEVELS];\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdzxetyvp.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpdzxetyvp.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_open`\\n/tmp/tmpdzxetyvp.d(18):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_close`\\n/tmp/tmpdzxetyvp.d(19): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `bool[MAX_LEVELS] is_open2`\\n/tmp/tmpdzxetyvp.d(20): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close2`\\\
    n/tmp/tmpdzxetyvp.d(21): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[MAX_LEVELS] is_open3`\\n/tmp/tmpdzxetyvp.d(22): Deprecation: instead of\
    \ C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close3`\\n/tmp/tmpdzxetyvp.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_open4`\\n/tmp/tmpdzxetyvp.d(24): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `bool[MAX_LEVELS] is_close4`\\n/tmp/tmpdzxetyvp.d(25): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_open5`\\\
    n/tmp/tmpdzxetyvp.d(26): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[MAX_LEVELS] is_close5`\\n/tmp/tmpdzxetyvp.d(27): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_open6`\\n/tmp/tmpdzxetyvp.d(28):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_close6`\\n/tmp/tmpdzxetyvp.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `bool[MAX_LEVELS] is_open7`\\n/tmp/tmpdzxetyvp.d(30): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close7`\\\
    n/tmp/tmpdzxetyvp.d(31): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[MAX_LEVELS] is_open8`\\n/tmp/tmpdzxetyvp.d(32): Deprecation: instead of\
    \ C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close8`\\n/tmp/tmpdzxetyvp.d(33):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_open9`\\n/tmp/tmpdzxetyvp.d(34): De"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_nesting = 1;\n    long paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_nesting_levels[] = new long[paren_string.length()];\n    long\
    \ paren_levels_size = 0;\n    long paren_nesting_levels_size = 0;\n    long paren_levels_index\
    \ = 0;\n    long paren_nesting_levels_index = 0;\n    long paren_levels_size_index\
    \ = 0;\n    long paren_nesting_levels_size_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_nesting_levels_index2 = 0;\n    long paren_levels_size_index2\
    \ = 0;\n    long paren_nesting_levels_size_index2 = 0;\n    long paren_levels_index3\
    \ = 0;\n    long paren_nesting_levels_index3 = 0;\n    long paren_levels_size_index3\
    \ = 0;\n    long paren_nesting_levels_size_index3 = 0;\n    long paren_levels_index4\
    \ = 0;\n    long paren_nesting_levels_index4 = 0;\n    long paren_levels_size_index4\
    \ = 0;\n    long paren_nesting_levels_size_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_nesting_levels_index5 = 0;\n    long paren_levels_size_index5\
    \ = 0;\n    long paren_nesting_levels_size_index5 = 0;\n    long paren_levels_index6\
    \ = 0;\n    long paren_nesting_levels_index6 = 0;\n    long paren_levels_size_index6\
    \ = 0;\n    long paren_nesting_levels_size_index6 = 0;\n    long paren_levels_index7\
    \ = 0;\n    long paren_nesting_levels_index7 = 0;\n    long paren_levels_size_index7\
    \ = 0;\n    long paren_nesting_levels_size_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_nesting_levels_index8 = 0;\n    long paren_levels_size_index8\
    \ = 0;\n    long paren_nesting_levels_size_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_nesting_levels_index9 = 0;\n    long paren_levels_size_index9\
    \ = 0;\n    long paren_nesting_levels_size_index9 = 0;\n    long paren_levels_index10\
    \ = 0;\n    long paren_nesting_levels_index10 = 0;\n    long paren_levels_size_index10\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9g5aqjf_.d(18): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] paren_levels`\\n/tmp/tmp9g5aqjf_.d(19): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[] paren_nesting_levels`\\n/tmp/tmp9g5aqjf_.d(61):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9g5aqjf_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string.trim();\n    long[] max_levels_of_nesting = new long[paren_groups.length()];\n\
    \    long max_levels_of_nesting_level = 0;\n    long levels_of_nesting_level =\
    \ 0;\n    long current_level = 0;\n    long current_level_of_nesting_level = 0;\n\
    \    long current_level_of_nesting_level_of_nesting_level = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level_of_nesting_level\
    \ = 0;\n    long current_level_of_nesting_level_of_nesting_level_of_nest\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpewr6bqy0.d(33): Error: semicolon expected, not `unittest`\\n/tmp/tmpewr6bqy0.d(33):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpewr6bqy0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long max_level = 0;\n    long level\
    \ = 0;\n    bool has_opening = false;\n    bool has_closing = false;\n    bool\
    \ has_opening_closing = false;\n    bool has_opening_opening = false;\n    bool\
    \ has_opening_opening_closing = false;\n    bool has_opening_opening_opening =\
    \ false;\n    bool has_opening_opening_opening_closing = false;\n    bool has_opening_opening_opening_opening\
    \ = false;\n    bool has_opening_opening_opening_opening_closing = false;\n  \
    \  bool has_opening_opening_opening_opening_opening = false;\n    bool has_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening = false;\n\
    \    bool has_opening_opening_opening_opening_opening_opening_closing = false;\n\
    \    bool has_opening_opening_opening_opening_opening_opening_opening = false;\n\
    \    bool has_opening_opening_opening_opening_opening_opening_closing = false;\n\
    \    bool has_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8sml3d9p.d(45): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8sml3d9p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    \n    for(int i\
    \ = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            levels[level] = level;\n            level++;\n\
    \        } else if(c == ')') {\n            level--;\n            if(levels[level]\
    \ == 0) {\n                levels[level] = level;\n            }\n        }\n\
    \        if(level > max_level) {\n            max_level = level;\n        }\n\
    \    }\n    \n    long[] result = new long[max_level + 1];\n    for(int i = 0;\
    \ i < levels.length; i++) {\n        result[i] = levels[i];\n    }\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwc0af62q.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpwc0af62q.d(16): Error: undefined\
    \ identifier `MAX_LEVELS`\\n/tmp/tmpwc0af62q.d(18): Error: no property `length`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwc0af62q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    bool in_paren = false;\n\
    \    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n   \
    \ bool in_paren_group_close = false;\n    bool in_paren_group_open_brace = false;\n\
    \    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close = false;\n    bool\
    \ in_paren_group_open_brace_close_close_close = false;\n    bool in_paren_group_close_brace_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close = false;\n\
    \    bool in_paren_group_close_brace_close_close_close_close = false;\n    bool\
    \ in_paren_group_open_brace_close_close_close_close_close = false;\n    bool in_paren_group_close_brace_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcj_ckoy5.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpcj_ckoy5.d(48): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmpcj_ckoy5.d(48): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcj_ckoy5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long paren_index = 0;\n    long paren_level =\
    \ 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjh72ny_a.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpjh72ny_a.d(20): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] paren_levels`\\n/tmp/tmpjh72ny_a.d(67): Error:\
    \ semicolon expected, not `unittest`\\n/tmp/tmpjh72ny_a.d(67): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpjh72ny_a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_min_max = 0;\n\
    \    long paren_level_count_max2 = 0;\n    long paren_level_count_min2 = 0;\n\
    \    long paren_level_count_min_max2 = 0;\n    long paren_level_count_max3 = 0;\n\
    \    long paren_level_count_min3 = 0;\n    long paren_level_count_min_max3 = 0;\n\
    \    long paren_level_count_max4 = 0;\n    long paren_level_count_min4 = 0;\n\
    \    long paren_level_count_min_max4 = 0;\n    long paren_level_count_max5 = 0;\n\
    \    long paren_level_count_min5 = 0;\n    long paren_level_count_min_max5 = 0;\n\
    \    long paren_level_count_max6 = 0;\n    long paren_level_count_min6 = 0;\n\
    \    long paren_level_count_min_max6 = 0;\n    long paren_level_count_max7 = 0;\n\
    \    long paren_level_count_min7 = 0;\n    long paren_level_count_min_max7 = 0;\n\
    \    long paren_level_count_max8 = 0;\n    long paren_level_count_min8 = 0;\n\
    \    long paren_level_count_min_max8 = 0;\n    long paren_level_count_max9 = 0;\n\
    \    long paren_level_count_min9 = 0;\n    long paren_level_count_min_max9 = 0;\n\
    \    long paren_level_count_max10 = 0;\n    long paren_level_count_min10 = 0;\n\
    \    long paren_level_count_min_max10 = 0;\n    long paren_level_count_max11 =\
    \ 0;\n    long paren_level_count_min11 = 0;\n    long paren_level_count_min_max11\
    \ = 0;\n    long paren_level_count_max12 = 0;\n    long paren_level_count_min12\
    \ = 0;\n    long paren_level_count_min_max12 = 0;\n    long paren_level_count_max13\
    \ = 0;\n    long paren_level_count_min13 = 0;\n    long paren_level_count_min_max13\
    \ = 0;\n    long paren_level_count_max14 = 0;\n    long paren_level_count_min14\
    \ = 0;\n    long paren_level_count_min_max14 = 0;\n    long paren_level_count_max15\
    \ = 0;\n    long paren_level_count_min15 = 0;\n    long paren_level_count_min_max15\
    \ = 0;\n    long paren_level_count_max16 = 0;\n    long paren_level_count_min16\
    \ = 0;\n    long paren_level_count_min_max\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprew_dqj8.d(66): Error: semicolon expected, not `unittest`\\n/tmp/tmprew_dqj8.d(66):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprew_dqj8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack[MAX_STACK_SIZE];\n    long level_stack_pointer\
    \ = 0;\n    long paren_stack_pointer = 0;\n    long paren_level = 0;\n    long\
    \ paren_level_stack[MAX_STACK_SIZE];\n    long paren_level_stack_pointer = 0;\n\
    \    long paren_level_count = 0;\n    long paren_level_count_stack[MAX_STACK_SIZE];\n\
    \    long paren_level_count_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_STACK_SIZE];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_STACK_SIZE];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_sum\
    \ = 0;\n    long paren_level_count_sum_stack[MAX_STACK_SIZE];\n    long paren_level_count_sum_stack_pointer\
    \ = 0;\n    long paren_level_count_product = 0;\n    long paren_level_count_product_stack[MAX_STACK_SIZE];\n\
    \    long paren_level_count_product_stack_pointer = 0;\n    long paren_level_count_quotient\
    \ = 0;\n    long paren_level_count_quotient_stack[MAX_STACK_SIZE];\n    long paren_level_count_quotient_stack_pointer\
    \ = 0;\n    long paren_level_count_remainder = 0;\n    long paren_level_count_remainder_stack[MAX_STACK_SIZE];\n\
    \    long paren_level_count_remainder_stack_pointer = 0;\n    long paren_level_count_product2\
    \ = 0;\n    long paren_level_count_product2_stack[MAX_STACK_SIZE];\n    long paren_level_count_product2_stack_pointer\
    \ = 0;\n    long paren_level_count_product3 = 0;\n    long paren_level_count_product3_stack[MAX_STACK_SIZE];\n\
    \    long paren_level_count_product3_stack_pointer = 0;\n    long paren_level_count_product4\
    \ = 0;\n    long paren_level_count_product4_stack[MAX_STACK_SIZE];\n    long paren_level_count_product4_stack_pointer\
    \ = 0;\n    long paren_level_count_product5 = 0;\n    long paren_level_count_product5_stack[MAX_STACK_SIZE];\n\
    \    long paren_level_count_product5_stack_pointer = 0;\n    long paren_level_count_product6\
    \ = 0;\n    long paren_level_count_product6_stack[MAX_STACK_SIZE];\n    long paren_level_count_product6_stack_pointer\
    \ = 0;\n    long paren_level_count_product7 = 0;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgg701g2q.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_STACK_SIZE] level_stack`\\n/tmp/tmpgg701g2q.d(20): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE] paren_level_stack`\\\
    n/tmp/tmpgg701g2q.d(23): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_STACK_SIZE] paren_level_count_stack`\\n/tmp/tmpgg701g2q.d(26): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE] paren_level_count_max_stack`\\\
    n/tmp/tmpgg701g2q.d(29): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_STACK_SIZE] paren_level_count_min_stack`\\n/tmp/tmpgg701g2q.d(32):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE]\
    \ paren_level_count_sum_stack`\\n/tmp/tmpgg701g2q.d(35): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE] paren_level_count_product_stack`\\\
    n/tmp/tmpgg701g2q.d(38): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_STACK_SIZE] paren_level_count_quotient_stack`\\n/tmp/tmpgg701g2q.d(41):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE]\
    \ paren_level_count_remainder_stack`\\n/tmp/tmpgg701g2q.d(44): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE] paren_level_count_product2_stack`\\\
    n/tmp/tmpgg701g2q.d(47): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_STACK_SIZE] paren_level_count_product3_stack`\\n/tmp/tmpgg701g2q.d(50):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE]\
    \ paren_level_count_product4_stack`\\n/tmp/tmpgg701g2q.d(53): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_STACK_SIZE] paren_level_count_product5_stack`\\\
    n/tmp/tmpgg701g2q.d(56): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_STACK_SIZE] paren_level_count_product6_stack`\\n/tmp/tmpgg701g2q.d(60):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgg701g2q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_strings_copy;\n    string paren_strings_copy2;\n    string paren_strings_copy3;\n\
    \    string paren_strings_copy4;\n    string paren_strings_copy5;\n    string\
    \ paren_strings_copy6;\n    string paren_strings_copy7;\n    string paren_strings_copy8;\n\
    \    string paren_strings_copy9;\n    string paren_strings_copy10;\n    string\
    \ paren_strings_copy11;\n    string paren_strings_copy12;\n    string paren_strings_copy13;\n\
    \    string paren_strings_copy14;\n    string paren_strings_copy15;\n    string\
    \ paren_strings_copy16;\n    string paren_strings_copy17;\n    string paren_strings_copy18;\n\
    \    string paren_strings_copy19;\n    string paren_strings_copy20;\n    string\
    \ paren_strings_copy21;\n    string paren_strings_copy22;\n    string paren_strings_copy23;\n\
    \    string paren_strings_copy24;\n    string paren_strings_copy25;\n    string\
    \ paren_strings_copy26;\n    string paren_strings_copy27;\n    string paren_strings_copy28;\n\
    \    string paren_strings_copy29;\n    string paren_strings_copy30;\n    string\
    \ paren_strings_copy31;\n    string paren_strings_copy32;\n    string paren_strings_copy33;\n\
    \    string paren_strings_copy34;\n    string paren_strings_copy35;\n    string\
    \ paren_strings_copy36;\n    string paren_strings_copy37;\n    string paren_strings_copy38;\n\
    \    string paren_strings_copy39;\n    string paren_strings_copy40;\n    string\
    \ paren_strings_copy41;\n    string paren_strings_copy42;\n    string paren_strings_copy43;\n\
    \    string paren_strings_copy44;\n    string paren_strings_copy45;\n    string\
    \ paren_strings_copy46;\n    string paren_strings_copy47;\n    string paren_strings_copy48;\n\
    \    string paren_strings_copy49;\n    string paren_strings_copy50;\n    string\
    \ paren_strings_copy51;\n    string paren_strings_copy52;\n    string paren_strings_copy53;\n\
    \    string paren_string\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp33by2fjz.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp33by2fjz.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp33by2fjz.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmp33by2fjz.d(73): Error: found `paren_string` when expecting\
    \ `;` following statement\\n/tmp/tmp33by2fjz.d(74): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33by2fjz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    long levels_counter = 0;\n    long level_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counter = 0;\n \
    \   long level_counters_counters[] = new long[paren_string.length()];\n    long\
    \ level_counters_counters_counter = 0;\n    long level_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters[] = new long[paren_string.length()];\n\
    \    long level_counters_counters_counters_counters_counter = 0;\n    long level_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[]\
    \ = new long[paren_string.length()];\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp83lr3z9m.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp83lr3z9m.d(19): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] level_counters`\\n/tmp/tmp83lr3z9m.d(21):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[] level_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(23): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters`\\n/tmp/tmp83lr3z9m.d(25): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[] level_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(27): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters_counters_counters`\\n/tmp/tmp83lr3z9m.d(29):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[] level_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(31): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(33): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(35): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(37): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(39): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[] level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmp83lr3z9m.d(42): Error: semicolon expected, not `unittest`\\n/tmp/tmp83lr3z9m.d(42):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp83lr3z9m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long level_start = 0;\n    long level_end = 0;\n    long level_length\
    \ = 0;\n    long level_start_index = 0;\n    long level_end_index = 0;\n    long\
    \ level_length_index = 0;\n    long level_start_index2 = 0;\n    long level_end_index2\
    \ = 0;\n    long level_length_index2 = 0;\n    long level_start_index3 = 0;\n\
    \    long level_end_index3 = 0;\n    long level_length_index3 = 0;\n    long level_start_index4\
    \ = 0;\n    long level_end_index4 = 0;\n    long level_length_index4 = 0;\n  \
    \  long level_start_index5 = 0;\n    long level_end_index5 = 0;\n    long level_length_index5\
    \ = 0;\n    long level_start_index6 = 0;\n    long level_end_index6 = 0;\n   \
    \ long level_length_index6 = 0;\n    long level_start_index7 = 0;\n    long level_end_index7\
    \ = 0;\n    long level_length_index7 = 0;\n    long level_start_index8 = 0;\n\
    \    long level_end_index8 = 0;\n    long level_length_index8 = 0;\n    long level_start_index9\
    \ = 0;\n    long level_end_index9 = 0;\n    long level_length_index9 = 0;\n  \
    \  long level_start_index10 = 0;\n    long level_end_index10 = 0;\n    long level_length_index10\
    \ = 0;\n    long level_start_index11 = 0;\n    long level_end_index11 = 0;\n \
    \   long level_length_index11 = 0;\n    long level_start_index12 = 0;\n    long\
    \ level_end_index12 = 0;\n    long level_length_index12 = 0;\n    long level_start_index13\
    \ = 0;\n    long level_end_index13 = 0;\n    long level_length_index13 = 0;\n\
    \    long level_start_index14 = 0;\n    long level_end_index14 = 0;\n    long\
    \ level_length_index14 = 0;\n    long level_start_index15 = 0;\n    long level_end_index15\
    \ = 0;\n    long level_length_index15 = 0;\n    long level_start_index16 = 0;\n\
    \    long level_end_index16 = 0;\n    long level_length_index16 = 0;\n    long\
    \ level_start_index17 = 0;\n    long level_end_index17 = 0;\n    long level_length_index17\
    \ = 0;\n    long level_start_index18 = 0;\n    long level_end_index18 = 0;\n \
    \   long level_length_index18 = 0;\n    long level_start_index19 = 0;\n    long\
    \ level_end_index19 = 0;\n    long level_length_index19 = 0;\n    long level_start_index20\
    \ = 0;\n    long level_end_index20 = 0;\n    long level_length_index20 = 0;\n\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpynq3f_ep.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpynq3f_ep.d(82): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpynq3f_ep.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n    long level_stack_pos\
    \ = 0;\n    long pos = 0;\n    long num_open = 0;\n    long num_close = 0;\n \
    \   long num_open_braces = 0;\n    long num_close_braces = 0;\n    long num_open_parens\
    \ = 0;\n    long num_close_parens = 0;\n    long num_open_parens_after_open_braces\
    \ = 0;\n    long num_close_parens_after_open_braces = 0;\n    long num_open_parens_after_close_braces\
    \ = 0;\n    long num_close_parens_after_close_braces = 0;\n    long num_open_parens_after_open_parens\
    \ = 0;\n    long num_close_parens_after_open_parens = 0;\n    long num_open_parens_after_close_parens\
    \ = 0;\n    long num_close_parens_after_close_parens = 0;\n    long num_open_parens_after_open_parens_after_open_braces\
    \ = 0;\n    long num_close_parens_after_open_parens_after_open_braces = 0;\n \
    \   long num_open_parens_after_close_parens_after_close_braces = 0;\n    long\
    \ num_close_parens_after_close_parens_after_close_braces = 0;\n    long num_open_parens_after_open_parens_after_open_parens\
    \ = 0;\n    long num_close_parens_after_open_parens_after_open_parens = 0;\n \
    \   long num_open_parens_after_close_parens_after_close_parens = 0;\n    long\
    \ num_close_parens_after_close_parens_after_close_parens = 0;\n    long num_open_parens_after_open_parens_after_open_parens_after_open_braces\
    \ = 0;\n    long num_close_parens_after_open_parens_after_open_parens_after_open_braces\
    \ = 0;\n    long num_open_parens_after_close_parens_after_close_parens_after_close_braces\
    \ = 0;\n    long num_close_parens_after_close_parens_after_close_parens_after_close_braces\
    \ = 0;\n    long num_open_parens_after_open_parens_after_open_parens_after_open_parens\
    \ = 0;\n    long num_close_parens_after_open_parens_after_open_parens_after_open_parens\
    \ = 0;\n    long num_open_parens_after_close_parens_after_close_parens_after_close_parens\
    \ = 0;\n    long num_close_parens_after_close_parens_after_close_parens_after_close_parens\
    \ = 0;\n    long num_open_parens_after_open_parens_after_open_parens_after_open_parens_after_open_braces\
    \ = 0;\n    long num_close_parens_after_open_parens_after_open_parens_after_open_parens_after_open_braces\
    \ = 0;\n    long num_open_parens_after_close_parens_after_close_parens_after_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl427ltd6.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] level_stack`\\n/tmp/tmpl427ltd6.d(52): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpl427ltd6.d(52): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl427ltd6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl2ooq4d7.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpl2ooq4d7.d(62): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmpl2ooq4d7.d(62): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl2ooq4d7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_count_sum\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_sum = 0;\n    long paren_level_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_min = 0;\n    long paren_level_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_sum = 0;\n    long paren_level_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_sum = 0;\n    long paren_level_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_min = 0;\n    long\
    \ paren_level_count_count_count_count_count_max = 0;\n    long paren_level_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_sum = 0;\n  \
    \  long paren_level_count_count_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_sum = 0;\n  \
    \  long paren_level_count_count_count_count_count_count_count_sum = 0;\n    long\
    \ paren_level_count_count_count_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_sum = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_sum = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_min = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_max = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_sum = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_sum = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_min = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj0kix4_r.d(55): Error: semicolon expected, not `unittest`\\n/tmp/tmpj0kix4_r.d(55):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpj0kix4_r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long paren_index = 0;\n    long paren_level =\
    \ 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfsz7ko1l.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpfsz7ko1l.d(20): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] paren_levels`\\n/tmp/tmpfsz7ko1l.d(67): Error:\
    \ semicolon expected, not `unittest`\\n/tmp/tmpfsz7ko1l.d(67): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpfsz7ko1l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] result\
    \ = new long[paren_string.length()];\n    stack<int> paren_stack = new stack<int>();\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            paren_stack.push(i);\n        } else if(c\
    \ == ')') {\n            int top = paren_stack.top();\n            while(top !=\
    \ -1) {\n                result[top] = i;\n                paren_stack.pop();\n\
    \                top = paren_stack.top();\n            }\n            paren_stack.pop();\n\
    \        } else {\n            while(!paren_stack.empty() && paren_stack.top()\
    \ < i) {\n                result[paren_stack.top()] = i;\n                paren_stack.pop();\n\
    \            }\n            while(!paren_stack.empty() && paren_stack.top() >\
    \ i) {\n                result[paren_stack.top()] = i;\n                paren_stack.pop();\n\
    \            }\n            if(!paren_stack.empty()) {\n                result[paren_stack.top()]\
    \ = i;\n            }\n            paren_stack.push(i);\n        }\n    }\n  \
    \  while(!paren_stack.empty()) {\n        result[paren_stack.top()] = i;\n   \
    \     paren_stack.pop();\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp6ba4ol4.d(15): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpp6ba4ol4.d(15): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpp6ba4ol4.d(15): Error: found `(` when expecting identifier following\
    \ `int`.\\n/tmp/tmpp6ba4ol4.d(15): Error: found `)` when expecting `;` following\
    \ statement\\n/tmp/tmpp6ba4ol4.d(15): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp6ba4ol4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos = new long[paren_groups.length()];\n\
    \    long[] levels_stack_pos_stack = new long[paren_groups.length()];\n    long[]\
    \ levels_stack_pos_stack_pos = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_stack_pos_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpipeeztiz.d(37): Error: semicolon expected, not `unittest`\\n/tmp/tmpipeeztiz.d(37):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpipeeztiz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_strings_copy;\n    string paren_strings_copy2;\n    string paren_strings_copy3;\n\
    \    string paren_strings_copy4;\n    string paren_strings_copy5;\n    string\
    \ paren_strings_copy6;\n    string paren_strings_copy7;\n    string paren_strings_copy8;\n\
    \    string paren_strings_copy9;\n    string paren_strings_copy10;\n    string\
    \ paren_strings_copy11;\n    string paren_strings_copy12;\n    string paren_strings_copy13;\n\
    \    string paren_strings_copy14;\n    string paren_strings_copy15;\n    string\
    \ paren_strings_copy16;\n    string paren_strings_copy17;\n    string paren_strings_copy18;\n\
    \    string paren_strings_copy19;\n    string paren_strings_copy20;\n    string\
    \ paren_strings_copy21;\n    string paren_strings_copy22;\n    string paren_strings_copy23;\n\
    \    string paren_strings_copy24;\n    string paren_strings_copy25;\n    string\
    \ paren_strings_copy26;\n    string paren_strings_copy27;\n    string paren_strings_copy28;\n\
    \    string paren_strings_copy29;\n    string paren_strings_copy30;\n    string\
    \ paren_strings_copy31;\n    string paren_strings_copy32;\n    string paren_strings_copy33;\n\
    \    string paren_strings_copy34;\n    string paren_strings_copy35;\n    string\
    \ paren_strings_copy36;\n    string paren_strings_copy37;\n    string paren_strings_copy38;\n\
    \    string paren_strings_copy39;\n    string paren_strings_copy40;\n    string\
    \ paren_strings_copy41;\n    string paren_strings_copy42;\n    string paren_strings_copy43;\n\
    \    string paren_strings_copy44;\n    string paren_strings_copy45;\n    string\
    \ paren_strings_copy46;\n    string paren_strings_copy47;\n    string paren_strings_copy48;\n\
    \    string paren_strings_copy49;\n    string paren_strings_copy50;\n    string\
    \ paren_strings_copy51;\n    string paren_strings_copy52;\n    string paren_strings_copy53;\n\
    \    string paren_string\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgqjbptq4.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpgqjbptq4.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmpgqjbptq4.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmpgqjbptq4.d(73): Error: found `paren_string` when expecting\
    \ `;` following statement\\n/tmp/tmpgqjbptq4.d(74): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgqjbptq4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    while(i < paren_string.length())\n    {\n        char c\
    \ = paren_string[i];\n        if(c == '(')\n        {\n            level++;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \   }\n        levels[i] = level;\n        i++;\n    }\n    long[] result = new\
    \ long[paren_string.length()];\n    for(i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(levels[i] > max_level)\n        {\n            max_level =\
    \ levels[i];\n        }\n        result[i] = max_level;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution doesn't work for nested\
    \ parentheses such as `((()))`\n<|/ c |>\n<| c |>\nIt works for nested parentheses\
    \ such as ((())). Can you give an example where it doesn't work?\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work for nested parentheses such as `((()))`. Try `parse_nested_parens(\"\
    ((()))\")`.\n<|/ c |>\n<| c |>\nI tested it and it works for me. Can you give\
    \ an example where it doesn't work?\n<|/ c |>\n<| c |>\nIt doesn't work for nested\
    \ parentheses such as `((()))`. Try `parse_nested_parens(\"((()))\")`.\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport\
    \ java.io.*;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6d0rla2d.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp6d0rla2d.d(43): Error: declaration expected,\
    \ not `<`\\n/tmp/tmp6d0rla2d.d(46): Error: unterminated character constant\\n/tmp/tmp6d0rla2d.d(49):\
    \ Error: unterminated character constant\\n/tmp/tmp6d0rla2d.d(52): Error: unterminated\
    \ character constant\\n/tmp/tmp6d0rla2d.d(55): Error: unterminated character constant\\\
    n/tmp/tmp6d0rla2d.d(58): Error: unterminated character constant\\n/tmp/tmp6d0rla2d.d(63):\
    \ Error: identifier expected following `package`\\n/tmp/tmp6d0rla2d.d(63): Error:\
    \ `;` expected\\n/tmp/tmp6d0rla2d.d(64): Error: identifier expected following\
    \ `package`\\n/tmp/tmp6d0rla2d.d(64): Error: `;` expected\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6d0rla2d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppcp0741o.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmppcp0741o.d(79): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmppcp0741o.d(79): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppcp0741o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string;\n    long max_level = 0;\n    long level = 0;\n    long max_level_group\
    \ = 0;\n    long level_group = 0;\n    long max_level_group_len = 0;\n    long\
    \ level_group_len = 0;\n    long level_group_start = 0;\n    long level_group_end\
    \ = 0;\n    long level_group_len = 0;\n    long level_group_start = 0;\n    long\
    \ level_group_end = 0;\n    long level_group_len = 0;\n    long level_group_start\
    \ = 0;\n    long level_group_end = 0;\n    long level_group_len = 0;\n    long\
    \ level_group_start = 0;\n    long level_group_end = 0;\n    long level_group_len\
    \ = 0;\n    long level_group_start = 0;\n    long level_group_end = 0;\n    long\
    \ level_group_len = 0;\n    long level_group_start = 0;\n    long level_group_end\
    \ = 0;\n    long level_group_len = 0;\n    long level_group_start = 0;\n    long\
    \ level_group_end = 0;\n    long level_group_len = 0;\n    long level_group_start\
    \ = 0;\n    long level_group_end = 0;\n    long level_group_len = 0;\n    long\
    \ level_group_start = 0;\n    long level_group_end = 0;\n    long level_group_len\
    \ = 0;\n    long level_group_start = 0;\n    long level_group_end = 0;\n    long\
    \ level_group_len = 0;\n    long level_group_start = 0;\n    long level_group_end\
    \ = 0;\n    long level_group_len = 0;\n    long level_group_start = 0;\n    long\
    \ level_group_end = 0;\n    long level_group_len = 0;\n    long level_group_start\
    \ = 0;\n    long level_group_end = 0;\n    long level_group_len = 0;\n    long\
    \ level_group_start = 0;\n    long level_group_end = 0;\n    long level_group_len\
    \ = 0;\n    long level_group_start = 0;\n    long level_group_end = 0;\n    long\
    \ level_group_len = 0;\n    long level_group_start = 0;\n    long level_group_end\
    \ = 0;\n    long level_group_len = 0;\n    long level_group_start = 0;\n    long\
    \ level_group_end = 0;\n    long level_group_len = 0;\n    long level_group_start\
    \ = 0;\n    long level_group_end = 0;\n    long level_group_len = 0;\n    long\
    \ level_group_start = 0;\n    long level_group_end = 0;\n    long level_group_len\
    \ = 0;\n    long level_group_start = 0;\n    long level_group_end = 0;\n    long\
    \ level_group_len = 0;\n    long level_group_start = 0;\n    long level_group_end\
    \ = 0;\n    long level_group_len = 0;\n    long level_group_start = 0;\n    long\
    \ level_group_end = 0;\n    long level_group_len = 0;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf70rzght.d(87): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf70rzght.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long level_counter\
    \ = 0;\n    long level_counters[MAX_LEVELS];\n    long level_counters_index =\
    \ 0;\n    long level_counters_index2 = 0;\n    long level_counters_index3 = 0;\n\
    \    long level_counters_index4 = 0;\n    long level_counters_index5 = 0;\n  \
    \  long level_counters_index6 = 0;\n    long level_counters_index7 = 0;\n    long\
    \ level_counters_index8 = 0;\n    long level_counters_index9 = 0;\n    long level_counters_index10\
    \ = 0;\n    long level_counters_index11 = 0;\n    long level_counters_index12\
    \ = 0;\n    long level_counters_index13 = 0;\n    long level_counters_index14\
    \ = 0;\n    long level_counters_index15 = 0;\n    long level_counters_index16\
    \ = 0;\n    long level_counters_index17 = 0;\n    long level_counters_index18\
    \ = 0;\n    long level_counters_index19 = 0;\n    long level_counters_index20\
    \ = 0;\n    long level_counters_index21 = 0;\n    long level_counters_index22\
    \ = 0;\n    long level_counters_index23 = 0;\n    long level_counters_index24\
    \ = 0;\n    long level_counters_index25 = 0;\n    long level_counters_index26\
    \ = 0;\n    long level_counters_index27 = 0;\n    long level_counters_index28\
    \ = 0;\n    long level_counters_index29 = 0;\n    long level_counters_index30\
    \ = 0;\n    long level_counters_index31 = 0;\n    long level_counters_index32\
    \ = 0;\n    long level_counters_index33 = 0;\n    long level_counters_index34\
    \ = 0;\n    long level_counters_index35 = 0;\n    long level_counters_index36\
    \ = 0;\n    long level_counters_index37 = 0;\n    long level_counters_index38\
    \ = 0;\n    long level_counters_index39 = 0;\n    long level_counters_index40\
    \ = 0;\n    long level_counters_index41 = 0;\n    long level_counters_index42\
    \ = 0;\n    long level_counters_index43 = 0;\n    long level_counters_index44\
    \ = 0;\n    long level_counters_index45 = 0;\n    long level_counters_index46\
    \ = 0;\n    long level_counters_index47 = 0;\n    long level_counters_index48\
    \ = 0;\n    long level_counters_index49 = 0;\n    long level_counters_index50\
    \ = 0;\n    long level_counters_index51 = 0;\n    long level_counters_index52\
    \ = 0;\n    long level_counters_index53 = 0;\n    long \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprbcx4lod.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmprbcx4lod.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] level_counters`\\n/tmp/tmprbcx4lod.d(73):\
    \ Error: no identifier for declarator `long`\\n/tmp/tmprbcx4lod.d(73): Error:\
    \ found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmprbcx4lod.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    long paren_counter = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_counter = 0;\n    long paren_level_counters[] = new\
    \ long[paren_string.length()];\n    long paren_level_counters_index = 0;\n   \
    \ long paren_level_counters_index_max = 0;\n    long paren_level_counters_index_min\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long paren_level_counters_index_min_index = 0;\n    long paren_level_counters_index_max_index\
    \ = 0;\n    long \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjvti47nd.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpjvti47nd.d(21): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] paren_level_counters`\\n/tmp/tmpjvti47nd.d(60):\
    \ Error: no identifier for declarator `long`\\n/tmp/tmpjvti47nd.d(60): Error:\
    \ found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpjvti47nd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    bool in_paren = false;\n    bool in_paren2\
    \ = false;\n    bool in_paren3 = false;\n    bool in_paren4 = false;\n    bool\
    \ in_paren5 = false;\n    bool in_paren6 = false;\n    bool in_paren7 = false;\n\
    \    bool in_paren8 = false;\n    bool in_paren9 = false;\n    bool in_paren10\
    \ = false;\n    bool in_paren11 = false;\n    bool in_paren12 = false;\n    bool\
    \ in_paren13 = false;\n    bool in_paren14 = false;\n    bool in_paren15 = false;\n\
    \    bool in_paren16 = false;\n    bool in_paren17 = false;\n    bool in_paren18\
    \ = false;\n    bool in_paren19 = false;\n    bool in_paren20 = false;\n    bool\
    \ in_paren21 = false;\n    bool in_paren22 = false;\n    bool in_paren23 = false;\n\
    \    bool in_paren24 = false;\n    bool in_paren25 = false;\n    bool in_paren26\
    \ = false;\n    bool in_paren27 = false;\n    bool in_paren28 = false;\n    bool\
    \ in_paren29 = false;\n    bool in_paren30 = false;\n    bool in_paren31 = false;\n\
    \    bool in_paren32 = false;\n    bool in_paren33 = false;\n    bool in_paren34\
    \ = false;\n    bool in_paren35 = false;\n    bool in_paren36 = false;\n    bool\
    \ in_paren37 = false;\n    bool in_paren38 = false;\n    bool in_paren39 = false;\n\
    \    bool in_paren40 = false;\n    bool in_paren41 = false;\n    bool in_paren42\
    \ = false;\n    bool in_paren43 = false;\n    bool in_paren44 = false;\n    bool\
    \ in_paren45 = false;\n    bool in_paren46 = false;\n    bool in_paren47 = false;\n\
    \    bool in_paren48 = false;\n    bool in_paren49 = false;\n    bool in_paren50\
    \ = false;\n    bool in_paren51 = false;\n    bool in_paren52 = false;\n    bool\
    \ in_paren53 = false;\n    bool in_paren54 = false;\n    bool in_paren55 = false;\n\
    \    bool in_paren56 = false;\n    bool in_paren57 = false;\n    bool in_paren58\
    \ = false;\n    bool in_paren59 = false;\n    bool in_paren60 = false;\n    bool\
    \ in_paren61 = false;\n    bool in_paren62 = false;\n    bool in_paren63 = false;\n\
    \    bool in_paren64 = false;\n    bool in_paren65 = false;\n    bool in_paren66\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcb2_mzd6.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpcb2_mzd6.d(86): Error: no identifier\
    \ for declarator `bool`\\n/tmp/tmpcb2_mzd6.d(86): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcb2_mzd6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    bool paren_found = false;\n    bool paren_open\
    \ = false;\n    bool paren_closed = false;\n    bool paren_level = false;\n  \
    \  bool paren_levels[] = new bool[paren_string.length()];\n    bool paren_levels_found\
    \ = false;\n    bool paren_levels_open = false;\n    bool paren_levels_closed\
    \ = false;\n    bool paren_levels_level = false;\n    bool paren_levels_levels[]\
    \ = new bool[paren_string.length()];\n    bool paren_levels_levels_found = false;\n\
    \    bool paren_levels_levels_open = false;\n    bool paren_levels_levels_closed\
    \ = false;\n    bool paren_levels_levels_level = false;\n    bool paren_levels_levels_levels[]\
    \ = new bool[paren_string.length()];\n    bool paren_levels_levels_levels_found\
    \ = false;\n    bool paren_levels_levels_levels_open = false;\n    bool paren_levels_levels_levels_closed\
    \ = false;\n    bool paren_levels_levels_levels_level = false;\n    bool paren_levels_levels_levels_levels[]\
    \ = new bool[paren_string.length()];\n    bool paren_levels_levels_levels_levels_found\
    \ = false;\n    bool paren_levels_levels_levels_levels_open = false;\n    bool\
    \ paren_levels_levels_levels_levels_closed = false;\n    bool paren_levels_levels_levels_levels_level\
    \ = false;\n    bool paren_levels_levels_levels_levels_levels[] = new bool[paren_string.length()];\n\
    \    bool paren_levels_levels_levels_levels_levels_found = false;\n    bool paren_levels_levels_levels_levels_levels_open\
    \ = false;\n    bool paren_levels_levels_levels_levels_levels_closed = false;\n\
    \    bool paren_levels_levels_levels_levels_levels_level = false;\n    bool paren_levels_levels_levels_levels_levels_levels[]\
    \ = new bool[paren_string.length()];\n    bool paren_levels_levels_levels_levels_levels_levels_found\
    \ = false;\n    bool paren_levels_levels_levels_levels_levels_levels_open = false;\n\
    \    bool paren_levels_levels_levels_levels_levels_levels_closed = false;\n  \
    \  bool paren_levels_levels_levels_levels_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj5mwq47f.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpj5mwq47f.d(23): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `bool[] paren_levels`\\n/tmp/tmpj5mwq47f.d(28): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[] paren_levels_levels`\\\
    n/tmp/tmpj5mwq47f.d(33): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[] paren_levels_levels_levels`\\n/tmp/tmpj5mwq47f.d(38): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `bool[] paren_levels_levels_levels_levels`\\\
    n/tmp/tmpj5mwq47f.d(43): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[] paren_levels_levels_levels_levels_levels`\\n/tmp/tmpj5mwq47f.d(48):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[] paren_levels_levels_levels_levels_levels_levels`\\\
    n/tmp/tmpj5mwq47f.d(53): Error: semicolon expected, not `unittest`\\n/tmp/tmpj5mwq47f.d(53):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpj5mwq47f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_sum = 0;\n  \
    \  long paren_level_count_count_sum = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpugtec9sf.d(67): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpugtec9sf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,string\
    \ |>\n<code>\npublic int GetMaxNestingLevel(string input)\n{\n    Stack<char>\
    \ stack = new Stack<char>();\n    stack.Push('(');\n    int max = 0;\n    foreach\
    \ (char c in input)\n    {\n        if (stack.Count == 0)\n        {\n       \
    \     stack.Push(c);\n        }\n        else if (stack.Count == 1)\n        {\n\
    \            if (c == ')')\n            {\n                stack.Pop();\n    \
    \        }\n            else\n            {\n                stack.Pop();\n  \
    \              stack.Push(c);\n            }\n        }\n        else\n      \
    \  {\n            if (c == ')')\n            {\n                stack.Pop();\n\
    \                stack.Push(c);\n            }\n            else\n           \
    \ {\n                stack.Pop();\n                stack.Push(c);\n          \
    \  }\n        }\n        if (stack.Count > max)\n        {\n            max =\
    \ stack.Count;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=c#,algorithm,string |>\n<code>\npublic int GetMaxNestingLevel(string\
    \ input)\n{\n    Stack<char> stack = new Stack<char>();\n    stack.Push('(');\n\
    \    int max = 0;\n    foreach (char c in input)\n    {\n        if (stack.Count\
    \ == 0)\n        {\n            stack.Push(c);\n        }\n        else if (stack.Count\
    \ == 1)\n        {\n            if (c == ')')\n            {\n               \
    \ stack.Pop();\n            }\n            else\n            {\n             \
    \   stack.Pop();\n                stack.Push(c);\n            }\n        }\n \
    \       else\n        {\n            if (c == ')')\n            {\n          \
    \      stack.Pop();\n                stack.Push(c);\n            }\n         \
    \   else\n            {\n                stack.Pop();\n                stack.Push(c);\n\
    \            }\n        }\n        if (stack.Count > max)\n        {\n       \
    \     max = stack.Count;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=c#,algorithm,string |>\n<code>\npublic int GetMaxNestingLevel(string\
    \ input)\n{\n    Stack<char> stack = new Stack\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpin_gyrlq.d(30): Error: declaration expected, not `<`\\n/tmp/tmpin_gyrlq.d(37):\
    \ Error: unexpected `(` in declarator\\n/tmp/tmpin_gyrlq.d(37): Error: basic type\
    \ expected, not `40U`\\n/tmp/tmpin_gyrlq.d(37): Error: found `40U` when expecting\
    \ `)`\\n/tmp/tmpin_gyrlq.d(37): Error: no identifier for declarator `stack.Push(_error_)`\\\
    n/tmp/tmpin_gyrlq.d(37): Error: semicolon expected following function declaration\\\
    n/tmp/tmpin_gyrlq.d(37): Error: declaration expected, not `)`\\n/tmp/tmpin_gyrlq.d(39):\
    \ Error: declaration expected, not `foreach`\\n/tmp/tmpin_gyrlq.d(44): Error:\
    \ unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpin_gyrlq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3isi0riw.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp3isi0riw.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp3isi0riw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_paren = 0;\n    long level_paren\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_paren = 0;\n    long paren_level_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren = 0;\n    long paren_level_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren = 0;\n \
    \   long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk8fu9uyi.d(39): Error: semicolon expected, not `unittest`\\n/tmp/tmpk8fu9uyi.d(39):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpk8fu9uyi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n    bool\
    \ in_paren_group_open = false;\n    bool in_paren_group_close = false;\n    bool\
    \ in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace = false;\n\
    \    bool in_paren_group_open_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_or_comma_brace = false;\n    bool in_paren_group_open_brace_or_comma_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_comma_brace = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma = false;\n   \
    \ bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace = false;\n \
    \   bool in_paren_group_close_brace_or_comma_comma_brace_comma = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplk3ke0uu.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmplk3ke0uu.d(45): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmplk3ke0uu.d(45): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplk3ke0uu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp33mzdp20.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp33mzdp20.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp33mzdp20.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(long i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n    }\n    for(long i = 0; i < levels.length;\
    \ i++)\n    {\n        if(levels[i] > max_level)\n        {\n            max_level\
    \ = levels[i];\n        }\n    }\n    return max_level;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdo1rf99n.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpdo1rf99n.d(16): Error: no property `length`\
    \ for type `string`\\n/tmp/tmpdo1rf99n.d(17): Error: no property `length` for\
    \ type `string`\\n/tmp/tmpdo1rf99n.d(37): Error: cannot implicitly convert expression\
    \ `max_level` of type `long` to `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpdo1rf99n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n    long paren_levels_index47\
    \ = 0;\n    long paren_levels_index48 = 0;\n    long paren_levels_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6l3ad6pf.d(17): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] paren_levels`\\n/tmp/tmp6l3ad6pf.d(67): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmp6l3ad6pf.d(67): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6l3ad6pf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp44xnnwly.d(14): Error: no property `length` for type `string`\\\
    n/tmp/tmp44xnnwly.d(16): Error: no property `length` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp44xnnwly.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long level_index\
    \ = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n    long paren_level_index\
    \ = 0;\n    long paren_max_level = 0;\n    long paren_max_level_index = 0;\n \
    \   long paren_level_index = 0;\n    long paren_level_count = 0;\n    long paren_level_count_index\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_index\
    \ = 0;\n    long paren_level_count_max_count = 0;\n    long paren_level_count_max_count_index\
    \ = 0;\n    long paren_level_count_max_count_max = 0;\n    long paren_level_count_max_count_max_index\
    \ = 0;\n    long paren_level_count_max_count_max_count = 0;\n    long paren_level_count_max_count_max_index\
    \ = 0;\n    long paren_level_count_max_count_max_count_max = 0;\n    long paren_level_count_max_count_max_count_max_index\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count = 0;\n    long\
    \ paren_level_count_max_count_max_count_max_index = 0;\n    long paren_level_count_max_count_max_count_max_count_max\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_index = 0;\n\
    \    long paren_level_count_max_count_max_count_max_count_max_count = 0;\n   \
    \ long paren_level_count_max_count_max_count_max_count_max_index = 0;\n    long\
    \ paren_level_count_max_count_max_count_max_count_max_count_max = 0;\n    long\
    \ paren_level_count_max_count_max_count_max_count_max_count_index = 0;\n    long\
    \ paren_level_count_max_count_max_count_max_count_max_count_max_count = 0;\n \
    \   long paren_level_count_max_count_max_count_max_count_max_count_max_index =\
    \ 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_max\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_index\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_max\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_index\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_max\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_index\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_max\
    \ = 0;\n    long paren_level_count_max_count_max_count_max_count_max_count_max_count_index\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpst0hptf_.d(55): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpst0hptf_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwc3_qb0j.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpwc3_qb0j.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpwc3_qb0j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] result\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long levels[] =\
    \ new long[paren_string.length()];\n    long levels_index = 0;\n    long levels_index2\
    \ = 0;\n    long levels_index3 = 0;\n    long levels_index4 = 0;\n    long levels_index5\
    \ = 0;\n    long levels_index6 = 0;\n    long levels_index7 = 0;\n    long levels_index8\
    \ = 0;\n    long levels_index9 = 0;\n    long levels_index10 = 0;\n    long levels_index11\
    \ = 0;\n    long levels_index12 = 0;\n    long levels_index13 = 0;\n    long levels_index14\
    \ = 0;\n    long levels_index15 = 0;\n    long levels_index16 = 0;\n    long levels_index17\
    \ = 0;\n    long levels_index18 = 0;\n    long levels_index19 = 0;\n    long levels_index20\
    \ = 0;\n    long levels_index21 = 0;\n    long levels_index22 = 0;\n    long levels_index23\
    \ = 0;\n    long levels_index24 = 0;\n    long levels_index25 = 0;\n    long levels_index26\
    \ = 0;\n    long levels_index27 = 0;\n    long levels_index28 = 0;\n    long levels_index29\
    \ = 0;\n    long levels_index30 = 0;\n    long levels_index31 = 0;\n    long levels_index32\
    \ = 0;\n    long levels_index33 = 0;\n    long levels_index34 = 0;\n    long levels_index35\
    \ = 0;\n    long levels_index36 = 0;\n    long levels_index37 = 0;\n    long levels_index38\
    \ = 0;\n    long levels_index39 = 0;\n    long levels_index40 = 0;\n    long levels_index41\
    \ = 0;\n    long levels_index42 = 0;\n    long levels_index43 = 0;\n    long levels_index44\
    \ = 0;\n    long levels_index45 = 0;\n    long levels_index46 = 0;\n    long levels_index47\
    \ = 0;\n    long levels_index48 = 0;\n    long levels_index49 = 0;\n    long levels_index50\
    \ = 0;\n    long levels_index51 = 0;\n    long levels_index52 = 0;\n    long levels_index53\
    \ = 0;\n    long levels_index54 = 0;\n    long levels_index55 = 0;\n    long levels_index56\
    \ = 0;\n    long levels_index57 = 0;\n    long levels_index58 = 0;\n    long levels_index59\
    \ = 0;\n    long levels_index60 = 0;\n    long levels_index\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ejmijsk.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp8ejmijsk.d(78): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmp8ejmijsk.d(78): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ejmijsk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    bool has_open = false;\n    bool has_close = false;\n    bool has_open_brace\
    \ = false;\n    bool has_close_brace = false;\n    bool has_open_paren = false;\n\
    \    bool has_close_paren = false;\n    bool has_open_curly = false;\n    bool\
    \ has_close_curly = false;\n    bool has_open_angle = false;\n    bool has_close_angle\
    \ = false;\n    bool has_open_parens = false;\n    bool has_close_parens = false;\n\
    \    bool has_open_curlys = false;\n    bool has_close_curlys = false;\n    bool\
    \ has_open_angles = false;\n    bool has_close_angles = false;\n    bool has_open_parens_2\
    \ = false;\n    bool has_close_parens_2 = false;\n    bool has_open_curlys_2 =\
    \ false;\n    bool has_close_curlys_2 = false;\n    bool has_open_angles_2 = false;\n\
    \    bool has_close_angles_2 = false;\n    bool has_open_parens_3 = false;\n \
    \   bool has_close_parens_3 = false;\n    bool has_open_curlys_3 = false;\n  \
    \  bool has_close_curlys_3 = false;\n    bool has_open_angles_3 = false;\n   \
    \ bool has_close_angles_3 = false;\n    bool has_open_parens_4 = false;\n    bool\
    \ has_close_parens_4 = false;\n    bool has_open_curlys_4 = false;\n    bool has_close_curlys_4\
    \ = false;\n    bool has_open_angles_4 = false;\n    bool has_close_angles_4 =\
    \ false;\n    bool has_open_parens_5 = false;\n    bool has_close_parens_5 = false;\n\
    \    bool has_open_curlys_5 = false;\n    bool has_close_curlys_5 = false;\n \
    \   bool has_open_angles_5 = false;\n    bool has_close_angles_5 = false;\n  \
    \  bool has_open_parens_6 = false;\n    bool has_close_parens_6 = false;\n   \
    \ bool has_open_curlys_6 = false;\n    bool has_close_curlys_6 = false;\n    bool\
    \ has_open_angles_6 = false;\n    bool has_close_angles_6 = false;\n    bool has_open_parens_7\
    \ = false;\n    bool has_close_parens_7 = false;\n    bool has_open_curlys_7 =\
    \ false;\n    bool has_close_curlys_7 = false;\n    bool has_open_angles_7 = false;\n\
    \    bool has_close_angles_7 = false;\n    bool has_open_parens_8 = false;\n \
    \   bool has_close_parens_8 = false;\n    bool has_open_curlys_\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbd9vi4sm.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpbd9vi4sm.d(73): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpbd9vi4sm.d(73): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbd9vi4sm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long level_counter\
    \ = 0;\n    long level_counters[MAX_LEVELS];\n    long level_counters_index =\
    \ 0;\n    long level_counters_index2 = 0;\n    long level_counters_index3 = 0;\n\
    \    long level_counters_index4 = 0;\n    long level_counters_index5 = 0;\n  \
    \  long level_counters_index6 = 0;\n    long level_counters_index7 = 0;\n    long\
    \ level_counters_index8 = 0;\n    long level_counters_index9 = 0;\n    long level_counters_index10\
    \ = 0;\n    long level_counters_index11 = 0;\n    long level_counters_index12\
    \ = 0;\n    long level_counters_index13 = 0;\n    long level_counters_index14\
    \ = 0;\n    long level_counters_index15 = 0;\n    long level_counters_index16\
    \ = 0;\n    long level_counters_index17 = 0;\n    long level_counters_index18\
    \ = 0;\n    long level_counters_index19 = 0;\n    long level_counters_index20\
    \ = 0;\n    long level_counters_index21 = 0;\n    long level_counters_index22\
    \ = 0;\n    long level_counters_index23 = 0;\n    long level_counters_index24\
    \ = 0;\n    long level_counters_index25 = 0;\n    long level_counters_index26\
    \ = 0;\n    long level_counters_index27 = 0;\n    long level_counters_index28\
    \ = 0;\n    long level_counters_index29 = 0;\n    long level_counters_index30\
    \ = 0;\n    long level_counters_index31 = 0;\n    long level_counters_index32\
    \ = 0;\n    long level_counters_index33 = 0;\n    long level_counters_index34\
    \ = 0;\n    long level_counters_index35 = 0;\n    long level_counters_index36\
    \ = 0;\n    long level_counters_index37 = 0;\n    long level_counters_index38\
    \ = 0;\n    long level_counters_index39 = 0;\n    long level_counters_index40\
    \ = 0;\n    long level_counters_index41 = 0;\n    long level_counters_index42\
    \ = 0;\n    long level_counters_index43 = 0;\n    long level_counters_index44\
    \ = 0;\n    long level_counters_index45 = 0;\n    long level_counters_index46\
    \ = 0;\n    long level_counters_index47 = 0;\n    long level_counters_index48\
    \ = 0;\n    long level_counters_index49 = 0;\n    long level_counters_index50\
    \ = 0;\n    long level_counters_index51 = 0;\n    long level_counters_index52\
    \ = 0;\n    long level_counters_index53 = 0;\n    long \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz7t1bbno.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpz7t1bbno.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] level_counters`\\n/tmp/tmpz7t1bbno.d(73):\
    \ Error: no identifier for declarator `long`\\n/tmp/tmpz7t1bbno.d(73): Error:\
    \ found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpz7t1bbno.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren =\
    \ false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n            levels[level] = level;\n\
    \            in_paren = true;\n        }\n        else if(paren_string[i] == ')')\n\
    \        {\n            level--;\n            if(level < 0)\n            {\n \
    \               throw new Exception(\"Invalid parentheses\");\n            }\n\
    \            levels[level] = level;\n            in_paren = false;\n        }\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    I wrote a recursive solution that works for any number of nested parentheses:\n\
    <code>\npublic static int countNestedParens(String s) {\n    return countNestedParens(s,\
    \ 0);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe4ii8knh.d(38): Error: declaration expected, not `<`\\n/tmp/tmpe4ii8knh.d(45):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpe4ii8knh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack = 0;\n    long level_stack_top\
    \ = 0;\n    long level_stack_bottom = 0;\n    long level_stack_max = 0;\n    long\
    \ level_stack_max_index = 0;\n    long level_stack_max_index2 = 0;\n    long level_stack_max_index3\
    \ = 0;\n    long level_stack_max_index4 = 0;\n    long level_stack_max_index5\
    \ = 0;\n    long level_stack_max_index6 = 0;\n    long level_stack_max_index7\
    \ = 0;\n    long level_stack_max_index8 = 0;\n    long level_stack_max_index9\
    \ = 0;\n    long level_stack_max_index10 = 0;\n    long level_stack_max_index11\
    \ = 0;\n    long level_stack_max_index12 = 0;\n    long level_stack_max_index13\
    \ = 0;\n    long level_stack_max_index14 = 0;\n    long level_stack_max_index15\
    \ = 0;\n    long level_stack_max_index16 = 0;\n    long level_stack_max_index17\
    \ = 0;\n    long level_stack_max_index18 = 0;\n    long level_stack_max_index19\
    \ = 0;\n    long level_stack_max_index20 = 0;\n    long level_stack_max_index21\
    \ = 0;\n    long level_stack_max_index22 = 0;\n    long level_stack_max_index23\
    \ = 0;\n    long level_stack_max_index24 = 0;\n    long level_stack_max_index25\
    \ = 0;\n    long level_stack_max_index26 = 0;\n    long level_stack_max_index27\
    \ = 0;\n    long level_stack_max_index28 = 0;\n    long level_stack_max_index29\
    \ = 0;\n    long level_stack_max_index30 = 0;\n    long level_stack_max_index31\
    \ = 0;\n    long level_stack_max_index32 = 0;\n    long level_stack_max_index33\
    \ = 0;\n    long level_stack_max_index34 = 0;\n    long level_stack_max_index35\
    \ = 0;\n    long level_stack_max_index36 = 0;\n    long level_stack_max_index37\
    \ = 0;\n    long level_stack_max_index38 = 0;\n    long level_stack_max_index39\
    \ = 0;\n    long level_stack_max_index40 = 0;\n    long level_stack_max_index41\
    \ = 0;\n    long level_stack_max_index42 = 0;\n    long level_stack_max_index43\
    \ = 0;\n    long level_stack_max_index44 = 0;\n    long level_stack_max_index45\
    \ = 0;\n    long level_stack_max_index46 = 0;\n    long level_stack_max_index47\
    \ = 0;\n    long level_stack_max_index48 = 0;\n    long level_stack_max_index49\
    \ = 0;\n    long level_stack_max_index50 = 0;\n    long level_stack_max_index51\
    \ = 0;\n    long level_stack_max_index52 = 0;\n    long level_stack_max_index53\
    \ = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpngatw4jd.d(74): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpngatw4jd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack = 0;\n    long level_stack_top\
    \ = 0;\n    long level_stack_bottom = 0;\n    long level_stack_max = 0;\n    long\
    \ level_stack_max_index = 0;\n    long level_stack_max_index2 = 0;\n    long level_stack_max_index3\
    \ = 0;\n    long level_stack_max_index4 = 0;\n    long level_stack_max_index5\
    \ = 0;\n    long level_stack_max_index6 = 0;\n    long level_stack_max_index7\
    \ = 0;\n    long level_stack_max_index8 = 0;\n    long level_stack_max_index9\
    \ = 0;\n    long level_stack_max_index10 = 0;\n    long level_stack_max_index11\
    \ = 0;\n    long level_stack_max_index12 = 0;\n    long level_stack_max_index13\
    \ = 0;\n    long level_stack_max_index14 = 0;\n    long level_stack_max_index15\
    \ = 0;\n    long level_stack_max_index16 = 0;\n    long level_stack_max_index17\
    \ = 0;\n    long level_stack_max_index18 = 0;\n    long level_stack_max_index19\
    \ = 0;\n    long level_stack_max_index20 = 0;\n    long level_stack_max_index21\
    \ = 0;\n    long level_stack_max_index22 = 0;\n    long level_stack_max_index23\
    \ = 0;\n    long level_stack_max_index24 = 0;\n    long level_stack_max_index25\
    \ = 0;\n    long level_stack_max_index26 = 0;\n    long level_stack_max_index27\
    \ = 0;\n    long level_stack_max_index28 = 0;\n    long level_stack_max_index29\
    \ = 0;\n    long level_stack_max_index30 = 0;\n    long level_stack_max_index31\
    \ = 0;\n    long level_stack_max_index32 = 0;\n    long level_stack_max_index33\
    \ = 0;\n    long level_stack_max_index34 = 0;\n    long level_stack_max_index35\
    \ = 0;\n    long level_stack_max_index36 = 0;\n    long level_stack_max_index37\
    \ = 0;\n    long level_stack_max_index38 = 0;\n    long level_stack_max_index39\
    \ = 0;\n    long level_stack_max_index40 = 0;\n    long level_stack_max_index41\
    \ = 0;\n    long level_stack_max_index42 = 0;\n    long level_stack_max_index43\
    \ = 0;\n    long level_stack_max_index44 = 0;\n    long level_stack_max_index45\
    \ = 0;\n    long level_stack_max_index46 = 0;\n    long level_stack_max_index47\
    \ = 0;\n    long level_stack_max_index48 = 0;\n    long level_stack_max_index49\
    \ = 0;\n    long level_stack_max_index50 = 0;\n    long level_stack_max_index51\
    \ = 0;\n    long level_stack_max_index52 = 0;\n    long level_stack_max_index53\
    \ = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt28ejel3.d(74): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt28ejel3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    bool is_open[MAX_LEVELS];\n\
    \    bool is_close[MAX_LEVELS];\n    bool is_open2[MAX_LEVELS];\n    bool is_close2[MAX_LEVELS];\n\
    \    bool is_open3[MAX_LEVELS];\n    bool is_close3[MAX_LEVELS];\n    bool is_open4[MAX_LEVELS];\n\
    \    bool is_close4[MAX_LEVELS];\n    bool is_open5[MAX_LEVELS];\n    bool is_close5[MAX_LEVELS];\n\
    \    bool is_open6[MAX_LEVELS];\n    bool is_close6[MAX_LEVELS];\n    bool is_open7[MAX_LEVELS];\n\
    \    bool is_close7[MAX_LEVELS];\n    bool is_open8[MAX_LEVELS];\n    bool is_close8[MAX_LEVELS];\n\
    \    bool is_open9[MAX_LEVELS];\n    bool is_close9[MAX_LEVELS];\n    bool is_open10[MAX_LEVELS];\n\
    \    bool is_close10[MAX_LEVELS];\n    bool is_open11[MAX_LEVELS];\n    bool is_close11[MAX_LEVELS];\n\
    \    bool is_open12[MAX_LEVELS];\n    bool is_close12[MAX_LEVELS];\n    bool is_open13[MAX_LEVELS];\n\
    \    bool is_close13[MAX_LEVELS];\n    bool is_open14[MAX_LEVELS];\n    bool is_close14[MAX_LEVELS];\n\
    \    bool is_open15[MAX_LEVELS];\n    bool is_close15[MAX_LEVELS];\n    bool is_open16[MAX_LEVELS];\n\
    \    bool is_close16[MAX_LEVELS];\n    bool is_open17[MAX_LEVELS];\n    bool is_close17[MAX_LEVELS];\n\
    \    bool is_open18[MAX_LEVELS];\n    bool is_close18[MAX_LEVELS];\n    bool is_open19[MAX_LEVELS];\n\
    \    bool is_close19[MAX_LEVELS];\n    bool is_open20[MAX_LEVELS];\n    bool is_close20[MAX_LEVELS];\n\
    \    bool is_open21[MAX_LEVELS];\n    bool is_close21[MAX_LEVELS];\n    bool is_open22[MAX_LEVELS];\n\
    \    bool is_close22[MAX_LEVELS];\n    bool is_open23[MAX_LEVELS];\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8uhntole.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp8uhntole.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_open`\\n/tmp/tmp8uhntole.d(18):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_close`\\n/tmp/tmp8uhntole.d(19): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `bool[MAX_LEVELS] is_open2`\\n/tmp/tmp8uhntole.d(20): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close2`\\\
    n/tmp/tmp8uhntole.d(21): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[MAX_LEVELS] is_open3`\\n/tmp/tmp8uhntole.d(22): Deprecation: instead of\
    \ C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close3`\\n/tmp/tmp8uhntole.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_open4`\\n/tmp/tmp8uhntole.d(24): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `bool[MAX_LEVELS] is_close4`\\n/tmp/tmp8uhntole.d(25): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_open5`\\\
    n/tmp/tmp8uhntole.d(26): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[MAX_LEVELS] is_close5`\\n/tmp/tmp8uhntole.d(27): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_open6`\\n/tmp/tmp8uhntole.d(28):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_close6`\\n/tmp/tmp8uhntole.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `bool[MAX_LEVELS] is_open7`\\n/tmp/tmp8uhntole.d(30): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close7`\\\
    n/tmp/tmp8uhntole.d(31): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `bool[MAX_LEVELS] is_open8`\\n/tmp/tmp8uhntole.d(32): Deprecation: instead of\
    \ C-style syntax, use D-style syntax `bool[MAX_LEVELS] is_close8`\\n/tmp/tmp8uhntole.d(33):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `bool[MAX_LEVELS]\
    \ is_open9`\\n/tmp/tmp8uhntole.d(34): De"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long level_counter\
    \ = 0;\n    long levels_counter = 0;\n    long level_counters[MAX_LEVELS];\n \
    \   long level_counters_counter = 0;\n    long level_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counter = 0;\n    long level_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counter = 0;\n    long level_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counter = 0;\n    long level_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counter = 0;\n  \
    \  long level_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 0;\n    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters[MAX_LEVELS];\n\
    \    long level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqvfa2009.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpqvfa2009.d(19): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] level_counters`\\n/tmp/tmpqvfa2009.d(21):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS]\
    \ level_counters_counters`\\n/tmp/tmpqvfa2009.d(23): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[MAX_LEVELS] level_counters_counters_counters`\\\
    n/tmp/tmpqvfa2009.d(25): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] level_counters_counters_counters_counters`\\n/tmp/tmpqvfa2009.d(27):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS]\
    \ level_counters_counters_counters_counters_counters`\\n/tmp/tmpqvfa2009.d(29):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS]\
    \ level_counters_counters_counters_counters_counters_counters`\\n/tmp/tmpqvfa2009.d(31):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS]\
    \ level_counters_counters_counters_counters_counters_counters_counters`\\n/tmp/tmpqvfa2009.d(33):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS]\
    \ level_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmpqvfa2009.d(35): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] level_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmpqvfa2009.d(37): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmpqvfa2009.d(39): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] level_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters_counters`\\\
    n/tmp/tmpqvfa2009.d(41): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] level_counters_counters_counters_counters_"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    \n    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \            if(level < 0)\n            {\n                throw new Exception(\"\
    Invalid parenthesis string\");\n            }\n            levels[level] = level;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \        }\n    }\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            level++;\n\
    \        }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd__7ewmt.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpd__7ewmt.d(138): Error: found `unittest` instead\
    \ of statement\\n/tmp/tmpd__7ewmt.d(146): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpd__7ewmt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n    long paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptfka_1ry.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmptfka_1ry.d(20): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_levels`\\n/tmp/tmptfka_1ry.d(68):\
    \ Error: semicolon expected, not `unittest`\\n/tmp/tmptfka_1ry.d(68): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptfka_1ry.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long num_parens\
    \ = 0;\n    long num_opens = 0;\n    long num_closes = 0;\n    long num_opens_at_level\
    \ = 0;\n    long num_closes_at_level = 0;\n    long num_opens_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level = 0;\n    long num_opens_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level = 0;\n    long num_opens_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level = 0;\n    long\
    \ num_opens_at_level_at_level_at_level_at_level_at_level = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_opens_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long num_closes_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy8o_dt63.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpy8o_dt63.d(44): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpy8o_dt63.d(44): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy8o_dt63.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string;\n    long[] max_level = new long[paren_groups.size()];\n   \
    \ long max_level_index = 0;\n    long level = 0;\n    bool has_opening_paren =\
    \ false;\n    bool has_closing_paren = false;\n    bool has_opening_curly = false;\n\
    \    bool has_closing_curly = false;\n    bool has_opening_square = false;\n \
    \   bool has_closing_square = false;\n    bool has_opening_angle = false;\n  \
    \  bool has_closing_angle = false;\n    bool has_opening_comma = false;\n    bool\
    \ has_closing_comma = false;\n    bool has_opening_colon = false;\n    bool has_closing_colon\
    \ = false;\n    bool has_opening_semicolon = false;\n    bool has_closing_semicolon\
    \ = false;\n    bool has_opening_colon2 = false;\n    bool has_closing_colon2\
    \ = false;\n    bool has_opening_semicolon2 = false;\n    bool has_closing_semicolon2\
    \ = false;\n    bool has_opening_colon3 = false;\n    bool has_closing_colon3\
    \ = false;\n    bool has_opening_semicolon3 = false;\n    bool has_closing_semicolon3\
    \ = false;\n    bool has_opening_colon4 = false;\n    bool has_closing_colon4\
    \ = false;\n    bool has_opening_semicolon4 = false;\n    bool has_closing_semicolon4\
    \ = false;\n    bool has_opening_colon5 = false;\n    bool has_closing_colon5\
    \ = false;\n    bool has_opening_semicolon5 = false;\n    bool has_closing_semicolon5\
    \ = false;\n    bool has_opening_colon6 = false;\n    bool has_closing_colon6\
    \ = false;\n    bool has_opening_semicolon6 = false;\n    bool has_closing_semicolon6\
    \ = false;\n    bool has_opening_colon7 = false;\n    bool has_closing_colon7\
    \ = false;\n    bool has_opening_semicolon7 = false;\n    bool has_closing_semicolon7\
    \ = false;\n    bool has_opening_colon8 = false;\n    bool has_closing_colon8\
    \ = false;\n    bool has_opening_semicolon8 = false;\n    bool has_closing_semicolon8\
    \ = false;\n    bool has_opening_colon9 = false;\n    bool has_closing_colon9\
    \ = false;\n    bool has_opening_semicolon9 = false;\n    bool has_closing_semicolon9\
    \ = false;\n    bool has_opening_colon10 = false;\n    bool has_closing_colon10\
    \ = false;\n    bool has_opening_semicolon10 = false;\n    bool has_closing_semicolon10\
    \ = false;\n    bool has_opening_colon11 = false;\n    bool has_closing_colon11\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphhlhuhqz.d(70): Error: semicolon expected, not `unittest`\\n/tmp/tmphhlhuhqz.d(70):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphhlhuhqz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    while(i < paren_string.length())\n    {\n\
    \        if(paren_string[i] == '(')\n        {\n            levels[level] = level;\n\
    \            level++;\n        }\n        else if(paren_string[i] == ')')\n  \
    \      {\n            levels[level] = level;\n            level--;\n        }\n\
    \        else if(paren_string[i] == ' ')\n        {\n            levels[level]\
    \ = level;\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string[i] ==\
    \ '(')\n        {\n            levels[level] = level;\n            level++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            levels[level]\
    \ = level;\n            level--;\n        }\n        else if(paren_string\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj25ry5ep.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpj25ry5ep.d(117): Error: found `unittest` when\
    \ expecting `)`\\n/tmp/tmpj25ry5ep.d(125): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmpj25ry5ep.d(125): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj25ry5ep.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_count_sum\
    \ = 0;\n    long paren_level_count_count_max = 0;\n    long paren_level_count_count_min\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi868oaj_.d(67): Error: semicolon expected, not `unittest`\\n/tmp/tmpi868oaj_.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpi868oaj_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS] = {0};\n    long levels_index\
    \ = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS]\
    \ = {0};\n    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n\
    \    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long\
    \ paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7\
    \ = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n\
    \    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long\
    \ paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14\
    \ = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n\
    \    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long\
    \ paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21\
    \ = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n\
    \    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long\
    \ paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28\
    \ = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n\
    \    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long\
    \ paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35\
    \ = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n\
    \    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long\
    \ paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42\
    \ = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n\
    \    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprr7ski0m.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmprr7ski0m.d(20): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_levels`\\n/tmp/tmprr7ski0m.d(68):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmprr7ski0m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    bool in_paren = false;\n    bool in_bracket\
    \ = false;\n    bool in_brace = false;\n    bool in_paren_group = false;\n   \
    \ bool in_bracket_group = false;\n    bool in_brace_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_bracket_group_open = false;\n    bool in_brace_group_open\
    \ = false;\n    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed\
    \ = false;\n    bool in_brace_group_closed = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_bracket_group_open_brace = false;\n    bool in_brace_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_paren_group_open_bracket\
    \ = false;\n    bool in_bracket_group_open_bracket = false;\n    bool in_brace_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_paren_group_open_brace_group\
    \ = false;\n    bool in_bracket_group_open_brace_group = false;\n    bool in_brace_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_paren_group_open_brace_group_open\
    \ = false;\n    bool in_bracket_group_open_brace_group_open = false;\n    bool\
    \ in_brace_group_open_brace_group_open = false;\n    bool in_paren_group_closed_brace_group_open\
    \ = false;\n    bool in_bracket_group_closed_brace_group_open = false;\n    bool\
    \ in_brace_group_closed_brace_group_open = false;\n    bool in_paren_group_open_brace_group_closed\
    \ = false;\n    bool in_bracket_group_open_brace_group_closed = false;\n    bool\
    \ in_brace_group_open_brace_group_closed = false;\n    bool in_paren_group_closed_brace_group_closed\
    \ = false;\n    bool in_bracket_group_closed_brace_group_closed = false;\n   \
    \ \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmoq0rwsi.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpmoq0rwsi.d(61): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmoq0rwsi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n    long level_stack_pos\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_stack[MAX_LEVELS];\n \
    \   long paren_level_stack_pos = 0;\n    long paren_level_stack_size = 0;\n  \
    \  long paren_level_stack_top = 0;\n    long paren_level_stack_bottom = 0;\n \
    \   long paren_level_stack_top_index = 0;\n    long paren_level_stack_bottom_index\
    \ = 0;\n    long paren_level_stack_top_index2 = 0;\n    long paren_level_stack_bottom_index2\
    \ = 0;\n    long paren_level_stack_top_index3 = 0;\n    long paren_level_stack_bottom_index3\
    \ = 0;\n    long paren_level_stack_top_index4 = 0;\n    long paren_level_stack_bottom_index4\
    \ = 0;\n    long paren_level_stack_top_index5 = 0;\n    long paren_level_stack_bottom_index5\
    \ = 0;\n    long paren_level_stack_top_index6 = 0;\n    long paren_level_stack_bottom_index6\
    \ = 0;\n    long paren_level_stack_top_index7 = 0;\n    long paren_level_stack_bottom_index7\
    \ = 0;\n    long paren_level_stack_top_index8 = 0;\n    long paren_level_stack_bottom_index8\
    \ = 0;\n    long paren_level_stack_top_index9 = 0;\n    long paren_level_stack_bottom_index9\
    \ = 0;\n    long paren_level_stack_top_index10 = 0;\n    long paren_level_stack_bottom_index10\
    \ = 0;\n    long paren_level_stack_top_index11 = 0;\n    long paren_level_stack_bottom_index11\
    \ = 0;\n    long paren_level_stack_top_index12 = 0;\n    long paren_level_stack_bottom_index12\
    \ = 0;\n    long paren_level_stack_top_index13 = 0;\n    long paren_level_stack_bottom_index13\
    \ = 0;\n    long paren_level_stack_top_index14 = 0;\n    long paren_level_stack_bottom_index14\
    \ = 0;\n    long paren_level_stack_top_index15 = 0;\n    long paren_level_stack_bottom_index15\
    \ = 0;\n    long paren_level_stack_top_index16 = 0;\n    long paren_level_stack_bottom_index16\
    \ = 0;\n    long paren_level_stack_top_index17 = 0;\n    long paren_level_stack_bottom_index17\
    \ = 0;\n    long paren_level_stack_top_index18 = 0;\n    long paren_level_stack_bottom_index18\
    \ = 0;\n    long paren_level_stack_top_index19 = 0;\n    long paren_level_stack_bottom_index19\
    \ = 0;\n    long paren_level_stack_top_index20 = 0;\n    long paren_level_stack_bottom_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjchl61v.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] level_stack`\\n/tmp/tmphjchl61v.d(19): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_stack`\\\
    n/tmp/tmphjchl61v.d(64): Error: semicolon expected, not `unittest`\\n/tmp/tmphjchl61v.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphjchl61v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long max_level = 0;\n    long level\
    \ = 0;\n    long pos = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpijo7_yul.d(86): Error: no identifier for declarator `bool`\\\
    n/tmp/tmpijo7_yul.d(86): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpijo7_yul.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next = 0;\n    long paren_level_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwdjbbjqo.d(50): Error: semicolon expected, not `unittest`\\n/tmp/tmpwdjbbjqo.d(50):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwdjbbjqo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for nested parentheses such as `((()))`\n<|/ c |>\n<| c |>\n: It does work.\
    \ Try it yourself. It returns `[2, 3, 1, 3]`.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ But it also returns `[2, 3, 1, 3]` for `((()))`\n<|/ c |>\n<| c |>\n: It returns\
    \ `[2, 3, 1, 3]` for me. Try it yourself.\n<|/ c |>\n<| c |>\nIt returns `[2,\
    \ 3, 1, 3]` for me too. Try it yourself.\n<|/ c |>\n<| a |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcf34u8j6.d(30): Error: declaration expected, not `<`\\n/tmp/tmpcf34u8j6.d(33):\
    \ Error: unterminated character constant\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpcf34u8j6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long level_index\
    \ = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n    bool has_paren\
    \ = false;\n    bool has_space = false;\n    bool has_comma = false;\n    bool\
    \ has_opening_paren = false;\n    bool has_closing_paren = false;\n    bool has_opening_paren_comma\
    \ = false;\n    bool has_closing_paren_comma = false;\n    bool has_opening_paren_space\
    \ = false;\n    bool has_closing_paren_space = false;\n    bool has_opening_paren_comma_and_space\
    \ = false;\n    bool has_closing_paren_comma_and_space = false;\n    bool has_opening_paren_space_and_comma\
    \ = false;\n    bool has_closing_paren_space_and_comma = false;\n    bool has_opening_paren_space_and_space\
    \ = false;\n    bool has_closing_paren_space_and_space = false;\n    bool has_opening_paren_comma_and_space_and_space\
    \ = false;\n    bool has_closing_paren_comma_and_space_and_space = false;\n  \
    \  bool has_opening_paren_space_and_space_and_space = false;\n    bool has_closing_paren_space_and_space_and_space\
    \ = false;\n    bool has_opening_paren_comma_and_space_and_space_and_space = false;\n\
    \    bool has_closing_paren_comma_and_space_and_space_and_space = false;\n   \
    \ bool has_opening_paren_space_and_space_and_space_and_space = false;\n    bool\
    \ has_closing_paren_space_and_space_and_space_and_space = false;\n    bool has_opening_paren_comma_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_closing_paren_comma_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_opening_paren_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_closing_paren_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_opening_paren_comma_and_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_closing_paren_comma_and_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_opening_paren_space_and_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_closing_paren_space_and_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_opening_paren_comma_and_space_and_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_closing_paren_comma_and_space_and_space_and_space_and_space_and_space_and_space\
    \ = false;\n    bool has_opening_paren_space_and_space_and_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp76ny5u9n.d(54): Error: semicolon expected, not `unittest`\\n/tmp/tmp76ny5u9n.d(54):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp76ny5u9n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    string current_level = \"\";\n    long\
    \ current_level_length = 0;\n    long current_level_nesting = 0;\n    long current_level_nesting_length\
    \ = 0;\n    long current_level_nesting_nesting = 0;\n    long current_level_nesting_nesting_length\
    \ = 0;\n    long current_level_nesting_nesting_nesting = 0;\n    long current_level_nesting_nesting_nesting_length\
    \ = 0;\n    long current_level_nesting_nesting_nesting_nesting = 0;\n    long\
    \ current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_level_nesting_nesting_nesting_length = 0;\n    long current_level_nesting_nesting_nesting_nesting\
    \ = 0;\n    long current_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl6j45azi.d(55): Error: semicolon expected, not `unittest`\\n/tmp/tmpl6j45azi.d(55):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpl6j45azi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_first = true;\n    bool is_last = true;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening = true;\n    bool is_closing\
    \ = false;\n    bool is_opening_open = false;\n    bool is_opening_closed = false;\n\
    \    bool is_closing_open = false;\n    bool is_closing_closed = false;\n    bool\
    \ is_opening_opening_open = false;\n    bool is_opening_opening_closed = false;\n\
    \    bool is_opening_closing_open = false;\n    bool is_opening_closing_closed\
    \ = false;\n    bool is_closing_opening_open = false;\n    bool is_closing_opening_closed\
    \ = false;\n    bool is_closing_closing_open = false;\n    bool is_closing_closing_closed\
    \ = false;\n    bool is_opening_opening_opening_open = false;\n    bool is_opening_opening_opening_closed\
    \ = false;\n    bool is_opening_opening_closing_open = false;\n    bool is_opening_opening_closing_closed\
    \ = false;\n    bool is_opening_closing_opening_open = false;\n    bool is_opening_closing_opening_closed\
    \ = false;\n    bool is_opening_closing_closing_open = false;\n    bool is_opening_closing_closing_closed\
    \ = false;\n    bool is_closing_opening_opening_open = false;\n    bool is_closing_opening_opening_closed\
    \ = false;\n    bool is_closing_opening_closing_open = false;\n    bool is_closing_opening_closing_closed\
    \ = false;\n    bool is_closing_closing_opening_open = false;\n    bool is_closing_closing_opening_closed\
    \ = false;\n    bool is_closing_closing_closing_open = false;\n    bool is_closing_closing_closing_closed\
    \ = false;\n    bool is_opening_opening_opening_open = false;\n    bool is_opening_opening_opening_closed\
    \ = false;\n    bool is_opening_opening_closing_open = false;\n    bool is_opening_opening_closing_closed\
    \ = false;\n    bool is_opening_closing_opening_open = false;\n    bool is_opening_closing_opening_closed\
    \ = false;\n    bool is_opening_closing_closing_open = false;\n    bool is_opening_closing_closing_closed\
    \ = false;\n    bool is_closing_opening_opening_open = false;\n    bool is_closing_opening_opening_closed\
    \ = false;\n    bool is_closing_opening_closing_open = false;\n    bool is_closing_opening_closing_closed\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ac9tc7p.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp_ac9tc7p.d(64): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ac9tc7p.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbz_fv240.d(45): Error: semicolon expected, not `unittest`\\n/tmp/tmpbz_fv240.d(45):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpbz_fv240.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening\
    \ = false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_curly_bracket_or_paren\
    \ = false;\n    bool is_closing_curly_bracket_or_paren = false;\n    bool is_opening_square_bracket_or_paren\
    \ = false;\n    bool is_closing_square_bracket_or_paren = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_square_bracket_or_paren_or_space = false;\n    bool is_closing_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_paren_or_space = false;\n    bool is_closing_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_square_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_square_bracket_or_paren_or_space = false;\n  \
    \  bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfsbucip9.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpfsbucip9.d(56): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpfsbucip9.d(56): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfsbucip9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwci7l95.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpbwci7l95.d(19): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `long[] paren_levels`\\n/tmp/tmpbwci7l95.d(67): Error:\
    \ semicolon expected, not `unittest`\\n/tmp/tmpbwci7l95.d(67): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpbwci7l95.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] current_levels = new long[paren_string.length()];\n\
    \    long[] current_levels_lengths = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum = new long[paren_string.length()];\n    long[] current_levels_lengths_sum2\
    \ = new long[paren_string.length()];\n    long[] current_levels_lengths_sum3 =\
    \ new long[paren_string.length()];\n    long[] current_levels_lengths_sum4 = new\
    \ long[paren_string.length()];\n    long[] current_levels_lengths_sum5 = new long[paren_string.length()];\n\
    \    long[] current_levels_lengths_sum6 = new long[paren_string.length()];\n \
    \   long[] current_levels_lengths_sum7 = new long[paren_string.length()];\n  \
    \  long[] current_levels_lengths_sum8 = new long[paren_string.length()];\n   \
    \ long[] current_levels_lengths_sum9 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum10 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum11 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum12 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum13 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum14 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum15 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum16 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum17 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum18 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum19 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum20 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum21 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum22 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum23 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum24 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum25 = new long[paren_string.length()];\n    long[]\
    \ current_levels_lengths_sum26 = new long[paren_string.length()];\n    long\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_fcn85i2.d(44): Error: no identifier for declarator `long`\\\
    n/tmp/tmp_fcn85i2.d(44): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_fcn85i2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    while(i < paren_string.length()) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n            levels[i] = level;\n\
    \        } else if(c == ')') {\n            level--;\n            levels[i] =\
    \ level;\n            if(level == 0) {\n                max_level = max(max_level,\
    \ levels[levels.length - 1]);\n            }\n        } else {\n            levels[i]\
    \ = level;\n        }\n        i++;\n    }\n    return max_level;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `parse_nested_parens(\"\
    ((()))\")` returns `1` instead of `3`.\n<|/ c |>\n<| c |>\nThis doesn't seem to\
    \ work. `parse_nested_parens(\"((()))\")` returns `1` instead of `3`.\n<|/ c |>\n\
    <| c |>\nThis doesn't seem to work. `parse_nested_parens(\"((()))\")` returns\
    \ `1` instead of `3`.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `parse_nested_parens(\"\
    ((()))\")` returns `1` instead of `3`.\n<|/ c |>\n<| c |>\nThis doesn't seem to\
    \ work. `parse_nested_parens(\"((()))\")` returns `1` instead of `3`.\n<|/ c |>\n\
    <| a dscore=2 |>\nI wrote a recursive solution that doesn't use any loops or recursion.\n\
    <code>\npublic static int getMaxNesting(String input) {\n    int max = 0;\n  \
    \  String[] parts = input.split(\"\\\\s+\");\n    for(int i = 0; i < parts.length;\
    \ i++) {\n        max = Math.max(max, getNesting(parts[i]));\n    }\n    return\
    \ max;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvhk6u7vd.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpvhk6u7vd.d(36): Error: declaration expected,\
    \ not `<`\\n/tmp/tmpvhk6u7vd.d(39): Error: unterminated character constant\\n/tmp/tmpvhk6u7vd.d(42):\
    \ Error: unterminated character constant\\n/tmp/tmpvhk6u7vd.d(45): Error: unterminated\
    \ character constant\\n/tmp/tmpvhk6u7vd.d(48): Error: unterminated character constant\\\
    n/tmp/tmpvhk6u7vd.d(51): Error: unterminated character constant\\n/tmp/tmpvhk6u7vd.d(54):\
    \ Error: unterminated character constant\\n/tmp/tmpvhk6u7vd.d(59): Error: declaration\
    \ expected, not `for`\\n/tmp/tmpvhk6u7vd.d(59): Error: no identifier for declarator\
    \ `i`\\n/tmp/tmpvhk6u7vd.d(59): Error: declaration expected, not `<`\\n/tmp/tmpvhk6u7vd.d(59):\
    \ Error: no identifier for declarator `i`\\n/tmp/tmpvhk6u7vd.d(59): Error: declaration\
    \ expected, not `++`\\n/tmp/tmpvhk6u7vd.d(61): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvhk6u7vd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next = 0;\n    long paren_level_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next = 0;\n    long paren_level_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpijsaekcz.d(50): Error: semicolon expected, not `unittest`\\n/tmp/tmpijsaekcz.d(50):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpijsaekcz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 1;\n    bool has_open = false;\n    bool has_close = false;\n    bool has_open2\
    \ = false;\n    bool has_close2 = false;\n    bool has_open3 = false;\n    bool\
    \ has_close3 = false;\n    bool has_open4 = false;\n    bool has_close4 = false;\n\
    \    bool has_open5 = false;\n    bool has_close5 = false;\n    bool has_open6\
    \ = false;\n    bool has_close6 = false;\n    bool has_open7 = false;\n    bool\
    \ has_close7 = false;\n    bool has_open8 = false;\n    bool has_close8 = false;\n\
    \    bool has_open9 = false;\n    bool has_close9 = false;\n    bool has_open10\
    \ = false;\n    bool has_close10 = false;\n    bool has_open11 = false;\n    bool\
    \ has_close11 = false;\n    bool has_open12 = false;\n    bool has_close12 = false;\n\
    \    bool has_open13 = false;\n    bool has_close13 = false;\n    bool has_open14\
    \ = false;\n    bool has_close14 = false;\n    bool has_open15 = false;\n    bool\
    \ has_close15 = false;\n    bool has_open16 = false;\n    bool has_close16 = false;\n\
    \    bool has_open17 = false;\n    bool has_close17 = false;\n    bool has_open18\
    \ = false;\n    bool has_close18 = false;\n    bool has_open19 = false;\n    bool\
    \ has_close19 = false;\n    bool has_open20 = false;\n    bool has_close20 = false;\n\
    \    bool has_open21 = false;\n    bool has_close21 = false;\n    bool has_open22\
    \ = false;\n    bool has_close22 = false;\n    bool has_open23 = false;\n    bool\
    \ has_close23 = false;\n    bool has_open24 = false;\n    bool has_close24 = false;\n\
    \    bool has_open25 = false;\n    bool has_close25 = false;\n    bool has_open26\
    \ = false;\n    bool has_close26 = false;\n    bool has_open27 = false;\n    bool\
    \ has_close27 = false;\n    bool has_open28 = false;\n    bool has_close28 = false;\n\
    \    bool has_open29 = false;\n    bool has_close29 = false;\n    bool has_open30\
    \ = false;\n    bool has_close30 = false;\n    bool has_open31 = false;\n    bool\
    \ has_close31 = false;\n    bool has_open32 = false;\n    bool has_close32 = false;\n\
    \    bool has_open33 = false;\n    bool has_close33 = false;\n    bool has_open34\
    \ = false;\n    bool has_close34 = false;\n    bool has_open35 = false;\n    bool\
    \ \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyrzizc0u.d(87): Error: no identifier for declarator `bool`\\\
    n/tmp/tmpyrzizc0u.d(87): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyrzizc0u.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    bool has_paren\
    \ = false;\n    bool has_space = false;\n    bool has_spaces = false;\n    bool\
    \ has_spaces_after_paren = false;\n    bool has_spaces_after_space = false;\n\
    \    bool has_spaces_after_spaces = false;\n    bool has_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_space = false;\n    bool has_spaces_after_spaces_after_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_paren = false;\n\
    \    bool has_spaces_after_spaces_after_spaces_after_space = false;\n    bool\
    \ has_spaces_after_spaces_after_spaces_after_spaces = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvuh3e2rl.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpvuh3e2rl.d(39): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpvuh3e2rl.d(39): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvuh3e2rl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4bfnyaec.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp4bfnyaec.d(47): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmp4bfnyaec.d(47): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4bfnyaec.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp646g_xyx.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp646g_xyx.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp646g_xyx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n    long level_stack_pointer\
    \ = 0;\n    long paren_stack_pointer = 0;\n    long paren_level = 0;\n    long\
    \ paren_level_stack[MAX_LEVELS];\n    long paren_level_stack_pointer = 0;\n  \
    \  long paren_level_count = 0;\n    long paren_level_count_stack[MAX_LEVELS];\n\
    \    long paren_level_count_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_max\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmqjk0r05.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] level_stack`\\n/tmp/tmpmqjk0r05.d(20): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_stack`\\\
    n/tmp/tmpmqjk0r05.d(23): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_stack`\\n/tmp/tmpmqjk0r05.d(26): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpmqjk0r05.d(29): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpmqjk0r05.d(32): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpmqjk0r05.d(35): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpmqjk0r05.d(38): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpmqjk0r05.d(41): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpmqjk0r05.d(44): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpmqjk0r05.d(47): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpmqjk0r05.d(50): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpmqjk0r05.d(53): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpmqjk0r05.d(56): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpmqjk0r05.d(59): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpmqjk0r05.d(62): Error:\
    \ semicolon expected, not `unittest`\\n/tmp/tmpmqjk0r05.d(62): Error: found `unitte"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        if(level < 0)\n  \
    \      {\n            level = 0;\n        }\n        levels[i] = level;\n    }\n\
    \    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer.\
    \ Your code works perfectly for simple cases but fails for more complex cases.\
    \ E.g. `parse_nested_parens(\"(()()) ((())) () ((())()())\")` returns `[2, 3,\
    \ 1, 3]` instead of `[2, 3, 2, 3]`.\n<|/ c |>\n<| c |>\nI fixed the bug in the\
    \ code. Now it works for all cases. Thanks!\n<|/ c |>\n<| a dscore=0 |>\nI wrote\
    \ a recursive solution that works in O(n) time and O(1) space. \n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4mbivb7r.d(34): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4mbivb7r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long level = 0;\n    long levels_stack_index = 0;\n    long max_level = 0;\n\
    \    long max_level_index = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_paren_or_closed = false;\n    bool is_closing_paren_or_open\
    \ = false;\n    bool is_opening_paren_or_opening_paren = false;\n    bool is_closing_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_open = false;\n    bool\
    \ is_closing_paren_or_closing_paren_or_closed = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_closing_paren_or_open = false;\n\
    \    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_closing_paren_or_open = false;\n\
    \    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_clo\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2gaa48jg.d(44): Error: semicolon expected, not `unittest`\\n/tmp/tmp2gaa48jg.d(44):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp2gaa48jg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long level = 0;\n    long level_stack = 0;\n    long max_level = 0;\n   \
    \ bool is_first = true;\n    bool is_last = true;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing = false;\n    bool is_closing_paren_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_paren = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening = false;\n \
    \   bool is_closing_paren_or_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpynxakj91.d(45): Error: semicolon expected, not `unittest`\\n/tmp/tmpynxakj91.d(45):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpynxakj91.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxqnpb1qa.d(14): Error: no property `length` for type `string`\\\
    n/tmp/tmpxqnpb1qa.d(16): Error: no property `length` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxqnpb1qa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long\
    \ paren_level_cur_count = 0;\n    long paren_level_cur_max = 0;\n    long paren_level_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_count = 0;\n    long paren_level_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_count\
    \ = 0;\n    long paren_level_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_count = 0;\n    long paren_level_cur_cur_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_count\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_count = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_count\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_count = 0;\n    long\
    \ paren_level_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_count = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_count = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_count = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long\
    \ paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt474lr23.d(55): Error: semicolon expected, not `unittest`\\n/tmp/tmpt474lr23.d(55):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpt474lr23.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] max_levels = new long[paren_string.length()];\n\
    \    long[] level = 0;\n    long[] max_level = 0;\n    bool in_paren = false;\n\
    \    bool in_paren_group = false;\n    bool in_paren_group2 = false;\n    bool\
    \ in_paren_group3 = false;\n    bool in_paren_group4 = false;\n    bool in_paren_group5\
    \ = false;\n    bool in_paren_group6 = false;\n    bool in_paren_group7 = false;\n\
    \    bool in_paren_group8 = false;\n    bool in_paren_group9 = false;\n    bool\
    \ in_paren_group10 = false;\n    bool in_paren_group11 = false;\n    bool in_paren_group12\
    \ = false;\n    bool in_paren_group13 = false;\n    bool in_paren_group14 = false;\n\
    \    bool in_paren_group15 = false;\n    bool in_paren_group16 = false;\n    bool\
    \ in_paren_group17 = false;\n    bool in_paren_group18 = false;\n    bool in_paren_group19\
    \ = false;\n    bool in_paren_group20 = false;\n    bool in_paren_group21 = false;\n\
    \    bool in_paren_group22 = false;\n    bool in_paren_group23 = false;\n    bool\
    \ in_paren_group24 = false;\n    bool in_paren_group25 = false;\n    bool in_paren_group26\
    \ = false;\n    bool in_paren_group27 = false;\n    bool in_paren_group28 = false;\n\
    \    bool in_paren_group29 = false;\n    bool in_paren_group30 = false;\n    bool\
    \ in_paren_group31 = false;\n    bool in_paren_group32 = false;\n    bool in_paren_group33\
    \ = false;\n    bool in_paren_group34 = false;\n    bool in_paren_group35 = false;\n\
    \    bool in_paren_group36 = false;\n    bool in_paren_group37 = false;\n    bool\
    \ in_paren_group38 = false;\n    bool in_paren_group39 = false;\n    bool in_paren_group40\
    \ = false;\n    bool in_paren_group41 = false;\n    bool in_paren_group42 = false;\n\
    \    bool in_paren_group43 = false;\n    bool in_paren_group44 = false;\n    bool\
    \ in_paren_group45 = false;\n    bool in_paren_group46 = false;\n    bool in_paren_group47\
    \ = false;\n    bool in_paren_group48 = false;\n    bool in_paren_group49 = false;\n\
    \    bool in_paren_group50 = false;\n    bool in_paren_group51 = false;\n    \n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8q1or_y6.d(71): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8q1or_y6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long max_level = 0;\n    long level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpigodzo03.d(86): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpigodzo03.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long[] max_levels = new long[paren_string.length()];\n\
    \    long[] max_levels_index = new long[paren_string.length()];\n    long[] max_levels_index2\
    \ = new long[paren_string.length()];\n    long[] max_levels_index3 = new long[paren_string.length()];\n\
    \    long[] max_levels_index4 = new long[paren_string.length()];\n    long[] max_levels_index5\
    \ = new long[paren_string.length()];\n    long[] max_levels_index6 = new long[paren_string.length()];\n\
    \    long[] max_levels_index7 = new long[paren_string.length()];\n    long[] max_levels_index8\
    \ = new long[paren_string.length()];\n    long[] max_levels_index9 = new long[paren_string.length()];\n\
    \    long[] max_levels_index10 = new long[paren_string.length()];\n    long[]\
    \ max_levels_index11 = new long[paren_string.length()];\n    long[] max_levels_index12\
    \ = new long[paren_string.length()];\n    long[] max_levels_index13 = new long[paren_string.length()];\n\
    \    long[] max_levels_index14 = new long[paren_string.length()];\n    long[]\
    \ max_levels_index15 = new long[paren_string.length()];\n    long[] max_levels_index16\
    \ = new long[paren_string.length()];\n    long[] max_levels_index17 = new long[paren_string.length()];\n\
    \    long[] max_levels_index18 = new long[paren_string.length()];\n    long[]\
    \ max_levels_index19 = new long[paren_string.length()];\n    long[] max_levels_index20\
    \ = new long[paren_string.length()];\n    long[] max_levels_index21 = new long[paren_string.length()];\n\
    \    long[] max_levels_index22 = new long[paren_string.length()];\n    long[]\
    \ max_levels_index23 = new long[paren_string.length()];\n    long[] max_levels_index24\
    \ = new long[paren_string.length()];\n    long[] max_levels_index25 = new long[paren_string.length()];\n\
    \    long[] max_levels_index26 = new long[paren_string.length()];\n    long[]\
    \ max_levels_index27 = new long[paren_string.length()];\n    long[] max_levels_index28\
    \ = new long[paren_string.length()];\n    long[] max_levels_index29 = new long[paren_string.length()];\n\
    \    long[] max_levels_index30 = new long[paren_string.length()];\n    long[]\
    \ max_level\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_n7x4sm0.d(47): Error: semicolon expected, not `unittest`\\n/tmp/tmp_n7x4sm0.d(47):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_n7x4sm0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++)\n    {\n        if(paren_string[i] == '(')\n\
    \        {\n            level++;\n        }\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you\
    \ for sharing your solution. I am not familiar with recursive functions. Could\
    \ you please explain how it works?\n<|/ c |>\n<| c |>\nSure. `parse_nested_parens()`\
    \ takes in a string and returns a list of integers representing the levels of\
    \ nesting of parentheses in the string. `levels[i]` is the level of nesting at\
    \ position `i` in the string. `level` keeps track of the current level of nesting.\
    \ `level++` increments `level` by one and `level--` decrements `level` by one.\
    \ `levels[]` stores the levels of nesting in a way that allows us to easily find\
    \ the deepest level of nesting.\n<|/ c |>\n<| c |>\nThank you so much for explaining\
    \ your solution. I really appreciate it. I will try to understand your solution\
    \ and try to implement it in my code. Thanks again!\n<|/ c |>\n<| c |>\nI implemented\
    \ your solution in my code and I got this error: \"Exception in thread \"main\"\
    \ java.lang.ArrayIndexOutOfBoundsException: -1\". Do you know what this means?\n\
    <|/ c |>\n<| c |>\nI fixed the error by changing \"levels[level]++;\" to \"levels[level-1]++;\"\
    . Thank you so much for your help!\n<|/ c |>\n<| a tags=java,algorithm |>\nI implemented\
    \ a recursive solution in Java. \n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc4p_odnt.d(30): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc4p_odnt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_max = 0;\n    long paren_level_next2 = 0;\n    long paren_level_next3\
    \ = 0;\n    long paren_level_next4 = 0;\n    long paren_level_next5 = 0;\n   \
    \ long paren_level_next6 = 0;\n    long paren_level_next7 = 0;\n    long paren_level_next8\
    \ = 0;\n    long paren_level_next9 = 0;\n    long paren_level_next10 = 0;\n  \
    \  long paren_level_next11 = 0;\n    long paren_level_next12 = 0;\n    long paren_level_next13\
    \ = 0;\n    long paren_level_next14 = 0;\n    long paren_level_next15 = 0;\n \
    \   long paren_level_next16 = 0;\n    long paren_level_next17 = 0;\n    long paren_level_next18\
    \ = 0;\n    long paren_level_next19 = 0;\n    long paren_level_next20 = 0;\n \
    \   long paren_level_next21 = 0;\n    long paren_level_next22 = 0;\n    long paren_level_next23\
    \ = 0;\n    long paren_level_next24 = 0;\n    long paren_level_next25 = 0;\n \
    \   long paren_level_next26 = 0;\n    long paren_level_next27 = 0;\n    long paren_level_next28\
    \ = 0;\n    long paren_level_next29 = 0;\n    long paren_level_next30 = 0;\n \
    \   long paren_level_next31 = 0;\n    long paren_level_next32 = 0;\n    long paren_level_next33\
    \ = 0;\n    long paren_level_next34 = 0;\n    long paren_level_next35 = 0;\n \
    \   long paren_level_next36 = 0;\n    long paren_level_next37 = 0;\n    long paren_level_next38\
    \ = 0;\n    long paren_level_next39 = 0;\n    long paren_level_next40 = 0;\n \
    \   long paren_level_next41 = 0;\n    long paren_level_next42 = 0;\n    long paren_level_next43\
    \ = 0;\n    long paren_level_next44 = 0;\n    long paren_level_next45 = 0;\n \
    \   long paren_level_next46 = 0;\n    long paren_level_next47 = 0;\n    long paren_level_next48\
    \ = 0;\n    long paren_level_next49 = 0;\n    long paren_level_next50 = 0;\n \
    \   long paren_level_next51 = 0;\n    long paren_level_next52 = 0;\n    long paren_level_next53\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa1i2evsa.d(72): Error: semicolon expected, not `unittest`\\n/tmp/tmpa1i2evsa.d(72):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpa1i2evsa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_min_max = 0;\n\
    \    long paren_level_count_max_min = 0;\n    long paren_level_count_min_max_max\
    \ = 0;\n    long paren_level_count_min_max_max_min = 0;\n    long paren_level_count_min_max_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min = 0;\n    long paren_level_count_min_max_max_min_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min = 0;\n    long\
    \ paren_level_count_min_max_max_min_max_min_max_min_max = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = 0;\n    long paren_level_count_min_max_max_min_max_min_max_min_max_min_max_min_max_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe8u_i_82.d(44): Error: semicolon expected, not `unittest`\\n/tmp/tmpe8u_i_82.d(44):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpe8u_i_82.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_cur\
    \ = 0;\n    long paren_level_next = 0;\n    long paren_level_next2 = 0;\n    long\
    \ paren_level_next3 = 0;\n    long paren_level_next4 = 0;\n    long paren_level_next5\
    \ = 0;\n    long paren_level_next6 = 0;\n    long paren_level_next7 = 0;\n   \
    \ long paren_level_next8 = 0;\n    long paren_level_next9 = 0;\n    long paren_level_next10\
    \ = 0;\n    long paren_level_next11 = 0;\n    long paren_level_next12 = 0;\n \
    \   long paren_level_next13 = 0;\n    long paren_level_next14 = 0;\n    long paren_level_next15\
    \ = 0;\n    long paren_level_next16 = 0;\n    long paren_level_next17 = 0;\n \
    \   long paren_level_next18 = 0;\n    long paren_level_next19 = 0;\n    long paren_level_next20\
    \ = 0;\n    long paren_level_next21 = 0;\n    long paren_level_next22 = 0;\n \
    \   long paren_level_next23 = 0;\n    long paren_level_next24 = 0;\n    long paren_level_next25\
    \ = 0;\n    long paren_level_next26 = 0;\n    long paren_level_next27 = 0;\n \
    \   long paren_level_next28 = 0;\n    long paren_level_next29 = 0;\n    long paren_level_next30\
    \ = 0;\n    long paren_level_next31 = 0;\n    long paren_level_next32 = 0;\n \
    \   long paren_level_next33 = 0;\n    long paren_level_next34 = 0;\n    long paren_level_next35\
    \ = 0;\n    long paren_level_next36 = 0;\n    long paren_level_next37 = 0;\n \
    \   long paren_level_next38 = 0;\n    long paren_level_next39 = 0;\n    long paren_level_next40\
    \ = 0;\n    long paren_level_next41 = 0;\n    long paren_level_next42 = 0;\n \
    \   long paren_level_next43 = 0;\n    long paren_level_next44 = 0;\n    long paren_level_next45\
    \ = 0;\n    long paren_level_next46 = 0;\n    long paren_level_next47 = 0;\n \
    \   long paren_level_next48 = 0;\n    long paren_level_next49 = 0;\n    long paren_level_next50\
    \ = 0;\n    long paren_level_next51 = 0;\n    long paren_level_next52 = 0;\n \
    \   \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt50gp5sp.d(73): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt50gp5sp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_chars[MAX_LEVELS];\n\
    \    string paren_char;\n    string paren_chars[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_char;\n    string paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp74o_mbmj.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp74o_mbmj.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(21): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(23):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(25): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(27):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(29): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(31):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(33): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(35):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(37): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(39):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(41): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(43):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(45): Deprecation: instead of C-style syntax,\
    \ use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp74o_mbmj.d(47):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_chars`\\n/tmp/tmp74o_mbmj.d(49): Deprecation: instead of C-style syntax, "
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool has_open = false;\n    bool has_close = false;\n    bool has_open_brace\
    \ = false;\n    bool has_close_brace = false;\n    bool has_open_paren = false;\n\
    \    bool has_close_paren = false;\n    bool has_open_curly = false;\n    bool\
    \ has_close_curly = false;\n    bool has_open_paren_or_curly = false;\n    bool\
    \ has_close_paren_or_curly = false;\n    bool has_open_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_cur\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpypo1zvhk.d(49): Error: semicolon expected, not `unittest`\\n/tmp/tmpypo1zvhk.d(49):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpypo1zvhk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n            levels[level] = level;\n      \
    \  }\n        else if(paren_string[i] == ')') {\n            level--;\n      \
    \      if(level == 0) {\n                max_level = max(max_level, levels[level]);\n\
    \            }\n        }\n    }\n    return max_level;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nI wrote a recursive solution in C#, that works with any number\
    \ of nested parentheses.\n<code>\nstatic List<int> GetMaxLevels(string str)\n\
    {\n    List<int> levels = new List<int>();\n    levels = GetMaxLevelsRecursive(str,\
    \ levels);\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3mu4xvw8.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp3mu4xvw8.d(31): Error: declaration expected,\
    \ not `<`\\n/tmp/tmp3mu4xvw8.d(39): Error: no identifier for declarator `levels`\\\
    n/tmp/tmp3mu4xvw8.d(39): Error: declaration expected, not `=`\\n/tmp/tmp3mu4xvw8.d(40):\
    \ Error: declaration expected, not `return`\\n/tmp/tmp3mu4xvw8.d(41): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3mu4xvw8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_count_max\
    \ = 0;\n    long paren_level_count_count_min = 0;\n    long paren_level_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_max = 0;\n    long paren_level_count_count_count_min\
    \ = 0;\n    long paren_level_count_count_count_sum = 0;\n    long paren_level_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_max = 0;\n    long\
    \ paren_level_count_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_max = 0;\n  \
    \  long paren_level_count_count_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_max = 0;\n\
    \    long paren_level_count_count_count_count_count_count_count_min = 0;\n   \
    \ long paren_level_count_count_count_count_count_count_count_sum = 0;\n    long\
    \ paren_level_count_count_count_count_count_count_count_count_max = 0;\n    long\
    \ paren_level_count_count_count_count_count_count_count_min = 0;\n    long paren_level_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_min\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_sum\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    long paren_level_count_count_count_count_count_count_count_count_count_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6fdh6_55.d(53): Error: semicolon expected, not `unittest`\\n/tmp/tmp6fdh6_55.d(53):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6fdh6_55.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    long max_level_count = 0;\n    long current_level\
    \ = 0;\n    long current_level_count = 0;\n    long current_max_level = 0;\n \
    \   long current_max_level_count = 0;\n    bool has_opening_paren = false;\n \
    \   bool has_closing_paren = false;\n    bool has_opening_paren_or_closing_paren\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_opening_paren = false;\n    bool has_closing_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ has_closing_paren_or_closing_paren_or_opening_paren = false;\n    bool has_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpitiu71g4.d(50): Error: semicolon expected, not `unittest`\\n/tmp/tmpitiu71g4.d(50):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpitiu71g4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long max_level = 0;\n    long current_level\
    \ = 0;\n    long current_index = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3vjtz3fv.d(68): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3vjtz3fv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_diff = 0;\n    long paren_level_diff2 = 0;\n    long paren_level_diff3\
    \ = 0;\n    long paren_level_diff4 = 0;\n    long paren_level_diff5 = 0;\n   \
    \ long paren_level_diff6 = 0;\n    long paren_level_diff7 = 0;\n    long paren_level_diff8\
    \ = 0;\n    long paren_level_diff9 = 0;\n    long paren_level_diff10 = 0;\n  \
    \  long paren_level_diff11 = 0;\n    long paren_level_diff12 = 0;\n    long paren_level_diff13\
    \ = 0;\n    long paren_level_diff14 = 0;\n    long paren_level_diff15 = 0;\n \
    \   long paren_level_diff16 = 0;\n    long paren_level_diff17 = 0;\n    long paren_level_diff18\
    \ = 0;\n    long paren_level_diff19 = 0;\n    long paren_level_diff20 = 0;\n \
    \   long paren_level_diff21 = 0;\n    long paren_level_diff22 = 0;\n    long paren_level_diff23\
    \ = 0;\n    long paren_level_diff24 = 0;\n    long paren_level_diff25 = 0;\n \
    \   long paren_level_diff26 = 0;\n    long paren_level_diff27 = 0;\n    long paren_level_diff28\
    \ = 0;\n    long paren_level_diff29 = 0;\n    long paren_level_diff30 = 0;\n \
    \   long paren_level_diff31 = 0;\n    long paren_level_diff32 = 0;\n    long paren_level_diff33\
    \ = 0;\n    long paren_level_diff34 = 0;\n    long paren_level_diff35 = 0;\n \
    \   long paren_level_diff36 = 0;\n    long paren_level_diff37 = 0;\n    long paren_level_diff38\
    \ = 0;\n    long paren_level_diff39 = 0;\n    long paren_level_diff40 = 0;\n \
    \   long paren_level_diff41 = 0;\n    long paren_level_diff42 = 0;\n    long paren_level_diff43\
    \ = 0;\n    long paren_level_diff44 = 0;\n    long paren_level_diff45 = 0;\n \
    \   long paren_level_diff46 = 0;\n    long paren_level_diff47 = 0;\n    long paren_level_diff48\
    \ = 0;\n    long paren_level_diff49 = 0;\n    long paren_level_diff50 = 0;\n \
    \   long paren_level_diff51 = 0;\n    long paren_level_diff52 = 0;\n    long paren_level_diff53\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgwl8nwjk.d(72): Error: semicolon expected, not `unittest`\\n/tmp/tmpgwl8nwjk.d(72):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgwl8nwjk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[MAX_LEVELS];\n    long\
    \ levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n\
    \    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxttgfjbt.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpxttgfjbt.d(79): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmpxttgfjbt.d(79): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxttgfjbt.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    bool has_left_paren = false;\n    bool\
    \ has_right_paren = false;\n    long level = 0;\n    long max_level = 0;\n   \
    \ long max_level_left = 0;\n    long max_level_right = 0;\n    long max_level_left_left\
    \ = 0;\n    long max_level_left_right = 0;\n    long max_level_right_left = 0;\n\
    \    long max_level_right_right = 0;\n    long level_left = 0;\n    long level_right\
    \ = 0;\n    long level_left_left = 0;\n    long level_left_right = 0;\n    long\
    \ level_right_left = 0;\n    long level_right_right = 0;\n    long level_left_left_left\
    \ = 0;\n    long level_left_left_right = 0;\n    long level_left_right_left =\
    \ 0;\n    long level_left_right_right = 0;\n    long level_right_left_left = 0;\n\
    \    long level_right_left_right = 0;\n    long level_right_right_left = 0;\n\
    \    long level_right_right_right = 0;\n    long level_left_left_left_left = 0;\n\
    \    long level_left_left_left_right = 0;\n    long level_left_left_right_left\
    \ = 0;\n    long level_left_left_right_right = 0;\n    long level_left_right_left_left\
    \ = 0;\n    long level_left_right_left_right = 0;\n    long level_left_right_right_left\
    \ = 0;\n    long level_left_right_right_right = 0;\n    long level_right_left_left_left\
    \ = 0;\n    long level_right_left_left_right = 0;\n    long level_right_left_right_left\
    \ = 0;\n    long level_right_left_right_right = 0;\n    long level_right_right_left_left\
    \ = 0;\n    long level_right_right_left_right = 0;\n    long level_right_right_right_left\
    \ = 0;\n    long level_right_right_right_right = 0;\n    long level_left_left_left_left_left\
    \ = 0;\n    long level_left_left_left_left_right = 0;\n    long level_left_left_left_right_left\
    \ = 0;\n    long level_left_left_left_right_right = 0;\n    long level_left_left_right_left_left\
    \ = 0;\n    long level_left_left_right_left_right = 0;\n    long level_left_left_right_right_left\
    \ = 0;\n    long level_left_left_right_right_right = 0;\n    long level_left_right_left_left_left\
    \ = 0;\n    long level_left_right_left_left_right = 0;\n    long level_left_right_left_right_left\
    \ = 0;\n    long level_left_right_left_right_right = 0;\n    long level_left_right_right_left_left\
    \ = 0;\n    long level_left_right_right_left_right = 0;\n    long level_left_right_right_right_left\
    \ = 0;\n    long level_left_right_right_right_right = 0;\n    long level_right_left_left_left_left\
    \ = 0;\n    long level_right_left_left_left_right = 0;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz6dg80mk.d(73): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz6dg80mk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_chars\
    \ = paren_string;\n    long[] levels = new long[paren_chars.length()];\n    long\
    \ level = 0;\n    long max_level = 0;\n    long max_level_index = 0;\n    bool\
    \ has_open = false;\n    bool has_close = false;\n    bool has_open_brace = false;\n\
    \    bool has_close_brace = false;\n    bool has_open_bracket = false;\n    bool\
    \ has_close_bracket = false;\n    bool has_open_paren = false;\n    bool has_close_paren\
    \ = false;\n    bool has_open_curly = false;\n    bool has_close_curly = false;\n\
    \    bool has_open_paren_or_curly = false;\n    bool has_close_paren_or_curly\
    \ = false;\n    bool has_open_curly_or_curly = false;\n    bool has_close_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly = false;\n    bool has_close_paren_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_paren_or_curly_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjeqtkfca.d(52): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjeqtkfca.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace = false;\n    bool in_paren_group_close_brace_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiki9fxpt.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpiki9fxpt.d(47): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmpiki9fxpt.d(47): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiki9fxpt.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_open2 = false;\n    bool is_closed2 = false;\n    bool\
    \ is_open3 = false;\n    bool is_closed3 = false;\n    bool is_open4 = false;\n\
    \    bool is_closed4 = false;\n    bool is_open5 = false;\n    bool is_closed5\
    \ = false;\n    bool is_open6 = false;\n    bool is_closed6 = false;\n    bool\
    \ is_open7 = false;\n    bool is_closed7 = false;\n    bool is_open8 = false;\n\
    \    bool is_closed8 = false;\n    bool is_open9 = false;\n    bool is_closed9\
    \ = false;\n    bool is_open10 = false;\n    bool is_closed10 = false;\n    bool\
    \ is_open11 = false;\n    bool is_closed11 = false;\n    bool is_open12 = false;\n\
    \    bool is_closed12 = false;\n    bool is_open13 = false;\n    bool is_closed13\
    \ = false;\n    bool is_open14 = false;\n    bool is_closed14 = false;\n    bool\
    \ is_open15 = false;\n    bool is_closed15 = false;\n    bool is_open16 = false;\n\
    \    bool is_closed16 = false;\n    bool is_open17 = false;\n    bool is_closed17\
    \ = false;\n    bool is_open18 = false;\n    bool is_closed18 = false;\n    bool\
    \ is_open19 = false;\n    bool is_closed19 = false;\n    bool is_open20 = false;\n\
    \    bool is_closed20 = false;\n    bool is_open21 = false;\n    bool is_closed21\
    \ = false;\n    bool is_open22 = false;\n    bool is_closed22 = false;\n    bool\
    \ is_open23 = false;\n    bool is_closed23 = false;\n    bool is_open24 = false;\n\
    \    bool is_closed24 = false;\n    bool is_open25 = false;\n    bool is_closed25\
    \ = false;\n    bool is_open26 = false;\n    bool is_closed26 = false;\n    bool\
    \ is_open27 = false;\n    bool is_closed27 = false;\n    bool is_open28 = false;\n\
    \    bool is_closed28 = false;\n    bool is_open29 = false;\n    bool is_closed29\
    \ = false;\n    bool is_open30 = false;\n    bool is_closed30 = false;\n    bool\
    \ is_open31 = false;\n    bool is_closed31 = false;\n    bool is_open32 = false;\n\
    \    bool is_closed32 = false;\n    bool is_open33 = false;\n    bool is_closed33\
    \ = false;\n    bool is_open34 = false;\n    bool is_closed34\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph_95fzcr.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmph_95fzcr.d(87): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmph_95fzcr.d(87): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph_95fzcr.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren =\
    \ false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_close = false;\n    bool in_group_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open = false;\n    bool in_group_close_brace_open\
    \ = false;\n    bool in_group_open_brace_close_brace = false;\n    bool in_group_close_brace_close_brace\
    \ = false;\n    bool in_group_open_brace_open_brace = false;\n    bool in_group_close_brace_open_brace\
    \ = false;\n    bool in_group_open_brace_close_brace_close = false;\n    bool\
    \ in_group_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close = false;\n    bool\
    \ in_group_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close = false;\n\
    \    bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_open_brace_close\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp79rqinfe.d(49): Error: semicolon expected, not `unittest`\\n/tmp/tmp79rqinfe.d(49):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp79rqinfe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_string\
    \ = paren_string.trim();\n    for(int i = 0; i < paren_string.length(); i++) {\n\
    \        char c = paren_string[i];\n        if(c == '(') {\n            levels[level]\
    \ = level;\n            level++;\n        }\n        else if(c == ')') {\n   \
    \         level = levels[level];\n        }\n        else {\n            levels[level]\
    \ = MAX_LEVELS;\n        }\n        if(level > max_level) {\n            max_level\
    \ = level;\n        }\n    }\n    long[] result = new long[max_level + 1];\n \
    \   for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level = levels[level];\n        }\n     \
    \   else if(c == ')') {\n            level = levels[level];\n        }\n     \
    \   else {\n            result[level] = i;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| c |>\nThanks for the answer.\
    \ I am not able to understand how this works. Can you please explain it a bit?\n\
    <|/ c |>\n<| c |>\nI added some comments to explain how it works.\n<|/ c |>\n\
    <| c |>\nThanks for the explanation. Can you please explain how this works?\n\
    <|/ c |>\n<| c |>\nI added some comments to explain how it works.\n<|/ c |>\n\
    <| c |>\nThanks for the explanation. Can you please explain how this works?\n\
    <|/ c |>\n<| a |>\n<code>\n#include <iostream>\n#include <string>\n#include <vector>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7o3ka1jv.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp7o3ka1jv.d(49): Error: declaration\
    \ expected, not `<`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7o3ka1jv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_stack;\n\
    \    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_index46 = 0;\n    long paren_levels_index47 = 0;\n    long\
    \ paren_levels_index48 = 0;\n    long paren_levels_index49 = 0;\n\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp55rn4ekn.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] paren_levels`\\n/tmp/tmp55rn4ekn.d(67): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp55rn4ekn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpekw_xjad.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpekw_xjad.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpekw_xjad.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string parens[MAX_LEVELS];\n\
    \    string current_paren;\n    string current_paren_level;\n    string current_paren_levels[MAX_LEVELS];\n\
    \    string current_paren_levels_string = \"\";\n    string current_paren_levels_string_length\
    \ = 0;\n    string current_paren_levels_string_lengths[MAX_LEVELS];\n    string\
    \ current_paren_levels_string_lengths_string = \"\";\n    string current_paren_levels_string_lengths_string_length\
    \ = 0;\n    string current_paren_levels_string_lengths_string_lengths[MAX_LEVELS];\n\
    \    string current_paren_levels_string_lengths_string_lengths_string = \"\";\n\
    \    string current_paren_levels_string_lengths_string_lengths_string_length =\
    \ 0;\n    string current_paren_levels_string_lengths_string_lengths_string_lengths[MAX_LEVELS];\n\
    \    string current_paren_levels_string_lengths_string_lengths_string_lengths_string\
    \ = \"\";\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_length\
    \ = 0;\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths[MAX_LEVELS];\n\
    \    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string\
    \ = \"\";\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_length\
    \ = 0;\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths[MAX_LEVELS];\n\
    \    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string\
    \ = \"\";\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_length\
    \ = 0;\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths[MAX_LEVELS];\n\
    \    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string\
    \ = \"\";\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_length\
    \ = 0;\n    string current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths[MAX_LEVELS];\n\
    \    string current_paren_levels_string_lengths_string_lengths_string_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpapbozzga.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpapbozzga.d(17): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] parens`\\n/tmp/tmpapbozzga.d(20):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ current_paren_levels`\\n/tmp/tmpapbozzga.d(23): Deprecation: instead of C-style\
    \ syntax, use D-style syntax `string[MAX_LEVELS] current_paren_levels_string_lengths`\\\
    n/tmp/tmpapbozzga.d(26): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `string[MAX_LEVELS] current_paren_levels_string_lengths_string_lengths`\\n/tmp/tmpapbozzga.d(29):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ current_paren_levels_string_lengths_string_lengths_string_lengths`\\n/tmp/tmpapbozzga.d(32):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths`\\\
    n/tmp/tmpapbozzga.d(35): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `string[MAX_LEVELS] current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths`\\\
    n/tmp/tmpapbozzga.d(38): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `string[MAX_LEVELS] current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths`\\\
    n/tmp/tmpapbozzga.d(41): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `string[MAX_LEVELS] current_paren_levels_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths_string_lengths`\\\
    n/tmp/tmpapbozzga.d(42): Error: found `current_paren_levels_string_lengths_string_lengths_string_`\
    \ when expecting `;` following statement\\n/tmp/tmpapbozzga.d(43): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpapbozzga.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n    long paren_levels[MAX_LEVELS];\n\
    \    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n    long\
    \ paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long paren_levels_index5\
    \ = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n\
    \    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n    long\
    \ paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n\
    \    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n    long\
    \ paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n\
    \    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n    long\
    \ paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long paren_levels_index26\
    \ = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n\
    \    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n    long\
    \ paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long paren_levels_index33\
    \ = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n\
    \    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n    long\
    \ paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long paren_levels_index40\
    \ = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n\
    \    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n    long\
    \ paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n    long paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt01ecash.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpt01ecash.d(20): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_levels`\\n/tmp/tmpt01ecash.d(68):\
    \ Error: semicolon expected, not `unittest`\\n/tmp/tmpt01ecash.d(68): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpt01ecash.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_strings[MAX_LEVELS];\n\
    \    string paren_strings_temp;\n    string paren_strings_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp;\n    string paren_strings_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp;\n    string paren_strings_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp;\n    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n    string\
    \ paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp;\n\
    \    string paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_lyxbtu9.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp_lyxbtu9.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp_lyxbtu9.d(19):\
    \ Deprecation: instead of C-style syntax, use D-style syntax `string[MAX_LEVELS]\
    \ paren_strings`\\n/tmp/tmp_lyxbtu9.d(44): Error: found `paren_strings_temp_temp_temp_temp_temp_temp_temp_temp_`\
    \ when expecting `;` following statement\\n/tmp/tmp_lyxbtu9.d(45): Error: found\
    \ `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_lyxbtu9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    while(i < paren_string.length())\n    {\n        char c\
    \ = paren_string[i];\n        if(c == '(')\n        {\n            level++;\n\
    \        }\n        else if(c == ')')\n        {\n            level--;\n     \
    \   }\n        levels[i] = level;\n        i++;\n    }\n    for(int j = 0; j <\
    \ levels.length; j++)\n    {\n        if(levels[j] > max_level)\n        {\n \
    \           max_level = levels[j];\n        }\n    }\n    return levels;\n}\n\
    </code>\n<|/ a tags=algorithm,c++,parentheses,string |>\n<| c |>\nI like your\
    \ solution. I'm going to try it out and see how it goes. Thanks!\n<|/ c |>\n<|\
    \ c |>\nI tested it and it works perfectly. Thanks so much!\n<|/ c |>\n<| a tags=algorithm,c++,parentheses,string\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3lbp0jw.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmpf3lbp0jw.d(41): Error: declaration expected,\
    \ not `<`\\n/tmp/tmpf3lbp0jw.d(44): Error: unterminated character constant\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf3lbp0jw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_sum = 0;\n  \
    \  long paren_level_count_sum_max = 0;\n    long paren_level_count_sum_min = 0;\n\
    \    long paren_level_count_sum_avg = 0;\n    long paren_level_count_sum_avg_max\
    \ = 0;\n    long paren_level_count_sum_avg_min = 0;\n    long paren_level_count_sum_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_max = 0;\n    long paren_level_count_sum_avg_avg_min\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_level_count_sum_avg_avg_avg = 0;\n    long paren_level_count_sum_avg_avg_avg\
    \ = 0;\n    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfzwvl78x.d(60): Error: semicolon expected, not `unittest`\\n/tmp/tmpfzwvl78x.d(60):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfzwvl78x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long level_counter\
    \ = 0;\n    long level_counters[MAX_LEVELS];\n    long level_counters_index =\
    \ 0;\n    long level_counters_index2 = 0;\n    long level_counters_index3 = 0;\n\
    \    long level_counters_index4 = 0;\n    long level_counters_index5 = 0;\n  \
    \  long level_counters_index6 = 0;\n    long level_counters_index7 = 0;\n    long\
    \ level_counters_index8 = 0;\n    long level_counters_index9 = 0;\n    long level_counters_index10\
    \ = 0;\n    long level_counters_index11 = 0;\n    long level_counters_index12\
    \ = 0;\n    long level_counters_index13 = 0;\n    long level_counters_index14\
    \ = 0;\n    long level_counters_index15 = 0;\n    long level_counters_index16\
    \ = 0;\n    long level_counters_index17 = 0;\n    long level_counters_index18\
    \ = 0;\n    long level_counters_index19 = 0;\n    long level_counters_index20\
    \ = 0;\n    long level_counters_index21 = 0;\n    long level_counters_index22\
    \ = 0;\n    long level_counters_index23 = 0;\n    long level_counters_index24\
    \ = 0;\n    long level_counters_index25 = 0;\n    long level_counters_index26\
    \ = 0;\n    long level_counters_index27 = 0;\n    long level_counters_index28\
    \ = 0;\n    long level_counters_index29 = 0;\n    long level_counters_index30\
    \ = 0;\n    long level_counters_index31 = 0;\n    long level_counters_index32\
    \ = 0;\n    long level_counters_index33 = 0;\n    long level_counters_index34\
    \ = 0;\n    long level_counters_index35 = 0;\n    long level_counters_index36\
    \ = 0;\n    long level_counters_index37 = 0;\n    long level_counters_index38\
    \ = 0;\n    long level_counters_index39 = 0;\n    long level_counters_index40\
    \ = 0;\n    long level_counters_index41 = 0;\n    long level_counters_index42\
    \ = 0;\n    long level_counters_index43 = 0;\n    long level_counters_index44\
    \ = 0;\n    long level_counters_index45 = 0;\n    long level_counters_index46\
    \ = 0;\n    long level_counters_index47 = 0;\n    long level_counters_index48\
    \ = 0;\n    long level_counters_index49 = 0;\n    long level_counters_index50\
    \ = 0;\n    long level_counters_index51 = 0;\n    long level_counters_index52\
    \ = 0;\n    long level_counters_index53 = 0;\n    long \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5w352ai6.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp5w352ai6.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] level_counters`\\n/tmp/tmp5w352ai6.d(73):\
    \ Error: no identifier for declarator `long`\\n/tmp/tmp5w352ai6.d(73): Error:\
    \ found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp5w352ai6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long level_index\
    \ = 0;\n    bool has_opening = false;\n    bool has_closing = false;\n    bool\
    \ has_opening_closing = false;\n    bool has_opening_opening_closing = false;\n\
    \    bool has_opening_opening_opening_closing = false;\n    bool has_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_closing = false;\n\
    \    bool has_opening_opening_opening_opening_opening_opening_closing = false;\n\
    \    bool has_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_opening_closing\
    \ = false;\n    bool has_opening_opening_opening_opening_opening_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3vxlhupl.d(41): Error: semicolon expected, not `unittest`\\n/tmp/tmp3vxlhupl.d(41):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3vxlhupl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    bool in_parens = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace = false;\n    bool in_group_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close = false;\n  \
    \  bool in_group_open_brace_or_close_brace_or_open_brace = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzb_dqbtn.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpzb_dqbtn.d(42): Error: semicolon\
    \ expected, not `unittest`\\n/tmp/tmpzb_dqbtn.d(42): Error: found `unittest` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzb_dqbtn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5y7i7_4t.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp5y7i7_4t.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp5y7i7_4t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxpke_607.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpxpke_607.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpxpke_607.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_group;\n    string paren_group_string;\n    string paren_group_char;\n\
    \    string paren_group_chars[MAX_LEVELS];\n    long paren_group_length = 0;\n\
    \    long paren_group_count = 0;\n    long paren_group_count_max = 0;\n    long\
    \ paren_group_count_current = 0;\n    long paren_group_count_max2 = 0;\n    long\
    \ paren_group_count_current2 = 0;\n    long paren_group_count_max3 = 0;\n    long\
    \ paren_group_count_current3 = 0;\n    long paren_group_count_max4 = 0;\n    long\
    \ paren_group_count_current4 = 0;\n    long paren_group_count_max5 = 0;\n    long\
    \ paren_group_count_current5 = 0;\n    long paren_group_count_max6 = 0;\n    long\
    \ paren_group_count_current6 = 0;\n    long paren_group_count_max7 = 0;\n    long\
    \ paren_group_count_current7 = 0;\n    long paren_group_count_max8 = 0;\n    long\
    \ paren_group_count_current8 = 0;\n    long paren_group_count_max9 = 0;\n    long\
    \ paren_group_count_current9 = 0;\n    long paren_group_count_max10 = 0;\n   \
    \ long paren_group_count_current10 = 0;\n    long paren_group_count_max11 = 0;\n\
    \    long paren_group_count_current11 = 0;\n    long paren_group_count_max12 =\
    \ 0;\n    long paren_group_count_current12 = 0;\n    long paren_group_count_max13\
    \ = 0;\n    long paren_group_count_current13 = 0;\n    long paren_group_count_max14\
    \ = 0;\n    long paren_group_count_current14 = 0;\n    long paren_group_count_max15\
    \ = 0;\n    long paren_group_count_current15 = 0;\n    long paren_group_count_max16\
    \ = 0;\n    long paren_group_count_current16 = 0;\n    long paren_group_count_max17\
    \ = 0;\n    long paren_group_count_current17 = 0;\n    long paren_group_count_max18\
    \ = 0;\n    long paren_group_count_current18 = 0;\n    long paren_group_count_max19\
    \ = 0;\n    long paren_group_count_current19 = 0;\n    long paren_group_count_max20\
    \ = 0;\n    long paren_group_count_current20 = 0;\n    long paren_group_count_max21\
    \ = 0;\n    long paren_group_count_current21 = 0;\n    long paren_group_count_max22\
    \ = 0;\n    long paren_group_count_current22 = 0;\n    long paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph20s_enx.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmph20s_enx.d(21): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_group_chars`\\\
    n/tmp/tmph20s_enx.d(69): Error: semicolon expected, not `unittest`\\n/tmp/tmph20s_enx.d(69):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmph20s_enx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_paren = 0;\n    long level_paren\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_paren = 0;\n    long paren_level_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren = 0;\n    long paren_level_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren = 0;\n \
    \   long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren = 0;\n\
    \    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_paren_paren_paren_paren_paren_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1z2vs1cc.d(39): Error: semicolon expected, not `unittest`\\n/tmp/tmp1z2vs1cc.d(39):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1z2vs1cc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprekna6dg.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmprekna6dg.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmprekna6dg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren =\
    \ false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool in_group3\
    \ = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n    bool\
    \ in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8 = false;\n\
    \    bool in_group9 = false;\n    bool in_group10 = false;\n    bool in_group11\
    \ = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n    bool\
    \ in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16 = false;\n\
    \    bool in_group17 = false;\n    bool in_group18 = false;\n    bool in_group19\
    \ = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n    bool\
    \ in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24 = false;\n\
    \    bool in_group25 = false;\n    bool in_group26 = false;\n    bool in_group27\
    \ = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n    bool\
    \ in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32 = false;\n\
    \    bool in_group33 = false;\n    bool in_group34 = false;\n    bool in_group35\
    \ = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n    bool\
    \ in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40 = false;\n\
    \    bool in_group41 = false;\n    bool in_group42 = false;\n    bool in_group43\
    \ = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n    bool\
    \ in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48 = false;\n\
    \    bool in_group49 = false;\n    bool in_group50 = false;\n    bool in_group51\
    \ = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n    bool\
    \ in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56 = false;\n\
    \    bool in_group57 = false;\n    bool in_group58 = false;\n    bool in_group59\
    \ = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n    bool\
    \ in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64 = false;\n\
    \    bool in_group65 = false;\n    bool in_group66 = false;\n    bool in_group67\
    \ = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_1_bnkmd.d(85): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_1_bnkmd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    \n    foreach(char\
    \ c in paren_string) {\n        if(c == '(') {\n            levels[level] = level;\n\
    \            level++;\n        } else if(c == ')') {\n            level--;\n \
    \           if(levels[level] == 0) {\n                levels[level] = level;\n\
    \            }\n        } else {\n            levels[level] = 0;\n        }\n\
    \        \n        if(level > max_level) {\n            max_level = level;\n \
    \       }\n    }\n    \n    long[] result = new long[max_level + 1];\n    for(int\
    \ i = 0; i < max_level; i++) {\n        result[i] = levels[i];\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr9q0e_oc.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpr9q0e_oc.d(18): Error: found `in`\
    \ when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr9q0e_oc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren =\
    \ false;\n    for(int i = 0; i < paren_string.length(); i++) {\n        char c\
    \ = paren_string[i];\n        if(c == '(') {\n            in_paren = true;\n \
    \           level++;\n        }\n        else if(c == ')') {\n            in_paren\
    \ = false;\n            level--;\n        }\n        else if(!in_paren) {\n  \
    \          levels[level] = levels[level] + 1;\n        }\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c# |>\n<| c |>\nI like this solution,\
    \ but I wonder if it will work for all cases. For example, what about `((()))`?\
    \ It has three levels of nesting, but your algorithm returns `2`.\n<|/ c |>\n\
    <| c |>\nYes, I agree with you. My algorithm only works for nested parentheses\
    \ separated by spaces. I didn't think about other cases. Thanks for pointing out.\n\
    <|/ c |>\n<| a tags=string,algorithm,c# |>\nI wrote a recursive solution that\
    \ seems to work well:\n<code>\npublic static int GetMaxNestingLevel(string input)\n\
    {\n    if (input.Length == 0)\n        return 0;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwrzrnotr.d(33): Error: declaration expected, not `<`\\n/tmp/tmpwrzrnotr.d(39):\
    \ Error: unterminated character constant\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpwrzrnotr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2 = 0;\n\
    \    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 = 0;\n  \
    \  long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n    long\
    \ max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n    long level7\
    \ = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9 =\
    \ 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbn5o3nft.d(95): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbn5o3nft.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_prev\
    \ = 0;\n    long paren_level_next = 0;\n    long paren_level_next_prev = 0;\n\
    \    long paren_level_next_next = 0;\n    long paren_level_next_next_prev = 0;\n\
    \    long paren_level_next_next_next = 0;\n    long paren_level_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpju590jid.d(53): Error: semicolon expected, not `unittest`\\n/tmp/tmpju590jid.d(53):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpju590jid.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cqca716.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmp5cqca716.d(79): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmp5cqca716.d(79): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5cqca716.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_pos = -1;\n    bool has_open = false;\n    bool has_close\
    \ = false;\n    bool has_open_brace = false;\n    bool has_close_brace = false;\n\
    \    bool has_open_brace_or_close_brace = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ela1hen.d(51): Error: semicolon expected, not `unittest`\\n/tmp/tmp3ela1hen.d(51):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3ela1hen.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) {\n        if(paren_string[i] == '(') {\n  \
    \          level++;\n        }\n        else if(paren_string[i] == ')') {\n  \
    \          level--;\n        }\n        levels[i] = level;\n    }\n    return\
    \ levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpge6fi09s.d(14): Error: no property `length` for type `string`\\\
    n/tmp/tmpge6fi09s.d(16): Error: no property `length` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpge6fi09s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n    long level_stack_pointer\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_stack[MAX_LEVELS];\n \
    \   long paren_level_stack_pointer = 0;\n    long paren_level_count = 0;\n   \
    \ long paren_level_count_stack[MAX_LEVELS];\n    long paren_level_count_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n\
    \    long paren_level_count_max_stack_pointer = 0;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n\
    \    long paren_level_count_max_stack_pointer = 0;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n\
    \    long paren_level_count_max_stack_pointer = 0;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n\
    \    long paren_level_count_max_stack_pointer = 0;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n\
    \    long paren_level_count_max_stack_pointer = 0;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_stack[MAX_LEVELS];\n\
    \    long paren_level_count_max_stack_pointer = 0;\n    long paren_level_count_min\
    \ = 0;\n    long paren_level_count_min_stack[MAX_LEVELS];\n    long paren_level_count_min_stack_pointer\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkew_ysum.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] level_stack`\\n/tmp/tmpkew_ysum.d(19): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_stack`\\\
    n/tmp/tmpkew_ysum.d(22): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_stack`\\n/tmp/tmpkew_ysum.d(25): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpkew_ysum.d(28): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpkew_ysum.d(31): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpkew_ysum.d(34): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpkew_ysum.d(37): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpkew_ysum.d(40): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpkew_ysum.d(43): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpkew_ysum.d(46): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpkew_ysum.d(49): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpkew_ysum.d(52): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpkew_ysum.d(55): Deprecation:\
    \ instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_count_max_stack`\\\
    n/tmp/tmpkew_ysum.d(58): Deprecation: instead of C-style syntax, use D-style syntax\
    \ `long[MAX_LEVELS] paren_level_count_min_stack`\\n/tmp/tmpkew_ysum.d(62): Error:\
    \ semicolon expected, not `unittest`\\n/tmp/tmpkew_ysum.d(62): Error: found `unitte"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgtby71f8.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpgtby71f8.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpgtby71f8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    string paren_char;\n\
    \    string paren_chars[MAX_LEVELS];\n    string paren_chars_string = \"\";\n\
    \    string paren_chars_string_temp;\n    string paren_chars_string_temp2;\n \
    \   string paren_chars_string_temp3;\n    string paren_chars_string_temp4;\n \
    \   string paren_chars_string_temp5;\n    string paren_chars_string_temp6;\n \
    \   string paren_chars_string_temp7;\n    string paren_chars_string_temp8;\n \
    \   string paren_chars_string_temp9;\n    string paren_chars_string_temp10;\n\
    \    string paren_chars_string_temp11;\n    string paren_chars_string_temp12;\n\
    \    string paren_chars_string_temp13;\n    string paren_chars_string_temp14;\n\
    \    string paren_chars_string_temp15;\n    string paren_chars_string_temp16;\n\
    \    string paren_chars_string_temp17;\n    string paren_chars_string_temp18;\n\
    \    string paren_chars_string_temp19;\n    string paren_chars_string_temp20;\n\
    \    string paren_chars_string_temp21;\n    string paren_chars_string_temp22;\n\
    \    string paren_chars_string_temp23;\n    string paren_chars_string_temp24;\n\
    \    string paren_chars_string_temp25;\n    string paren_chars_string_temp26;\n\
    \    string paren_chars_string_temp27;\n    string paren_chars_string_temp28;\n\
    \    string paren_chars_string_temp29;\n    string paren_chars_string_temp30;\n\
    \    string paren_chars_string_temp31;\n    string paren_chars_string_temp32;\n\
    \    string paren_chars_string_temp33;\n    string paren_chars_string_temp34;\n\
    \    string paren_chars_string_temp35;\n    string paren_chars_string_temp36;\n\
    \    string paren_chars_string_temp37;\n    string paren_chars_string_temp38;\n\
    \    string paren_chars_string_temp39;\n    string paren_chars_string_temp40;\n\
    \    string paren_chars_string_temp41;\n    string paren_chars_string_temp42;\n\
    \    string paren_chars_string_temp43;\n    string paren_chars_string_temp44\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp129khd4r.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmp129khd4r.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `string[MAX_LEVELS] paren_chars`\\n/tmp/tmp129khd4r.d(63):\
    \ Error: found `paren_chars_string_temp44` when expecting `;` following statement\\\
    n/tmp/tmp129khd4r.d(64): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp129khd4r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long level_index\
    \ = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n    bool\
    \ in_paren_group_open = false;\n    bool in_paren_group_close = false;\n    bool\
    \ in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace = false;\n\
    \    bool in_paren_group_open_brace_or_close_brace = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace =\
    \ false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open_brace_or_close_or_open\
    \ = false;\n    bool in_paren_group_open_brace_or_close_brace_or_open_brace_or_close_or_open_brace_or_close_or_open_b\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfx0fznoh.d(38): Error: semicolon expected, not `unittest`\\n/tmp/tmpfx0fznoh.d(38):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfx0fznoh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_paren\
    \ = false;\n    bool in_paren_group_close_paren = false;\n    bool in_paren_group_open_curly\
    \ = false;\n    bool in_paren_group_close_curly = false;\n    bool in_paren_group_open_angle\
    \ = false;\n    bool in_paren_group_close_angle = false;\n    bool in_paren_group_open_paren_angle\
    \ = false;\n    bool in_paren_group_close_paren_angle = false;\n    bool in_paren_group_open_curly_angle\
    \ = false;\n    bool in_paren_group_close_curly_angle = false;\n    bool in_paren_group_open_paren_brace\
    \ = false;\n    bool in_paren_group_close_paren_brace = false;\n    bool in_paren_group_open_curly_brace\
    \ = false;\n    bool in_paren_group_close_curly_brace = false;\n    bool in_paren_group_open_angle_brace\
    \ = false;\n    bool in_paren_group_close_angle_brace = false;\n    bool in_paren_group_open_paren_angle_brace\
    \ = false;\n    bool in_paren_group_close_paren_angle_brace = false;\n    bool\
    \ in_paren_group_open_curly_angle_brace = false;\n    bool in_paren_group_close_curly_angle_brace\
    \ = false;\n    bool in_paren_group_open_paren_brace_angle = false;\n    bool\
    \ in_paren_group_close_paren_brace_angle = false;\n    bool in_paren_group_open_curly_brace_angle\
    \ = false;\n    bool in_paren_group_close_curly_brace_angle = false;\n    bool\
    \ in_paren_group_open_angle_brace_angle = false;\n    bool in_paren_group_close_angle_brace_angle\
    \ = false;\n    bool in_paren_group_open_paren_angle_brace_angle = false;\n  \
    \  bool in_paren_group_close_paren_angle_brace_angle = false;\n    bool in_paren_group_open_curly_brace_angle_brace\
    \ = false;\n    bool in_paren_group_close_curly_brace_angle_brace = false;\n \
    \   bool in_paren_group_open_angle_brace_angle_brace = false;\n    bool in_paren_group_close_angle_brace_angle_brace\
    \ = false;\n    bool in_paren_group_open_paren_angle_brace_angle\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppfjiqb4w.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmppfjiqb4w.d(56): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmppfjiqb4w.d(56): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfjiqb4w.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdbauel9a.d(75): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdbauel9a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeazhg778.d(86): Error: no identifier for declarator `bool`\\\
    n/tmp/tmpeazhg778.d(86): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeazhg778.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long level_counter\
    \ = 0;\n    long level_counters[MAX_LEVELS];\n    long level_counters_index =\
    \ 0;\n    long level_counters_index2 = 0;\n    long level_counters_index3 = 0;\n\
    \    long level_counters_index4 = 0;\n    long level_counters_index5 = 0;\n  \
    \  long level_counters_index6 = 0;\n    long level_counters_index7 = 0;\n    long\
    \ level_counters_index8 = 0;\n    long level_counters_index9 = 0;\n    long level_counters_index10\
    \ = 0;\n    long level_counters_index11 = 0;\n    long level_counters_index12\
    \ = 0;\n    long level_counters_index13 = 0;\n    long level_counters_index14\
    \ = 0;\n    long level_counters_index15 = 0;\n    long level_counters_index16\
    \ = 0;\n    long level_counters_index17 = 0;\n    long level_counters_index18\
    \ = 0;\n    long level_counters_index19 = 0;\n    long level_counters_index20\
    \ = 0;\n    long level_counters_index21 = 0;\n    long level_counters_index22\
    \ = 0;\n    long level_counters_index23 = 0;\n    long level_counters_index24\
    \ = 0;\n    long level_counters_index25 = 0;\n    long level_counters_index26\
    \ = 0;\n    long level_counters_index27 = 0;\n    long level_counters_index28\
    \ = 0;\n    long level_counters_index29 = 0;\n    long level_counters_index30\
    \ = 0;\n    long level_counters_index31 = 0;\n    long level_counters_index32\
    \ = 0;\n    long level_counters_index33 = 0;\n    long level_counters_index34\
    \ = 0;\n    long level_counters_index35 = 0;\n    long level_counters_index36\
    \ = 0;\n    long level_counters_index37 = 0;\n    long level_counters_index38\
    \ = 0;\n    long level_counters_index39 = 0;\n    long level_counters_index40\
    \ = 0;\n    long level_counters_index41 = 0;\n    long level_counters_index42\
    \ = 0;\n    long level_counters_index43 = 0;\n    long level_counters_index44\
    \ = 0;\n    long level_counters_index45 = 0;\n    long level_counters_index46\
    \ = 0;\n    long level_counters_index47 = 0;\n    long level_counters_index48\
    \ = 0;\n    long level_counters_index49 = 0;\n    long level_counters_index50\
    \ = 0;\n    long level_counters_index51 = 0;\n    long level_counters_index52\
    \ = 0;\n    long level_counters_index53 = 0;\n    long \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpus0z75qu.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpus0z75qu.d(18): Deprecation: instead\
    \ of C-style syntax, use D-style syntax `long[MAX_LEVELS] level_counters`\\n/tmp/tmpus0z75qu.d(73):\
    \ Error: no identifier for declarator `long`\\n/tmp/tmpus0z75qu.d(73): Error:\
    \ found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpus0z75qu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string paren_groups\
    \ = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] max_levels_index\
    \ = new long[paren_groups.length()];\n    long[] levels_index = new long[paren_groups.length()];\n\
    \    long[] max_levels_index2 = new long[paren_groups.length()];\n    long[] levels_index2\
    \ = new long[paren_groups.length()];\n    long[] max_levels_index3 = new long[paren_groups.length()];\n\
    \    long[] levels_index3 = new long[paren_groups.length()];\n    long[] max_levels_index4\
    \ = new long[paren_groups.length()];\n    long[] levels_index4 = new long[paren_groups.length()];\n\
    \    long[] max_levels_index5 = new long[paren_groups.length()];\n    long[] levels_index5\
    \ = new long[paren_groups.length()];\n    long[] max_levels_index6 = new long[paren_groups.length()];\n\
    \    long[] levels_index6 = new long[paren_groups.length()];\n    long[] max_levels_index7\
    \ = new long[paren_groups.length()];\n    long[] levels_index7 = new long[paren_groups.length()];\n\
    \    long[] max_levels_index8 = new long[paren_groups.length()];\n    long[] levels_index8\
    \ = new long[paren_groups.length()];\n    long[] max_levels_index9 = new long[paren_groups.length()];\n\
    \    long[] levels_index9 = new long[paren_groups.length()];\n    long[] max_levels_index10\
    \ = new long[paren_groups.length()];\n    long[] levels_index10 = new long[paren_groups.length()];\n\
    \    long[] max_levels_index11 = new long[paren_groups.length()];\n    long[]\
    \ levels_index11 = new long[paren_groups.length()];\n    long[] max_levels_index12\
    \ = new long[paren_groups.length()];\n    long[] levels_index12 = new long[paren_groups.length()];\n\
    \    long[] max_levels_index13 = new long[paren_groups.length()];\n    long[]\
    \ levels_index13 = new long[paren_groups.length()];\n    long[] max_levels_index14\
    \ = new long[paren_groups.length()];\n    long[] levels_index14 = new long[paren_groups.length()];\n\
    \    long[] max_levels_index15 = new long[paren_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpprwv9_0t.d(46): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmpprwv9_0t.d(47): Error: semicolon expected, not `{`\\n/tmp/tmpprwv9_0t.d(54):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpprwv9_0t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    long current_level_parens = 0;\n    long current_level_parens_level\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_parens = 0;\n    long\
    \ parens_level_parens_level = 0;\n    long parens_level_parens_level_parens =\
    \ 0;\n    long parens_level_parens_level_parens_level = 0;\n    long parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level = 0;\n  \
    \  long parens_level_parens_level_parens_level_parens_level_parens = 0;\n    long\
    \ parens_level_parens_level_parens_level_parens_level_parens_level = 0;\n    long\
    \ parens_level_parens_level_parens_level_parens_level_parens_level_parens = 0;\n\
    \    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens_level_parens\
    \ = 0;\n    long parens_level_parens_level_paren\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptzshrhws.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[] levels`\\n/tmp/tmptzshrhws.d(42): Error: semicolon expected,\
    \ not `unittest`\\n/tmp/tmptzshrhws.d(42): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptzshrhws.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long levels[MAX_LEVELS];\n    long levels_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_index5 = 0;\n    long levels_index6 = 0;\n    long levels_index7\
    \ = 0;\n    long levels_index8 = 0;\n    long levels_index9 = 0;\n    long levels_index10\
    \ = 0;\n    long levels_index11 = 0;\n    long levels_index12 = 0;\n    long levels_index13\
    \ = 0;\n    long levels_index14 = 0;\n    long levels_index15 = 0;\n    long levels_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_index20 = 0;\n    long levels_index21 = 0;\n    long levels_index22\
    \ = 0;\n    long levels_index23 = 0;\n    long levels_index24 = 0;\n    long levels_index25\
    \ = 0;\n    long levels_index26 = 0;\n    long levels_index27 = 0;\n    long levels_index28\
    \ = 0;\n    long levels_index29 = 0;\n    long levels_index30 = 0;\n    long levels_index31\
    \ = 0;\n    long levels_index32 = 0;\n    long levels_index33 = 0;\n    long levels_index34\
    \ = 0;\n    long levels_index35 = 0;\n    long levels_index36 = 0;\n    long levels_index37\
    \ = 0;\n    long levels_index38 = 0;\n    long levels_index39 = 0;\n    long levels_index40\
    \ = 0;\n    long levels_index41 = 0;\n    long levels_index42 = 0;\n    long levels_index43\
    \ = 0;\n    long levels_index44 = 0;\n    long levels_index45 = 0;\n    long levels_index46\
    \ = 0;\n    long levels_index47 = 0;\n    long levels_index48 = 0;\n    long levels_index49\
    \ = 0;\n    long levels_index50 = 0;\n    long levels_index51 = 0;\n    long levels_index52\
    \ = 0;\n    long levels_index53 = 0;\n    long levels_index54 = 0;\n    long levels_index55\
    \ = 0;\n    long levels_index56 = 0;\n    long levels_index57 = 0;\n    long levels_index58\
    \ = 0;\n    long levels_index59 = 0;\n    long levels_index60 = 0;\n    long levels_index61\
    \ = 0;\n    long levels_index62 = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz2jv297o.d(16): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[MAX_LEVELS] levels`\\n/tmp/tmpz2jv297o.d(79): Error: found `unittest`\
    \ instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpz2jv297o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[] levels\
    \ = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf02nfpyp.d(75): Error: semicolon expected, not `unittest`\\n/tmp/tmpf02nfpyp.d(75):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf02nfpyp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\
    \    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long max_level\
    \ = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ke_oilw.d(76): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ke_oilw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
