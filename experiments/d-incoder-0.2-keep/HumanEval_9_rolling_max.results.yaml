name: HumanEval_9_rolling_max
language: humaneval_to_dlang.py
results:
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long currentMax = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n            maxIndex = i;\n     \
    \   }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long\
    \ minIndex = 0;\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long count = 0;\n    long currentSum =\
    \ 0;\n    long currentCount = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        count++;\n        if(count == 1)\n\
    \        {\n            currentSum = numbers[i];\n            currentCount = 1;\n\
    \        }\n        else\n        {\n            currentSum += numbers[i];\n \
    \           currentCount++;\n        }\n    }\n    long average = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - average;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1, 2,\
    \ 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long currentSum\
    \ = 0;\n    long currentCount = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < currentSum)\n        {\n            currentSum\
    \ = number\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp83kx2slv.d(110): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp83kx2slv.d(119): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp83kx2slv.d(119): Error: found `End\
    \ of File` when expecting `}` following compound statement\\n/tmp/tmp83kx2slv.d(119):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83kx2slv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for\
    \ (int i = 0; i < n; ++i) {\n        cur = numbers[i];\n        if (cur > max)\
    \ {\n            max = cur;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 1, 2, 2, 1]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    long cur = 0;\n    for (int i = 0; i < n; ++i) {\n   \
    \     cur = numbers[i];\n        if (cur < min) {\n            min = cur;\n  \
    \      }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling sum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 6, 6, 12, 12, 18]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    int n = numbers.length;\n    long[] result = new long[n];\n    long sum\
    \ = 0;\n    long cur = 0;\n    for (int i = 0; i < n; ++i) {\n        cur = numbers[i];\n\
    \        sum += cur;\n        result[i] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 720, 5040]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long product = 1;\n    long cur = 0;\n    for (int i = 0; i < n; ++i) {\n\
    \        cur = numbers[i];\n        product *= cur;\n        result[i] = product;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 12, 12, 18]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long quotient = 1;\n    long cur = 0;\n\
    \    for (int i = 0; i < n; ++i) {\n        cur = numbers[i];\n        quotient\
    \ /= cur;\n        result[i] = quotient;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6i5glyqe.d(107): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6i5glyqe.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    result[max_so_far_index] =\
    \ max_so_far;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    result[min_so_far_index] =\
    \ min_so_far;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 5]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long sum_so_far = 0;\n    long\
    \ sum_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        sum_so_far += numbers[i];\n        if(sum_so_far > numbers[i])\n    \
    \    {\n            sum_so_far = numbers[i];\n            sum_so_far_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n  \
    \  }\n    result[sum_so_far_index] = sum_so_far;\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling product element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 6]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long product_so_far = 1;\n    long product_so_far_index =\
    \ 0;\n    for(int i = 1; i < \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8v52sx_a.d(97): Error: expression expected, not `unittest`\\\
    n/tmp/tmp8v52sx_a.d(98): Error: found `{` when expecting `;` following `for` condition\\\
    n/tmp/tmp8v52sx_a.d(99): Error: expression expected, not `alias`\\n/tmp/tmp8v52sx_a.d(99):\
    \ Error: found `candidate` when expecting `)`\\n/tmp/tmp8v52sx_a.d(99): Error:\
    \ found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp8v52sx_a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        for(int j = 0; j < i; j++)\n        {\n            if(result[j]\
    \ > result[i])\n            {\n                result[i] = result[j];\n      \
    \      }\n        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        for(int j = 0; j < i; j++)\n        {\n            if(result[j]\
    \ < result[i])\n            {\n                result[i] = result[j];\n      \
    \      }\n        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5,\
    \ 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i <\
    \ n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n -\
    \ 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n    \
    \        result[i] = result[i] + result[j];\n        }\n        result[i] /= (i\
    \ + 1);\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int\
    \ j = 0; j < i; j++)\n        {\n            result[i] += result[j];\n       \
    \ }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling count element found until given moment\n    in the sequence.\n\
    \    >>> rolling_count([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 1, 2, 1, 2, 1]\n   \
    \ \n*/\nlong\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ft3951h.d(114): Error: no identifier for declarator `long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ft3951h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n        max = numbers[i];\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 1, 2, 1, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ += result[i-numbers.length];\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling product element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 6, 12, 24, 48, 96]\n    \n*/\nlong[] rolling_product(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n  \
    \  for(; i < numbers.length; i++)\n    {\n        result[i] *= result[i-numbers.length];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < \nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1umrt07j.d(113): Error: expression expected, not `unittest`\\\
    n/tmp/tmp1umrt07j.d(114): Error: found `{` when expecting `;` following `for`\
    \ condition\\n/tmp/tmp1umrt07j.d(115): Error: expression expected, not `alias`\\\
    n/tmp/tmp1umrt07j.d(115): Error: found `candidate` when expecting `)`\\n/tmp/tmp1umrt07j.d(115):\
    \ Error: found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1umrt07j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_value\
    \ = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_pos = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n \
    \   {\n        result[i] = numbers[max_pos];\n        max_pos++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpotr49kcp.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285be]\\n??:? long[] tmpotr49kcp.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpotr49kcp.__unittest_L30_C1() [0x427f9e]\\n??:? void\
    \ tmpotr49kcp.__modtest() [0x42828c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5eb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b47e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430709]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430695]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b455]\\n??:? runModuleUnitTests [0x42c3c1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289d0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428957]\\n??:? _d_run_main [0x4288c2]\\n??:? main [0x42829f]\\\
    n??:? __libc_start_main [0x38408554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = max(result[i], numbers[i]);\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int\
    \ i = n - 1; i >= 0; i--)\n    {\n        result[i] = min(result[i], numbers[i]);\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n    {\n        result[i]\
    \ = result[i] + numbers[i];\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product element found until given moment\n\
    \    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 6, 12, 24, 12]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n  \
    \  int n = numbers.length;\n    long[] result = new long[n];\n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i\
    \ = n - 1; i >= 0; i--)\n    {\n        result[i] = result[i] * numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 12]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = result[i] / numbers[i];\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9kd8b3ks.d(108): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9kd8b3ks.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long maxIndex = -1;\n\
    \    for (int i = 0; i < n; ++i) {\n        if (numbers[i] > max) {\n        \
    \    max = numbers[i];\n            maxIndex = i;\n        }\n    }\n    \n  \
    \  for (int i = 0; i < n; ++i) {\n        result[i] = numbers[i];\n        if\
    \ (i == maxIndex) {\n            result[i] = max;\n        }\n    }\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprapz_jkf.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmprapz_jkf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    for(int i = max_so_far_index; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    for(int i\
    \ = min_so_far_index; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = numbers[0];\n    long sum_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far >= numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == sum_so_far)\n        {\n            result[i]\
    \ = sum_so_far;\n        }\n        else\n        {\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ydf91x2.d(106): Error: found `unittest` instead of statement\\\
    n/tmp/tmp_ydf91x2.d(115): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmp_ydf91x2.d(115): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_ydf91x2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n \
    \       if(result[i] != numbers[i])\n        {\n            result[max_so_far_index]\
    \ = result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn_y1c902.d(34): Error: cannot implicitly convert expression `numbers.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpn_y1c902.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = max_so_far;\n    }\n    for(int i = numbers.length\
    \ - 1; i >= 0; i--)\n    {\n        result[max_so_far_index] = numbers[i];\n \
    \       max_so_far_index--;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxx7itenw.d(27): Error: cannot implicitly convert expression `numbers.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpxx7itenw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int len = numbers.length;\n\
    \    long[] result = new long[len];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n            maxIndex = i;\n        }\n \
    \   }\n    for(int i = 0; i < len; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int len = numbers.length;\n    long[] result = new long[len];\n\
    \    long min = 0;\n    long minIndex = 0;\n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            result[i] = min;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    int len = numbers.length;\n  \
    \  long[] result = new long[len];\n    long sum = 0;\n    long sumIndex = 0;\n\
    \    for(int i = 0; i < len; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(sumIndex == 0)\n        {\n            result[i] = sum;\n        }\n    \
    \    else\n        {\n            result[i] = sum - numbers[sumIndex];\n     \
    \   }\n        sumIndex++;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product element found until given moment\n\
    \    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 3, 3, 3, 4, 4]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n  \
    \  int len = numbers.length;\n    long[] result = new long[len];\n    long product\
    \ = 1;\n    long productIndex = 0;\n    for(int i = 0; i < len; i++)\n    {\n\
    \        product *= numbers[i];\n        if(productIndex == 0)\n        {\n  \
    \          result[i] = product;\n        }\n        else\n        {\n        \
    \    result[i] = product * numbers[productIndex];\n        }\n        productIndex++;\n\
    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpquoyytrx.d(125): Error: found `unittest` instead of statement\\\
    n/tmp/tmpquoyytrx.d(134): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpquoyytrx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    if(current > max)\n        {\n            max = current;\n        }\n   \
    \     result[i] = max;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=algorithm,c#,arrays |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvacesg1y.d(26): Error: declaration expected, not `<`\\n/tmp/tmpvacesg1y.d(31):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmpvacesg1y.d(31): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmpvacesg1y.d(32): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmpvacesg1y.d(32): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmpvacesg1y.d(33): Error: semicolon expected, not `.`\\n/tmp/tmpvacesg1y.d(33):\
    \ Error: no identifier for declarator `.Text`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvacesg1y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = maxIndex; i < numbers.length; i++)\n    {\n      \
    \  result[maxIndex] = numbers[i];\n        maxIndex++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4rfmbeiz.d(23): Error: cannot implicitly convert expression `maxIndex`\
    \ of type `long` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp4rfmbeiz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n   \
    \ long min = numbers[0];\n    long minIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[minIndex] = min;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] += result[i-1];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n  \
    \  }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] =\
    \ result[i] / numbers.length;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling variance element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_variance([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 1, 2, 1, 2, 1]\n    \n*/\ndouble[] rolling_variance(double[] numbers)\
    \ \n{\n    double[] result = new double[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfeci4n8k.d(110): Error: expression expected, not `unittest`\\\
    n/tmp/tmpfeci4n8k.d(111): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpfeci4n8k.d(119): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfeci4n8k.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long currentMax = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n            maxIndex = i;\n     \
    \   }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n    long minIndex\
    \ = 0;\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling sum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ list of \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7u1uj61n.d(105): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7u1uj61n.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n  \
    \  \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n\
    \    }\n    \n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    int i = 0;\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    \n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum\
    \ / numbers.length;\n        sum = sum - numbers[i] * numbers[i];\n    }\n   \
    \ \n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling median element found until given moment\n    in the sequence.\n \
    \   >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n   \
    \ \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        int\
    \ j = (i + 1) >> 1;\n        \n        if(numbers[i] < numbers[j])\n        {\n\
    \            result[i] = numbers[i];\n        }\n        else\n        {\n   \
    \         result[i] = numbers[j];\n        }\n    }\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling variance element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_variance([1,\
    \ 2, 3, 2, 3, 4, 2])\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpleoi5_lr.d(120): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpleoi5_lr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 1, 2, 3, 4]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long minIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    result[minIndex]\
    \ = minValue;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 1.5, 2.5, 3.5, 4.5]\n\
    \    \n*/\ndouble[] rolling_avg(double[] numbers) \n{\n    double[] result = new\
    \ double[numbers.length];\n    double sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    double avg = sum / numbers.length;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - avg;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 1.5, 2.5, 3.5, 4.5]\n\
    \    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[] result\
    \ = new double[numbers.length];\n    double sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    double avg = sum / numbers.length;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - avg;\n    }\n    Arrays.sort(result);\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling standard deviation element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_std([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 1.4142135623730951, 1.4142135623730951, 1.4142135623730951,\
    \ 1.4142135623730951, 1.\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfduqlkvt.d(94): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfduqlkvt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = max(result[i], numbers[i]);\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        result[i] = min(result[i],\
    \ numbers[i]);\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4,\
    \ 5]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = result[i] + numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\ndouble rolling_average(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    double sum = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n    }\n    return sum\
    \ / n;\n}\n/*\n From a given list of integers, generate a list of rolling median\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_median([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\ndouble rolling_median(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    double sum = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n    }\n    double median\
    \ = sum / n;\n    for(int i = 0; i < n; i++)\n    {\n        if(numbers[i] > median)\n\
    \        {\n            median = numbers[i];\n        }\n    }\n    return median;\n\
    }\n/*\n From a given list of integers, generate a list of rolling mode element\
    \ found until given moment\n    in the sequence.\n    >>> roll\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp52mj8_hw.d(108): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp52mj8_hw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[maxIndex] = numbers[i];\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = numbers[0];\n    long minIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n            minIndex = i;\n        }\n \
    \   }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum of element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long product = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n        result[i] = product;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long quotient = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        \nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpptzxnfvl.d(111): Error: found `unittest` instead of statement\\\
    n/tmp/tmpptzxnfvl.d(120): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpptzxnfvl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpznxg758d.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428566]\\n??:? long[] tmpznxg758d.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpznxg758d.__unittest_L24_C1() [0x427f4a]\\n??:? void\
    \ tmpznxg758d.__modtest() [0x428238]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c593]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b426]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43063d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3fd]\\n??:? runModuleUnitTests [0x42c369]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428978]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4288ff]\\n??:? _d_run_main [0x42886a]\\n??:? main [0x42824b]\\\
    n??:? __libc_start_main [0x188ce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > max)\n        {\n\
    \            max = sum;\n            maxIndex = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[maxIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = numbers[0];\n    long minIndex = 0;\n    long sum\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sum < min)\n        {\n            min = sum;\n            minIndex\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> rolling_var([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 1, 2, 1, 2, 1]\n    \n\
    */\nlong[] rolling_var(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling standard deviation element found until given moment\n    in\
    \ the \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphlirrsa1.d(107): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphlirrsa1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            result[i] = max;\n\
    \            max = numbers[i];\n        }\n        else\n        {\n         \
    \   result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = 0;\n    int i =\
    \ 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n            min = numbers[i];\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = result[i]\
    \ / numbers.length;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling median element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5,\
    \ 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = result[i] / numbers.length;\n    }\n    long\
    \ median = 0;\n    int j = 0;\n    for(; j < numbers.length; j++)\n    {\n   \
    \     if(result[j] < median)\n        {\n            median = result[j];\n   \
    \     }\n    }\n    for(; j < numbers.length; j++)\n    {\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuxcs6_v9.d(120): Error: found `unittest` instead of statement\\\
    n/tmp/tmpuxcs6_v9.d(129): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuxcs6_v9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \        max_index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmp3wpxhfut.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285ae]\\n??:? long[] tmp3wpxhfut.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmp3wpxhfut.__unittest_L30_C1() [0x427f92]\\n??:? void\
    \ tmp3wpxhfut.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5db]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b46e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430685]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b445]\\n??:? runModuleUnitTests [0x42c3b1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428947]\\n??:? _d_run_main [0x4288b2]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xf9e67554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for\
    \ (int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if (cur >\
    \ max)\n        {\n            max = cur;\n        }\n        result[i] = max;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min = 0;\n    long cur = 0;\n    for (int i\
    \ = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if (cur < min)\n\
    \        {\n            min = cur;\n        }\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\n\
    long[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for (int i\
    \ = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n  \
    \      result[i] = sum / n;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n   \
    \ int n = numbers.length;\n    long[] result = new long[n];\n    long sum = 0;\n\
    \    long cur = 0;\n    for (int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        sum += cur;\n        if (sum / n >= numbers[n - 1])\n        {\n    \
    \        result[i] = sum / n;\n        }\n        else\n        {\n          \
    \  result[i] = numbers[n - 1];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling standard deviation\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_std([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_std(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    long cur = 0;\n    for (int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqdqrw6ev.d(117): Error: expression expected, not `unittest`\\\
    n/tmp/tmpqdqrw6ev.d(118): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpqdqrw6ev.d(126): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqdqrw6ev.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long temp = 0;\n   \
    \ for(int i = 0; i < n; i++)\n    {\n        temp = numbers[i];\n        for(int\
    \ j = i; j < n; j++)\n        {\n            if(numbers[j] > temp)\n         \
    \   {\n                temp = numbers[j];\n            }\n        }\n        result[i]\
    \ = temp;\n        if(temp > max)\n        {\n            max = temp;\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjxb_fk4u.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpjxb_fk4u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == maxValue)\n        {\n            result[maxIndex] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpexr8mt0g.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285de]\\n??:? long[] tmpexr8mt0g.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpexr8mt0g.__unittest_L32_C1() [0x427fc2]\\n??:? void\
    \ tmpexr8mt0g.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c60b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b49e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430729]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b475]\\n??:? runModuleUnitTests [0x42c3e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428977]\\n??:? _d_run_main [0x4288e2]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0x47554554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| a tags=java,arrays |>\n<code>\npublic static void main(String[] args)\
    \ {\n    int[] arr = {1, 2, 3, 2, 3, 4, 2};\n    System.out.println(Arrays.toString(rolling_max(arr)));\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw3ejgc1u.d(30): Error: declaration expected, not `<`\\n/tmp/tmpw3ejgc1u.d(36):\
    \ Error: identifier expected following `.` instead of `out`\\n/tmp/tmpw3ejgc1u.d(36):\
    \ Error: no identifier for declarator `System`\\n/tmp/tmpw3ejgc1u.d(36): Error:\
    \ declaration expected, not `out`\\n/tmp/tmpw3ejgc1u.d(37): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw3ejgc1u.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 3, 2, 3]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long minIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 240, 720]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = 1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        product *=\
    \ numbers[i];\n        result[i] = product;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling quotient of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 2, 6, 2, 6]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long quotient\
    \ = 1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        quotient /=\
    \ numbers[i];\n        result[i] = quotient;\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnhbj7ohw.d(109): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnhbj7ohw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[max_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_so_far)\n        {\n            result[min_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long sum_so_far = 0;\n   \
    \ long sum_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        sum_so_far += numbers[i];\n        sum_so_far_index = i;\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] ==\
    \ sum_so_far)\n        {\n            result[sum_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling median element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5,\
    \ 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    \nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpipkzq498.d(98): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipkzq498.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    result[0] = max_so_far;\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n\
    \            result[i] = max_so_far;\n        }\n        else\n        {\n   \
    \         result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ min_so_far = numbers[0];\n    long min_so_far_index = -1;\n    for(int i = 1;\
    \ i < n; i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n       \
    \     min_so_far = numbers[i];\n            min_so_far_index = i;\n        }\n\
    \    }\n    result[0] = min_so_far;\n    for(int i = 1; i < n; i++)\n    {\n \
    \       if(numbers[i] < min_so_far)\n        {\n            result[i] = min_so_far;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n\
    \    \n*/\ndouble[] rolling_average(double[] numbers) \n{\n    int n = numbers.length;\n\
    \    double[] result = new double[n];\n    double sum_so_far = 0.0;\n    double\
    \ sum_so_far_index = 0.0;\n    for(int i = 1; i < n; i++)\n    {\n        sum_so_far\
    \ += numbers[i];\n        sum_so_far_index += numbers[i];\n    }\n    double average\
    \ = sum_so_far/sum_so_far_index;\n    for(int i = 1; i < n; i++)\n    {\n    \
    \    result[i] = numbers[i] - average;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling median element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4,\
    \ 2])\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3ule0er.d(98): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf3ule0er.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long currentMax\
    \ = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > currentMax)\n        {\n            currentMax = numbers[i];\n        }\n\
    \    }\n    result[0] = currentMax;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > currentMax)\n        {\n            result[i]\
    \ = currentMax;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long minValue = numbers[0];\n    long currentMin\
    \ = minValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n        }\n\
    \    }\n    result[0] = currentMin;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < currentMin)\n        {\n            result[i]\
    \ = currentMin;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        currentSum += numbers[i];\n\
    \        if(currentSum > sum)\n        {\n            sum = currentSum;\n    \
    \    }\n    }\n    result[0] = sum;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        currentSum += numbers[i];\n        if(currentSum > sum)\n    \
    \    {\n            result[i] = sum;\n        }\n        else\n        {\n   \
    \         result[i] = currentSum;\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling product element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[number\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphdnhy06c.d(114): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmphdnhy06c.d(115): Error: semicolon expected, not `{`\\n/tmp/tmphdnhy06c.d(123):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphdnhy06c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    long\
    \ index = 0;\n    for(long i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        max = Math.max(max, current);\n        result[index++]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = Long.MAX_VALUE;\n    long current = 0;\n    long index = 0;\n\
    \    for(long i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        min = Math.min(min, current);\n        result[index++] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum of element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long current = 0;\n    long index = 0;\n    for(long i\
    \ = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n      \
    \  sum += current;\n        result[index++] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 240, 720]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = 1;\n    long current = 0;\n    long index = 0;\n    for(long i = 0; i < numbers.length;\
    \ i++)\n    {\n        current = numbers[i];\n        product *= current;\n  \
    \      result[index++] = product;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling quotient of element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_quotient([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long quotient\
    \ = 1;\n    long current = 0;\n    long index = 0;\n    for(long i = 0; i < numbers.length;\
    \ i++)\n    {\n        current = \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuxjm4tda.d(103): Error: expression expected, not `unittest`\\\
    n/tmp/tmpuxjm4tda.d(104): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpuxjm4tda.d(112): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuxjm4tda.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            result[max_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static int[] rollingMax(int[] numbers)\
    \ {\n    int[] result = new int[numbers.length];\n    int max = 0;\n    int maxIndex\
    \ = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i]\
    \ > max) {\n            result[maxIndex] = numbers[i];\n        }\n    }\n   \
    \ return result;\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| a dscore=0 |>\n\
    <code>\npublic static void main(String[] args) {\n    int[] numbers = {1, 2, 3,\
    \ 2, 3, 4, 2};\n    int[] result = rollingMax(numbers);\n    System.out.println(Arrays.toString(result));\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcp97418a.d(32): Error: declaration expected, not `<`\\n/tmp/tmpcp97418a.d(40):\
    \ Error: declaration expected, not `for`\\n/tmp/tmpcp97418a.d(40): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpcp97418a.d(40): Error: declaration expected, not\
    \ `<`\\n/tmp/tmpcp97418a.d(40): Error: no identifier for declarator `i`\\n/tmp/tmpcp97418a.d(40):\
    \ Error: declaration expected, not `++`\\n/tmp/tmpcp97418a.d(43): Error: no identifier\
    \ for declarator `maxIndex`\\n/tmp/tmpcp97418a.d(43): Error: declaration expected,\
    \ not `=`\\n/tmp/tmpcp97418a.d(44): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcp97418a.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long index = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n            index = i;\n        }\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[index] = numbers[i];\n            index++;\n  \
    \      }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 3, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[index]\
    \ = numbers[i];\n            index++;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 2.5, 2.5]\n    \n*/\ndouble[] rolling_avg(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    double\
    \ sum = 0;\n    double avg = 0;\n    double index = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n    avg = sum\
    \ / numbers.length;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] > avg)\n        {\n            avg = numbers[i];\n        \
    \    index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > avg)\n        {\n            result[index] = numbers[i];\n\
    \            index++;\n        }\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling median element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2.5, 3, 2.5, 2.5]\n    \n*/\ndouble[] rolling_median(double[] numbers)\
    \ \n{\n    double[] result = new double[numbers.length];\n    double sum = 0;\n\
    \    double avg = 0;\n    double index = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    avg = sum / numbers.length;\n\
    \    for(int i = 0; i < \nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0vd9omk8.d(118): Error: expression expected, not `unittest`\\\
    n/tmp/tmp0vd9omk8.d(119): Error: found `{` when expecting `;` following `for`\
    \ condition\\n/tmp/tmp0vd9omk8.d(120): Error: expression expected, not `alias`\\\
    n/tmp/tmp0vd9omk8.d(120): Error: found `candidate` when expecting `)`\\n/tmp/tmp0vd9omk8.d(120):\
    \ Error: found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp0vd9omk8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[maxIndex] = max;\n        }\n        else\n   \
    \     {\n            result[maxIndex] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = min;\n        }\n        else\n        {\n            result[minIndex] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n  \
    \  long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n  \
    \      sum += numbers[i];\n        if(sumIndex == 0)\n        {\n            sum\
    \ = sum;\n        }\n        else\n        {\n            sum = sum - numbers[sumIndex];\n\
    \        }\n        sumIndex++;\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(sumIndex == 0)\n\
    \        {\n            result[sumIndex] = sum;\n        }\n        else\n   \
    \     {\n            result[sumIndex] = sum - numbers[i];\n        }\n       \
    \ sumIndex++;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n\
    {\n    double sum = 0;\n    double sumIndex = 0;\n    \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8iv3cfc5.d(120): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8iv3cfc5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        for(int j = 0; j < i; j++)\n        {\n            if(result[j]\
    \ > result[i])\n            {\n                result[i] = result[j];\n      \
    \      }\n        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        for(int j = 0; j < i; j++)\n        {\n            if(result[j]\
    \ < result[i])\n            {\n                result[i] = result[j];\n      \
    \      }\n        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        for(int j = 0; j < i; j++)\n        {\n            result[i] +=\
    \ result[j];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int\
    \ i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n       \
    \ {\n            result[i] += result[j] / j;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling variance element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_var([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 1, 2, 1, 2, 1]\n    \n*/\nlong[] rolling_var(long[]\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7nptzk5s.d(113): Error: found `unittest` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7nptzk5s.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n    while(i\
    \ < numbers.length)\n    {\n        if(numbers[i] > max)\n        {\n        \
    \    max = numbers[i];\n        }\n        \n        result[i] = max;\n      \
    \  i++;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        max = Math.max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        min = Math.min(min, numbers[i]);\n        result[i] = min;\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n  \
    \  \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        sum += numbers[i];\n        result[i] = sum / n;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n   \
    \ \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long median = 0;\n \
    \   for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n        if (sum\
    \ / n >= median) {\n            median = sum / n;\n        }\n        result[i]\
    \ = median;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling standard deviation element found until given moment\n\
    \    in the sequence.\n    >>> rolling_std([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_std(long[] numbers) \n{\n   \
    \ int n = numbers.length;\n    long[] result = new long[n];\n    long sum = 0;\n\
    \    long sum2 = 0;\n    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n\
    \        sum2 += Math.pow(numbers[i], 2);\n        result[i] = Math.sqrt(sum2\
    \ / n - Math.pow(sum / n, 2));\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling variance element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_var([1, 2, 3, 2, \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt8ooiig7.d(99): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt8ooiig7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpyp4qc_3y.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285ae]\\n??:? long[] tmpyp4qc_3y.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpyp4qc_3y.__unittest_L29_C1() [0x427f92]\\n??:? void\
    \ tmpyp4qc_3y.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5db]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b46e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430685]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b445]\\n??:? runModuleUnitTests [0x42c3b1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428947]\\n??:? _d_run_main [0x4288b2]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xb7798554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        for(int j = 0; j < i; j++)\n        {\n            if(result[j]\
    \ > result[i])\n            {\n                result[i] = result[j];\n      \
    \      }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=c#,algorithm,arrays |>\n<code>\npublic static int[] GetMax(int[] arr)\n\
    {\n    int max = arr[0];\n    int maxIndex = 0;\n    for (int i = 0; i < arr.Length;\
    \ i++)\n    {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n\
    \            maxIndex = i;\n        }\n    }\n    int[] result = new int[arr.Length];\n\
    \    for (int i = 0; i < arr.Length; i++)\n    {\n        if (i == maxIndex)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = arr[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=c#,algorithm,arrays |>\n<code>\npublic static int[]\
    \ GetMax(int[] arr)\n{\n    int max = arr[0];\n    int maxIndex = 0;\n    for\
    \ (int i = 0; i < arr.Length; i++)\n    {\n        if (arr[i] > max)\n       \
    \ {\n            max = arr[i];\n            maxIndex = i;\n        }\n    }\n\
    \    int[] result = new int[arr.Length];\n    for (int i = 0; i < arr.Length;\
    \ i++)\n    {\n        if (i == maxIndex)\n        {\n            result[i] =\
    \ max;\n        }\n        else\n        {\n            result[i] = arr[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,arrays\
    \ |>\n<code>\npublic static int[] GetMax(int[] arr)\n{\n    int max = arr[0];\n\
    \    int maxIndex = 0;\n    for (int i = 0; i < arr.Length; i++)\n    {\n    \
    \    if (arr[i] > max)\n        {\n            max = arr[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    int[] result = new int[arr.Length];\n    for (int\
    \ i = 0; i < arr.Length; i++)\n    {\n        if (i == maxIndex)\n        {\n\
    \            result[i] = max;\n        }\n        else\n        {\n          \
    \  result[i] = arr[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=c#,algorithm,arrays |>\n<code>\npublic static int[]\
    \ GetMax(int[] arr)\n{\n    int max = arr[0];\n    int maxIndex = 0;\n    for\
    \ (int i = 0; i < arr.Length; i++)\n    {\n        if (arr[i] > max)\n       \
    \ {\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph3mtxt3z.d(30): Error: declaration expected, not `<`\\n/tmp/tmph3mtxt3z.d(38):\
    \ Error: declaration expected, not `for`\\n/tmp/tmph3mtxt3z.d(38): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmph3mtxt3z.d(38): Error: declaration expected, not\
    \ `<`\\n/tmp/tmph3mtxt3z.d(38): Error: no identifier for declarator `i`\\n/tmp/tmph3mtxt3z.d(38):\
    \ Error: declaration expected, not `++`\\n/tmp/tmph3mtxt3z.d(43): Error: no identifier\
    \ for declarator `maxIndex`\\n/tmp/tmph3mtxt3z.d(43): Error: declaration expected,\
    \ not `=`\\n/tmp/tmph3mtxt3z.d(44): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph3mtxt3z.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long cur = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           result[i] = max;\n        }\n        else\n        {\n           \
    \ result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n  \
    \  long[] result = new long[numbers.length];\n    long min = numbers[0];\n   \
    \ long cur = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \    }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            result[i] = min;\n        }\n        else\n \
    \       {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 3]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ cur = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = sum / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1, 2,\
    \ 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 3]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n    }\n    long mid\
    \ = numbers[numbers.length / 2];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > mid)\n        {\n            result[i] = mid;\n\
    \        }\n    }\n    return result;\n\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz38re9g8.d(119): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz38re9g8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n  \
    \  long[] result = new long[numbers.length];\n    long min = numbers[0];\n   \
    \ long minIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] < min)\n        {\n            min = numbers[i];\n      \
    \      minIndex = i;\n        }\n    }\n    result[minIndex] = min;\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        sum += numbers[i];\n        if(sum == numbers[i])\n        {\n\
    \            sumIndex = i;\n        }\n    }\n    result[sumIndex] = sum;\n  \
    \  return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_average(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        sum += numbers[i];\n        if(sum == numbers[i])\n        {\n\
    \            sumIndex = i;\n        }\n    }\n    long average = sum / numbers.length;\n\
    \    result[sumIndex] = average;\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n\
    \    long[] result = new \nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpku42qlpu.d(106): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpku42qlpu.d(106): Error: semicolon expected, not `unittest`\\n/tmp/tmpku42qlpu.d(106):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpku42qlpu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \        if(numbers[i] > max)\n        {\n            result[i] = max;\n     \
    \   }\n    }\n    result[max_index] = max;\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n  \
    \  long min = numbers[0];\n    long min_index = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            min_index = i;\n        }\n    }\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n        if(numbers[i] < min)\n\
    \        {\n            result[i] = min;\n        }\n    }\n    result[min_index]\
    \ = min;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n    long sum_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(numbers[i] > sum)\n        {\n            sum = numbers[i];\n    \
    \        sum_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \        if(numbers[i] > sum)\n        {\n            result[i] = sum;\n     \
    \   }\n    }\n    result[sum_index] = sum;\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[]\
    \ numbers) \n{\n    double sum = 0;\n    double sum_index = 0;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i]\
    \ > sum)\n        {\n            sum = \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpod9k7zac.d(114): Error: expression expected, not `unittest`\\\
    n/tmp/tmpod9k7zac.d(115): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpod9k7zac.d(123): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpod9k7zac.d(123): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpod9k7zac.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    max = Math.max(max, current);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ Long.MAX_VALUE;\n    long current = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        current = numbers[i];\n        min = Math.min(min, current);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long current = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        sum += current;\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[]\
    \ rolling_average(double[] numbers) \n{\n    double[] result = new double[numbers.length];\n\
    \    double sum = 0;\n    double current = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        current = numbers[i];\n        sum += current;\n      \
    \  result[i] = sum / numbers.length;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling median element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4,\
    \ 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_median(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    double\
    \ sum = 0;\n    double current = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        current = numbers[i];\n        sum += current;\n        if(sum\
    \ % 2 == 0)\n        {\n            result[i] = sum / 2;\n        }\n        else\n\
    \        {\n            result[i] = (\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiwx3gvy9.d(106): Error: expression expected, not `unittest`\\\
    n/tmp/tmpiwx3gvy9.d(105): Error: found `{` when expecting `)`\\n/tmp/tmpiwx3gvy9.d(108):\
    \ Error: found `alias` when expecting `;` following statement\\n/tmp/tmpiwx3gvy9.d(115):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpiwx3gvy9.d(115): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiwx3gvy9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[0] = maxValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n            result[i]\
    \ = maxValue;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long minValue = numbers[0];\n    long minIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    result[0] = minValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            result[i]\
    \ = minValue;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3,\
    \ 3.5, 4.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ count++;\n    }\n    double average = sum / count;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - average;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1, 2,\
    \ 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4.5]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long median\
    \ = 0;\n    long count = 0;\n    for(int i = 1; i < numbers.length; i++)\n   \
    \ {\n        median = (numbers[i] + numbers[i - 1]) / 2;\n        count++;\n \
    \   }\n    double average = \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf0kmm8qm.d(113): Error: expression expected, not `unittest`\\\
    n/tmp/tmpf0kmm8qm.d(114): Error: semicolon expected, not `{`\\n/tmp/tmpf0kmm8qm.d(122):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf0kmm8qm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long currentMax = 0;\n \
    \   long currentIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        max = numbers[i];\n        currentMax = max;\n        currentIndex =\
    \ i;\n        for(int j = i; j < numbers.length; j++)\n        {\n           \
    \ if(numbers[j] > max)\n            {\n                max = numbers[j];\n   \
    \             currentMax = max;\n                currentIndex = j;\n         \
    \   }\n        }\n        result[i] = currentMax;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays |>\n<| a dscore=0 |>\n<code>\npublic class\
    \ MaxRoller {\n    public static void main(String[] args) {\n        int[] nums\
    \ = {1,2,3,4,5,6,7,8,9,10};\n        int[] maxRoll = new int[nums.length];\n \
    \       for(int i = 0; i < nums.length; i++) {\n            maxRoll[i] = nums[i];\n\
    \        }\n        for(int i = nums.length - 1; i >= 0; i--) {\n            for(int\
    \ j = 0; j < i; j++) {\n                if(nums[j] > maxRoll[i]) {\n         \
    \           maxRoll[i] = nums[j];\n                }\n            }\n        }\n\
    \        for(int i = 0; i < nums.length; i++) {\n            System.out.println(nums[i]\
    \ + \" \" + maxRoll[i]);\n        }\n    }\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| a |>\n<code>\npublic class MaxRoller {\n    public static void main(String[]\
    \ args) {\n        int[] nums = {1,2,3,4,5,6,7,8,9,10};\n        int[] maxRoll\
    \ = new int[nums.length];\n        for(int i = 0; i < nums.length; i++) {\n  \
    \          maxRoll[i] = nums[i];\n        }\n        for(int i = nums.length -\
    \ 1; i >= 0; i--) {\n            for(int j = 0; j < i; j++) {\n              \
    \  if(nums[j] > maxRoll[i]) {\n                    maxRoll[i] = nums[j];\n   \
    \             }\n            }\n        }\n        for(int i = 0; i < nums.length;\
    \ i++) {\n            System.out.println(nums[i] + \" \" + maxRoll[i]);\n    \
    \    }\n    }\n}\n</code>\n<|/ a dscore=0 tags=java,arrays |>\n<| a dscore=0 |>\n\
    <code>\npublic class MaxRoller {\n    public static void main(String[] args) {\n\
    \        int[] nums = {1,2,3,4,5,6,7,8,9,10};\n        int[] maxRoll = new int[nums.length];\n\
    \        for(int i = 0; i < nums.length; i++) {\n            maxRoll[i] = nums[i];\n\
    \        }\n        for(int i = nums.length - 1; i >= 0; i--) {\n            for(int\
    \ j = 0; j < i; j++) {\n                if(nums[j] > maxRoll[i]) {\n         \
    \           maxRoll[i] = nums[j];\n                }\n            }\n        }\n\
    \        for(int i = 0; i < nums.length; i++) {\n            System.out.println(nums[i]\
    \ + \" \" + maxRoll[i]);\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps078wf0_.d(34): Error: declaration expected, not `<`\\n/tmp/tmps078wf0_.d(42):\
    \ Error: declaration expected, not `for`\\n/tmp/tmps078wf0_.d(42): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmps078wf0_.d(42): Error: declaration expected, not\
    \ `<`\\n/tmp/tmps078wf0_.d(42): Error: no identifier for declarator `i`\\n/tmp/tmps078wf0_.d(42):\
    \ Error: declaration expected, not `++`\\n/tmp/tmps078wf0_.d(44): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps078wf0_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    int i = 0;\n    \n \
    \   while(i < n) {\n        max = std.max(max, numbers[i]);\n        result[i]\
    \ = max;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpowadius5.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpowadius5.d(18): Error: undefined identifier\
    \ `max` in package `std`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpowadius5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = numbers.length - 1;\
    \ i >= 0; i--)\n    {\n        if(numbers[i] > max_so_far)\n        {\n      \
    \      result[max_so_far_index] = numbers[i];\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp0qmd2bc.d(23): Error: cannot implicitly convert expression `numbers.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpp0qmd2bc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        max\
    \ = cur;\n        for(int j = i; j < numbers.length; j++)\n        {\n       \
    \     if(numbers[j] > cur)\n            {\n                max = numbers[j];\n\
    \            }\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb0inbx9r.d(30): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb0inbx9r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[0] = maxValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n            result[i]\
    \ = maxValue;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long minValue = numbers[0];\n    long minIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    result[0] = minValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            result[i]\
    \ = minValue;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(sum > numbers[i])\n        {\n            sum = numbers[i];\n           \
    \ sumIndex = i;\n        }\n    }\n    result[0] = sum;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(sum >\
    \ numbers[i])\n        {\n            result[i] = sum;\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[]\
    \ rolling_average(double[] numbers) \n{\n    double[] result = new double[numbers.length];\n\
    \    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_4f7aep_.d(118): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_4f7aep_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n    while(i\
    \ < numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i;\
    \ j < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n    \
    \        {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp42qppofy.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284d5]\\n??:? void tmp42qppofy.__unittest_L31_C1()\
    \ [0x428059]\\n??:? void tmp42qppofy.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b446]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43065d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b41d]\\n??:? runModuleUnitTests [0x42c389]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428998]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42891f]\\n??:? _d_run_main [0x42888a]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0xa3d8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = -1;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \         maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    System.arraycopy(numbers, 0, result, 0, maxIndex + 1);\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyng1jw2t.d(23): Error: undefined identifier `System`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyng1jw2t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < n; i++)\n  \
    \  {\n        if(max_so_far_index != i)\n        {\n            result[i] = numbers[max_so_far_index];\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3lsailx7.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp3lsailx7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == max)\n        {\n            result[maxIndex] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays\
    \ |>\n<| a tags=c#,algorithm,arrays |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6n1_d8n7.d(32): Error: declaration expected, not `<`\\n/tmp/tmp6n1_d8n7.d(37):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmp6n1_d8n7.d(37): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmp6n1_d8n7.d(38): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmp6n1_d8n7.d(38): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmp6n1_d8n7.d(39): Error: semicolon expected, not `.`\\n/tmp/tmp6n1_d8n7.d(39):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmp6n1_d8n7.d(40): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmp6n1_d8n7.d(40): Error: no identifier for\
    \ declarator `.Threading.Tasks`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp6n1_d8n7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    \n    for(int i = n - 1; i >= 0;\
    \ i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp23v3bkac.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp23v3bkac.d(22): Error: undefined identifier\
    \ `max`, did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp23v3bkac.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for(int i = 0; i < n; ++i)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    \n    for(int i = n - 1; i >= 0;\
    \ --i)\n    {\n        result[i] = std.math.max(result[i], numbers[i]);\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzhpy9jx1.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpzhpy9jx1.d(22): Error: undefined identifier\
    \ `max` in module `std.math`, did you mean function `fmax`?\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzhpy9jx1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    long max_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    result[0] = max_value;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            result[i]\
    \ = max_value;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long min_value = numbers[0];\n    long min_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_value)\n        {\n            min_value = numbers[i];\n            min_pos\
    \ = i;\n        }\n    }\n    result[0] = min_value;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            result[i]\
    \ = min_value;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long sum2 = 0;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        sum2\
    \ += numbers[i] * numbers[i];\n    }\n    result[0] = sum;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        result[i] = sum2 - sum * numbers[i\
    \ - 1];\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 720, 5040]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long product = 1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n    }\n    result[0] = product;\n\
    \    for(int i = 1; i < numbers.length\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpte8o6ms5.d(112): Error: found `unittest` when expecting `;` following\
    \ `for` condition\\n/tmp/tmpte8o6ms5.d(121): Error: found `void` when expecting\
    \ `)`\\n/tmp/tmpte8o6ms5.d(121): Error: found `{` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpte8o6ms5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[maxIndex] = numbers[i];\n        }\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 3, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            result[0] = sum;\n        }\n\
    \        else if(sumIndex == numbers.length - 1)\n        {\n            result[numbers.length\
    \ - 1] = sum;\n        }\n        else\n        {\n            result[sumIndex]\
    \ = sum;\n        }\n        sumIndex++;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    double\
    \ sum = 0;\n    double sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n   \
    \         result[0] = sum;\n        }\n        else if(sumIndex == numbers.length\
    \ - 1)\n        {\n            result[numbers.length - 1] = sum;\n        }\n\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv5ieos40.d(116): Error: found `unittest` instead of statement\\\
    n/tmp/tmpv5ieos40.d(125): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv5ieos40.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[max_index] = max;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long min = numbers[0];\n    long min_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[min_index] = min;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n \
    \   \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long product = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n        result[i] = product;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long quotient = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        quotient /= numbers[i];\n        result[i] = \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf99x9j6p.d(108): Error: expression expected, not `unittest`\\\
    n/tmp/tmpf99x9j6p.d(109): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpf99x9j6p.d(117): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf99x9j6p.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index] = max_so_far;\n\
    \    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[max_so_far_index] = numbers[i];\n        }\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n            min_so_far_index\
    \ = i;\n        }\n    }\n    result[min_so_far_index] = min_so_far;\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n\
    \            result[min_so_far_index] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_avg([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long avg_so_far = numbers[0];\n    long avg_so_far_index = 0;\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        avg_so_far += numbers[i];\n    }\n    avg_so_far\
    \ /= n;\n    result[avg_so_far_index] = avg_so_far;\n    for(int i = 1; i < n;\
    \ i++)\n    {\n        avg_so_far += numbers[i];\n        result[avg_so_far_index]\
    \ = avg_so_far / n;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling median element found until given moment\n    in the\
    \ sequence.\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpivt4_xtd.d(91): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpivt4_xtd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n    foreach(long\
    \ number in numbers)\n    {\n        if(number > max)\n        {\n           \
    \ max = number;\n        }\n    }\n    \n    foreach(long number in numbers)\n\
    \    {\n        if(number == max)\n        {\n            result[i] = max;\n \
    \           i++;\n        }\n        else\n        {\n            result[i] =\
    \ number;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyxwve9ow.d(16): Error: found `in` when expecting `;`\\n/tmp/tmpyxwve9ow.d(24):\
    \ Error: found `in` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpyxwve9ow.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    max = Math.max(max, current);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpclsnauq9.d(18): Error: undefined identifier `Math`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpclsnauq9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max_value = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ = numbers[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmp677_qsnk.d(14): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285a6]\\n??:? long[] tmp677_qsnk.rolling_max(long[])\
    \ [0x427e69]\\n??:? void tmp677_qsnk.__unittest_L32_C1() [0x427f86]\\n??:? void\
    \ tmp677_qsnk.__modtest() [0x428274]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b466]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43067d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b43d]\\n??:? runModuleUnitTests [0x42c3a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42893f]\\n??:? _d_run_main [0x4288aa]\\n??:? main [0x428287]\\\
    n??:? __libc_start_main [0xfb589554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 1, 2, 1, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n    long minIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 1.5, 2.5, 3, 3.5]\n\
    \    \n*/\ndouble[] rolling_avg(long[] numbers) \n{\n    double sum = 0;\n   \
    \ double sumOfSquares = 0;\n    double avg = 0;\n    double avgOfSquares = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        sumOfSquares += numbers[i] * numbers[i];\n    }\n    avg = sum / numbers.length;\n\
    \    avgOfSquares = sumOfSquares / numbers.length;\n    double[] result = new\
    \ double[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = avg;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2, 1.5, 2.5, 3, 3.5]\n    \n*/\ndouble[] rolling_median(long[] numbers) \n\
    {\n    double median = 0;\n    double medianOfSquares = 0;\n    double medianOfThree\
    \ = 0;\n    double medianOfThreeOfSquares = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        median += numbers[i];\n        medianOfSquares += numbers[i]\
    \ * numbers[i];\n        medianOfThree += numbers[i] / 3;\n        medianOfThreeOfSquares\
    \ += numbers[i] / 3 * numbers[i];\n    }\n    median = median / \nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpve3sg1c2.d(103): Error: expression expected, not `unittest`\\\
    n/tmp/tmpve3sg1c2.d(104): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpve3sg1c2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n        max = numbers[i];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnwddika4.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284d5]\\n??:? void tmpnwddika4.__unittest_L29_C1()\
    \ [0x428055]\\n??:? void tmpnwddika4.__modtest() [0x428254]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b446]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43065d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b41d]\\n??:? runModuleUnitTests [0x42c389]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428998]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42891f]\\n??:? _d_run_main [0x42888a]\\n??:? main [0x428267]\\\
    n??:? __libc_start_main [0xe3af9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long max_pos =\
    \ 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            max_pos = i;\n\
    \        }\n    }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            result[max_pos] = numbers[i];\n\
    \            max_pos++;\n        }\n    }\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   long min_pos = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] < min)\n        {\n            min = numbers[i];\n      \
    \      min_pos = i;\n        }\n    }\n    for(int i = numbers.length - 1; i >=\
    \ 0; i--)\n    {\n        if(numbers[i] < min)\n        {\n            result[min_pos]\
    \ = numbers[i];\n            min_pos++;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / count;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling variance element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_var([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_var(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / count;\n    }\n    double avg = rolling_avg(result);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = result[i]\
    \ - avg;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqe1c_8x_.d(23): Error: cannot implicitly convert expression `numbers.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpqe1c_8x_.d(53): Error: cannot implicitly\
    \ convert expression `numbers.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpqe1c_8x_.d(107):\
    \ Error: cannot implicitly convert expression `rolling_avg(result)` of type `long[]`\
    \ to `double`\\n/tmp/tmpqe1c_8x_.d(110): Error: cannot implicitly convert expression\
    \ `cast(double)result[cast(ulong)i] - avg` of type `double` to `long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqe1c_8x_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxln87t4o.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428535]\\n??:? void tmpxln87t4o.__unittest_L36_C1()\
    \ [0x428156]\\n??:? void tmpxln87t4o.__modtest() [0x4282b8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c613]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430731]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b47d]\\n??:? runModuleUnitTests [0x42c3e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42897f]\\n??:? _d_run_main [0x4288ea]\\n??:? main [0x4282cb]\\\
    n??:? __libc_start_main [0xff5de554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = 0;\n    long max_so_far_index = 0;\n    long max_so_far_rolling_max = 0;\n\
    \    long max_so_far_rolling_max_index = 0;\n    \n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        max_so_far = numbers[i];\n        max_so_far_index = i;\n\
    \        max_so_far_rolling_max = max_so_far;\n        max_so_far_rolling_max_index\
    \ = i;\n        \n        for(int j = i + 1; j < numbers.length; j++)\n      \
    \  {\n            if(numbers[j] > max_so_far)\n            {\n               \
    \ max_so_far = numbers[j];\n                max_so_far_index = j;\n          \
    \      max_so_far_rolling_max = max_so_far;\n                max_so_far_rolling_max_index\
    \ = j;\n            }\n        }\n        \n        numbers[max_so_far_index]\
    \ = max_so_far_rolling_max;\n    }\n    \n    return numbers;\n}\n</code>\n<|/\
    \ a tags=arrays,c#,algorithm |>\n<| c |>\nThis doesn't work if the array is empty\
    \ or has only one element. Also, your algorithm is O(n^2), which is very inefficient.\n\
    <|/ c |>\n<| c |>\nI agree with you, my algorithm is O(n^2), but it is very simple\
    \ and easy to understand. Also, your algorithm is O(n^2) because you use two loops,\
    \ one for iterating over the array and another for iterating over the array again.\
    \ My algorithm is O(n), because you only iterate over the array once.\n<|/ c |>\n\
    <| c |>\nI agree with you, my algorithm is O(n^2), but it is very simple and easy\
    \ to understand. Also, your algorithm is O(n^2) because you use two loops, one\
    \ for iterating over the array and another for iterating over the array again.\
    \ My algorithm is O(n), because you only iterate over the array once.\n<|/ c |>\n\
    <| c |>\nI agree with you, my algorithm is O(n^2), but it is very simple and easy\
    \ to understand. Also, your algorithm is O(n^2) because you use two loops, one\
    \ for iterating over the array and another for iterating over the array again.\
    \ My algorithm is O(n), because you only iterate over the array once.\n<|/ c |>\n\
    <| c |>\nI agree with you, my algorithm is O(n^2), but it is very simple and easy\
    \ to understand. Also, your algorithm is O(n^2) because you use two loops, one\
    \ for iterating \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrcz2wdv.d(40): Error: declaration expected, not `<`\\n/tmp/tmpcrcz2wdv.d(43):\
    \ Error: unterminated character constant\\n/tmp/tmpcrcz2wdv.d(60): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpcrcz2wdv.d(61): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpcrcz2wdv.d(62): Error: declaration expected, not `assert`\\\
    n/tmp/tmpcrcz2wdv.d(63): Error: declaration expected, not `assert`\\n/tmp/tmpcrcz2wdv.d(64):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcrcz2wdv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long[] result = new long[numbers.length];\n    for (int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n        result[i\
    \ - 1] = max_so_far;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=c#,algorithm,arrays |>\n<code>\npublic int[] GetMax(int[] arr, int size)\n\
    {\n    int[] result = new int[size];\n    int max = arr[0];\n    int maxIndex\
    \ = 0;\n    for (int i = 0; i < size; i++)\n    {\n        if (arr[i] > max)\n\
    \        {\n            max = arr[i];\n            maxIndex = i;\n        }\n\
    \    }\n    result[maxIndex] = max;\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=c#,algorithm,arrays |>\n<code>\npublic int[] GetMax(int[] arr,\
    \ int size)\n{\n    int[] result = new int[size];\n    int max = arr[0];\n   \
    \ int maxIndex = 0;\n    for (int i = 0; i < size; i++)\n    {\n        if (arr[i]\
    \ > max)\n        {\n            max = arr[i];\n            maxIndex = i;\n  \
    \      }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic int[] GetMax(int[] arr, int\
    \ size)\n{\n    int[] result = new int[size];\n    int max = arr[0];\n    int\
    \ maxIndex = 0;\n    for (int i = 0; i < size; i++)\n    {\n        if (arr[i]\
    \ > max)\n        {\n            max = arr[i];\n            maxIndex = i;\n  \
    \      }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,arrays |>\n<| a tags=c#,algorithm,arrays |>\n<code>\n\
    public int[] GetMax(int[] arr, int size)\n{\n    int[] result = new int[size];\n\
    \    int max = arr[0];\n    int maxIndex = 0;\n    for (int i = 0; i < size; i++)\n\
    \    {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    result[maxIndex] = max;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,algorithm,arrays |>\n<code>\n\
    public int[] GetMax(int[] arr, int size)\n{\n    int[] result = new int[size];\n\
    \    int max = arr[0];\n    int \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi0afjklz.d(24): Error: declaration expected, not `<`\\n/tmp/tmpi0afjklz.d(33):\
    \ Error: declaration expected, not `for`\\n/tmp/tmpi0afjklz.d(33): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpi0afjklz.d(33): Error: declaration expected, not\
    \ `<`\\n/tmp/tmpi0afjklz.d(33): Error: no identifier for declarator `i`\\n/tmp/tmpi0afjklz.d(33):\
    \ Error: declaration expected, not `++`\\n/tmp/tmpi0afjklz.d(38): Error: no identifier\
    \ for declarator `maxIndex`\\n/tmp/tmpi0afjklz.d(38): Error: declaration expected,\
    \ not `=`\\n/tmp/tmpi0afjklz.d(39): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi0afjklz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > max)\n        {\n\
    \            max = sum;\n            maxIndex = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[maxIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    long sum = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sum < min)\n        {\n            min = sum;\n            minIndex\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n\
    */\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n    long avg =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = avg;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling median element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4,\
    \ 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    Arrays.sort(numbers);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[numbers.length\
    \ / 2 - i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling standard deviation element found until given moment\n\
    \    in the sequence.\n    >>> rolling_std([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 4]\n    \n*/\nlong[] rolling_std(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpspepxr6l.d(111): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpspepxr6l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[i] = max;\n        }\n        else\n \
    \       {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 2]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            result[i] = sum;\n        }\n\
    \        else\n        {\n            result[i] = sum / sumIndex;\n        }\n\
    \        sumIndex++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    long sum = 0;\n    long sumIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            result[i] = sum;\n        }\n\
    \        else\n        {\n            result[i] = sum / sumIndex;\n        }\n\
    \        sumIndex++;\n    }\n    long middle = sum / sumIndex;\n    for(int i\
    \ = 0; i < numbers.length; i++)\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzbqwhv11.d(123): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzbqwhv11.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long minIndex = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    result[minIndex]\
    \ = minValue;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = 1;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        product *=\
    \ numbers[i];\n        result[i] = product;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling quotient of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 1, 2, 1, 2, 1]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long quotient\
    \ = 1;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        quotient\
    \ /= numbers[i];\n        result[i] = quotient;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling remainder of element\
    \ found until given moment\n\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg0atw7xp.d(103): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg0atw7xp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max_so_far = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n    }\n    \n   \
    \ for(; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n   \
    \     max_so_far = numbers[i];\n    }\n    \n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    int i = 0;\n    long min_so_far\
    \ = numbers[0];\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n        }\n\
    \    }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \        min_so_far = numbers[i];\n    }\n    \n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    int i = 0;\n    long sum_so_far\
    \ = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        sum_so_far +=\
    \ numbers[i];\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n      \
    \  result[i] = sum_so_far;\n        sum_so_far = numbers[i];\n    }\n    \n  \
    \  return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product element found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 240, 720]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long product_so_far = 1;\n    \n    for(; i < numbers.length; i++)\n    {\n\
    \        product_so_far *= numbers[i];\n    }\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = product_so_far;\n        product_so_far = numbers[i];\n\
    \    }\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp06uz4czv.d(111): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp06uz4czv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    long max_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_index\
    \ = i;\n        }\n    }\n    result[max_index] = max_value;\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_value\
    \ = numbers[0];\n    long min_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_index = i;\n        }\n    }\n    result[min_index]\
    \ = min_value;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum / numbers.length;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2,\
    \ 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sum % 2 == 0)\n        {\n            result[i] = sum / 2;\n     \
    \   }\n        else\n        {\n            result[i] = (sum + 1\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppk92fev6.d(105): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmppk92fev6.d(107): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmppk92fev6.d(115): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmppk92fev6.d(115): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppk92fev6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  \n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays |>\n<| c |>\n\
    The second for loop should be `for(; i < numbers.length; i++)`\n<|/ c |>\n<| c\
    \ |>\nThanks for noticing! I fixed it.\n<|/ c |>\n<| a tags=c#,algorithm,arrays\
    \ |>\n<code>\npublic int[] rollingMax(int[] numbers)\n{\n    int[] result = new\
    \ int[numbers.Length];\n    int i = 0;\n    int max = 0;\n    \n    for(; i <\
    \ numbers.Length; i++)\n    {\n        if(numbers[i] > max)\n        {\n     \
    \       max = numbers[i];\n        }\n    }\n    \n    for(; i < numbers.Length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  \n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\n\
    public int[] rollingMax(int[] numbers)\n{\n    int[] result = new int[numbers.Length];\n\
    \    int i = 0;\n    int max = 0;\n    \n    for(; i < numbers.Length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n    }\n    \n    for(; i < numbers.Length; i++)\n    {\n        result[i]\
    \ = max;\n        max = numbers[i];\n    }\n    \n    return result;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,arrays |>\n<| a dscore=2 |>\n<code>\npublic int[] rollingMax(int[]\
    \ numbers)\n{\n    int[] result = new int[numbers.Length];\n    int i = 0;\n \
    \   int max = 0;\n    \n    for(; i < numbers.Length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n    }\n    \n \
    \   for(; i < numbers.Length; i++)\n    {\n        result[i] = max;\n        max\
    \ = numbers[i];\n    }\n    \n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays\
    \ |>\n<| a tags=c#,algorithm,arrays |>\n<code>\npublic int[] rollingMax(int[]\
    \ numbers)\n{\n    int[] result = new int[numbers.Length];\n    int i = 0;\n\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqnqnuzpz.d(32): Error: declaration expected, not `<`\\n/tmp/tmpqnqnuzpz.d(48):\
    \ Error: declaration expected, not `for`\\n/tmp/tmpqnqnuzpz.d(48): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpqnqnuzpz.d(48): Error: declaration expected, not\
    \ `<`\\n/tmp/tmpqnqnuzpz.d(48): Error: no identifier for declarator `i`\\n/tmp/tmpqnqnuzpz.d(48):\
    \ Error: declaration expected, not `++`\\n/tmp/tmpqnqnuzpz.d(53): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqnqnuzpz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    long max_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_value)\n        {\n            result[max_pos] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    long\
    \ min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_value)\n        {\n            min_value = numbers[i];\n            min_pos\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_value)\n        {\n            result[min_pos] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long sum2 = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        sum2 += numbers[i] * numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum - sum2;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 16]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = 1;\n    long product2 = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        product *= numbers[i];\n        product2 *= numbers[i] * numbers[i];\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = product - product2;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling quotient element found until given moment\n\
    \    in the \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9srojbd4.d(107): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9srojbd4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n  \
    \  for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 1, 2, 1, 2, 1]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] += result[i-1];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 720, 5040]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] *= result[i-1];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling quotient element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] /= result[i-1];\n\
    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkp94ring.d(114): Error: found `unittest` instead of statement\\\
    n/tmp/tmpkp94ring.d(123): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkp94ring.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        max = Math.max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n\
    <| c |>\nThis doesn't answer the question. The OP wants to find the max element\
    \ in the array *rolling* the max element to the right of the max element. Your\
    \ code doesn't do that.\n<|/ c |>\n<| c |>\nI believe this does answer the question.\
    \ He wants to find the max element in the array rolling the max element to the\
    \ right of the max element. He also stated that he wants to find the max element\
    \ in the array rolling the max element to the right of the max element. He also\
    \ stated that he wants to find the max element in the array rolling the max element\
    \ to the right of the max element. He also stated that he wants to find the max\
    \ element in the array rolling the max element to the right of the max element.\
    \ He also stated that he wants to find the max element in the array rolling the\
    \ max element to the right of the max element. He also stated that he wants to\
    \ find the max element in the array rolling the max element to the right of the\
    \ max element. He also stated that he wants to find the max element in the array\
    \ rolling the max element to the right of the max element. He also stated that\
    \ he wants to find the max element in the array rolling the max element to the\
    \ right of the max element. He also stated that he wants to find the max element\
    \ in the array rolling the max element to the right of the max element. He also\
    \ stated that he wants to find the max element in the array rolling the max element\
    \ to the right of the max element. He also stated that he wants to find the max\
    \ element in the array rolling the max element to the right of the max element.\
    \ He also stated that he wants to find the max element in the array rolling the\
    \ max element to the right of the max element. He also stated that he wants to\
    \ find the max element in the array rolling the max element to the right of the\
    \ max element. He also stated that he wants to find the max element in the array\
    \ rolling the max element to the right of the max element. He also stated that\
    \ he wants to find the max element in the array rolling the max element to the\
    \ right of the max element. He also stated that he wants to find the max element\
    \ in the array rolling the max element to the right of the max element. He also\
    \ stated that he wants to find the max element in the array roll\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcp68gj8w.d(22): Error: declaration expected, not `<`\\n/tmp/tmpcp68gj8w.d(25):\
    \ Error: unterminated character constant\\n/tmp/tmpcp68gj8w.d(25): Error: unterminated\
    \ character constant\\n/tmp/tmpcp68gj8w.d(33): Error: declaration expected, not\
    \ `assert`\\n/tmp/tmpcp68gj8w.d(34): Error: declaration expected, not `assert`\\\
    n/tmp/tmpcp68gj8w.d(35): Error: declaration expected, not `assert`\\n/tmp/tmpcp68gj8w.d(36):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpcp68gj8w.d(37): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcp68gj8w.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    if(current > max)\n        {\n            max = current;\n        }\n   \
    \     result[i] = max;\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,java,arrays\
    \ |>\n<| a tags=algorithm,java,arrays |>\n<code>\npublic static void main(String[]\
    \ args) {\n    int[] arr = {1, 2, 3, 2, 3, 4, 2};\n    System.out.println(Arrays.toString(rolling_max(arr)));\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxl0hwd36.d(26): Error: declaration expected, not `<`\\n/tmp/tmpxl0hwd36.d(32):\
    \ Error: identifier expected following `.` instead of `out`\\n/tmp/tmpxl0hwd36.d(32):\
    \ Error: no identifier for declarator `System`\\n/tmp/tmpxl0hwd36.d(32): Error:\
    \ declaration expected, not `out`\\n/tmp/tmpxl0hwd36.d(33): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxl0hwd36.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long currentMax = 0;\n \
    \   long currentNumber = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        currentNumber = numbers[i];\n        max = currentNumber;\n     \
    \   currentMax = currentNumber;\n        for(int j = i; j < numbers.length; j++)\n\
    \        {\n            if(numbers[j] > currentNumber)\n            {\n      \
    \          max = numbers[j];\n                currentMax = numbers[j];\n     \
    \       }\n        }\n        result[i] = currentMax;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 3, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ currentMin = 0;\n    long currentNumber = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        currentNumber = numbers[i];\n        min = currentNumber;\n\
    \        currentMin = currentNumber;\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            if(numbers[j] < currentNumber)\n            {\n\
    \                min = numbers[j];\n                currentMin = numbers[j];\n\
    \            }\n        }\n        result[i] = currentMin;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    long currentNumber = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n     \
    \   sum = currentNumber;\n        currentSum = currentNumber;\n        for(int\
    \ j = i; j < numbers.length; j++)\n        {\n            sum += numbers[j];\n\
    \            currentSum += numbers[j];\n        }\n        result[i] = currentSum;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n{\n    double[]\
    \ result = new double[numbers.length];\n    double sum = 0;\n    double currentSum\
    \ = 0;\n    double currentNumber\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8zm84tky.d(103): Error: semicolon expected, not `unittest`\\\
    n/tmp/tmp8zm84tky.d(103): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8zm84tky.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_value\
    \ = numbers[0];\n    long max_index = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[max_index];\n        max_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long min_value = numbers[0];\n   \
    \ long min_index = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n \
    \       if (numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_index];\n\
    \        min_index++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] / numbers.length;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling median\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_median([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long median\
    \ = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        median =\
    \ (numbers[i] + median) / 2;\n        result[i] = median;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling standard deviation\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_std([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_std(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = std.math.std(numbers);\n\
    \    }\n    return result;\n}\n/*\n From a given \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj1bvs68f.d(107): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj1bvs68f.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \       max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long min_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            min_pos = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 240]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long prod =\
    \ 1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        prod *= numbers[i];\n\
    \        result[i] = prod;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling quotient element found until given moment\n\
    \    in the sequence.\n    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long quo = 1;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        quo *= numbers[i];\n        result[i]\
    \ = quo;\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr8kcq_gc.d(109): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr8kcq_gc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = numbers[0];\n    long maxIndex\
    \ = -1;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    result[0] = max;\n    for(int i = 1; i < n; i++)\n    {\n    \
    \    if(maxIndex == i)\n        {\n            result[i] = numbers[i];\n     \
    \   }\n        else\n        {\n            result[i] = numbers[maxIndex];\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min = numbers[0];\n    long minIndex = -1;\n\
    \    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] < min)\n       \
    \ {\n            min = numbers[i];\n            minIndex = i;\n        }\n   \
    \ }\n    result[0] = min;\n    for(int i = 1; i < n; i++)\n    {\n        if(minIndex\
    \ == i)\n        {\n            result[i] = numbers[i];\n        }\n        else\n\
    \        {\n            result[i] = numbers[minIndex];\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    result[0] = sum;\n    for(int i = 1; i < n; i++)\n    {\n        result[i]\
    \ = sum - numbers[i - 1];\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling product element found until given moment\n\
    \    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 6, 12, 24, 48, 96]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    long product\
    \ = 1;\n    for(int i = 0; i < n; i++)\n    {\n        product *= numbers[i];\n\
    \    }\n    result[0] = product;\n    for(int i = 1; i < n; i++)\n    {\n    \
    \    result[i] = product / numbers[i - 1];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3_48856a.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3_48856a.d(47): Error: cannot implicitly\
    \ convert expression `numbers.length` of type `ulong` to `int`\\n/tmp/tmp3_48856a.d(82):\
    \ Error: cannot implicitly convert expression `numbers.length` of type `ulong`\
    \ to `int`\\n/tmp/tmp3_48856a.d(105): Error: cannot implicitly convert expression\
    \ `numbers.length` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3_48856a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_i = 0;\n    long max_so_far_j = 0;\n    long\
    \ max_so_far_k = 0;\n    long max_so_far_l = 0;\n    long max_so_far_m = 0;\n\
    \    long max_so_far_n = 0;\n    long max_so_far_o = 0;\n    long max_so_far_p\
    \ = 0;\n    long max_so_far_t = 0;\n    long max_so_far_u = 0;\n    long max_so_far_v\
    \ = 0;\n    long max_so_far_w = 0;\n    long max_so_far_x = 0;\n    long max_so_far_y\
    \ = 0;\n    long max_so_far_z = 0;\n    long max_so_far_a = 0;\n    long max_so_far_b\
    \ = 0;\n    long max_so_far_c = 0;\n    long max_so_far_d = 0;\n    long max_so_far_e\
    \ = 0;\n    long max_so_far_f = 0;\n    long max_so_far_g = 0;\n    long max_so_far_h\
    \ = 0;\n    long max_so_far_i = 0;\n    long max_so_far_j = 0;\n    long max_so_far_k\
    \ = 0;\n    long max_so_far_l = 0;\n    long max_so_far_m = 0;\n    long max_so_far_n\
    \ = 0;\n    long max_so_far_o = 0;\n    long max_so_far_p = 0;\n    long max_so_far_t\
    \ = 0;\n    long max_so_far_u = 0;\n    long max_so_far_v = 0;\n    long max_so_far_w\
    \ = 0;\n    long max_so_far_x = 0;\n    long max_so_far_y = 0;\n    long max_so_far_z\
    \ = 0;\n    long max_so_far_a = 0;\n    long max_so_far_b = 0;\n    long max_so_far_c\
    \ = 0;\n    long max_so_far_d = 0;\n    long max_so_far_e = 0;\n    long max_so_far_f\
    \ = 0;\n    long max_so_far_g = 0;\n    long max_so_far_h = 0;\n    long max_so_far_i\
    \ = 0;\n    long max_so_far_j = 0;\n    long max_so_far_k = 0;\n    long max_so_far_l\
    \ = 0;\n    long max_so_far_m = 0;\n    long max_so_far_n = 0;\n    long max_so_far_o\
    \ = 0;\n    long max_so_far_p = 0;\n    long max_so_far_t = 0;\n    long max_so_far_\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkf2_sq2j.d(69): Error: semicolon expected, not `unittest`\\n/tmp/tmpkf2_sq2j.d(69):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkf2_sq2j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/11878677)\n<|/ c |>\n<| c |>\nI believe\
    \ this does answer the question. He wants to generate a list of rolling maximum\
    \ element found until a given moment in the sequence. He has provided a solution\
    \ to his problem and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution. He has provided\
    \ a solution and he is asking if he can improve his solution.\n<|/ c |>\n<| c\
    \ |>\nThis does not provide an answer to the question. To critique or request\
    \ clarification from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11878677)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He wants to generate\
    \ a list of rolling maximum element found until a given moment in the sequence.\
    \ He has provided a solution to his problem and he is asking if he can improve\
    \ his solution. He has provided a solution and he is asking if he can improve\
    \ his solution. He has provided a solution and he is asking if he can improve\
    \ his solution. He has provided a solution and he is asking if he can improve\
    \ his solution. He has provided a solution and he is asking if he can improve\
    \ his solution. He has provided a solution and he is asking if he can improve\
    \ his \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_l70r992.d(28): Error: declaration expected, not `<`\\n/tmp/tmp_l70r992.d(45):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmp_l70r992.d(46): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmp_l70r992.d(47): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmp_l70r992.d(48): Error: declaration expected, not `assert`\\\
    n/tmp/tmp_l70r992.d(49): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp_l70r992.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    long rollingMax\
    \ = 0;\n    \n    while(i < numbers.length)\n    {\n        max = numbers[i];\n\
    \        rollingMax = max;\n        \n        for(int j = i + 1; j < numbers.length;\
    \ j++)\n        {\n            if(numbers[j] > max)\n            {\n         \
    \       max = numbers[j];\n                rollingMax = max;\n            }\n\
    \        }\n        \n        result[i] = rollingMax;\n        i++;\n    }\n \
    \   \n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long min = 0;\n    long rollingMin = 0;\n    \n    while(i\
    \ < numbers.length)\n    {\n        min = numbers[i];\n        rollingMin = min;\n\
    \        \n        for(int j = i + 1; j < numbers.length; j++)\n        {\n  \
    \          if(numbers[j] < min)\n            {\n                min = numbers[j];\n\
    \                rollingMin = min;\n            }\n        }\n        \n     \
    \   result[i] = rollingMin;\n        i++;\n    }\n    \n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling sum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    long\
    \ sum = 0;\n    long rollingSum = 0;\n    \n    while(i < numbers.length)\n  \
    \  {\n        sum = numbers[i];\n        rollingSum = sum;\n        \n       \
    \ for(int j = i + 1; j < numbers.length; j++)\n        {\n            sum += numbers[j];\n\
    \            rollingSum += sum;\n        }\n        \n        result[i] = rollingSum;\n\
    \        i++;\n    }\n    \n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n\
    {\n    double[] result = new double[numbers.length];\n    int \nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnekxy603.d(113): Error: no identifier for declarator `int`\\\
    n/tmp/tmpnekxy603.d(113): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnekxy603.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    int i = 0;\n    \n \
    \   while (i < n) {\n        max = numbers[i];\n        \n        for (int j =\
    \ i + 1; j < n; j++) {\n            if (numbers[j] > max) {\n                max\
    \ = numbers[j];\n            }\n        }\n        \n        result[i] = max;\n\
    \        i++;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj76pk9a4.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpj76pk9a4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n        maxValue\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long minValue = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < minValue)\n\
    \        {\n            minValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = minValue;\n        minValue\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum of the elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6,\
    \ 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = sum;\n        sum = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product of the elements found until given moment\n    in the\
    \ sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6,\
    \ 6, 6, 6]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long product = 1;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        product *= numbers[i];\n    }\n   \
    \ for(; i < numbers.length; i++)\n    {\n        result[i] = product;\n      \
    \  product = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling quotient of the elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_quotient([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxwj04k2r.d(112): Error: no identifier for declarator `long`\\\
    n/tmp/tmpxwj04k2r.d(112): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxwj04k2r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_value\
    \ = numbers[0];\n    long max_index = numbers[0];\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[max_index];\n        max_index++;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmphs1dl53t.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285c6]\\n??:? long[] tmphs1dl53t.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmphs1dl53t.__unittest_L30_C1() [0x427faa]\\n??:? void\
    \ tmphs1dl53t.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5f3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b486]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430711]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43069d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b45d]\\n??:? runModuleUnitTests [0x42c3c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289d8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42895f]\\n??:? _d_run_main [0x4288ca]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x24ff0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n\
    \    {\n        result[i] = max_so_far;\n    }\n    result[max_so_far_index] =\
    \ max_so_far;\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpflp57b93.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285be]\\n??:? long[] tmpflp57b93.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpflp57b93.__unittest_L30_C1() [0x427f9e]\\n??:? void\
    \ tmpflp57b93.__modtest() [0x42828c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5eb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b47e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430709]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430695]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b455]\\n??:? runModuleUnitTests [0x42c3c1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289d0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428957]\\n??:? _d_run_main [0x4288c2]\\n??:? main [0x42829f]\\\
    n??:? __libc_start_main [0x133c7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n  \
    \  for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpgi5xgb9u.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285a6]\\n??:? long[] tmpgi5xgb9u.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpgi5xgb9u.__unittest_L29_C1() [0x427f86]\\n??:? void\
    \ tmpgi5xgb9u.__modtest() [0x428274]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b466]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43067d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b43d]\\n??:? runModuleUnitTests [0x42c3a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42893f]\\n??:? _d_run_main [0x4288aa]\\n??:? main [0x428287]\\\
    n??:? __libc_start_main [0xe59d9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpn04udf9h.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428576]\\n??:? long[] tmpn04udf9h.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpn04udf9h.__unittest_L27_C1() [0x427f5a]\\n??:? void\
    \ tmpn04udf9h.__modtest() [0x428248]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b436]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306c1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b70]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43064d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b40d]\\n??:? runModuleUnitTests [0x42c379]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428988]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42890f]\\n??:? _d_run_main [0x42887a]\\n??:? main [0x42825b]\\\
    n??:? __libc_start_main [0x10f86554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpss3z_axo.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42849d]\\n??:? void tmpss3z_axo.__unittest_L28_C1()\
    \ [0x428021]\\n??:? void tmpss3z_axo.__modtest() [0x428220]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c57b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b40e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430699]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b48]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430625]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3e5]\\n??:? runModuleUnitTests [0x42c351]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428960]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4288e7]\\n??:? _d_run_main [0x428852]\\n??:? main [0x428233]\\\
    n??:? __libc_start_main [0x24bc5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n        maxValue\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long minValue = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < minValue)\n\
    \        {\n            minValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = minValue;\n        minValue\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ += numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n{\n \
    \   double[] result = new double[numbers.length];\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = result[i] / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> rolling_variance([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\ndouble[] rolling_variance(double[] numbers) \n{\n    double[] result\
    \ = new double[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphcepoqty.d(113): Error: found `unittest` instead of statement\\\
    n/tmp/tmphcepoqty.d(118): Error: found `;` when expecting `)`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphcepoqty.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if(cur > max)\n\
    \        {\n            max = cur;\n        }\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if(cur < min)\n  \
    \      {\n            min = cur;\n        }\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for(int i = 0; i <\
    \ n; i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n\
    \        result[i] = sum / n;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling median element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ sum = 0;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n       \
    \ cur = numbers[i];\n        sum += cur;\n        result[i] = sum / n;\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp183o2rw6.d(111): Error: found `unittest` instead of statement\\\
    n/tmp/tmp183o2rw6.d(120): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp183o2rw6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_pos = i;\n        }\n    }\n    for(int i = numbers.length - 1; i\
    \ >= 0; i--)\n    {\n        if(numbers[i] > max_so_far)\n        {\n        \
    \    result[max_so_far_pos] = numbers[i];\n            max_so_far = numbers[i];\n\
    \            max_so_far_pos = i;\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    for(int\
    \ i = numbers.length - 1; i >= 0; i--)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            result[min_so_far_pos] = numbers[i];\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_avg([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\ndouble[] rolling_avg(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    double\
    \ sum_so_far = 0;\n    double sum_so_far_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum_so_far += numbers[i];\n        sum_so_far_pos = i;\n\
    \    }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n        sum_so_far\
    \ += numbers[i];\n        sum_so_far_pos = i;\n    }\n    for(int i = numbers.length\
    \ - 1; i >= 0; i--)\n    {\n        result[sum_so_far_pos] = sum_so_far / i;\n\
    \        sum_so_far = 0;\n        sum_so_far_pos = \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvj5885gj.d(92): Error: expression expected, not `unittest`\\\
    n/tmp/tmpvj5885gj.d(93): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpvj5885gj.d(101): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvj5885gj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    int i = 0;\n    \n \
    \   while(i < n) {\n        if(numbers[i] > max) {\n            max = numbers[i];\n\
    \        }\n        i++;\n    }\n    \n    while(i < n) {\n        result[i] =\
    \ max;\n        i++;\n    }\n    \n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    long min = 0;\n   \
    \ int i = 0;\n    \n    while(i < n) {\n        if(numbers[i] < min) {\n     \
    \       min = numbers[i];\n        }\n        i++;\n    }\n    \n    while(i <\
    \ n) {\n        result[i] = min;\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    int i = 0;\n    \n    while(i < n) {\n        sum += numbers[i];\n\
    \        i++;\n    }\n    \n    while(i < n) {\n        result[i] = sum;\n   \
    \     i++;\n    }\n    \n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n\
    {\n    int n = numbers.length;\n    double[] result = new double[n];\n    double\
    \ sum = 0;\n    int i = 0;\n    \n    while(i < n) {\n        sum += numbers[i];\n\
    \        i++;\n    }\n    \n    while(i < n) {\n        result[i] = sum / i;\n\
    \        i++;\n    }\n    \n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling median element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5,\
    \ 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n  \
    \  int n = number\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpivrwx0ph.d(121): Error: semicolon expected, not `unittest`\\\
    n/tmp/tmpivrwx0ph.d(121): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpivrwx0ph.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n        maxValue\
    \ = numbers[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpnnyu13cw.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285a6]\\n??:? long[] tmpnnyu13cw.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpnnyu13cw.__unittest_L29_C1() [0x427f86]\\n??:? void\
    \ tmpnnyu13cw.__modtest() [0x428274]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b466]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43067d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b43d]\\n??:? runModuleUnitTests [0x42c3a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42893f]\\n??:? _d_run_main [0x4288aa]\\n??:? main [0x428287]\\\
    n??:? __libc_start_main [0x661e6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    int i = 0;\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ = numbers[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpelau5n05.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285a6]\\n??:? long[] tmpelau5n05.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpelau5n05.__unittest_L32_C1() [0x427f86]\\n??:? void\
    \ tmpelau5n05.__modtest() [0x428274]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b466]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43067d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b43d]\\n??:? runModuleUnitTests [0x42c3a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42893f]\\n??:? _d_run_main [0x4288aa]\\n??:? main [0x428287]\\\
    n??:? __libc_start_main [0xdb85f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min\
    \ = 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \        minIndex++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] += result[i-1];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] *= result[i-1];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ehjelbj.d(112): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ehjelbj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == max)\n        {\n            result[i] = max;\n        }\n\
    \        else\n        {\n            result[i] = numbers[i];\n        }\n   \
    \ }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    long minIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3,\
    \ 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            result[i] = sum;\n        }\n\
    \        else\n        {\n            result[i] = sum / sumIndex;\n        }\n\
    \        sumIndex++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        if(sumIndex == 0)\n        {\n            result[i]\
    \ = sum;\n        }\n        else\n        {\n            result[i] = sum / sumIndex;\n\
    \        }\n        sumIndex++;\n    }\n    \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphkoq_2xt.d(122): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkoq_2xt.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \        max_index--;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min\
    \ = numbers[0];\n    long min_index = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_index];\n\
    \        min_index++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum\
    \ = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        sum += numbers[i];\n        count++;\n    }\n    long avg = sum /\
    \ count;\n    long[] result = new long[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> rolling_std([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_std(long[] numbers) \n{\n    double sum = 0;\n    double count\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    double avg = sum / count;\n    double variance =\
    \ sum / count - avg * avg;\n    long[] result = new long[numbers.length];\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - avg;\n        result[i] *= result[i] / Math.sqrt(variance);\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling variance\
    \ element found until \nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwawezqpc.d(107): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwawezqpc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long max_pos =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            max_pos = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == max)\n        {\n            result[max_pos] = max;\n    \
    \    }\n        else\n        {\n            result[max_pos] = numbers[i];\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 3, 4, 3]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            min_pos = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min)\n        {\n            result[min_pos]\
    \ = min;\n        }\n        else\n        {\n            result[min_pos] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum of the elements found until given moment\n  \
    \  in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6,\
    \ 6, 3, 4, 5]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long sum_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(sum > numbers[i - 1])\n        {\n            sum = numbers[i - 1];\n   \
    \         sum_pos = i - 1;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == sum)\n        {\n            result[sum_pos]\
    \ = sum;\n        }\n        else\n        {\n            result[sum_pos] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling product of the elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_prod([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 3, 4, 5]\n    \n*/\nlong[] rolling_prod(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long prod = 1;\n    long prod_pos =\
    \ 0;\n    for(int i = 1\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiitqf2zz.d(116): Error: semicolon expected, not `unittest`\\\
    n/tmp/tmpiitqf2zz.d(116): Error: expression expected, not `unittest`\\n/tmp/tmpiitqf2zz.d(117):\
    \ Error: found `{` when expecting `;` following `for` condition\\n/tmp/tmpiitqf2zz.d(118):\
    \ Error: expression expected, not `alias`\\n/tmp/tmpiitqf2zz.d(118): Error: found\
    \ `candidate` when expecting `)`\\n/tmp/tmpiitqf2zz.d(118): Error: found `=` instead\
    \ of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiitqf2zz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,arrays |>\n<code>\n\
    public static int[] GetMax(int[] array)\n{\n    int[] result = new int[array.Length];\n\
    \    int maxValue = array[0];\n    int maxIndex = 0;\n    for (int i = 0; i <\
    \ array.Length; i++)\n    {\n        if (array[i] > maxValue)\n        {\n   \
    \         maxValue = array[i];\n            maxIndex = i;\n        }\n    }\n\
    \    result[maxIndex] = maxValue;\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=c#,algorithm,arrays |>\n<code>\npublic static int[] GetMax(int[]\
    \ array)\n{\n    int[] result = new int[array.Length];\n    int maxValue = array[0];\n\
    \    int maxIndex = 0;\n    for (int i = 0; i < array.Length; i++)\n    {\n  \
    \      if (array[i] > maxValue)\n        {\n            maxValue = array[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n\
    \    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,arrays\
    \ |>\n<code>\npublic int[] GetMax(int[] array)\n{\n    int[] result = new int[array.Length];\n\
    \    int maxValue = array[0];\n    int maxIndex = 0;\n    for (int i = 0; i <\
    \ array.Length; i++)\n    {\n        if (array[i] > maxValue)\n        {\n   \
    \         maxValue = array[i];\n            maxIndex = i;\n        }\n    }\n\
    \    result[maxIndex] = maxValue;\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static int[] GetMax(int[] array)\n{\n \
    \   int[] result = new int[array.Length];\n    int maxValue = array[0];\n    int\
    \ maxIndex = 0;\n    for (int i = 0; i < array.Length; i++)\n    {\n        if\
    \ (array[i] > maxValue)\n        {\n            maxValue = array[i];\n       \
    \     maxIndex = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays |>\n<| a dscore=1 |>\n<code>\n\
    public static int[] GetMax(int[] array)\n{\n    int[] result = new int[array.Length];\n\
    \    int maxValue = array\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbemcydfe.d(28): Error: declaration expected, not `<`\\n/tmp/tmpbemcydfe.d(37):\
    \ Error: declaration expected, not `for`\\n/tmp/tmpbemcydfe.d(37): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpbemcydfe.d(37): Error: declaration expected, not\
    \ `<`\\n/tmp/tmpbemcydfe.d(37): Error: no identifier for declarator `i`\\n/tmp/tmpbemcydfe.d(37):\
    \ Error: declaration expected, not `++`\\n/tmp/tmpbemcydfe.d(42): Error: no identifier\
    \ for declarator `maxIndex`\\n/tmp/tmpbemcydfe.d(42): Error: declaration expected,\
    \ not `=`\\n/tmp/tmpbemcydfe.d(43): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbemcydfe.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] > max)\n        {\n            result[maxIndex] = numbers[i];\n\
    \            maxIndex++;\n        }\n    }\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   long minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = numbers[i];\n            minIndex++;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n     \
    \       result[sumIndex] = sum;\n            sumIndex++;\n        }\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling product element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 240, 720]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long product = 1;\n    long productIndex = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        product *= numbers[i];\n\
    \        if(productIndex == 0)\n        {\n            result[productIndex] =\
    \ product;\n            productIndex++;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling quotient element\
    \ found until given moment\n    in the sequence.\n    >>> \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp39cfz3iu.d(109): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp39cfz3iu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long max_index = 0;\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > max)\n        {\n\
    \            max = sum;\n            max_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=c#,algorithm |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7h03rney.d(31): Error: declaration expected, not `<`\\n/tmp/tmp7h03rney.d(36):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmp7h03rney.d(36): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmp7h03rney.d(37): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmp7h03rney.d(37): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmp7h03rney.d(38): Error: semicolon expected, not `.`\\n/tmp/tmp7h03rney.d(38):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmp7h03rney.d(39): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmp7h03rney.d(39): Error: no identifier for\
    \ declarator `.Threading.Tasks`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp7h03rney.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long currentMax = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n            maxIndex = i;\n     \
    \   }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long\
    \ minIndex = 0;\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long sumIndex = 0;\n    long currentSum\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        sumIndex++;\n    }\n    long currentSum = sum;\n    long currentSumIndex\
    \ = sumIndex;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        sumIndex++;\n    }\n    long currentSum = sum;\n   \
    \ long currentSumIndex = sumIndex;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        sumIndex++;\n    }\n    long currentSum\
    \ = sum;\n    long currentSumIndex = sumIndex;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        sumIndex++;\n    }\n    long\
    \ currentSum = sum;\n    long currentSumIndex = sumIndex;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        sumIndex++;\n\
    \    }\n    long currentSum = sum;\n    long currentSumIndex = sumIndex;\n   \
    \ for(int i = 1; i < number\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8m43fu2h.d(105): Error: found `unittest` when expecting `;` following\
    \ `for` condition\\n/tmp/tmp8m43fu2h.d(114): Error: found `void` when expecting\
    \ `)`\\n/tmp/tmp8m43fu2h.d(114): Error: found `{` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8m43fu2h.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n        result[i-1]\
    \ = max_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_so_far\
    \ = numbers[0];\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n        }\n        result[i-1]\
    \ = min_so_far;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum_so_far = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum_so_far += numbers[i];\n        result[i-1] = sum_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long prod_so_far =\
    \ 1;\n    long[] result = new long[numbers.length];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        prod_so_far *= numbers[i];\n        result[i-1] = prod_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n   \
    \ \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long quot_so_far = 1;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        quot_so_far /= \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5u8o_zlv.d(95): Error: expression expected, not `unittest`\\\
    n/tmp/tmp5u8o_zlv.d(96): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmp5u8o_zlv.d(104): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5u8o_zlv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_value = numbers[0];\n    long\
    \ max_pos = 0;\n    for(int i = 1; i < n; ++i)\n    {\n        if(numbers[i] >\
    \ max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    for(int i = max_pos; i < n; ++i)\n    {\n      \
    \  result[i - max_pos] = max_value;\n        max_value = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    long min_value = numbers[0];\n    long min_pos = 0;\n  \
    \  for(int i = 1; i < n; ++i)\n    {\n        if(numbers[i] < min_value)\n   \
    \     {\n            min_value = numbers[i];\n            min_pos = i;\n     \
    \   }\n    }\n    for(int i = min_pos; i < n; ++i)\n    {\n        result[i -\
    \ min_pos] = min_value;\n        min_value = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    long count = 0;\n    for(int i = 0; i < n; ++i)\n    {\n\
    \        sum += numbers[i];\n        ++count;\n    }\n    for(int i = 0; i < n;\
    \ ++i)\n    {\n        result[i] = sum / count;\n        sum -= numbers[i];\n\
    \        count += 1;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < n; ++i)\n    {\n        sum\
    \ += numbers[i];\n        ++count;\n    }\n    for(int i = 0; i < n; ++i)\n  \
    \  {\n        result[i] = sum / count;\n        sum -= numbers[i];\n        count\
    \ += 1;\n    }\n    long mid = sum / 2;\n\nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9fgzothh.d(111): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9fgzothh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    int\
    \ i = 0;\n    \n    foreach(long number in numbers)\n    {\n        current =\
    \ number;\n        foreach(long number in numbers)\n        {\n            current\
    \ = (current > number) ? current : number;\n        }\n        \n        if(current\
    \ > max)\n        {\n            max = current;\n        }\n        \n       \
    \ result[i] = max;\n        i++;\n    }\n    \n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static int[] rollingMax(int[]\
    \ numbers) {\n    int[] result = new int[numbers.length];\n    int max = 0;\n\
    \    int current = 0;\n    int i = 0;\n    \n    foreach(int number in numbers)\
    \ {\n        current = number;\n        foreach(int number in numbers) {\n   \
    \         current = (current > number) ? current : number;\n        }\n      \
    \  \n        if(current > max) {\n            max = current;\n        }\n    \
    \    \n        result[i] = max;\n        i++;\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| a tags=c#,algorithm |>\n<code>\nusing\
    \ System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\
    using System.Threading.Tasks;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5pwy8x0u.d(17): Error: found `in` when expecting `;`\\n/tmp/tmp5pwy8x0u.d(20):\
    \ Error: found `in` when expecting `;`\\n/tmp/tmp5pwy8x0u.d(36): Error: declaration\
    \ expected, not `<`\\n/tmp/tmp5pwy8x0u.d(46): Error: declaration expected, not\
    \ `foreach`\\n/tmp/tmp5pwy8x0u.d(48): Error: declaration expected, not `foreach`\\\
    n/tmp/tmp5pwy8x0u.d(50): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp5pwy8x0u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = numbers[0];\n    for (int i = 1; i < numbers.length; ++i)\n\
    \    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[max_index];\n\
    \        max_index = (max_index + 1) % numbers.length;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpqbjwxmd5.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285e6]\\n??:? long[] tmpqbjwxmd5.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpqbjwxmd5.__unittest_L30_C1() [0x427fc6]\\n??:? void\
    \ tmpqbjwxmd5.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c613]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430731]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b47d]\\n??:? runModuleUnitTests [0x42c3e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42897f]\\n??:? _d_run_main [0x4288ea]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x47942554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 1, 2, 2, 1]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long minIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    result[minIndex]\
    \ = minValue;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_average(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum / numbers.length;\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2,\
    \ 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long median\
    \ = 0;\n    long middle = numbers.length / 2;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < numbers[middle])\n        {\n         \
    \   result[i] = numbers[i];\n        }\n        else\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu4746h7h.d(104): Error: found `unittest` instead of statement\\\
    n/tmp/tmpu4746h7h.d(113): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu4746h7h.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_value\
    \ = numbers[0];\n    long max_index = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    System.arraycopy(numbers, 0, result, 0, max_index);\n\
    \    System.arraycopy(numbers, max_index, result, max_index + 1, numbers.length\
    \ - max_index);\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long min_value = numbers[0];\n   \
    \ long min_index = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n \
    \       if (numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    System.arraycopy(numbers, 0, result, 0, min_index);\n    System.arraycopy(numbers,\
    \ min_index, result, min_index + 1, numbers.length - min_index);\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    long[] result = new long[numbers.length];\n\
    \    System.arraycopy(numbers, 0, result, 0, numbers.length);\n    System.arraycopy(numbers,\
    \ numbers.length, result, 0, numbers.length - numbers.length);\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long product = 1;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n    }\n    long[] result = new\
    \ long[numbers.length];\n    System.arraycopy(numbers, 0, result, 0, numbers.length);\n\
    \    System.arraycopy(numbers, numbers.length, result, 0, numbers.length - numbers.length);\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling quotient element found until given moment\n    in the sequence.\n  \
    \  >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc3wp7qiq.d(89): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc3wp7qiq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long currentMax = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        max = numbers[i];\n\
    \        currentMax = max;\n        for(; i < numbers.length && numbers[i] >=\
    \ max; i++)\n        {\n            max = numbers[i];\n            currentMax\
    \ = max;\n        }\n        result[i] = currentMax;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkm0_ubm7.d(29): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkm0_ubm7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max_so_far;\n        max_so_far = numbers[i];\n\
    \    }\n    result[max_so_far_index] = max_so_far;\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n  \
    \      min_so_far = numbers[i];\n    }\n    result[min_so_far_index] = min_so_far;\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\ndouble[] rolling_average(double[] numbers) \n{\n    double[] result\
    \ = new double[numbers.length];\n    double sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    double average = sum / numbers.length;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = average;\n\
    \        average = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling median element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_median(double[] numbers)\
    \ \n{\n    double[] result = new double[numbers.length];\n    double sum = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    double average = sum\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcnixtbjx.d(98): Error: semicolon expected, not `unittest`\\n/tmp/tmpcnixtbjx.d(98):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpcnixtbjx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n    while(i\
    \ < numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i;\
    \ j < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n    \
    \        {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsp9p7tyv.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284d5]\\n??:? void tmpsp9p7tyv.__unittest_L31_C1()\
    \ [0x428059]\\n??:? void tmpsp9p7tyv.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b446]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43065d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b41d]\\n??:? runModuleUnitTests [0x42c389]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428998]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42891f]\\n??:? _d_run_main [0x42888a]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0xa34eb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for (int i = 1; i < n; i++) {\n        if (numbers[i] > max) {\n \
    \           max = numbers[i];\n            maxIndex = i;\n        }\n    }\n \
    \   result[maxIndex] = max;\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for (int i = 1; i < n; i++) {\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n            minIndex = i;\n       \
    \ }\n    }\n    result[minIndex] = min;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 4]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    long sum = 0;\n   \
    \ for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n    }\n    result[0]\
    \ = sum;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n \
    \   \n*/\nlong[] rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long product = 1;\n    for (int i = 0;\
    \ i < n; i++) {\n        product *= numbers[i];\n    }\n    result[0] = product;\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling variance element found until given moment\n    in the sequence.\n  \
    \  >>> rolling_variance([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n  \
    \  \n*/\nlong[] rolling_variance(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long product = 1;\n\
    \    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n        product\
    \ *= numbers[i];\n    }\n    double mean = sum / n;\n    double variance = product\
    \ / (n - 1);\n    result[0] = variance;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling standard deviation element \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4oc8yy5j.d(105): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4oc8yy5j.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current < min)\n        {\n            min = current;\n        }\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 5]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        sum += current;\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        current = numbers[i];\n        sum += current;\n    }\n    long\
    \ avg = sum / numbers.length;\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = avg;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling variance element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_var([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 3, 3, 3, 4, 2.25]\n    \n*/\nlong[] rolling_var(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ current = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        sum += current;\n    }\n    long avg = sum / numbers.length;\n\
    \    long variance = 0;\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy98tgja7.d(112): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy98tgja7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    long max_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_value)\n        {\n            result[max_index]\
    \ = numbers[i];\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 2,\
    \ 3, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long min_value = numbers[0];\n    long min_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_value)\n        {\n            min_value = numbers[i];\n            min_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == min_value)\n        {\n            result[min_index]\
    \ = numbers[i];\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 1.6666666666666667,\
    \ 1.6666666666666667, 1.6666666666666667]\n    \n*/\ndouble[] rolling_average(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    double\
    \ sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n        result[i] = sum;\n    }\n    double average = sum / numbers.length;\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 1.5, 1.5, 1.5, \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2fduqx5p.d(106): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2fduqx5p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long\
    \ minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n    long sumIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            sumIndex = i;\n        }\n\
    \    }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long sumIndex = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(sumIndex\
    \ == 0)\n        {\n            sumIndex = i;\n        }\n    }\n    long avg\
    \ = sum / numbers.length;\n    long[] result = new long[numbers.length];\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = avg;\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling variance element found until given moment\n    in the sequence.\n\
    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb8alhdqi.d(108): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb8alhdqi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n        max = numbers[i];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe04ya6i7.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284d5]\\n??:? void tmpe04ya6i7.__unittest_L29_C1()\
    \ [0x428055]\\n??:? void tmpe04ya6i7.__modtest() [0x428254]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b446]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43065d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b41d]\\n??:? runModuleUnitTests [0x42c389]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428998]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42891f]\\n??:? _d_run_main [0x42888a]\\n??:? main [0x428267]\\\
    n??:? __libc_start_main [0x6816d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    result[max_so_far_index] = max_so_far;\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    result[min_so_far_index]\
    \ = min_so_far;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = numbers[0];\n    long sum_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far >= numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == sum_so_far)\n        {\n            result[i]\
    \ = sum_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    result[sum_so_far_index\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb1oufixx.d(104): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpb1oufixx.d(113): Error: found `void` when expecting `,`\\n/tmp/tmpb1oufixx.d(113):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpb1oufixx.d(113): Error: expression\
    \ expected, not `}`\\n/tmp/tmpb1oufixx.d(113): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpb1oufixx.d(113): Error: found `End of File` when expecting\
    \ `]`\\n/tmp/tmpb1oufixx.d(113): Error: found `End of File` when expecting `;`\
    \ following statement\\n/tmp/tmpb1oufixx.d(113): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpb1oufixx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n        result[i]\
    \ = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpmdmv6f1f.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428566]\\n??:? long[] tmpmdmv6f1f.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpmdmv6f1f.__unittest_L24_C1() [0x427f4a]\\n??:? void\
    \ tmpmdmv6f1f.__modtest() [0x428238]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c593]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b426]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43063d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3fd]\\n??:? runModuleUnitTests [0x42c369]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428978]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4288ff]\\n??:? _d_run_main [0x42886a]\\n??:? main [0x42824b]\\\
    n??:? __libc_start_main [0x2fb71554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < n; ++i)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < n; ++i)\n  \
    \  {\n        if(numbers[i] == max_so_far)\n        {\n            result[max_so_far_index]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = max_so_far;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = -1;\n    for(int i = 1; i < n; ++i)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < n; ++i)\n  \
    \  {\n        if(numbers[i] == min_so_far)\n        {\n            result[min_so_far_index]\
    \ = min_so_far;\n        }\n        else\n        {\n            result[i] = min_so_far;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5,\
    \ 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_avg(double[] numbers) \n{\n    int\
    \ n = numbers.length;\n    double[] result = new double[n];\n    double sum =\
    \ 0;\n    for(int i = 0; i < n; ++i)\n    {\n        sum += numbers[i];\n    }\n\
    \    double avg = sum / n;\n    for(int i = 0; i < n; ++i)\n    {\n        result[i]\
    \ = numbers[i] - avg;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n   \
    \ int n = numbers.length;\n    long[] result = new long\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ck2lv6p.d(105): Error: semicolon expected, not `unittest`\\\
    n/tmp/tmp3ck2lv6p.d(105): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ck2lv6p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    long max_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_value)\n        {\n            result[i] = max_value;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpsz5f2l7a.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x42860e]\\n??:? long[] tmpsz5f2l7a.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpsz5f2l7a.__unittest_L36_C1() [0x427ff2]\\n??:? void\
    \ tmpsz5f2l7a.__modtest() [0x4282e0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c63b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430759]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b4a5]\\n??:? runModuleUnitTests [0x42c411]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a20]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4289a7]\\n??:? _d_run_main [0x428912]\\n??:? main [0x4282f3]\\\
    n??:? __libc_start_main [0xb6cb1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long currentMax\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > currentMax)\n        {\n            currentMax = numbers[i];\n        }\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > currentMax)\n        {\n            result[i] = currentMax;\n            currentMax\
    \ = numbers[i];\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long minValue = numbers[0];\n    long currentMin\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n        }\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            result[i] = currentMin;\n            currentMin\
    \ = numbers[i];\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > currentSum)\n\
    \        {\n            currentSum = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > currentSum)\n\
    \        {\n            result[i] = currentSum;\n            currentSum = numbers[i];\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n \
    \   \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ew2a8pk.d(116): Error: expression expected, not `unittest`\\\
    n/tmp/tmp3ew2a8pk.d(117): Error: found `{` when expecting `]`\\n/tmp/tmp3ew2a8pk.d(118):\
    \ Error: semicolon expected, not `alias`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp3ew2a8pk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = 0; i < n - 1; i++)\n   \
    \ {\n        result[i] = max(result[i], result[i + 1]);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf8ms6fzx.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpf8ms6fzx.d(20): Error: undefined identifier\
    \ `max`, did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpf8ms6fzx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n  \
    \  for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] + numbers[i\
    \ + 1];\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * numbers[i + 1];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling quotient element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] / numbers[i\
    \ + 1];\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvprteqk_.d(104): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvprteqk_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n            max = numbers[i];\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpogqapwiy.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428565]\\n??:? void tmpogqapwiy.__unittest_L39_C1()\
    \ [0x4280e5]\\n??:? void tmpogqapwiy.__modtest() [0x4282e4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c643]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4d6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b4ad]\\n??:? runModuleUnitTests [0x42c419]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a28]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4289af]\\n??:? _d_run_main [0x42891a]\\n??:? main [0x4282f7]\\\
    n??:? __libc_start_main [0x82863554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long currentMax = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n            maxIndex = i;\n     \
    \   }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n    long minIndex\
    \ = 0;\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long count = 0;\n    long currentSum =\
    \ 0;\n    long currentCount = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        count++;\n    }\n    long average\
    \ = sum / count;\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - average;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n  \
    \  \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[(int)\
    \ (i + 0.5f)];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling variance element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_variance([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3,\
    \ 3, 3, 4, 4]\n    \n*/\nlong[] rolling_variance(long[] \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp25b41nkk.d(95): Error: C style cast illegal, use `cast(int)(i\
    \ + 0.5F)`\\n/tmp/tmp25b41nkk.d(107): Error: found `unittest` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp25b41nkk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[max_index]\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 3,\
    \ 4, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n\
    \    long min_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[min_index]\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3,\
    \ 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum\
    \ = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        sum += numbers[i];\n        count++;\n    }\n    long avg = sum /\
    \ count;\n    long[] result = new long[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n   \
    \ \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long sum = 0;\n    long\
    \ count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n    long\
    \ median = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < avg)\n        {\n            median = numbers[i];\n            break;\n  \
    \      }\n    }\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - median;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling standard devi\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbxg8m297.d(112): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbxg8m297.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n    while(i\
    \ < numbers.length)\n    {\n        if(numbers[i] > max)\n        {\n        \
    \    max = numbers[i];\n        }\n        i++;\n    }\n    \n    for(i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max;\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp22k1abz7.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284a5]\\n??:? void tmp22k1abz7.__unittest_L32_C1()\
    \ [0x428029]\\n??:? void tmp22k1abz7.__modtest() [0x428228]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c583]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b416]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306a1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b50]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43062d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3ed]\\n??:? runModuleUnitTests [0x42c359]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428968]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4288ef]\\n??:? _d_run_main [0x42885a]\\n??:? main [0x42823b]\\\
    n??:? __libc_start_main [0xc6022554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if(current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long current = 0;\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        current =\
    \ numbers[i];\n        if(current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given list of integers, generate a list of rolling sum of element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long sum = 0;\n    long current\
    \ = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        sum += current;\n        result[i] = sum;\n    }\n  \
    \  return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ product of element found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 240, 240]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = 1;\n    long current = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        current = numbers[i];\n        product *= current;\n        result[i]\
    \ = product;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling quotient of element found until given moment\n  \
    \  in the sequence.\n    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n \
    \   long[] result = new long[numbers.length];\n    long quotient = 1;\n    long\
    \ current = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n  \
    \      current = numbers[i];\n        quotient /= current;\n\nunittest\n{\n  \
    \  alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp367u63b5.d(111): Error: found `unittest` instead of statement\\\
    n/tmp/tmp367u63b5.d(120): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp367u63b5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long minIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    result[minIndex]\
    \ = minValue;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[]\
    \ rolling_average(double[] numbers) \n{\n    double[] result = new double[numbers.length];\n\
    \    double sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n   \
    \     sum += numbers[i];\n        result[i] = sum / numbers.length;\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[] result\
    \ = new double[numbers.length];\n    double sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    Arrays.sort(result);\n    return result;\n}\n/*\n From a given list\
    \ of \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp900vqcyo.d(104): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp900vqcyo.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[i] = max;\n        }\n        else\n \
    \       {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmsuge90m.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428535]\\n??:? void tmpmsuge90m.__unittest_L36_C1()\
    \ [0x428152]\\n??:? void tmpmsuge90m.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c613]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4a6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430731]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b47d]\\n??:? runModuleUnitTests [0x42c3e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42897f]\\n??:? _d_run_main [0x4288ea]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd1f1c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long\
    \ minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n    long sumIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            sum = numbers[i];\n       \
    \     sumIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n{\n    double sum\
    \ = 0;\n    double sumIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n   \
    \         sum = numbers[i];\n            sumIndex = i;\n        }\n    }\n   \
    \ double average = sum / numbers.length;\n    double[] result = new double[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = average;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median \nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeo7gtg12.d(110): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeo7gtg12.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_so_far = max;\n    long max_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n            max_so_far = max;\n            max_so_far_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n  \
    \      if(max_so_far_index == i)\n        {\n            result[i] = max_so_far;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_so_far = min;\n    long min_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            min_so_far = min;\n            min_so_far_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n  \
    \      if(min_so_far_index == i)\n        {\n            result[i] = min_so_far;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n  \
    \  long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(sum_so_far_index\
    \ == i)\n        {\n            sum_so_far = sum;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n        if(sum_so_far_index == i)\n \
    \       {\n            result[i] = sum_so_far;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 6]\n    \n*/\nlong[] rolling_product(long\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjio0gko3.d(106): Error: found `unittest` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjio0gko3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    for(int i = numbers.length - 1; i > max_so_far_index; i--)\n\
    \    {\n        result[i] = numbers[i - 1];\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    for(int i\
    \ = numbers.length - 1; i > min_so_far_index; i--)\n    {\n        result[i] =\
    \ numbers[i - 1];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum_so_far = 0;\n    long sum_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far\
    \ += numbers[i];\n        if(sum_so_far >= numbers[i])\n        {\n          \
    \  sum_so_far = numbers[i];\n            sum_so_far_index = i;\n        }\n  \
    \  }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == sum_so_far)\n        {\n            result\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdwny8mw1.d(103): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpdwny8mw1.d(112): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmpdwny8mw1.d(112): Error: found `End\
    \ of File` when expecting `}` following compound statement\\n/tmp/tmpdwny8mw1.d(112):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdwny8mw1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index] = max_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[max_so_far_index] = numbers[i];\n        }\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpstbkjdyt.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x42860e]\\n??:? long[] tmpstbkjdyt.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpstbkjdyt.__unittest_L33_C1() [0x427fee]\\n??:? void\
    \ tmpstbkjdyt.__modtest() [0x4282dc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c63b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430759]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b4a5]\\n??:? runModuleUnitTests [0x42c411]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a20]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4289a7]\\n??:? _d_run_main [0x428912]\\n??:? main [0x4282ef]\\\
    n??:? __libc_start_main [0x46699554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[0] = maxValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n            result[i]\
    \ = maxValue;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmps8parhl6.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x42862e]\\n??:? long[] tmps8parhl6.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmps8parhl6.__unittest_L37_C1() [0x428012]\\n??:? void\
    \ tmps8parhl6.__modtest() [0x428300]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c65b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4ee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430779]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430705]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b4c5]\\n??:? runModuleUnitTests [0x42c431]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a40]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4289c7]\\n??:? _d_run_main [0x428932]\\n??:? main [0x428313]\\\
    n??:? __libc_start_main [0xad56f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long current = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        current = numbers[i];\n        if\
    \ (current > max) {\n            max = current;\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min = 0;\n    long current = 0;\n    for (int\
    \ i = 0; i < n; i++) {\n        current = numbers[i];\n        if (current < min)\
    \ {\n            min = current;\n        }\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    long sum = 0;\n    long current = 0;\n    for (int i = 0;\
    \ i < n; i++) {\n        current = numbers[i];\n        sum += current;\n    \
    \    result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling product element found until given moment\n\
    \    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 6, 12, 24, 48, 96]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    long product\
    \ = 1;\n    long current = 0;\n    for (int i = 0; i < n; i++) {\n        current\
    \ = numbers[i];\n        product *= current;\n        result[i] = product;\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 1, 2, 1, 2, 1]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long quotient = 1;\n    long current =\
    \ 0;\n    for (int i = 0; i < n; i++) {\n        current = numbers[i];\n     \
    \   quotient /= current;\n        result[i] = quotient;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling remainder element\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqdvk56iz.d(107): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqdvk56iz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \       max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[max_pos +\
    \ i] = numbers[i];\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work. `rolling_max` returns `[3, 3, 3, 3,\
    \ 3, 3, 3]` when given `[3, 3, 3, 3, 3, 4, 2]`.\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I used the code from your question and added the rolling_max function.\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I used the code from your question\
    \ and added the rolling_max function.\n<|/ c |>\n<| c |>\nI tested it again and\
    \ it works. I used the code from your question and added the rolling_max function.\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I used the code from your question\
    \ and added the rolling_max function.\n<|/ c |>\n<| a tags=c#,algorithm,arrays\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_kosfxl5.d(29): Error: declaration expected, not `<`\\n/tmp/tmp_kosfxl5.d(32):\
    \ Error: unterminated character constant\\n/tmp/tmp_kosfxl5.d(49): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmp_kosfxl5.d(49): Error: no identifier for declarator\
    \ `.Collections.Generic`\\n/tmp/tmp_kosfxl5.d(50): Error: semicolon expected,\
    \ not `.`\\n/tmp/tmp_kosfxl5.d(50): Error: no identifier for declarator `.Linq`\\\
    n/tmp/tmp_kosfxl5.d(51): Error: semicolon expected, not `.`\\n/tmp/tmp_kosfxl5.d(51):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmp_kosfxl5.d(52): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmp_kosfxl5.d(52): Error: no identifier for\
    \ declarator `.Threading.Tasks`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_kosfxl5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \        if(max_index != i)\n        {\n            result[max_index] = max;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \        if(min_index != i)\n        {\n            result[min_index] = min;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n\
    \    \n*/\ndouble[] rolling_avg(double[] numbers) \n{\n    double[] result = new\
    \ double[numbers.length];\n    double sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   double avg = sum / numbers.length;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling standard deviation element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_std([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_std(double[]\
    \ numbers) \n{\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvukkwrw6.d(109): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvukkwrw6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for (int i = 1; i < n; i++)\n    {\n        if (numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    long min =\
    \ numbers[0];\n    long minIndex = 0;\n    for (int i = 1; i < n; i++)\n    {\n\
    \        if (numbers[i] < min)\n        {\n            min = numbers[i];\n   \
    \         minIndex = i;\n        }\n    }\n    result[minIndex] = min;\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_average(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum / n;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling variance element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_variance([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 1, 2, 1, 2, 1]\n    \n*/\nlong[] rolling_variance(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum / n;\n    }\n    long mean = sum / n;\n    for (int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = result[i] - mean;\n    }\n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnl9xl01a.d(112): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnl9xl01a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long maxValue = numbers[0];\n    long currentMaxValue\
    \ = maxValue;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] >\
    \ currentMaxValue)\n        {\n            currentMaxValue = numbers[i];\n   \
    \     }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        if(numbers[i] >\
    \ currentMaxValue)\n        {\n            result[i] = currentMaxValue;\n    \
    \    }\n        else\n        {\n            result[i] = numbers[i];\n       \
    \ }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long minValue = numbers[0];\n    long currentMinValue\
    \ = minValue;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] <\
    \ currentMinValue)\n        {\n            currentMinValue = numbers[i];\n   \
    \     }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        if(numbers[i] <\
    \ currentMinValue)\n        {\n            result[i] = currentMinValue;\n    \
    \    }\n        else\n        {\n            result[i] = numbers[i];\n       \
    \ }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long sum = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n    }\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        currentSum = sum;\n        sum = sum - numbers[i];\n\
    \        result[i] = currentSum;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling product element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    long product\
    \ = 1;\n    long currentProduct = 1;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        product *= numbers[i];\n    }\n    for(int i = 0; i < n; i++)\n    {\n\
    \        currentProduct = product;\n        product = product * numbers[i];\n\
    \        result[i] = currentProduct\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp93xjc3x8.d(116): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp93xjc3x8.d(125): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp93xjc3x8.d(125): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93xjc3x8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n    long minIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ + numbers[i+1];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n\
    {\n    double[] result = new double[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] + numbers[i+1];\n    }\n    double\
    \ sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum +=\
    \ result[i];\n    }\n    double average = sum / numbers.length;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = average - result[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[]\
    \ result = new double[\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyub_v8__.d(107): Error: expression expected, not `unittest`\\\
    n/tmp/tmpyub_v8__.d(108): Error: found `{` when expecting `]`\\n/tmp/tmpyub_v8__.d(109):\
    \ Error: semicolon expected, not `alias`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpyub_v8__.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[0] = maxValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n            result[i]\
    \ = maxValue;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays\
    \ |>\n<| a dscore=0 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cvhq_ma.d(37): Error: declaration expected, not `<`\\n/tmp/tmp5cvhq_ma.d(42):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmp5cvhq_ma.d(42): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmp5cvhq_ma.d(43): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmp5cvhq_ma.d(43): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmp5cvhq_ma.d(44): Error: semicolon expected, not `.`\\n/tmp/tmp5cvhq_ma.d(44):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmp5cvhq_ma.d(45): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmp5cvhq_ma.d(45): Error: no identifier for\
    \ declarator `.Threading.Tasks`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5cvhq_ma.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for (int i = 0; i < n; ++i) {\n        max = numbers[i];\n        maxIndex\
    \ = i;\n        for (int j = i + 1; j < n; ++j) {\n            if (numbers[j]\
    \ > max) {\n                max = numbers[j];\n                maxIndex = j;\n\
    \            }\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    long minIndex = 0;\n    for (int i = 0; i < n; ++i) {\n\
    \        min = numbers[i];\n        minIndex = i;\n        for (int j = i + 1;\
    \ j < n; ++j) {\n            if (numbers[j] < min) {\n                min = numbers[j];\n\
    \                minIndex = j;\n            }\n        }\n        result[i] =\
    \ min;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long sum = 0;\n    long sumIndex = 0;\n    for (int\
    \ i = 0; i < n; ++i) {\n        sum = numbers[i];\n        sumIndex = i;\n   \
    \     for (int j = i + 1; j < n; ++j) {\n            sum += numbers[j];\n    \
    \        sumIndex += j;\n        }\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_avg([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    long sumIndex = 0;\n    for (int i = 0; i < n; ++i) {\n\
    \        sum = numbers[i];\n        sumIndex = i;\n        for (int j = i + 1;\
    \ j < n; ++j) {\n            sum += numbers[j];\n            sumIndex += j;\n\
    \        }\n        result[i] = sum / sumIndex;\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling median element\
    \ found until given moment\n\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn4kp00ck.d(103): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn4kp00ck.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = maxIndex; i < numbers.length; i++)\n    {\n      \
    \  result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long minIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n            minIndex = i;\n       \
    \ }\n    }\n    for(int i = minIndex; i < numbers.length; i++)\n    {\n      \
    \  result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_avg(double[] numbers) \n\
    {\n    double[] result = new double[numbers.length];\n    double sum = 0;\n  \
    \  double avg = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n    }\n    avg = sum / numbers.length;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] + avg;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[]\
    \ result = new double[numbers.length];\n    double sum = 0;\n    double avg =\
    \ 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    avg = sum / numbers.length;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] + avg;\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n/*\n From a given list of integers, generate a list of\
    \ rolling standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> rolling_std([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3wuhz72r.d(102): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3wuhz72r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = 0;\n    long max_so_far_index = 0;\n    long max_so_far_times = 0;\n    long\
    \ max_so_far_times_index = 0;\n    \n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        max_so_far = max(max_so_far, numbers[i]);\n        max_so_far_index\
    \ = i;\n        max_so_far_times = 1;\n        max_so_far_times_index = i;\n \
    \       \n        for (int j = i + 1; j < numbers.length; j++)\n        {\n  \
    \          if (numbers[j] > max_so_far)\n            {\n                max_so_far\
    \ = numbers[j];\n                max_so_far_index = j;\n                max_so_far_times\
    \ = 1;\n                max_so_far_times_index = j;\n            }\n         \
    \   else\n            {\n                max_so_far_times = max_so_far_times +\
    \ 1;\n                if (max_so_far_times == max_so_far_times_index)\n      \
    \          {\n                    max_so_far_times = 1;\n                    max_so_far_times_index\
    \ = j;\n                }\n            }\n        }\n    }\n    \n    long[] result\
    \ = new long[numbers.length];\n    \n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = max_so_far;\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbz92fz3e.d(19): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbz92fz3e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = numbers[0];\n    long max_index\
    \ = 0;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            max_index = i;\n      \
    \  }\n    }\n    result[max_index] = max;\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpogndxqu7.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpogndxqu7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    result[maxIndex] = max;\n    for (int i = maxIndex + 1; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i - 1];\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| c |>\nI believe this algorithm is O(n^2)\
    \ because of the nested loops. I believe this can be done in O(n) by using a stack\
    \ and a while loop. I'll post an answer with my solution if I manage to implement\
    \ it.\n<|/ c |>\n<| c |>\nYes, it can be done in O(n) by using a stack and a while\
    \ loop. I'll post an answer with my solution if I manage to implement it.\n<|/\
    \ c |>\n<| c |>\nI believe this algorithm is O(n^2) because of the nested loops.\
    \ I believe this can be done in O(n) by using a stack and a while loop. I'll post\
    \ an answer with my solution if I manage to implement it.\n<|/ c |>\n<| c |>\n\
    I believe this algorithm is O(n^2) because of the nested loops. I believe this\
    \ can be done in O(n) by using a stack and a while loop. I'll post an answer with\
    \ my solution if I manage to implement it.\n<|/ c |>\n<| a dscore=0 |>\nI believe\
    \ this can be done in O(n) by using a stack and a while loop. I'll post an answer\
    \ with my solution if I manage to implement it.\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3s8qjv6d.d(30): Error: declaration expected, not `<`\\n/tmp/tmp3s8qjv6d.d(33):\
    \ Error: unterminated character constant\\n/tmp/tmp3s8qjv6d.d(36): Error: unterminated\
    \ character constant\\n/tmp/tmp3s8qjv6d.d(39): Error: unterminated character constant\\\
    n/tmp/tmp3s8qjv6d.d(42): Error: unterminated character constant\\n/tmp/tmp3s8qjv6d.d(45):\
    \ Error: unterminated character constant\\n/tmp/tmp3s8qjv6d.d(48): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmp3s8qjv6d.d(48): Error: no identifier for declarator\
    \ `.Collections.Generic`\\n/tmp/tmp3s8qjv6d.d(49): Error: semicolon expected,\
    \ not `.`\\n/tmp/tmp3s8qjv6d.d(49): Error: no identifier for declarator `.Linq`\\\
    n/tmp/tmp3s8qjv6d.d(50): Error: semicolon expected, not `.`\\n/tmp/tmp3s8qjv6d.d(50):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmp3s8qjv6d.d(51): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmp3s8qjv6d.d(51): Error: no identifier for\
    \ declarator `.Threading.Tasks`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3s8qjv6d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = numbers[0];\n    long maxIndex\
    \ = -1;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = n - 1; i >= 0; i--)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[maxIndex] = numbers[i];\n            max\
    \ = numbers[i];\n            maxIndex = i;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = numbers[0];\n    long minIndex = -1;\n    for(int i = 1; i < n;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = n - 1; i >= 0; i--)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = numbers[i];\n            min = numbers[i];\n            minIndex = i;\n  \
    \      }\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 5]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long sum = 0;\n    for(int i = 0; i < n; i++)\n \
    \   {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling average\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_avg([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\ndouble[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    double[] result = new double[n];\n\
    \    double sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum / n;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling median element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\ndouble[] rolling_median(long[] \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1bvysjtl.d(113): Error: found `unittest` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bvysjtl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long i = 0;\n    long j\
    \ = 0;\n    while(i < numbers.length)\n    {\n        max = Math.max(max, numbers[i]);\n\
    \        i++;\n    }\n    while(j < numbers.length)\n    {\n        if(numbers[j]\
    \ > max)\n        {\n            result[j] = max;\n            max = numbers[j];\n\
    \            j++;\n        }\n        else\n        {\n            result[j] =\
    \ numbers[j];\n            j++;\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    while(i < numbers.length)\n    {\n        min =\
    \ Math.min(min, numbers[i]);\n        i++;\n    }\n    while(j < numbers.length)\n\
    \    {\n        if(numbers[j] < min)\n        {\n            result[j] = min;\n\
    \            min = numbers[j];\n            j++;\n        }\n        else\n  \
    \      {\n            result[j] = numbers[j];\n            j++;\n        }\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long i = 0;\n    long j = 0;\n    while(i < numbers.length)\n\
    \    {\n        sum += numbers[i];\n        i++;\n    }\n    while(j < numbers.length)\n\
    \    {\n        result[j] = sum;\n        sum += numbers[j];\n        j++;\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n{\n    double[]\
    \ result = new double[numbers.length];\n    double sum = 0;\n    double i = 0;\n\
    \    double j = 0;\n    while(i < numbers.length)\n    {\n        sum += numbers[i];\n\
    \        i++;\n    }\n    while(j < numbers.length)\n    {\n        result[j]\
    \ = sum/numbers.length;\n        \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47fibqi1.d(119): Error: found `unittest` instead of statement\\\
    n/tmp/tmp47fibqi1.d(128): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47fibqi1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long currentMax = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n            maxIndex = i;\n     \
    \   }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            result[i] = currentMax;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    for(int i = maxIndex;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    long currentMin\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n           \
    \ minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < currentMin)\n\
    \        {\n            result[i] = currentMin;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    for(int i\
    \ = minIndex; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ + numbers[i+1];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling product element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6,\
    \ 24, 120, 240, 720]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * numbers[i+1];\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of roll\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe5bhahyd.d(111): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe5bhahyd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n    foreach(long\
    \ n in numbers)\n    {\n        if(n > max)\n        {\n            max = n;\n\
    \        }\n        result[i++] = max;\n    }\n    \n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't seem to work. `rolling_max` returns `[3, 3, 3,\
    \ 3, 3, 3, 3]` for `rolling_max([1, 2, 3, 2, 3, 4, 2])`.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I added the code I used and tested it.\n<|/ c |>\n<|\
    \ c |>\nI tested it and it works. I added the code I used and tested it.\n<|/\
    \ c |>\n<| c |>\nI tested it and it works. I added the code I used and tested\
    \ it.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the code I used and\
    \ tested it.\n<|/ c |>\n<| a tags=c#,algorithm |>\nI came up with this solution:\n\
    <code>\npublic static IEnumerable<T> RollingMax<T>(this IEnumerable<T> source)\n\
    {\n    var max = new T();\n    var currentMax = max;\n    foreach (var item in\
    \ source)\n    {\n        if (item > currentMax)\n        {\n            currentMax\
    \ = item;\n        }\n        yield return currentMax;\n    }\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=c#,algorithm |>\n<code>\npublic static IEnumerable<T>\
    \ RollingMax<T>(this IEnumerable<T> source)\n{\n    var max = new T();\n    var\
    \ currentMax = max;\n    foreach (var item in source)\n    {\n        if (item\
    \ > currentMax)\n        {\n            currentMax = item;\n        }\n      \
    \  yield return currentMax;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>\npublic static IEnumerable<T> RollingMax<T>(this IEnumerable<T> source)\n\
    {\n    var max = new T();\n    var currentMax = max;\n    foreach (var item in\
    \ source)\n    {\n        if (item > currentMax)\n        {\n            currentMax\
    \ = item;\n        }\n        yield return currentMax;\n    }\n}\n</code>\n<|/\
    \ a tags=c#,algorithm |>\n<| a dscore=1 |>\n<code>\npublic static IEnumerable<T>\
    \ RollingMax<T>(this IEnumerable<T> source)\n{\n    var max = new \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpayeycz15.d(16): Error: found `in` when expecting `;`\\n/tmp/tmpayeycz15.d(27):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpayeycz15.d(30): Error: unterminated\
    \ character constant\\n/tmp/tmpayeycz15.d(51): Error: declaration expected, not\
    \ `foreach`\\n/tmp/tmpayeycz15.d(56): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpayeycz15.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    long currentMax = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n            maxIndex = i;\n     \
    \   }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n    long minIndex\
    \ = 0;\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long sumIndex = 0;\n    long currentSum\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        sumIndex++;\n    }\n    long currentSum = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        currentSum += numbers[i];\n    }\n    long\
    \ currentSumIndex = 0;\n    long currentSum = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < currentSum)\n     \
    \   {\n            currentSum = numbers[i];\n            currentSumIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[sumIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long sum = 0;\n\
    \    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpizc8995b.d(107): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpizc8995b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n \
    \   [1, 2, 2, 1, 2, 1, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long min = numbers[0];\n    long minIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[minIndex] = min;\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum\
    \ = 0;\n    long sumIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n   \
    \         sum = numbers[i];\n            sumIndex = i;\n        }\n        else\n\
    \        {\n            if(sum > numbers[sumIndex])\n            {\n         \
    \       sum = numbers[sumIndex];\n                sumIndex = i;\n            }\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n  \
    \  }\n    result[sumIndex] = sum;\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_average(long[] numbers)\
    \ \n{\n    long sum = 0;\n    long sumIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sumIndex == 0)\n       \
    \ {\n            sum = numbers[i];\n            sumIndex = i;\n        }\n   \
    \     else\n        {\n\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxlk76hz8.d(115): Error: found `unittest` instead of statement\\\
    n/tmp/tmpxlk76hz8.d(124): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpxlk76hz8.d(124): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxlk76hz8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max_value = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmp_h_6c67w.d(14): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285a6]\\n??:? long[] tmp_h_6c67w.rolling_max(long[])\
    \ [0x427e69]\\n??:? void tmp_h_6c67w.__unittest_L32_C1() [0x427f86]\\n??:? void\
    \ tmp_h_6c67w.__modtest() [0x428274]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b466]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43067d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b43d]\\n??:? runModuleUnitTests [0x42c3a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42893f]\\n??:? _d_run_main [0x4288aa]\\n??:? main [0x428287]\\\
    n??:? __libc_start_main [0xce6ed554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpt7cr928e.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285ae]\\n??:? long[] tmpt7cr928e.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpt7cr928e.__unittest_L29_C1() [0x427f8e]\\n??:? void\
    \ tmpt7cr928e.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5db]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b46e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430685]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b445]\\n??:? runModuleUnitTests [0x42c3b1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428947]\\n??:? _d_run_main [0x4288b2]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xcbd12554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_pos = 0;\n    long max_so_far_neg = 0;\n\
    \    long max_so_far_neg2 = 0;\n    long max_so_far_neg3 = 0;\n    long max_so_far_neg4\
    \ = 0;\n    long max_so_far_neg5 = 0;\n    long max_so_far_neg6 = 0;\n    long\
    \ max_so_far_neg7 = 0;\n    long max_so_far_neg8 = 0;\n    long max_so_far_neg9\
    \ = 0;\n    long max_so_far_neg10 = 0;\n    long max_so_far_neg11 = 0;\n    long\
    \ max_so_far_neg12 = 0;\n    long max_so_far_neg13 = 0;\n    long max_so_far_neg14\
    \ = 0;\n    long max_so_far_neg15 = 0;\n    long max_so_far_neg16 = 0;\n    long\
    \ max_so_far_neg17 = 0;\n    long max_so_far_neg18 = 0;\n    long max_so_far_neg19\
    \ = 0;\n    long max_so_far_neg20 = 0;\n    long max_so_far_neg21 = 0;\n    long\
    \ max_so_far_neg22 = 0;\n    long max_so_far_neg23 = 0;\n    long max_so_far_neg24\
    \ = 0;\n    long max_so_far_neg25 = 0;\n    long max_so_far_neg26 = 0;\n    long\
    \ max_so_far_neg27 = 0;\n    long max_so_far_neg28 = 0;\n    long max_so_far_neg29\
    \ = 0;\n    long max_so_far_neg30 = 0;\n    long max_so_far_neg31 = 0;\n    long\
    \ max_so_far_neg32 = 0;\n    long max_so_far_neg33 = 0;\n    long max_so_far_neg34\
    \ = 0;\n    long max_so_far_neg35 = 0;\n    long max_so_far_neg36 = 0;\n    long\
    \ max_so_far_neg37 = 0;\n    long max_so_far_neg38 = 0;\n    long max_so_far_neg39\
    \ = 0;\n    long max_so_far_neg40 = 0;\n    long max_so_far_neg41 = 0;\n    long\
    \ max_so_far_neg42 = 0;\n    long max_so_far_neg43 = 0;\n    long max_so_far_neg44\
    \ = 0;\n    long max_so_far_neg45 = 0;\n    long max_so_far_neg46 = 0;\n    long\
    \ max_so_far_neg47 = 0;\n    long max_so_far_neg48 = 0;\n    long max_so_far_neg49\
    \ = 0;\n    long max_so_far_\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq9pp97fo.d(64): Error: semicolon expected, not `unittest`\\n/tmp/tmpq9pp97fo.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpq9pp97fo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = -1;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \         max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    result[max_index] = max;\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis code doesn't work. Try it with a list of length 1.\n<|/ c\
    \ |>\n<| c |>\nIt does work. Try it with a list of length 1.\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with a list of length 1.\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with a list of length 1.\n<|/ c |>\n<| c |>\nIt does work. Try it with\
    \ a list of length 1.\n<|/ c |>\n<| a tags=algorithm,c#,arrays |>\n<code>\npublic\
    \ static int[] GetMax(int[] numbers)\n{\n    int max = numbers[0];\n    int max_index\
    \ = -1;\n    for (int i = 1; i < numbers.Length; i++)\n    {\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            max_index = i;\n\
    \        }\n    }\n    int[] result = new int[numbers.Length];\n    result[max_index]\
    \ = max;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code\
    \ doesn't work. Try it with a list of length 1.\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with a list of length 1.\n<|/ c |>\n<| c |>\nIt does work. Try it with\
    \ a list of length 1.\n<|/ c |>\n<| a |>\n<code>\npublic static int[] GetMax(int[]\
    \ numbers)\n{\n    int max = numbers[0];\n    int max_index = -1;\n    for (int\
    \ i = 1; i < numbers.Length; i++)\n    {\n        if (numbers[i] > max)\n    \
    \    {\n            max = numbers[i];\n            max_index = i;\n        }\n\
    \    }\n    int[] result = new int[numbers.Length];\n    result[max_index] = max;\n\
    \    return result;\n}\n</code>\n<|/ a tags=algorithm,c#,arrays dscore=2 |>\n\
    <| c |>\nThis code doesn't work. Try it with a list of length 1.\n<|/ c |>\n<|\
    \ c |>\nIt does work. Try it with a list of length 1.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it with a list of length 1.\n<|/ c |>\n\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpscy5xbka.d(26): Error: declaration expected, not `<`\\n/tmp/tmpscy5xbka.d(29):\
    \ Error: unterminated character constant\\n/tmp/tmpscy5xbka.d(35): Error: unterminated\
    \ character constant\\n/tmp/tmpscy5xbka.d(49): Error: declaration expected, not\
    \ `for`\\n/tmp/tmpscy5xbka.d(49): Error: no identifier for declarator `i`\\n/tmp/tmpscy5xbka.d(49):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpscy5xbka.d(49): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpscy5xbka.d(49): Error: declaration expected, not\
    \ `++`\\n/tmp/tmpscy5xbka.d(54): Error: no identifier for declarator `max_index`\\\
    n/tmp/tmpscy5xbka.d(54): Error: declaration expected, not `=`\\n/tmp/tmpscy5xbka.d(55):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpscy5xbka.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        if (numbers[i] > max) {\n        \
    \    max = numbers[i];\n            maxIndex = i;\n        }\n    }\n    result[maxIndex]\
    \ = max;\n    for (int i = maxIndex + 1; i < n; i++) {\n        result[i] = numbers[i\
    \ - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe8b16ak7.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe8b16ak7.d(23): Error: cannot implicitly\
    \ convert expression `maxIndex + 1L` of type `long` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe8b16ak7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long sum = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        sum += numbers[i];\n        if (sum > max)\
    \ {\n            max = sum;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n   \
    \     sum += numbers[i];\n        if (sum < min) {\n            min = sum;\n \
    \       }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n\
    \    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n  \
    \      result[i] = sum / n;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ sum = 0;\n    long max = 0;\n    for (int i = 0; i < n; i++) {\n        sum\
    \ += numbers[i];\n        if (sum > max) {\n            max = sum;\n        }\n\
    \        result[i] = sum / n;\n    }\n    return result;\n}\n/*\n From a given\
    \ list of integers, generate a list of rolling standard deviation element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_std([1, 2, 3, 2, 3,\
    \ 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_std(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    long max = 0;\n    for (int i = 0; i < n; i++) {\n   \
    \     sum += numbers[i];\n        if (sum > max) {\n            max = sum;\n \
    \       }\n        result[i] = Math.sqrt(sum / n);\n    }\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwbfocapk.d(107): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwbfocapk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\npublic\
    \ static void main(String[] args) {\n    int[] arr = new int[]{1,2,3,4,5,6,7,8,9,10};\n\
    \    System.out.println(Arrays.toString(rolling_max(arr)));\n}\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpihzv66hv.d(29): Error: declaration expected, not `<`\\n/tmp/tmpihzv66hv.d(35):\
    \ Error: identifier expected following `.` instead of `out`\\n/tmp/tmpihzv66hv.d(35):\
    \ Error: no identifier for declarator `System`\\n/tmp/tmpihzv66hv.d(35): Error:\
    \ declaration expected, not `out`\\n/tmp/tmpihzv66hv.d(36): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpihzv66hv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    \n    for(int i = n - 1; i >= 0;\
    \ i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(result[j]\
    \ > result[i])\n            {\n                result[i] = result[j];\n      \
    \      }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5grn067l.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp5grn067l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[maxIndex] = numbers[i];\n        }\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sum > 0)\n        {\n            result[sumIndex] = sum;\n       \
    \     sum = 0;\n            sumIndex++;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[]\
    \ rolling_average(double[] numbers) \n{\n    double[] result = new double[numbers.length];\n\
    \    double sum = 0;\n    double sumIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > 0)\n        {\n  \
    \          result[sumIndex] = sum;\n            sum = 0;\n            sumIndex++;\n\
    \        }\n    }\n    double average = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        average += numbers[i];\n    }\n    average /= numbers.length;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo0ssawvk.d(115): Error: found `unittest` instead of statement\\\
    n/tmp/tmpo0ssawvk.d(124): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo0ssawvk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int len = numbers.length;\n\
    \    long[] result = new long[len];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = -1;\n    for(int i = 1; i < len; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < len; i++)\n    {\n        if(maxIndex\
    \ == i)\n            result[i] = maxValue;\n        else\n            result[i]\
    \ = numbers[maxIndex];\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 3, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int len =\
    \ numbers.length;\n    long[] result = new long[len];\n    long minValue = numbers[0];\n\
    \    long minIndex = -1;\n    for(int i = 1; i < len; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < len; i++)\n    {\n        if(minIndex\
    \ == i)\n            result[i] = minValue;\n        else\n            result[i]\
    \ = numbers[minIndex];\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int len\
    \ = numbers.length;\n    long[] result = new long[len];\n    long sum = 0;\n \
    \   for(int i = 0; i < len; i++)\n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n \
    \   \n*/\nlong[] rolling_product(long[] numbers) \n{\n    int len = numbers.length;\n\
    \    long[] result = new long[len];\n    long product = 1;\n    for(int i = 0;\
    \ i < len; i++)\n    {\n        product *= numbers[i];\n        result[i] = product;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n\
    \    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    int len = numbers.length;\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvqiz3xjg.d(111): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvqiz3xjg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex =\
    \ 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        result[i] = result[i - 1];\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 1, 2, 1, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long minIndex = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[minIndex] = min;\n  \
    \  for (int i = 1; i < numbers.length; i++)\n    {\n        result[i] = result[i\
    \ - 1];\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n\
    \    \n*/\ndouble[] rolling_avg(double[] numbers) \n{\n    double[] result = new\
    \ double[numbers.length];\n    double sum = 0;\n    double avg = 0;\n    double\
    \ avgIndex = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n       \
    \ sum += numbers[i];\n    }\n    avg = sum / numbers.length;\n    for (int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - avg;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n\
    \    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[] result\
    \ = new double[numbers.length];\n    double sum = 0;\n    double avg = 0;\n  \
    \  double avgIndex = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    avg = sum / numbers.length;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - avg;\n\
    \    }\n    Arrays.sort(result);\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling standard deviation element found until\
    \ given moment\n    in the sequence.\n    >>> \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq2w6z4re.d(106): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq2w6z4re.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < n; ++i)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index] = max_so_far;\n\
    \    for(int i = max_so_far_index + 1; i < n; ++i)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            result[i - 1] = numbers[i];\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < n; ++i)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n            min_so_far_index\
    \ = i;\n        }\n    }\n    result[min_so_far_index] = min_so_far;\n    for(int\
    \ i = min_so_far_index + 1; i < n; ++i)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            result[i - 1] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling sum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_sum([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 5]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1;\
    \ i < n; ++i)\n    {\n        sum_so_far += numbers[i];\n        if(sum_so_far\
    \ >= numbers[i])\n        {\n            sum_so_far_index = i;\n        }\n  \
    \  }\n    result[sum_so_far_index] = sum_so_far;\n    for(int i = sum_so_far_index\
    \ + 1; i < n; ++i)\n    {\n        sum_so_far += numbers[i];\n        if(sum_so_far\
    \ >= numbers[i])\n        {\n            result[i - 1] = numbers[i];\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjx741wft.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjx741wft.d(25): Error: cannot implicitly\
    \ convert expression `max_so_far_index + 1L` of type `long` to `int`\\n/tmp/tmpjx741wft.d(43):\
    \ Error: cannot implicitly convert expression `numbers.length` of type `ulong`\
    \ to `int`\\n/tmp/tmpjx741wft.d(56): Error: cannot implicitly convert expression\
    \ `min_so_far_index + 1L` of type `long` to `int`\\n/tmp/tmpjx741wft.d(74): Error:\
    \ cannot implicitly convert expression `numbers.length` of type `ulong` to `int`\\\
    n/tmp/tmpjx741wft.d(87): Error: cannot implicitly convert expression `sum_so_far_index\
    \ + 1L` of type `long` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpjx741wft.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long currentMaxValue\
    \ = maxValue;\n    long currentMaxIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > currentMaxValue)\n        {\n         \
    \   currentMaxValue = numbers[i];\n            currentMaxIndex = i;\n        }\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == currentMaxValue)\n        {\n            result[i] = currentMaxIndex;\n \
    \       }\n        else\n        {\n            result[i] = numbers[i];\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmp0lgxmx84.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428616]\\n??:? long[] tmp0lgxmx84.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmp0lgxmx84.__unittest_L37_C1() [0x427ffa]\\n??:? void\
    \ tmp0lgxmx84.__modtest() [0x4282e8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c643]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b4d6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430761]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b4ad]\\n??:? runModuleUnitTests [0x42c419]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a28]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4289af]\\n??:? _d_run_main [0x42891a]\\n??:? main [0x4282fb]\\\
    n??:? __libc_start_main [0xf041554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long maxValue = numbers[0];\n    long currentMax\
    \ = maxValue;\n    long currentMaxIndex = -1;\n    for(int i = 1; i < n; i++)\
    \ {\n        if(numbers[i] > currentMax) {\n            currentMax = numbers[i];\n\
    \            currentMaxIndex = i;\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        if(numbers[i] == currentMax) {\n            result[i] = currentMaxIndex;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 1,\
    \ 2, 1, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long minValue = numbers[0];\n    long currentMin\
    \ = minValue;\n    long currentMinIndex = -1;\n    for(int i = 1; i < n; i++)\
    \ {\n        if(numbers[i] < currentMin) {\n            currentMin = numbers[i];\n\
    \            currentMinIndex = i;\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        if(numbers[i] == currentMin) {\n            result[i] = currentMinIndex;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long currentSum = 0;\n\
    \    long currentSumIndex = -1;\n    for(int i = 1; i < n; i++) {\n        currentSum\
    \ += numbers[i];\n        if(currentSum > sum) {\n            currentSum = sum;\n\
    \            currentSumIndex = i;\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        if(numbers[i] == currentSum) {\n            result[i] = currentSumIndex;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5, 2.5]\n    \n*/\nlong[] rolling_average(long[] numbers) \n{\n\
    \    int n = numbers.length;\n    long[] result = new long[n];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    long currentSumIndex = -1;\n    for(int i\
    \ = 1; i < n; i++) {\n        currentSum += number\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp8gp_1xi.d(101): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmpp8gp_1xi.d(110): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmpp8gp_1xi.d(110): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp8gp_1xi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n    while(i\
    \ < numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i;\
    \ j < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n    \
    \        {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgccwv1vp.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284d5]\\n??:? void tmpgccwv1vp.__unittest_L31_C1()\
    \ [0x428059]\\n??:? void tmpgccwv1vp.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b446]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43065d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b41d]\\n??:? runModuleUnitTests [0x42c389]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428998]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42891f]\\n??:? _d_run_main [0x42888a]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0x40589554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n    long\
    \ sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        sum += current;\n        if(sum > max)\n        {\n \
    \           max = sum;\n        }\n        result[i] = max;\n        sum = 0;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\npublic\
    \ static int[] rolling_max(int[] numbers) {\n    int[] result = new int[numbers.length];\n\
    \    int max = 0;\n    int current = 0;\n    int sum = 0;\n    for (int i = 0;\
    \ i < numbers.length; i++) {\n        current = numbers[i];\n        sum += current;\n\
    \        if (sum > max) {\n            max = sum;\n        }\n        result[i]\
    \ = max;\n        sum = 0;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ dscore=0 |>\n<| a tags=java,arrays |>\n<code>\npublic static void main(String[]\
    \ args) {\n    int[] arr = new int[]{1,2,3,4,5,6,7,8,9,10};\n    int[] arr1 =\
    \ rolling_max(arr);\n    System.out.println(Arrays.toString(arr1));\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkluai0lx.d(29): Error: declaration expected, not `<`\\n/tmp/tmpkluai0lx.d(38):\
    \ Error: declaration expected, not `for`\\n/tmp/tmpkluai0lx.d(38): Error: no identifier\
    \ for declarator `i`\\n/tmp/tmpkluai0lx.d(38): Error: declaration expected, not\
    \ `<`\\n/tmp/tmpkluai0lx.d(38): Error: no identifier for declarator `i`\\n/tmp/tmpkluai0lx.d(38):\
    \ Error: declaration expected, not `++`\\n/tmp/tmpkluai0lx.d(40): Error: no identifier\
    \ for declarator `sum`\\n/tmp/tmpkluai0lx.d(40): Error: declaration expected,\
    \ not `+=`\\n/tmp/tmpkluai0lx.d(41): Error: declaration expected, not `if`\\n/tmp/tmpkluai0lx.d(43):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpkluai0lx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = numbers.length - 1;\
    \ i >= 0; i--)\n    {\n        if(numbers[i] > max_so_far)\n        {\n      \
    \      result[max_so_far_index] = numbers[i];\n            max_so_far_index =\
    \ i;\n        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    for(int i = numbers.length - 1;\
    \ i >= 0; i--)\n    {\n        if(numbers[i] < min_so_far)\n        {\n      \
    \      result[min_so_far_index] = numbers[i];\n            min_so_far_index =\
    \ i;\n        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3,\
    \ 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ count++;\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  result[i] = numbers[i] / count;\n    }\n    return result;\n}\n/*\n From a\
    \ given list of integers, generate a list of rolling median element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4,\
    \ 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkiv3li3v.d(101): Error: found `unittest` instead of statement\\\
    n/tmp/tmpkiv3li3v.d(110): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkiv3li3v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \       max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos];\n\
    \        max_pos++;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       min_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_pos];\n\
    \        min_pos++;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum of element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n  \
    \  long sum_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n   \
    \     sum += numbers[i];\n        sum_pos++;\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum;\n\
    \        sum++;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling product of element found until given moment\n   \
    \ in the sequence.\n    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 6, 6, 6, 6, 6]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long\
    \ product = 1;\n    long product_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n        product_pos++;\n    }\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = product;\n        product++;\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling quotient\
    \ of element found until given moment\n    in the sequence.\n    >>> rolling_quotient([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 1, 2, 1, 2, 1]\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprqvp2ibx.d(105): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprqvp2ibx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_rolling = 0;\n    long max_so_far_rolling_max\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far_rolling = max_so_far;\n   \
    \         max_so_far_rolling_max = max_so_far_rolling;\n        }\n        max_so_far_rolling\
    \ = max_so_far_rolling + numbers[i];\n        if(max_so_far_rolling > max_so_far_rolling_max)\n\
    \        {\n            max_so_far_rolling_max = max_so_far_rolling;\n       \
    \ }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_so_far_rolling_max;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_rolling = 0;\n    long min_so_far_rolling_min = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far_rolling = min_so_far;\n            min_so_far_rolling_min\
    \ = min_so_far_rolling;\n        }\n        min_so_far_rolling = min_so_far_rolling\
    \ + numbers[i];\n        if(min_so_far_rolling < min_so_far_rolling_min)\n   \
    \     {\n            min_so_far_rolling_min = min_so_far_rolling;\n        }\n\
    \    }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        result[i] = min_so_far_rolling_min;\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long sum_so_far = numbers[0];\n    long\
    \ sum_so_far_rolling = 0;\n    long sum_so_far_rolling_sum = 0;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        sum_so_far_rolling = sum_so_far\
    \ + \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg9ad3smj.d(82): Error: expression expected, not `unittest`\\\
    n/tmp/tmpg9ad3smj.d(83): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpg9ad3smj.d(91): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg9ad3smj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long maxValue = numbers[0];\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n  \
    \          maxValue = numbers[i];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        result[i] = maxValue;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuscgc6bx.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpuscgc6bx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = max_so_far;\n    }\n    result[max_so_far_index] =\
    \ max_so_far;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\n\
    long[] rolling_min(long[] numbers) \n{\n    long min_so_far = numbers[0];\n  \
    \  long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = min_so_far;\n    }\n    result[min_so_far_index] =\
    \ min_so_far;\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long sum_so_far = numbers[0];\n  \
    \  long sum_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        sum_so_far += numbers[i];\n        if(sum_so_far >= numbers[i])\n\
    \        {\n            sum_so_far = numbers[i];\n            sum_so_far_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum_so_far;\n  \
    \  }\n    result[sum_so_far_index] = sum_so_far;\n    return result;\n}\n/*\n\
    \ From a given list of integers, generate a list of rolling product element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 60]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long product_so_far = 1;\n\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkco0juvn.d(96): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkco0juvn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_index = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \         max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \        max_index++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpghts3mga.d(12): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285ae]\\n??:? long[] tmpghts3mga.rolling_max(long[])\
    \ [0x427e4b]\\n??:? void tmpghts3mga.__unittest_L30_C1() [0x427f92]\\n??:? void\
    \ tmpghts3mga.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5db]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b46e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430685]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b445]\\n??:? runModuleUnitTests [0x42c3b1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428947]\\n??:? _d_run_main [0x4288b2]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x412b5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[0] = max;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2,\
    \ 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long min = numbers[0];\n    long minIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    result[0] = min;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_average(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long sumOfSquares\
    \ = 0;\n    long average = 0;\n    long averageIndex = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        sumOfSquares\
    \ += numbers[i] * numbers[i];\n    }\n    average = sum / numbers.length;\n  \
    \  averageIndex = sumOfSquares / numbers.length;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        sumOfSquares += numbers[i]\
    \ * numbers[i];\n    }\n    average = sum / numbers.length;\n    averageIndex\
    \ = sumOfSquares / numbers.length;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        average = sum / numbers.length;\n        averageIndex = sumOfSquares\
    \ / numbers.length;\n        if(numbers[i] > average)\n        {\n           \
    \ average = numbers[i];\n            averageIndex = i;\n        }\n    }\n   \
    \ result[0] = average;\n    for(int i = 1; i < \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj8mflgh1.d(111): Error: expression expected, not `unittest`\\\
    n/tmp/tmpj8mflgh1.d(112): Error: found `{` when expecting `;` following `for`\
    \ condition\\n/tmp/tmpj8mflgh1.d(113): Error: expression expected, not `alias`\\\
    n/tmp/tmpj8mflgh1.d(113): Error: found `candidate` when expecting `)`\\n/tmp/tmpj8mflgh1.d(113):\
    \ Error: found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpj8mflgh1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n  \
    \  for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n   \
    \     if(numbers[i] < min)\n        {\n            min = numbers[i];\n       \
    \ }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = min;\n\
    \        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 5]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] += numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 2.5]\n    \n*/\ndouble[] rolling_average(double[]\
    \ numbers) \n{\n    double[] result = new double[numbers.length];\n    int i =\
    \ 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = result[i]\
    \ / numbers.length;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling variance element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_variance([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3,\
    \ 3, 3, 4, 2.5]\n    \n*/\ndouble[] rolling_variance(double[] numbers) \n{\n \
    \   double[] result = new double[numbers.length];\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = result[i] / numbers.length;\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqsjd0j19.d(115): Error: found `unittest` instead of statement\\\
    n/tmp/tmpqsjd0j19.d(124): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqsjd0j19.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[maxIndex] = numbers[i];\n        }\n \
    \   }\n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 3, 4, 3]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    long sum = 0;\n    long sumIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            result[i] = sum;\n        }\n\
    \        else if(sumIndex == 1)\n        {\n            result[i] = sum / 2;\n\
    \        }\n        else\n        {\n            result[i] = sum / 3;\n      \
    \  }\n        sumIndex++;\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\nlong[] rolling_median(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        if(sumIndex == 0)\n        {\n            result[i]\
    \ = sum;\n        }\n        else if(sumIndex == 1)\n        {\n            result[i]\
    \ = sum / 2;\n        }\n        else\n        {\n            result[i] = sum\
    \ / 3;\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphkkk3pa6.d(119): Error: found `unittest` instead of statement\\\
    n/tmp/tmphkkk3pa6.d(128): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmphkkk3pa6.d(128): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmphkkk3pa6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long maxValue = numbers[0];\n    long maxIndex\
    \ = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    result[maxIndex] = maxValue;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpiu853cnd.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428566]\\n??:? long[] tmpiu853cnd.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpiu853cnd.__unittest_L26_C1() [0x427f4a]\\n??:? void\
    \ tmpiu853cnd.__modtest() [0x428238]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c593]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b426]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306b1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43063d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b3fd]\\n??:? runModuleUnitTests [0x42c369]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428978]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4288ff]\\n??:? _d_run_main [0x42886a]\\n??:? main [0x42824b]\\\
    n??:? __libc_start_main [0x3b9b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long currentMax = 0;\n \
    \   long currentMaxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            currentMax = max;\n            currentMaxIndex = i;\n        }\n\
    \        else\n        {\n            currentMax = numbers[i];\n            currentMaxIndex\
    \ = i;\n        }\n    }\n    for(int i = currentMaxIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i - currentMaxIndex] = numbers[i];\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 3, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long currentMin = 0;\n    long currentMinIndex = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n            currentMin = min;\n            currentMinIndex\
    \ = i;\n        }\n        else\n        {\n            currentMin = numbers[i];\n\
    \            currentMinIndex = i;\n        }\n    }\n    for(int i = currentMinIndex;\
    \ i < numbers.length; i++)\n    {\n        result[i - currentMinIndex] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6]\n    \n*/\n\
    long[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long currentSum = 0;\n    long currentSumIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > 0)\n\
    \        {\n            sum += numbers[i];\n            currentSum = sum;\n  \
    \          currentSumIndex = i;\n        }\n        else\n        {\n        \
    \    currentSum = numbers[i];\n            currentSumIndex = i;\n        }\n \
    \   }\n    for(int i = currentSumIndex; i < numbers.length; i++)\n    {\n    \
    \    result[i - currentSumIndex] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 24, 120, 720]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppwvkdyep.d(110): Error: semicolon expected following function\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppwvkdyep.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_pos = 0;\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos\
    \ - i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n\
    import java.util.ArrayList;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_9de6sp.d(30): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm_9de6sp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    \n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 1,\
    \ 2, 2, 1]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long min = 0;\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    \n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6,\
    \ 6]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long sum = 0;\n    \n    for(; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n    \n   \
    \ for(; i < numbers.length; i++)\n    {\n        result[i] = sum;\n        sum\
    \ += numbers[i];\n    }\n    \n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers)\
    \ \n{\n    double[] result = new double[numbers.length];\n    int i = 0;\n   \
    \ double sum = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n   \
    \     result[i] = sum / numbers.length;\n        sum += numbers[i];\n    }\n \
    \   \n    return result;\n}\n/*\n From a given list of integers, generate a list\
    \ of rolling standard deviation element found until given moment\n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpejaiqy4r.d(125): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpejaiqy4r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far_index;\n        }\n        else\n        {\n            result[i]\
    \ = max_so_far;\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_so_far)\n        {\n            result[i]\
    \ = min_so_far_index;\n        }\n        else\n        {\n            result[i]\
    \ = min_so_far;\n        }\n    }\n    return result;\n}\n/*\n From a given list\
    \ of integers, generate a list of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1,\
    \ 2, 2.5, 3, 3.5, 4, 4.5]\n    \n*/\ndouble[] rolling_average(double[] numbers)\
    \ \n{\n    double[] result = new double[numbers.length];\n    double sum = 0;\n\
    \    double average = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    average = sum / numbers.length;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - average;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4, 4.5]\n\
    \    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[] result\
    \ = new double[numbers.length];\n    double sum = 0;\n    double average = 0;\n\
    \    for(int i = 0; i < \nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp87pon5gs.d(105): Error: expression expected, not `unittest`\\\
    n/tmp/tmp87pon5gs.d(106): Error: found `{` when expecting `;` following `for`\
    \ condition\\n/tmp/tmp87pon5gs.d(107): Error: expression expected, not `alias`\\\
    n/tmp/tmp87pon5gs.d(107): Error: found `candidate` when expecting `)`\\n/tmp/tmp87pon5gs.d(107):\
    \ Error: found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp87pon5gs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    int i = 0;\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ = numbers[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpfmrbd898.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285a6]\\n??:? long[] tmpfmrbd898.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpfmrbd898.__unittest_L32_C1() [0x427f86]\\n??:? void\
    \ tmpfmrbd898.__modtest() [0x428274]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b466]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4306f1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x43067d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b43d]\\n??:? runModuleUnitTests [0x42c3a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42893f]\\n??:? _d_run_main [0x4288aa]\\n??:? main [0x428287]\\\
    n??:? __libc_start_main [0x40a9d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 2]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min\
    \ = 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \        minIndex++;\n    }\n    return result;\n}\n/*\n From a given list of\
    \ integers, generate a list of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2,\
    \ 3, 3, 3, 4, 5]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum\
    \ = 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        if(sumIndex == numbers.length - 1)\n\
    \        {\n            sumIndex = 0;\n        }\n        sumIndex++;\n    }\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum;\n        sum++;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 6]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long product = 1;\n    long productIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        product *= numbers[i];\n   \
    \     if(productIndex == numbers.length - 1)\n        {\n            productIndex\
    \ = 0;\n        }\n        productIndex++;\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = product;\n\
    \        product++;\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling quotient element found until given moment\n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzrdviy4d.d(113): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzrdviy4d.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; ++i)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; ++i)\n\
    \    {\n        result[i] = max;\n        max = numbers[i];\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/10305640)\n\
    <|/ c |>\n<| c |>\nIt does provide an answer to the question. He asked for a way\
    \ to find the rolling maximum element in a given list. He also asked for ways\
    \ to improve the code. He also asked for ways to improve the code. He also asked\
    \ for ways to improve the code. He also asked for ways to improve the code. He\
    \ also asked for ways to improve the code. He also asked for ways to improve the\
    \ code. He also asked for ways to improve the code. He also asked for ways to\
    \ improve the code. He also asked for ways to improve the code. He also asked\
    \ for ways to improve the code. He also asked for ways to improve the code. He\
    \ also asked for ways to improve the code. He also asked for ways to improve the\
    \ code. He also asked for ways to improve the code. He also asked for ways to\
    \ improve the code. He also asked for ways to improve the code. He also asked\
    \ for ways to improve the code. He also asked for ways to improve the code. He\
    \ also asked for ways to improve the code. He also asked for ways to improve the\
    \ code. He also asked for ways to improve the code. He also asked for ways to\
    \ improve the code. He also asked for ways to improve the code. He also asked\
    \ for ways to improve the code. He also asked for ways to improve the code. He\
    \ also asked for ways to improve the code. He also asked for ways to improve the\
    \ code. He also asked for ways to improve the code. He also asked for way\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_tqxibq5.d(29): Error: declaration expected, not `<`\\n/tmp/tmp_tqxibq5.d(40):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmp_tqxibq5.d(41): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmp_tqxibq5.d(42): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmp_tqxibq5.d(43): Error: declaration expected, not `assert`\\\
    n/tmp/tmp_tqxibq5.d(44): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tqxibq5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max_so_far\
    \ = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n\
    \    {\n        result[i] = max_so_far;\n    }\n    for(int i = numbers.length\
    \ - 1; i >= 0; --i)\n    {\n        result[i] = numbers[max_so_far_index];\n \
    \       max_so_far_index = max_so_far_index - 1;\n    }\n    return result;\n\
    }\n/*\n From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3,\
    \ 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index = -1;\n  \
    \  for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n            min_so_far_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; ++i)\n    {\n        result[i] = min_so_far;\n  \
    \  }\n    for(int i = numbers.length - 1; i >= 0; --i)\n    {\n        result[i]\
    \ = numbers[min_so_far_index];\n        min_so_far_index = min_so_far_index -\
    \ 1;\n    }\n    return result;\n}\n/*\n From a given list of integers, generate\
    \ a list of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 3, 3.5, 4.5]\n  \
    \  \n*/\ndouble[] rolling_avg(double[] numbers) \n{\n    double sum = 0;\n   \
    \ for(int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n\
    \    }\n    double avg = sum / numbers.length;\n    double[] result = new double[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        result[i] = avg;\n\
    \    }\n    for(int i = numbers.length - 1; i >= 0; --i)\n    {\n        result[i]\
    \ = numbers[i - 1];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling median element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2.5,\
    \ 3, \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt1jumsqm.d(91): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt1jumsqm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long max = numbers[0];\n\
    \    long max_so_far = numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n\
    \    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = max;\n        }\n    }\n    long[] result = new long[numbers.length];\n  \
    \  for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n\
    */\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n    long\
    \ min_so_far = numbers[0];\n    for (int i = 1; i < numbers.length; i++)\n   \
    \ {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n        if (numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = min;\n        }\n    }\n    long[] result = new long[numbers.length];\n  \
    \  for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n\
    \    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given list of integers, generate a list of rolling quotient element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 12, 24, 48, 96]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] / \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdybxk5ff.d(106): Error: expression expected, not `unittest`\\\
    n/tmp/tmpdybxk5ff.d(107): Error: found `{` when expecting `;` following statement\\\
    n/tmp/tmpdybxk5ff.d(115): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdybxk5ff.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    result[maxIndex] = max;\n    for (int i = maxIndex + 1; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i - 1];\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk_gmw40k.d(30): Error: declaration expected, not `<`\\n/tmp/tmpk_gmw40k.d(35):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmpk_gmw40k.d(35): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmpk_gmw40k.d(36): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmpk_gmw40k.d(36): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmpk_gmw40k.d(37): Error: semicolon expected, not `.`\\n/tmp/tmpk_gmw40k.d(37):\
    \ Error: no identifier for declarator `.Text`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpk_gmw40k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given list of integers,\
    \ generate a list of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3,\
    \ 3, 4, 4]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n        max = numbers[i];\n    }\n    return\
    \ result;\n}\n/*\n From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1,\
    \ 2, 3, 2, 3, 4, 2])\n    [1, 2, 2, 2, 2, 2, 2]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 6, 6, 6, 6, 6]\n    \n\
    */\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ += result[i-1];\n    }\n    return result;\n}\n/*\n From a given list of integers,\
    \ generate a list of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5,\
    \ 2.5, 2.5, 2.5, 2.5]\n    \n*/\ndouble[] rolling_average(double[] numbers) \n\
    {\n    double[] result = new double[numbers.length];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n  \
    \  for(; i < numbers.length; i++)\n    {\n        result[i] = result[i] / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given list of integers, generate a\
    \ list of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 2.5, 2.5, 2.5, 2.5,\
    \ 2.5]\n    \n*/\ndouble[] rolling_median(double[] numbers) \n{\n    double[]\
    \ result = new double[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbf6ymiyf.d(113): Error: expression expected, not `unittest`\\\
    n/tmp/tmpbf6ymiyf.d(114): Error: found `{` when expecting `;` following `for`\
    \ condition\\n/tmp/tmpbf6ymiyf.d(115): Error: expression expected, not `alias`\\\
    n/tmp/tmpbf6ymiyf.d(115): Error: found `candidate` when expecting `)`\\n/tmp/tmpbf6ymiyf.d(115):\
    \ Error: found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpbf6ymiyf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
