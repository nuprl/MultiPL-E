name: HumanEval_21_rescale_to_unit
language: humaneval_to_dlang.py
prompt: "import std.math;\nimport std.typecons;\n/*\n Given list of numbers (of at\
  \ least two elements), apply a linear transform to that list,\n    such that the\
  \ smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
  \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
  \ numbers) \n"
tests: "unittest\n{\n    alias candidate = rescale_to_unit;\n\n    assert(candidate([2.0,\
  \ 49.9]) == [0.0, 1.0]);\n    assert(candidate([100.0, 49.9]) == [1.0, 0.0]);\n\
  \    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n\
  \    assert(candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n\
  \    assert(candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n\
  }\nvoid main(){}"
completions: ["{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        float number = numbers[i];\n        if (number < min)\n\
    \            min = number;\n        if (number > max)\n            max = number;\n\
    \        result[i] = (number - min) / (max - min);\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if you have a list of\
    \ negative numbers. For example, `[-1.0, -2.0, -3.0, -4.0, -5.0]` becomes `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ negative numbers. Thanks for the heads up!\n<|/ c |>\n<| a tags=java,math |>\n\
    <code>\npublic class RescaleToUnit {", "{\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n \
    \   for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem\
    \ to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works. I used the example\
    \ you provided. What exactly did you do?\n<|/ c |>\n<| c |>\nI used the example\
    \ you provided. What exactly did you do?\n<|/ c |>\n<| c |>\nI used the example\
    \ you provided. What exactly did you do?\n<|/ c |>\n<| c |>\nI used the example\
    \ you provided. What exactly did you do?\n<|/ c |>\n<| a tags=math,java,algorithm,arrays\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n        if(numbers[i] > max) {\n            max = numbers[i];\n      \
    \  }\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float scale = (max\
    \ - min) / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,java,algorithm,arrays\
    \ |>\n<| a tags=math,java,algorithm,arrays |>\n", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f /\
    \ range;\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; ++i)\n    {\n        float number = numbers[i];\n      \
    \  if(number < min)\n            min = number;\n        if(number > max)\n   \
    \         max = number;\n        result[i] = (number - min) / (max - min);\n \
    \   }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\n\
    Yes, I missed that case. Thanks for pointing it out. I've updated the answer.\n\
    <|/ c |>\n<| a tags=math,c#,algorithm |>\nI believe that your problem can be solved\
    \ using linear interpolation.\n<code>\npublic static float[] RescaleToUnit(float[]\
    \ numbers)\n{\n    float[] result = new float[numbers.Length];\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    float scale = 1;\n    for (int\
    \ i = 0; i < numbers.Length; i++)\n    {\n        float number = numbers[i];\n\
    \        if (number < min)\n            min = number;\n        if (number > max)\n\
    \            max = number;\n        result[i] = (number - min) * scale;\n    \
    \    scale *= (max - min) / (float)numbers.Length;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `RescaleToUnit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI believe that your problem can be\
    \ solved using linear interpolation.\n<|/ c |>\n<| c |>\nI believe that your problem\
    \ can be solved using linear interpolation.\n<|/ c |>\n<| c |>\nI believe that\
    \ your problem can be solved using linear interpolation.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\npublic static float[] RescaleToUnit(float[] numbers)\n{\n    float[]\
    \ result = new float[numbers.Length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float scale = 1;\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        float number = numbers[i];\n        if (number < min)\n\
    \            min = number;\n        if (number > max)\n            max = number;\n\
    \        result[i] = (number - ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if your input array has negative numbers. I believe it should, but it doesn't.\n\
    <|/ c |>\n<| c |>\nIt does work if you add `if (numbers[i] < 0.0) numbers[i] =\
    \ 0.0f;` before the `if` statement.\n<|/ c |>\n<| c |>\nIt doesn't work if your\
    \ input array has negative numbers. I believe it should, but it doesn't.\n<|/\
    \ c |>\n<| c |>\nIt does work if you add `if (numbers[i] < 0.0) numbers[i] = 0.0f;`\
    \ before the `if` statement.\n<|/ c |>\n<| c |>\nIt doesn't work if your input\
    \ array has negative numbers. I believe it should, but it doesn't.\n<|/ c |>\n\
    <| a tags=java,arrays,math |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    float[] result = new\
    \ float[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n   \
    \     result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    float[] result = new\
    \ float[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n   \
    \     result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math |>\n<| a tags=java,arrays,math |>\n<code>\npublic\
    \ static float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float range = max - min;\n    float scale =\
    \ 1.0f / range;\n    ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI wrote a\
    \ little function that does this for me:\n<code>\nfunction rescale_to_unit(numbers:\
    \ float[]): float[] {\n    var min = numbers[0];\n    var max = numbers[0];\n\
    \    for (var i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n        }\n        if (numbers[i] < min) {\n\
    \            min = numbers[i];\n        }\n    }\n    var range = max - min;\n\
    \    var scale = 1 / range;\n    var result = new Float32Array(numbers.length);\n\
    \    for (var i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,algorithm,c#,java\
    \ |>\n<| a tags=math,algorithm,c#,java |>\nI wrote a little function that does\
    \ this for me:\n<code>\nfunction rescale_to_unit(numbers: float[]): float[] {\n\
    \    var min = numbers[0];\n    var max = numbers[0];\n    for (var i = 1; i <\
    \ numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min) {\n            min = numbers[i];\n \
    \       }\n    }\n    var range = max - min;\n    var scale = 1 / range;\n   \
    \ var result = new Float32Array(numbers.length);\n    for (var i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min) {\n            min = numbers[i];\n        }\n    }\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    float[] result = new float[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,algorithm,c#,java\
    \ |>\n", "{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; ++i)\n    {\n        result[i] = numbers[i] * scale;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ if you have a list of numbers that don't sum to 1.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if you have a list of numbers that don't sum to 1.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have a list of numbers that don't sum to 1.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list of numbers that don't\
    \ sum to 1.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list of numbers\
    \ that don't sum to 1.\n<|/ c |>\n<| a tags=math,c#,algorithm,.net |>\n<code>\n\
    public static float Normalize(float value)\n{\n    float min = float.MaxValue;\n\
    \    float max = float.MinValue;\n    float range = max - min;\n    float scale\
    \ = 1.0f / range;\n    return value * scale;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if you have a list of numbers that don't sum to 1.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list of numbers that don't\
    \ sum to 1.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float Normalize(float\
    \ value)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    return value\
    \ * scale;\n}\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| a dscore=2 |>\n\
    <code>\npublic static float Normalize(float value)\n{\n    float min = float.MaxValue;\n\
    \    float max = float.MinValue;\n    float range = max - min;\n    float scale\
    \ = 1.0f / range;\n    return value * scale;\n}\n</code>\n<|/ a tags=math,c#,algorithm,.net\
    \ |>\n<| a dscore=2 |>\n<code>\n", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| c |>\nThis doesn't seem\
    \ to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\nIt\
    \ works, I tested it before posting it.  I added a test case to my answer.\n<|/\
    \ c |>\n<| c |>\nI tested it again and it works. I must have made a mistake when\
    \ I first tried it. Thanks!\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I must have made a mistake when I first tried it. Thanks!\n<|/ c |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if\
    \ (numbers[i] < min) {\n            min = numbers[i];\n        }\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (numbers.length - 1);\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I must have made a mistake when I first tried it. Thanks!\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if\
    \ (numbers[i] < min) {\n            min = numbers[i];\n        }\n        if (number",
  "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    float[] result\
    \ = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \        result[i] = numbers[i] - min;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] *= scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math\
    \ |>\n<| c |>\nI like this solution, however it has a bug in it: it assumes that\
    \ all numbers are positive. Try it with `[1.0, -2.0, 3.0, -4.0, 5.0]`\n<|/ c |>\n\
    <| c |>\nYes, I noticed that and fixed it. I also added a comment to explain why\
    \ I chose this method.\n<|/ c |>\n<| c |>\nI like your solution too, but I chose\
    \ the one that uses less memory and runs faster. Thanks anyway!\n<|/ c |>\n<|\
    \ c |>\nI like your solution too, but I chose the one that uses less memory and\
    \ runs faster. Thanks anyway!\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static\
    \ float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n        result[i] = numbers[i] - min;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n        result[i] *= scale;\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays,math |>\n<| c |>\nI like this solution, however\
    \ it has a bug in it: it assumes that all numbers are positive. Try it with `[1.0,\
    \ -2.0, 3.0, -4.0, 5.0]`\n<|/ c |>\n<| c |>\nI like your solution too, but I chose\
    \ the one that uses less memory and runs faster. Thanks anyway!\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>\npublic static float[] rescale(float[] numbers) {\n  \
    \  float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i\
    \ < number", "{\n    float[] result = new float[numbers.length];\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int\
    \ i = 0; i < numbers.length; ++i) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min) {\n            min = numbers[i];\n        }\n    }\n    float scale = 1.0f\
    \ / (max - min);\n    for (int i = 0; i < numbers.length; ++i) {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like this answer because it doesn't require a library and it's\
    \ very simple. Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI wrote a library that does\
    \ this for you:\nhttps://github.com/jonathanhudson/scala-math\n<code>\nimport\
    \ scala.math.LinearAlgebra._", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    <code>\npublic static float[] rescale(float[] numbers) {\n    float[] result =\
    \ new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,rescale,algorithm\
    \ |>\n<| a tags=java,arrays,rescale,algorithm |>\n<code>\npublic static float[]\
    \ rescale(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++) {\n        if(numbers[i] > max)\n            max =\
    \ numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \   }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\npublic static float[] rescale(float[] numbers) {\n    float[] result =\
    \ new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,rescale,algorithm\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static float[] rescale(float[] numbers)\
    \ {\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = number", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n       \
    \ result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works. I used the example you provided.\
    \ Maybe you missed something?\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I used the example you provided. Maybe you missed something?\n<|/ c |>\n<| c\
    \ |>\nI tested it again and it works. I used the example you provided. Maybe you\
    \ missed something?\n<|/ c |>\n<| c |>\nI tested it again and it works. I used\
    \ the example you provided. Maybe you missed something?\n<|/ c |>\n<| a dscore=4\
    \ |>\nI wrote a library that does this for you:\nhttps://github.com/david-rodriguez/scala-math-lib\n\
    It has some nice features like automatic type conversion, automatic type checking,\
    \ etc.\n<|/ a tags=math,java,algorithm,scala |>\n<| c |>\nThis library is awesome!\
    \ I used it for my own project and it's really easy to use. Thanks!\n<|/ c |>\n\
    <| c |>\nThis library is awesome! I used it for my own project and it's really\
    \ easy to use. Thanks!\n<|/ c |>\n<| c |>\nThis library is awesome! I used it\
    \ for my own project and it's really easy to use. Thanks!\n<|/ c |>\n<| a tags=math,java,algorithm,scala\
    \ |>\nI wrote a library that does this for you:\nhttps://github.com/david-rodriguez/scala-math-lib\n\
    It has some nice features like automatic type conversion, automatic type checking,\
    \ etc.\n<|/ a dscore=4 |>\n<| c ", "{\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n \
    \   for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| c\
    \ |>\nI believe this answer is wrong. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what OP wants.\n<|/ c |>\n\
    <| c |>\nI believe this answer is wrong. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what OP wants.\n\
    <|/ c |>\n<| c |>\nI believe this answer is wrong. `rescale_to_unit([1.0, 2.0,\
    \ 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what OP\
    \ wants.\n<|/ c |>\n<| c |>\nI believe this answer is wrong. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what\
    \ OP wants.\n<|/ c |>\n<| c |>\nI believe this answer is wrong. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what\
    \ OP wants.\n<|/ c |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI believe this answer is wrong.\
    \ `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`, which is not what OP wan", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        min = Math.min(min, numbers[i]);\n\
    \        max = Math.max(max, numbers[i]);\n    }\n    float range = max - min;\n\
    \    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<|\
    \ a dscore=0 |>\n<code>\npublic class ArrayRescale\n{\n    public static void\
    \ main(String[] args)\n    {\n        int[] numbers = {1,2,3,4,5,6,7,8,9,10};\n\
    \        int[] rescaledNumbers = rescaleToUnit(numbers);\n        System.out.println(Arrays.toString(rescaledNumbers));\n\
    \    }", "{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int i\
    \ = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n        if\
    \ (numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n  \
    \      if (numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \   }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for (int\
    \ i = 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,java,arrays\
    \ |>\n<| c |>\nThis doesn't work if the array is all zeroes. Try it with `new\
    \ float[]{0.0f}`.\n<|/ c |>\n<| c |>\nYes, I forgot about that case. Thanks for\
    \ pointing it out. I've updated the answer.\n<|/ c |>\n<| a tags=math,java,arrays\
    \ |>\nThe simplest way is to find the minimum and maximum values in the array,\
    \ and scale them accordingly. \n<code>\nfloat min = Float.MAX_VALUE;\nfloat max\
    \ = Float.MIN_VALUE;\nfor (float value : array) {\n    min = Math.min(min, value);\n\
    \    max = Math.max(max, value);\n}\nfloat scale = (max - min) / (array.length\
    \ - 1);\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the array is\
    \ all zeroes. Try it with `new float[]{0.0f}`.\n<|/ c |>\n<| c |>\nYes, I forgot\
    \ about that case. Thanks for pointing it out. I've updated the answer.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI used the code from and modified it a little bit to make\
    \ it more generic and to handle empty arrays:\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int i\
    \ = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min) {\n            min = numbers[i];\n        }\n    }\n    float scale = (max\
    \ - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++) {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=math,java,arrays |>\n<| a tags=math,java,arrays |>\n<code>\npublic\
    \ static float[] rescaleToUnit", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; ++i)\n    {\n        if (numbers[i] > max)\n           \
    \ max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    for (int i = 0; i < numbers.length; ++i)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= max - min;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays,math |>\n<| c |>\nThis doesn't work if you\
    \ have a list of numbers like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\n\
    It does work if you have a list of numbers like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n\
    <|/ c |>\n<| c |>\nIt does work if you have a list of numbers like `[1.0, 2.0,\
    \ 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work if you have a list of numbers\
    \ like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work if you have\
    \ a list of numbers like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    float[] result = new float[numbers.length];\n    for (int i\
    \ = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i] - min;\n   \
    \     result[i] /= max - min;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math\
    \ |>\n<| c |>\nThis doesn't work if you have a list of numbers like `[1.0, 2.0,\
    \ 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work if you have a list of numbers\
    \ like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work if you have\
    \ a list of numbers like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does\
    \ work if you have a list of numbers like `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n\
    <| c |>\nIt does work if you have a list of numbers like `[1.0, 2.0, 3.0, 4.0,\
    \ 5.", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ 1.0f / (max - min);\n    for (int i = 0; i < numbers.length; ++i)\n    {\n \
    \       result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math,algorithm |>\n<| c |>\nThis doesn't seem to work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt works. Try it\
    \ with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works for me. Try it with `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works for me too. Try it with `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a tags=java,arrays,math,algorithm |>\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers) {\n    float[] result =\
    \ new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; ++i) {\n        sum\
    \ += numbers[i];\n        if (numbers[i] > max) {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min) {\n            min = numbers[i];\n \
    \       }\n    }\n    float scale = 1.0f / (max - min);\n    for (int i = 0; i\
    \ < numbers.length; ++i) {\n        result[i] = numbers[i] * scale;\n    }\n \
    \   return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem\
    \ to work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt works.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works for me.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works for me\
    \ too. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works for\
    \ me too. ", "{\n    float[] result = new float[numbers.length];\n    float minValue\
    \ = numbers[0];\n    float maxValue = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n            minValue = numbers[i];\n\
    \        if(numbers[i] > maxValue)\n            maxValue = numbers[i];\n    }\n\
    \    float range = (maxValue - minValue);\n    float scale = (range == 0) ? 0\
    \ : (float)(numbers.length - 1) / (float)(range);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c |>\nThis doesn't work if the\
    \ range is greater than 1.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ ranges > 1.\n<|/ c |>\n<| c |>\nThis doesn't work if the range is greater than\
    \ 1.\n<|/ c |>\n<| c |>\nI added a version that works with ranges > 1.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if the range is greater than 1.\n<|/ c |>\n<|\
    \ a dscore=5 |>\nI wrote this in C#:\n<code>\npublic static float RescaleToUnit(float\
    \ value, float min, float max)\n{\n    if (min == max)\n    {\n        return\
    \ value;\n    }", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for\
    \ (int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n  \
    \      if (numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \   }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = 1.0f / (max - min);\n    for (int i = 0;\
    \ i < numbers.length; ++i)\n    {\n        result[i] = numbers[i] * scale;\n \
    \   }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c |>\n\
    This doesn't work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\n\
    It does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work. Try\
    \ it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a tags=math,c#,algorithm |>\n\
    <code>\npublic static float RescaleToUnit(float min, float max, float value)\n\
    {\n    return value * (max - min) + min;\n}\n</code>\n<|/ a dscore=4 |>\n<| c\
    \ |>\nThis doesn't work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<|\
    \ c |>\nIt does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c\
    \ |>\nIt does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\n\
    It does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a dscore=4 |>\n\
    <code>\npublic static float RescaleToUnit(float min, float max, float value)\n\
    {\n    return value * (max - min) + min;\n}\n</code>\n<|/ a tags=math,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1.0, 2.0, 3.0, 4.", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] - min;\n        result[i] *= scale;\n    }\n \
    \   return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = (float)(range == 0 ? 1\
    \ : range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\n  \
    \      result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis doesn't work when there are negative numbers in the list.\
    \ For example, `rescale_to_unit([-10, -5, -20, -10, -5, -10])` returns `[-10,\
    \ -5, -10, -5, -10, -10]`.\n<|/ c |>\n<| c |>\nThe question states that all numbers\
    \ are positive. `rescale_to_unit([-10, -5, -20, -10, -5, -10])` returns `[-10,\
    \ -5, -10, -5, -10, -10]` because `-10 + (-20 - 10) + (-10 - 5) + (-10 - 10) +\
    \ (-10 - 5) + (-10 - 10) = -10`.\n<|/ c |>\n<| c |>\nYes, I know. But the question\
    \ states that all numbers are positive. `rescale_to_unit([-10, -5, -20, -10, -5,\
    \ -10])` returns `[-10, -5, -10, -5, -10, -10]` because `-10 + (-20 - 10) + (-10\
    \ - 5) + (-10 - 10) + (-10 - 5) + (-10 - 10) = -10`.\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I've updated the answer to account for negative numbers. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=1 |>\nThe answer by is correct,\
    \ but I thought I'd post a more general solution that will work with any type\
    \ of number. \n<code>\npublic static <T> List<T> rescaleToUnit(List<T> numbers)\
    \ {\n    List<T> result = new ArrayList<>(numbers);\n    Collections.sort(result);\n\
    \    T min = result.get(0);\n    T max = result.get(result.size() - 1);\n    T\
    \ range = max - min;\n    T scale = (T) (range == 0 ? 1 : range / result.size());\n\
    \    for (int i = 0; i < result.size(); i++) {\n        result.set(i, result.get(i)\
    \ * scale);\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math\
    \ |>\n<| c |>\nThis doesn't work when there are negative numbers in the list. ",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (sum - 1);\n    for (int i = 0; i < numbers.length; i++)\n   \
    \ {\n        result[i] = numbers[i] - min;\n        result[i] *= scale;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| a tags=c#,math,algorithm\
    \ |>\nI wrote this in C#:\n<code>\npublic static class Math\n{\n    public static\
    \ double Normalize(double value)\n    {\n        if (value < 0)\n        {\n \
    \           throw new ArgumentOutOfRangeException(\"value\", \"The value must\
    \ be greater than or equal to 0.\");\n        }", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        float number = numbers[i];\n\
    \        if(number < min)\n            min = number;\n        if(number > max)\n\
    \            max = number;\n        result[i] = (number - min) / (max - min);\n\
    \    }\n    return result;\n}", "{\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n\
    \    return numbers;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c |>\nThis\
    \ doesn't work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]). Your function\
    \ returns [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<| c |>\nIt does work. Try it\
    \ yourself. It returns [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]). Your function returns\
    \ [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<| c |>\nIt does work. Try it yourself.\
    \ It returns [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<| c |>\nIt does work. Try\
    \ it yourself. It returns [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<| a tags=math,c#,algorithm\
    \ |>\nI came up with a solution that is pretty simple. \n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n \
    \   float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n   \
    \ {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n\
    \        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]).\
    \ Your function returns [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it yourself. It returns [0.0, 0.25, 0.5, 0.75, 1.0].\n<|/ c |>\n<|\
    \ c |>\nIt does work. Try it yourself. It returns [0.0, 0.25, 0.5, 0.75, 1.0].\n\
    <|/ c |>\n<| c |>\nIt does work. Try it ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        float number = numbers[i];\n      \
    \  if(number < min)\n            min = number;\n        if(number > max)\n   \
    \         max = number;\n        result[i] = (number - min) / (max - min);\n \
    \   }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c |>\n\
    This doesn't work if you have a list of numbers with negative numbers. For example,\
    \ if you have [1.0, -2.0, 3.0, -4.0, 5.0], the result will be [0.0, -0.5, 1.0,\
    \ 1.5, 2.0].\n<|/ c |>\n<| c |>\n: Yes, I noticed that and fixed it now. Thanks.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a list of numbers with negative\
    \ numbers. For example, if you have [1.0, -2.0, 3.0, -4.0, 5.0], the result will\
    \ be [0.0, -0.5, 1.0, 1.5, 2.0].\n<|/ c |>\n<| c |>\n: Yes, I noticed that and\
    \ fixed it now. Thanks.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list\
    \ of numbers with negative numbers. For example, if you have [1.0, -2.0, 3.0,\
    \ -4.0, 5.0], the result will be [0.0, -0.5, 1.0, 1.5, 2.0].\n<|/ c |>\n<| a dscore=5\
    \ |>\nI believe this should work:\n<code>\npublic static float Normalize(float\
    \ value)\n{\n    return value / Max(Abs(value), 1);\n}", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        float number = numbers[i];\n\
    \        if (number < min)\n            min = number;\n        if (number > max)\n\
    \            max = number;\n        result[i] = (number - min) / (max - min);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c\
    \ |>\nThis doesn't work if the numbers are negative.\n<|/ c |>\n<| c |>\n: Yes,\
    \ it does. `min` and `max` will never be negative.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you have a negative number in the list. Try `rescale_to_unit([-10.0,\
    \ 10.0, 20.0])`\n<|/ c |>\n<| c |>\n: Yes, it does. `min` and `max` will never\
    \ be negative.\n<|/ c |>\n<| c |>\n: Yes, it does. `min` and `max` will never\
    \ be negative.\n<|/ c |>\n<| a |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    float result = value * (max - min) + min;\n\
    \    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm dscore=5 |>\n<|\
    \ c |>\nThis doesn't work if the numbers are negative.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't work if you have a negative number in the list. Try `RescaleToUnit(-10.0,\
    \ 10.0, 20.0)`\n<|/ c |>\n<| c |>\n: Yes, it does. `min` and `max` will never\
    \ be negative.\n<|/ c |>\n<| c |>\n: Yes, it does. `min` and `max` will never\
    \ be negative.\n<|/ c |>\n<| c |>\n: Yes, it does. `min` and `max` will never\
    \ be negative.\n<|/ c |>\n<| a tags=math,c#,algorithm |>\n<code>\npublic static\
    \ float RescaleToUnit(float min, float max, float value)\n{\n    float result\
    \ = value * (max - min) + min;\n    return result;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't work if the numbers are negative.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if you have a negative number in the list. ", "{\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ range = (max - min);\n    float scale = (1.0f / range);\n    float[] result\
    \ = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given a\
    \ list of numbers (of at least two elements), apply a linear transform to that\
    \ list,\n    such that the smallest number will become 0 and the largest will\
    \ become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25,\
    \ 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float range)\
    \ \n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n       \
    \     min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (1.0f / range);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n/*\n Given a list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
    \ numbers, float min, float max) \n{\n    float range = (max - min);\n    float\
    \ scale = (1.0f / range);\n    float[] result = new float[numbers.length];\n \
    \   for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n/*\n Given a list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
    \ numbers, float min, float max, float range) \n{\n    float scale = (1.0f / range);\n\
    \    float[] result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given\
    \ a list of number", "{\n    float[] result = new float[numbers.length];\n   \
    \ float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n       \
    \ result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works. I used the exact same code\
    \ as you posted. I used `float[] numbers = { 1.0, 2.0, 3.0, 4.0, 5.0 };` instead\
    \ of `float[] numbers = { 1, 2, 3, 4, 5 };` because I didn't want to make any\
    \ assumptions about your data.\n<|/ c |>\n<| c |>\nI see what you're saying. My\
    \ bad. Thanks for your help!\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if(numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n        if(numbers[i] > max) {\n         \
    \   max = numbers[i];\n        }\n    }\n    float scale = (max - min) / (sum\
    \ - numbers[0]);\n    float[] result = new float[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a dscore=1\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float scale = (max\
    \ - min) / (sum - numbers[0]);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n", "{\n    float[] result = new float[numbers.length];\n\
    \    float minValue = numbers[0];\n    float maxValue = numbers[0];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < minValue)\n\
    \        {\n            minValue = numbers[i];\n        }\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n        }\n    }\n\
    \    float range = (maxValue - minValue);\n    float scale = (float)(range / numbers.length);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This doesn't work if the numbers are all negative.\n<|/ c |>\n<| c |>\nIt does\
    \ work if you change `float scale = (float)(range / numbers.length);` to `float\
    \ scale = (float)(range / (numbers.length - 1));`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the numbers are all negative.\n<|/ c |>\n<| c |>\nIt does work if you\
    \ change `float scale = (float)(range / numbers.length);` to `float scale = (float)(range\
    \ / (numbers.length - 1));`\n<|/ c |>\n<| a tags=java,math |>\nThe easiest way\
    \ is to use this formula:\n<code>\nfloat scale = (float)(max - min) / (max - min);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\nIt does work if you change `float scale = (float)(max\
    \ - min) / (max - min);` to `float scale = (float)(max - min) / (numbers.length\
    \ - 1);`\n<|/ c |>\n<| a |>\n<code>\nfloat scale = (float)(max - min) / (max -\
    \ min);\n</code>\n<|/ a dscore=2 tags=java,math |>\n<| c |>\nThis doesn't work\
    \ if the numbers are all negative.\n<|/ c |>\n<| a tags=java,math |>\n<code>\n\
    float scale = (float)(max - min) / (max - min);\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=java,math |>\n<code>\nfloat scale = (float)(max - min) / (max - min);\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nfloat scale = (float)(max\
    \ - min) / (max - min);\n</code>\n<|/ a tags=java,math |>\n<| a ", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 0; i < numbers.length; ++i)\n    {\n    \
    \    if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float range = max - min;\n\
    \    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,c#,math |>\n<| c |>\nThis doesn't work. Try it with\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`. `rescale_to_unit` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n\
    <|/ c |>\n<| c |>\nI see what you mean. My bad. Sorry. My comment was directed\
    \ at your original answer. Sorry again.\n<|/ c |>\n<| c |>\nNo problem. Thanks\
    \ for your help.\n<|/ c |>\n<| a tags=arrays,c#,math |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers)\n{\n    float min = numbers.Min();\n\
    \    float max = numbers.Max();\n    float range = max - min;\n    float scale\
    \ = 1.0f / range;\n    float[] result = new float[numbers.Length];\n    for (int\
    \ i = 0; i < numbers.Length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`. `rescale_to_unit` returns `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI see what you mean. My bad. Sorry. My\
    \ comment was directed at your original answer. Sorry again.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n    float\
    \ min = numbers.Min();\n    float max = numbers.Max();\n    float range = max\
    \ - min;\n    float scale = 1.0f / range;\n    float[] result = new float[numbers.Length];\n\
    \    for (int i = 0; i < numbers.Length; i++)\n    {", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = float.MAX_VALUE;\n    float max\
    \ = float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n    \
    \        max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0;\
    \ i < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,math,algorithm |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try rescale_to_unit([-10, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5]) which should return [-10, -5, -4, -3, -2, -1, 0, 1, 2,\
    \ 3, 4, 5] but instead returns [-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n<|/\
    \ c |>\n<| c |>\nI fixed the problem by changing the `if` statement to `if(numbers[i]\
    \ > max) max = numbers[i];`\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ negative numbers. Try rescale_to_unit([-10, -5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5]) which should return [-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5] but instead\
    \ returns [-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]\n<|/ c |>\n<| c |>\nI fixed\
    \ the problem by changing the `if` statement to `if(numbers[i] > max) max = numbers[i];`\n\
    <|/ c |>\n<| a tags=java,math,algorithm |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n\
    \    float sum = 0;\n    float scale = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    scale = 1 / (sum - numbers[0]);\n\
    \    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers. Try rescale_to_unit([-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) which\
    \ should return [-10, -5, -4, -3, -2, -1, ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        float number = numbers[i];\n      \
    \  if(number < min)\n            min = number;\n        if(number > max)\n   \
    \         max = number;\n    }\n    float range = max - min;\n    float scale\
    \ = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nfloat min = numbers[0];\nfloat max\
    \ = numbers[0];\nfor(int i = 0; i < numbers.length; i++)\n{\n    float number\
    \ = numbers[i];\n    if(number < min)\n        min = number;\n    if(number >\
    \ max)\n        max = number;\n}\nfloat range = max - min;\nfloat scale = 1.0f\
    \ / range;\nfor(int i = 0; i < numbers.length; i++)\n{\n    result[i] = numbers[i]\
    \ * scale;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a tags=java,arrays |>\n\
    <code>\npublic static void main(String[] args) {\n    int[] numbers = {1, 2, 3,\
    \ 4, 5};\n    System.out.println(rescale_to_unit(numbers));\n}", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ 1.0f / (max - min);\n    for (int i = 0; i < numbers.length; i++)\n    {\n \
    \       result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int i\
    \ = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min) {\n            min = numbers[i];\n        }\n    }\n    float scale = 1.0f\
    \ / (max - min);\n    for (int i = 0; i < numbers.length; i++) {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,math\
    \ |>\n<| a |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    float scale = 1.0f / (max - min);\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,math dscore=1\
    \ |>\n<| a tags=java,math |>\n<code>\npublic static float[] rescale(float[] numbers)\
    \ {\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    float scale = 1.0f / (max - min);\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\npublic static ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm,java |>\n<| c |>\n\
    I like this solution, but I wonder if it will work well with large numbers. I\
    \ wonder if there is a way to do this without having to store the entire array\
    \ in memory. Perhaps some kind of streaming solution?\n<|/ c |>\n<| c |>\nI wonder\
    \ if there is a way to do this without having to store the entire array in memory.\
    \ Perhaps some kind of streaming solution?\n<|/ c |>\n<| c |>\n: I added a solution\
    \ that doesn't require storing the entire array in memory.\n<|/ c |>\n<| c |>\n\
    : I added a solution that doesn't require storing the entire array in memory.\n\
    <|/ c |>\n<| c |>\n: I added a solution that doesn't require storing the entire\
    \ array in memory.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npublic static float rescaleToUnit(float\
    \ min, float max, float value)\n{\n    return ((value - min) / (max - min));\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm,java |>\n<| c |>\nThis does not work\
    \ if min and max are equal.\n<|/ c |>\n<| c |>\nThis does not work if min and\
    \ max are equal.\n<|/ c |>\n<| c |>\nThis does not work if min and max are equal.\n\
    <|/ c |>\n<| c |>\nThis does not work if min and max are equal.\n<|/ c |>\n<|\
    \ c |>\nThis does not work if min and max are equal.\n<|/ c |>\n<| a |>\n<code>\n\
    public static float rescaleToUnit(float min, float max, float value)\n{\n    return\
    \ ((value - min) / (max - min));\n}\n</code>\n<|/ a dscore=5 tags=math,c#,algorithm,java\
    \ |>\n<| c |>\nThis does not work if min and max are equal.\n<|/ c |>\n<| c |>\n\
    This does not work if min and max are ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (float) sum;\n    for (int i = 0; i < numbers.length; i++)\n        result[i]\
    \ = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nI like your solution, but I believe that it is more complicated than it\
    \ needs to be. Why not just use `std::minmax_element`?\n<|/ c |>\n<| c |>\nI agree\
    \ with you, `std::minmax_element` would be a better solution. I've edited my answer\
    \ to include a solution using `std::minmax_element`.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I believe that it is more complicated than it needs to be.\
    \ Why not just use `std::minmax_element`?\n<|/ c |>\n<| c |>\nI agree with you,\
    \ `std::minmax_element` would be a better solution. I've edited my answer to include\
    \ a solution using `std::minmax_element`.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I believe that it is more complicated than it needs to be. Why not just\
    \ use `std::minmax_element`?\n<|/ c |>\n<| a tags=c++,arrays,algorithm |>\n<code>\n\
    #include <iostream>\n#include <algorithm>\n#include <vector>", "{\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    float[] result = new\
    \ float[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n      \
    \  result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| a tags=c#,math,algorithm |>\nI used the answer from and modified it a\
    \ little bit to make it more generic. \n<code>\npublic static class MathExtensions\n\
    {\n    public static double[] ScaleToUnit(double[] numbers)\n    {\n        double\
    \ min = numbers[0];\n        double max = numbers[0];\n        foreach (double\
    \ number in numbers)\n        {\n            if (number < min)\n             \
    \   min = number;\n            if (number > max)\n                max = number;\n\
    \        }\n        double range = max - min;\n        double scale = 1.0f / range;\n\
    \        double[] result = new double[numbers.Length];\n        for (int i = 0;\
    \ i < numbers.Length; i++)\n            result[i] = numbers[i] * scale;\n    \
    \    return result;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static double[] ScaleToUnit(double[] numbers)\n{\n    double\
    \ min = numbers[0];\n    double max = numbers[0];\n    foreach (double number\
    \ in numbers)\n    {\n        if (number < min)\n            min = number;\n \
    \       if (number > max)\n            max = number;\n    }\n    double range\
    \ = max - min;\n    double scale = 1.0f / range;\n    double[] result = new double[numbers.Length];\n\
    \    for (int i = 0; i < numbers.Length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    <code>\npublic static double[] ScaleToUnit(double[] numbers)\n{\n    double min\
    \ = numbers[0];\n    double max = numbers[0];\n    foreach (double number in numbers)\n\
    \    {\n        if (number < min)\n            min = number;\n        if (number\
    \ > max)\n            max = number;\n    }\n    double range = max - min;\n  \
    \  double scale = 1.0f / range;\n    double[] result = new double[numbers.Length];\n\
    \    for (int i = 0; i < numbers.Length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n\
    <|", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \         max = numbers[i];\n        if (numbers[i] < min)\n            min =\
    \ numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for (int i =\
    \ 0; i < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] *= scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c\
    \ |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n\
    <|/ c |>\n<| c |>\nIt works fine for me. Are you sure you copied it correctly?\
    \ It returns `[0.0, 0.25, 0.5, 0.75, 1.0]` for me.\n<|/ c |>\n<| c |>\nI copied\
    \ it exactly as you wrote it. I also tried it on a different computer with different\
    \ results. I guess it's just my computer then.\n<|/ c |>\n<| c |>\nI guess it's\
    \ just my computer. I'll try it on a different computer when I get home.\n<|/\
    \ c |>\n<| c |>\nI tested it on another computer and it works fine. Thanks for\
    \ your help!\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nI wrote a C# version of\
    \ this in another answer. \n<code>\npublic static class Math\n{\n    public static\
    \ float RescaleToUnit(this float[] numbers)\n    {\n        if (numbers == null)\n\
    \            throw new ArgumentNullException(\"numbers\");\n        if (numbers.Length\
    \ < 2)\n            throw new ArgumentException(\"Must have at least two numbers.\"\
    , \"numbers\");", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n\
    \    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float\
    \ sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]` and it\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested it on `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]` and it returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n\
    <| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]` and it returns `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]`\
    \ and it returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a dscore=2 |>\nThis\
    \ should work:\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n\
    {\n    float[] result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    float sum = 0;\n    for (int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n        if (numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work.\
    \ `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float range = max - min;\n\
    \    float scale = (float)(range == 0 ? 1 : range / numbers.length);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI wrote this\
    \ in C#. Hope it helps.\n<code>\npublic static List<double> RescaleToUnit(List<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double range = max - min;\n    double scale = (double)(range == 0 ? 1 : range\
    \ / numbers.Count);\n    List<double> result = new List<double>();\n    foreach\
    \ (double number in numbers)\n    {\n        result.Add(number * scale);\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static List<double> RescaleToUnit(List<double> numbers)\n\
    {\n    double min = numbers.Min();\n    double max = numbers.Max();\n    double\
    \ range = max - min;\n    double scale = (double)(range == 0 ? 1 : range / numbers.Count);\n\
    \    List<double> result = new List<double>();\n    foreach (double number in\
    \ numbers)\n    {\n        result.Add(number * scale);\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic\
    \ static List<double> RescaleToUnit(List<double> numbers)\n{\n    double min =\
    \ numbers.Min();\n    double max = numbers.Max();\n    double range = max - min;\n\
    \    double scale = (double)(range == 0 ? 1 : range / numbers.Count);\n    List<double>\
    \ result = new List<double>();\n    foreach (double number in numbers)\n    {\n\
    \        result.Add(number * scale);\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\npublic static List<double> RescaleToUnit(List<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double range = max - min;\n    double scale = (double)(range == 0 ? 1 : range\
    \ / numbers.", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] <\
    \ min)\n            min = numbers[i];\n    }\n    float scale = (max - min) /\
    \ (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n    {\n  \
    \      result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,math |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI fixed the bug in the code (I forgot\
    \ to divide by sum). Now it works.\n<|/ c |>\n<| c |>\nThis doesn't seem to work.\
    \ `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI fixed the\
    \ bug in the code (I forgot to divide by sum). Now it works.\n<|/ c |>\n<| a dscore=4\
    \ |>\nI used the answer by but modified it a little bit to make it more generic\
    \ and to allow for negative numbers. \n<code>\npublic static double[] rescale_to_unit(double[]\
    \ numbers) {\n    double[] result = new double[numbers.length];\n    double min\
    \ = numbers[0];\n    double max = numbers[0];\n    double sum = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max) {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min) {\n            min = numbers[i];\n        }\n    }\n    double scale =\
    \ (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\
    \ {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,math |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI fixed the bug in the code (I forgot\
    \ to divide by sum). Now it works.\n<|/ c |>\n<|", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f /\
    \ range;\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = (float)(range / numbers.length);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works. I used the code from your\
    \ question and added the rescale_to_unit function I wrote.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I used the code from your question and added the rescale_to_unit\
    \ function I wrote.\n<|/ c |>\n<| c |>\nI tested it and it works. I used the code\
    \ from your question and added the rescale_to_unit function I wrote.\n<|/ c |>\n\
    <| c |>\nI tested it and it works. I used the code from your question and added\
    \ the rescale_to_unit function I wrote.\n<|/ c |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static float RescaleToUnit(float value, float min, float\
    \ max)\n{\n    float range = max - min;\n    return ((value - min) * range) /\
    \ range;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work. `RescaleToUnit(1.0,\
    \ 0.0, 1.0)` returns `0.0` instead of `1.0`\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works. I used the code from your question and added the rescale_to_unit function\
    \ I wrote.\n<|/ c |>\n<| c |>\nI tested it and it works. I used the code from\
    \ your question and added the rescale_to_unit function I wrote.\n<|/ c |>\n<|\
    \ c |>\nI tested it and it works. I used the code from your question and added\
    \ the rescale_to_unit function I wrote.\n<|/ c |>\n<| c ", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n            max = numbers[i];\n        if (numbers[i] < min)\n       \
    \     min = numbers[i];\n    }\n    float range = max - min;\n    for (int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - min;\n\
    \        result[i] /= range;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/\
    \ c |>\n<| c |>\nIt works fine for me. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n\
    <| c |>\nIt works for me on that example. Try it again. `[1.0, 2.0, 3.0, 4.0,\
    \ 5.0]` gives me `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nIt works for\
    \ me too. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a dscore=2 |>\n\
    The answer by is correct, but I thought I'd add an alternative solution that doesn't\
    \ require you to know the number of items in the array beforehand.\n<code>\npublic\
    \ static float[] rescale(float[] numbers)\n{\n    float[] result = new float[numbers.Length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.Length; i++)\n    {\n        if (numbers[i] > max)\n           \
    \ max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] /= range;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c\
    \ |>\nThis doesn't work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<|\
    \ c |>\nIt works for me on that example. Try it again. `[1.0, 2.0, 3.0, 4.0, 5.0]`\
    \ gives me `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nIt works for me too.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\n", "{\n    float[]\
    \ result = new float[numbers.length];\n    float minValue = numbers[0];\n    float\
    \ maxValue = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > maxValue)\n            maxValue = numbers[i];\n     \
    \   if(numbers[i] < minValue)\n            minValue = numbers[i];\n    }\n   \
    \ float scale = (maxValue - minValue) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    <code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        if(numbers[i] > max) {\n            max = numbers[i];\n    \
    \    }\n        if(numbers[i] < min) {\n            min = numbers[i];\n      \
    \  }\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n  \
    \  float[] result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=math,java,arrays |>\n<| a tags=math,java,arrays |>\n<code>\n\
    public static float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++) {\n\
    \        if(numbers[i] > max) {\n            max = numbers[i];\n        }\n  \
    \      if(numbers[i] < min) {\n            min = numbers[i];\n        }\n    }\n\
    \    float scale = (max - min) / (float)(numbers.length - 1);\n    float[] result\
    \ = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 0; i < numbers.length; i++) {\n        if(numbers[i] > max) {\n        \
    \    max = numbers[i];\n        }\n        if(numbers[i] < min) {\n          \
    \  min = numbers[i];\n        }\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n    }\n \
    \   return result;\n}\n</code>\n<|/ a tags=math,java,arrays |>\n<| a tags=math,java,arrays\
    \ |>\n<code>\npublic static float", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n        }\n    }\n    float scale = (max\
    \ - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis does not work if you have a list of negative\
    \ numbers. I suggest using Math.abs instead of Math.min and Math.max.\n<|/ c |>\n\
    <| c |>\nThis does not work if you have a list of negative numbers. I suggest\
    \ using Math.abs instead of Math.min and Math.max.\n<|/ c |>\n<| c |>\nThis does\
    \ not work if you have a list of negative numbers. I suggest using Math.abs instead\
    \ of Math.min and Math.max.\n<|/ c |>\n<| c |>\nThis does not work if you have\
    \ a list of negative numbers. I suggest using Math.abs instead of Math.min and\
    \ Math.max.\n<|/ c |>\n<| c |>\nThis does not work if you have a list of negative\
    \ numbers. I suggest using Math.abs instead of Math.min and Math.max.\n<|/ c |>\n\
    <| a tags=java,arrays,math |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ scale = (max - min) / (float)(numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        numbers[i] = numbers[i] * scale;\n    }\n    return numbers;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis does not work if you have a list\
    \ of negative numbers. I suggest using Math.abs instead of Math.min and Math.max.\n\
    <|/ c |>\n<| c |>\nThis does not work if you have a list of negative numbers.\
    \ I suggest using Math.abs instead of Math.min and Math.max.\n<|/ c |>\n<| c |>\n\
    This does not work if you have a list of negative numbers. I suggest using Math.abs\
    \ instead of Math.min and Math.max.\n<|/ c |>\n<| c |>\nThis does not work if\
    \ you have a list of negative numbers. I suggest using Math.abs instead of Math.min\
    \ and Math.max.\n<|/ c |>\n<| c |>\nThis does not work if you have a list of negative\
    \ numbers. I suggest using Math.abs instead of ", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n        {\n            max = numbers[i];\n        }\n        if (numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    float\
    \ scale = (max - min) / (float) numbers.length;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] *= scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| a\
    \ tags=math,c#,algorithm |>\n<code>\npublic static float RescaleToUnit(float min,\
    \ float max, float value)\n{\n    float scale = (max - min) / (float)Math.Abs(value);\n\
    \    return value * (float)scale + min;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This doesn't work if min is greater than max. For example, RescaleToUnit(10,20,5)\
    \ returns 10.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    float scale = (max - min) / (float)Math.Abs(value);\n\
    \    return value * (float)scale + min;\n}\n</code>\n<|/ a tags=math,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work if min is greater than max. For example, RescaleToUnit(10,20,5)\
    \ returns 10.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    float scale = (max - min) / (float)Math.Abs(value);\n\
    \    return value * (float)scale + min;\n}\n</code>\n<|/ a tags=math,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work if min is greater than max. For example, RescaleToUnit(10,20,5)\
    \ returns 10.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    float scale = (max - min) / (float)Math.Abs(value);\n\
    \    return value * (float)scale + min;\n}\n</code>\n<|/ a tags=math,c#,algorithm\
    \ |>\n<| a tags=math,c#,algorithm |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    float scale = (max - min) / (float)Math.Abs(value);\n\
    \    return ", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i] <\
    \ min)\n            min = numbers[i];\n    }\n    float scale = (max - min) /\
    \ (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n        result[i]\
    \ = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers. Try `rescale_to_unit([-10,\
    \ -20, -30, -40, -50])`\n<|/ c |>\n<| c |>\nYes, it does. Try it yourself. It\
    \ works perfectly for positive numbers. Try it with `rescale_to_unit([-10, -20,\
    \ -30, -40, -50])`\n<|/ c |>\n<| c |>\nYes, it does. Try it yourself. It works\
    \ perfectly for positive numbers. Try it with `rescale_to_unit([-10, -20, -30,\
    \ -40, -50])`\n<|/ c |>\n<| c |>\nYes, it does. Try it yourself. It works perfectly\
    \ for positive numbers. Try it with `rescale_to_unit([-10, -20, -30, -40, -50])`\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it yourself. It works perfectly for positive\
    \ numbers. Try it with `rescale_to_unit([-10, -20, -30, -40, -50])`\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>\npublic static float[] rescale(float[] numbers) {\n \
    \   float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max)\n        \
    \    max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for (int i =\
    \ 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| c |>\nThis\
    \ doesn't work if you have negative numbers. Try `rescale([-10, -20, -30, -40,\
    \ -50])`\n<|/ c |>\n<| c |>\nThis doesn't work", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (range/numbers.length);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This doesn't work if the list is all zeros or all ones. I believe it should be:\
    \ `float scale = (range/numbers.length);` `result[i] = numbers[i] * scale;`\n\
    <|/ c |>\n<| a tags=java,math,algorithm |>\nThe easiest way is to use logarithms:\n\
    <code>\npublic static float rescaleToUnit(float numbers[]) {\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = (max - min);\n    float scale = (range/numbers.length);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = Math.log(numbers[i])\
    \ / Math.log(scale);\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis doesn't work if the list is all zeros or all ones. I believe it\
    \ should be: `float scale = (range/numbers.length);` `numbers[i] = Math.log(numbers[i])\
    \ / Math.log(scale);`\n<|/ c |>\n<| c |>\nThis doesn't work if the list is all\
    \ zeros or all ones. I believe it should be: `float scale = (range/numbers.length);`\
    \ `numbers[i] = Math.log(numbers[i]) / Math.log(scale);`\n<|/ c |>\n<| a tags=java,math,algorithm\
    \ |>\n<code>\npublic static float rescaleToUnit(float numbers[]) {\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = (max - min);\n    float scale = (range/numbers.length);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        numbers[i] = numbers[i] * scale;\n\
    \    }\n    return numbers;\n}\n</code>\n<|/ a dscore=", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f /\
    \ range;\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ seem to work if you have negative numbers. For example, `rescale_to_unit([-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0]`\n<|/ c |>\n<| c\
    \ |>\nI added a fix for negative numbers. I tested it and it works.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for negative numbers. For example, `rescale_to_unit([-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0]`\n<|/ c |>\n<| c\
    \ |>\nI added a fix for negative numbers. I tested it and it works.\n<|/ c |>\n\
    <| c |>\nThis doesn't work for negative numbers. For example, `rescale_to_unit([-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0,\
    \ -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0]`\n<|/ c |>\n<| a\
    \ tags=math,c#,algorithm |>\nI came up with this solution:\n<code>\npublic static\
    \ IEnumerable<double> RescaleToUnit(this IEnumerable<double> numbers)\n{\n   \
    \ double min = numbers.Min();\n    double max = numbers.Max();\n    double range\
    \ = max - min;\n    double scale = 1.0f / range;\n    return numbers.Select(x\
    \ => x * scale);\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work for\
    \ negative numbers. For example, `RescaleToUnit([-10.0, -9.0, -8.0, -7.0, -6.0,\
    \ -5.0, -4.0, -3.0, -2.", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    float scale = 1;\n    for (int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        if (numbers[i] > max)\n        {\n       \
    \     max = numbers[i];\n        }\n        if (numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n        }\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=java,arrays |>\n<code>\npublic class ArrayRescale\
    \ {\n    public static void main(String[] args) {\n        int[] numbers = {1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] rescaledNumbers = rescale(numbers);\n\
    \        System.out.println(Arrays.toString(rescaledNumbers));\n    }", "{\n \
    \   float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,math,algorithm |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing\
    \ it out. Now it works.\n<|/ c |>\n<| a dscore=3 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max\
    \ = numbers[i];\n        }\n        if (numbers[i] < min) {\n            min =\
    \ numbers[i];\n        }\n    }\n    float scale = (max - min) / (float) (numbers.length\
    \ - 1);\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,math,algorithm |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max\
    \ = numbers[i];\n        }\n        if (numbers[i] < min) {\n            min =\
    \ numbers[i];\n        }\n    }\n    float scale = (max - min) / (float) (numbers.length\
    \ - 1);\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,math,algorithm |>\n<| a tags=java,math,algorithm |>\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers) {\n    float[] result =\
    \ new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) {", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     sum += numbers[i];\n        if (numbers[i] > max)\n        {\n         \
    \   max = numbers[i];\n        }\n        if (numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}", "{\n\
    \    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] > max)\n            max = numbers[i];\n        if\
    \ (numbers[i] < min)\n            min = numbers[i];\n    }\n    float range =\
    \ max - min;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= range;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works fine. Maybe\
    \ you missed something?\n<|/ c |>\n<| c |>\nI tested it and it works fine. Maybe\
    \ you missed something?\n<|/ c |>\n<| c |>\nI tested it and it works fine. Maybe\
    \ you missed something?\n<|/ c |>\n<| c |>\nI tested it and it works fine. Maybe\
    \ you missed something?\n<|/ c |>\n<| a tags=math,algorithm,c# |>\nI wrote this\
    \ in C#:\n<code>\npublic static class Math\n{\n    public static float RescaleToUnit(this\
    \ float value)\n    {\n        float min = float.MaxValue;\n        float max\
    \ = float.MinValue;\n        foreach (float number in new[] { value, float.NaN,\
    \ float.PositiveInfinity })\n        {\n            if (number > max)\n      \
    \          max = number;\n            if (number < min)\n                min =\
    \ number;\n        }\n        float range = max - min;\n        return value /\
    \ range;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to\
    \ work. `RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. Maybe you missed something?\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. Maybe you missed something?\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. Maybe you missed something?\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. Maybe you mis", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n      \
    \  result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=math,java,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/\
    \ c |>\n<| c |>\nIt doesn't work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<|\
    \ c |>\nIt does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max)\n            max = numbers[i];\n        if (numbers[i] < min)\n     \
    \       min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n\
    \    float[] result = new float[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=math,java,algorithm |>\n<| c |>\nThis doesn't seem to work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work. Try\
    \ it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for `[1.0, 2.0, 3.0,\
    \ 4.0, 5.0]`\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float[] rescal",
  "{\n    float[] result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    float sum = 0;\n    for (int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n        if (numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays |>\n<| a tags=java,arrays |>\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.List;", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; ++i)\n    {\n        min = min(min, numbers[i]);\n\
    \        max = max(max, numbers[i]);\n    }\n    float range = max - min;\n  \
    \  float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; ++i)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n     \
    \   result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math\
    \ |>\n<| a dscore=0 |>\n<code>\nimport java.util.Arrays;\nimport java.util.List;",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n    \
    \        max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0;\
    \ i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works fine for me. Did you try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`?\n<|/\
    \ c |>\n<| c |>\nYes, I did. `[1.0, 2.0, 3.0, 4.0, 5.0]` returns `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nOh, I see. Sorry, I misunderstood your\
    \ question. I'll update my answer.\n<|/ c |>\n<| c |>\nI updated my answer, please\
    \ take a look.\n<|/ c |>\n<| a |>\nI wrote a small library to solve this problem.\
    \ \n<code>\nimport std.math;\nimport std.typecons;", "{\n    float[] result =\
    \ new float[numbers.length];\n    float minValue = numbers[0];\n    float maxValue\
    \ = numbers[0];\n    float minIndex = 0;\n    float maxIndex = 0;\n    float minValue\
    \ = numbers[0];\n    float maxValue = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n        if (numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    float range = maxValue - minValue;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = (numbers[i] - minValue)\
    \ / range;\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if the numbers are all negative.\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ all numbers are negative. Try it yourself. It doesn't work if all numbers are\
    \ negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all numbers are negative. Try\
    \ it yourself. It doesn't work if all numbers are negative.\n<|/ c |>\n<| c |>\n\
    It doesn't work if all numbers are negative. Try it yourself. It doesn't work\
    \ if all numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all numbers\
    \ are negative. Try it yourself. It doesn't work if all numbers are negative.\n\
    <|/ c |>\n<| a tags=math,java,algorithm,arrays |>\n<code>\npublic static void\
    \ main(String[] args) {\n    int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\
    \    int[] result = rescale_to_unit(numbers);\n    System.out.println(Arrays.toString(result));\n\
    }", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n    \
    \        max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n \
    \   }\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; ++i)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try `rescale_to_unit([-10, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5])`\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; ++i) {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; ++i) {\n        result[i] =\
    \ numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,java,arrays\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int i\
    \ = 0; i < numbers.length; ++i) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max)\n            max = numbers[i];\n        if (numbers[i] < min)\n     \
    \       min = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for\
    \ (int i = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=math,java,arrays |>\n<| a tags=math,java,arrays\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        sum += numbers[i];\n        if (numbers[i] > max)\n        \
    \    max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = 1.0f / (max - min);\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        result[i] = numbers[i] * scale", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; ++i) {\n        float n = numbers[i];\n\
    \        if (n < min) min = n;\n        if (n > max) max = n;\n        result[i]\
    \ = (n - min) / (max - min);\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=math,c#,.net |>\n<code>\npublic static float RescaleToUnit(float\
    \ value, float min, float max)\n{\n    return (float)((value - min) / (max - min));\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static float RescaleToUnit(float\
    \ value, float min, float max)\n{\n    return (float)((value - min) / (max - min));\n\
    }\n</code>\n<|/ a tags=math,c#,.net |>\n<| a tags=math,c#,.net |>\n<code>\npublic\
    \ static float RescaleToUnit(float value, float min, float max)\n{\n    return\
    \ (float)((value - min) / (max - min));\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    <code>\npublic static float RescaleToUnit(float value, float min, float max)\n\
    {\n    return (float)((value - min) / (max - min));\n}\n</code>\n<|/ a tags=math,c#,.net\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static float RescaleToUnit(float\
    \ value, float min, float max)\n{\n    return (float)((value - min) / (max - min));\n\
    }\n</code>\n<|/ a tags=math,c#,.net |>\n<| a tags=math,c#,.net |>\n<code>\npublic\
    \ static float RescaleToUnit(float value, float min, float max)\n{\n    return\
    \ (float)((value - min) / (max - min));\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\npublic static float RescaleToUnit(float value, float min, float\
    \ max)\n{\n    return (float)((value - min) / (max - min));\n}\n</code>\n<|/ a\
    \ tags=math,c#,.net |>\n<| a dscore=1 |>\n<code>\npublic static float RescaleToUnit(float\
    \ value, float min, float max)\n{\n    return (float)((value - min) / (max - min));\n\
    }\n</code>\n<|/ a tags=math,c#,.net |>\n<| a d", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a |>\n\
    <code>\npublic static float[] rescale(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++) {\n\
    \        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    float scale = (max - min) / (numbers.length - 1);\n    float[] result = new\
    \ float[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n    \
    \    result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays dscore=0 |>\n<| a tags=java,arrays |>\n<code>\npublic static\
    \ float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 0; i < numbers.length; i++) {\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float scale = (max\
    \ - min) / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,arrays\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n        if(numbers[i] > max) {\n            max = numbers[i];\n      \
    \  }\n    }\n    float scale = (max - min) / (numbers.length - 1);\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,arrays |>\n<code>\npublic static\
    \ float[] rescale(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 0; i < numbers.length; i++) {\n        if(numbers[i]\
    \ < min) {\n", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = (float)(range / numbers.length);\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,java,algorithm\
    \ |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| c |>\nI added a version that works with negative numbers. I didn't test it\
    \ thoroughly, so there might be some bugs.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the numbers are all negative.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers. I didn't test it thoroughly, so there might be\
    \ some bugs.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n\
    <|/ c |>\n<| a tags=math,java,algorithm |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ range = max - min;\n    float scale = (float)(range / numbers.length);\n   \
    \ for(int i = 0; i < numbers.length; i++) {\n        numbers[i] *= scale;\n  \
    \  }\n    return numbers;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ work if the numbers are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if the numbers are all negative.\n<|/ c |>\n<| a tags=math,java,algorithm |>\n\
    <code>\npublic static float[] rescale(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float range = max - min;\n    float scale =\
    \ (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length; i++)\
    \ {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>", "{\n \
    \   float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to do this without having to import the math library. I'm working in\
    \ Unity, and I don't want to import the math library just to do this one function.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require importing the math\
    \ library.\n<|/ c |>\n<| c |>\nThanks, this works great! I added a version that\
    \ doesn't require importing the math library and also added a version that doesn't\
    \ require importing the math library but does require importing the System.Math\
    \ library.\n<|/ c |>\n<| a tags=c#,unity3d |>\nI added a version that doesn't\
    \ require importing the math library but does require importing the System.Math\
    \ library.\n<code>\nusing System.Collections;\nusing System.Collections.Generic;\n\
    using UnityEngine;", "{\n    float[] result = new float[numbers.length];\n   \
    \ float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float sum\
    \ = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math |>\n<| c |>\nThis doesn't work if the numbers are\
    \ all negative.\n<|/ c |>\n<| c |>\nIt does work if all numbers are negative.\n\
    <|/ c |>\n<| c |>\nIt does work if all numbers are negative. Try it yourself.\
    \ It doesn't work if all numbers are positive.\n<|/ c |>\n<| c |>\nIt does work\
    \ if all numbers are positive. Try it yourself. It doesn't work if all numbers\
    \ are negative.\n<|/ c |>\n<| c |>\nIt does work if all numbers are negative.\
    \ Try it yourself. It doesn't work if all numbers are positive.\n<|/ c |>\n<|\
    \ a |>\n<code>\npublic static void main(String[] args) {\n    int[] numbers =\
    \ {1, 2, 3, 4, 5};\n    System.out.println(rescale_to_unit(numbers));\n}", "{\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n    return\
    \ numbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem to work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works fine for\
    \ me. Are you sure you copied the code correctly?\n<|/ c |>\n<| c |>\nYes, I copied\
    \ it exactly. Maybe it's because I'm using a Mac?\n<|/ c |>\n<| c |>\nI tested\
    \ it on Windows and Linux, and it works fine. Are you sure you copied the code\
    \ correctly?\n<|/ c |>\n<| c |>\nYes, I copied it exactly. Maybe it's because\
    \ I'm using a Mac?\n<|/ c |>\n<| a tags=java,arrays,math |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n \
    \       if (numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if (numbers[i] > max) {\n            max = numbers[i];\n        }\n   \
    \ }\n    float scale = (max - min) / (numbers.length - 1);\n    for (int i = 0;\
    \ i < numbers.length; i++) {\n        numbers[i] = numbers[i] * scale;\n    }\n\
    \    return numbers;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem\
    \ to work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works\
    \ fine for me. Are you sure you copied the code correctly?\n<|/ c |>\n<| c |>\n\
    Yes, I copied it exactly. Maybe it's because I'm using a Mac?\n<|/ c |>\n<| c\
    \ |>\nI tested it on Windows and Linux, and it works fine. Are you sure you copied\
    \ the code correctly?\n<|/ c |>\n<| c |>\nYes, I copied it exactly. Maybe it's\
    \ because I'm using a Mac?\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n  \
    \  ", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        else if (numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm,statistics |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. `rescale_to_unit([-10.0, -9.0, -8.0, -7.0,\
    \ -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0, -9.0, -8.0, -7.0,\
    \ -6.0, -5.0, -4.0, -3.0, -2.0, -1.0, -0.0]`\n<|/ c |>\n<| c |>\nI added a fix\
    \ for negative numbers. I hope this helps.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have negative numbers. `rescale_to_unit([-10.0, -9.0, -8.0, -7.0, -6.0,\
    \ -5.0, -4.0, -3.0, -2.0, -1.0, -0.0])` returns `[-10.0, -9.0, -8.0, -7.0, -6.0,\
    \ -5.0, -4.0, -3.0, -2.0, -1.0, -0.0]`\n<|/ c |>\n<| c |>\nI added a fix for negative\
    \ numbers. I hope this helps.\n<|/ c |>\n<| a dscore=5 |>\nThe best solution I\
    \ found is this one:\n<code>\npublic static double rescaleToUnit(double value)\n\
    {\n    double min = double.MinValue;\n    double max = double.MaxValue;\n    double\
    \ sum = 0;\n    double scale = 0;\n    double rescaledValue = 0;\n    double absValue\
    \ = Math.Abs(value);", "{\n    float[] result = new float[numbers.length];\n \
    \   float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        float number = numbers[i];\n        if(number\
    \ < min)\n            min = number;\n        if(number > max)\n            max\
    \ = number;\n        result[i] = (number - min) / (max - min);\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try with [-0.5, -0.4, -0.3, -0.2, -0.1]\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers. Try with [-0.5,\
    \ -0.4, -0.3, -0.2, -0.1]\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers. Try with [-0.5, -0.4, -0.3, -0.2, -0.1]\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try with [-0.5, -0.4, -0.3, -0.2, -0.1]\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers. Try with [-0.5,\
    \ -0.4, -0.3, -0.2, -0.1]\n<|/ c |>\n<| a dscore=5 |>\nI wrote a C# version based\
    \ on some of the answers here that also handles negative numbers:\n<code>\npublic\
    \ static float RescaleToUnit(this float value)\n{\n    if (value == 0)\n     \
    \   return 0;", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n  \
    \      if (numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \   }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,c#,algorithm\
    \ |>\n<code>\npublic static float Normalize(float value)\n{\n    float min = float.MaxValue;\n\
    \    float max = float.MinValue;\n    float sum = 0;\n    float scale = 0;\n \
    \   float temp = 0;\n    float temp2 = 0;\n    float temp3 = 0;\n    float temp4\
    \ = 0;\n    float temp5 = 0;\n    float temp6 = 0;\n    float temp7 = 0;\n   \
    \ float temp8 = 0;\n    float temp9 = 0;\n    float temp10 = 0;\n    float temp11\
    \ = 0;\n    float temp12 = 0;\n    float temp13 = 0;\n    float temp14 = 0;\n\
    \    float temp15 = 0;\n    float temp16 = 0;\n    float temp17 = 0;\n    float\
    \ temp18 = 0;\n    float temp19 = 0;\n    float temp20 = 0;\n    float temp21\
    \ = 0;\n    float temp22 = 0;\n    float temp23 = 0;\n    float temp24 = 0;\n\
    \    float temp25 = 0;\n    float temp26 = 0;\n    float temp27 = 0;\n    float\
    \ temp28 = 0;\n    float temp29 = 0;\n    float temp30 = 0;\n    float temp31\
    \ = 0;\n    float temp32 = 0;\n    float temp33 = 0;\n    float temp34 = 0;\n\
    \    float temp35 = 0;\n    float temp36 = 0;\n    float temp37 = 0;\n    float\
    \ temp38 = 0;\n    float temp39 = 0;\n    float temp40 = 0;\n    float temp41\
    \ = 0;\n    float temp42 = 0;\n    float temp43 = 0;\n    float temp44 = 0;\n\
    \    float temp45 = 0;\n    float temp46 = 0;\n    float temp47 = 0;\n    float\
    \ temp48 = 0;\n    float temp49 = 0;\n    float temp50 = 0;\n    float temp51\
    \ = 0;\n    float temp52 = 0;\n    float temp53 = 0;\n    float temp54 = 0;\n\
    \    float temp55 = 0;\n    float temp56 = 0;\n    float temp57 = 0;\n    float\
    \ temp58 = 0;\n", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n  \
    \      if (numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \   }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - 1);\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c\
    \ |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n\
    <|/ c |>\n<| c |>\nI fixed the bug in the code. Now it works.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n\
    <|/ c |>\n<| c |>\nI fixed the bug in the code. Now it works.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n\
    <|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static IEnumerable<double>\
    \ RescaleToUnit(this IEnumerable<double> numbers)\n{\n    double min = numbers.Min();\n\
    \    double max = numbers.Max();\n    double sum = numbers.Sum();\n    double\
    \ scale = sum - 1;\n    double scaleFactor = scale / sum;\n    return numbers.Select(x\
    \ => x * scaleFactor);\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't seem\
    \ to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nThis\
    \ doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ ", "{\n\
    \    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        result[i] = numbers[i] - min;\n        result[i] /= (max - min);\n\
    \        result[i] *= sum;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works. I added the code I used\
    \ to test it.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the code I\
    \ used to test it.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the code\
    \ I used to test it.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the\
    \ code I used to test it.\n<|/ c |>\n<| a dscore=0 |>\nI believe this should work:\n\
    <code>\npublic static void main(String[] args) {\n    float[] numbers = {1.0,\
    \ 2.0, 3.0, 4.0, 5.0};\n    float[] rescaledNumbers = rescale_to_unit(numbers);\n\
    \    System.out.println(Arrays.toString(rescaledNumbers));\n}", "{\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}", "{\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=math,java,arrays |>\n<| c |>\nThis doesn't work\
    \ if you have negative numbers. Try it with `[-1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/\
    \ c |>\n<| c |>\nIt doesn't work if you have negative numbers. Try it with `[-1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative\
    \ numbers. Try it with `[-1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if you have negative numbers. Try it with `[-1.0, 2.0, 3.0, 4.0, 5.0]`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers. Try it with `[-1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| a tags=math,java,arrays |>\n<code>\npublic\
    \ static float[] rescale(float[] numbers) {\n    float min = numbers[0];\n   \
    \ float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n   \
    \     if(numbers[i] < min) {\n            min = numbers[i];\n        }\n     \
    \   if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    float scale = (max - min) / (numbers.length - 1);\n    float[] result = new\
    \ float[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n    \
    \    result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have negative numbers. Try\
    \ it with `[-1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ you have negative numbers. Try it with `[-1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work if you have negative numbers. Try it with `[-1.0,\
    \ 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative\
    \ numbers. Try it with `[-1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c ", "{\n \
    \   float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float range = (max - min);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] /= range;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| c |>\n\
    I believe this answer should be accepted as the correct one. Thanks.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>\npublic static double[] rescaleToUnit(double[] numbers)\
    \ {\n    double min = numbers[0];\n    double max = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n       \
    \     max = numbers[i];\n        }\n        if (numbers[i] < min) {\n        \
    \    min = numbers[i];\n        }\n    }\n    double range = (max - min);\n  \
    \  double[] result = new double[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] - min;\n        result[i] /= range;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a dscore=4\
    \ |>\n<code>\npublic static double[] rescaleToUnit(double[] numbers) {\n    double\
    \ min = numbers[0];\n    double max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n    }\n    double range = (max - min);\n    double[] result = new double[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] /= range;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math |>\n<| a dscore=4 |>\n<code>\npublic static double[]\
    \ rescaleToUnit(double[] numbers) {\n    double min = numbers[0];\n    double\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if\
    \ (numbers[i] > max) {\n            max = numbers[i];\n        }\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n    }\n    double range\
    \ = (max - min);\n    double[] result = new double[numbers.length];\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] - min;\n \
    \       result[i] /= range;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,array",
  "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] - min;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] *= scale;\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm,.net\
    \ |>\n<| c |>\nThis doesn't work if you have a list of numbers that don't add\
    \ up to 1\n<|/ c |>\n<| c |>\n: It does work if you have a list of numbers that\
    \ add up to 1.\n<|/ c |>\n<| c |>\n: It does work if you have a list of numbers\
    \ that add up to 1.\n<|/ c |>\n<| c |>\n: It does work if you have a list of numbers\
    \ that add up to 1.\n<|/ c |>\n<| c |>\n: It does work if you have a list of numbers\
    \ that add up to 1.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npublic static float Normalize(float\
    \ value)\n{\n    return value / Max(Abs(value), 1);\n}", "{\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n\
    \    float scale = (range/numbers.length);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a\
    \ tags=java,arrays,math |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    float scale = 1;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \    }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= (max - min);\n        result[i] *=\
    \ scale;\n    }\n    return result;\n}", "{\n    float min = numbers[0];\n   \
    \ float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n\
    \    float scale = (1.0f / range);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\n\
    I tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]` and it returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]` and it\
    \ returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested it on `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]` and it returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n\
    <| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]` and it returns `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a dscore=2 |>\nThe answer by is correct, but\
    \ I thought I'd add my own answer as I find it more readable. \n<code>\npublic\
    \ static float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = (max - min);\n\
    \    float scale = (1.0f / range);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=java,math |>\n<| c |>\nI\
    \ like this one better than mine. +1\n<|/ c |>\n<| c |>\nI like this one better\
    \ than mine. +1\n<|/ c |>\n<| a tags=java,math |>\nI came up with this solution:\n\
    <code>\npublic static float[] rescale_to_unit(float[] ", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n\
    <| c |>\nThis doesn't work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]).\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine. Can you give an example where\
    \ it doesn't work?\n<|/ c |>\n<| c |>\nThe OP wants to rescale a list of numbers\
    \ to fit in a range of 0 to 1, so your answer doesn't do that.\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works fine. Can you give an example where it doesn't\
    \ work?\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can you give an example\
    \ where it doesn't work?\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nI believe\
    \ this should work:\n<code>\npublic static float RescaleToUnit(float value)\n\
    {\n    float min = float.MaxValue;\n    float max = float.MinValue;\n    float\
    \ scale = (max - min) / (float)(value.Length - 1);\n    float result = 0.0f;\n\
    \    for(int i = 0; i < value.Length; i++)\n    {\n        result += value[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This doesn't work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]).\n<|/ c |>\n\
    <| c |>\nI tested it and it works fine. Can you give an example where it doesn't\
    \ work?\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can you give an example\
    \ where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can\
    \ you give an example where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works fine. Can you give an example where it doesn't work?\n<|/ c |>\n<|\
    \ a tags=c#,math,algorithm |>\n<code>\npublic static float RescaleToUnit(float\
    \ value)\n{\n", "{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n\
    \    foreach(float n in numbers) {\n        if (n < min) min = n;\n        if\
    \ (n > max) max = n;\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    foreach(float n in numbers) {\n        n -= min;\n        n /= scale;\n\
    \    }\n    return numbers;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| a\
    \ tags=c#,math,algorithm |>\nI wrote a C# version of this algorithm that uses\
    \ LINQ and is more efficient than my original answer:\n<code>\npublic static IEnumerable<double>\
    \ LinearTransform(IEnumerable<double> numbers)\n{\n    double min = numbers.Min();\n\
    \    double max = numbers.Max();\n    double scale = max - min;\n    double increment\
    \ = 1 / numbers.Count();\n    double current = min;\n    foreach (double n in\
    \ numbers)\n    {\n        yield return current += n * increment;\n    }\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static\
    \ IEnumerable<double> LinearTransform(IEnumerable<double> numbers)\n{\n    double\
    \ min = numbers.Min();\n    double max = numbers.Max();\n    double scale = max\
    \ - min;\n    double increment = 1 / numbers.Count();\n    double current = min;\n\
    \    foreach (double n in numbers)\n    {\n        yield return current += n *\
    \ increment;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static IEnumerable<double> LinearTransform(IEnumerable<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double scale = max - min;\n    double increment = 1 / numbers.Count();\n\
    \    double current = min;\n    foreach (double n in numbers)\n    {\n       \
    \ yield return current += n * increment;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\n<code>\npublic static IEnumerable<double> LinearTransform(IEnumerable<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double scale = max - min;\n    double increment = 1 / numbers.Count();\n\
    \    double current = min;\n    foreach (double n in numbers)\n    {\n       \
    \ yield return current += n * increment;\n    }\n}", "{\n    float[] result =\
    \ new float[numbers.length];\n    float min = float.MAX_VALUE;\n    float max\
    \ = float.MIN_VALUE;\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\nI added a version that works with negative numbers.\
    \ I didn't test it thoroughly though.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ the numbers are all negative.\n<|/ c |>\n<| c |>\nI added a version that works\
    \ with negative numbers. I didn't test it thoroughly though.\n<|/ c |>\n<| c |>\n\
    This doesn't work if the numbers are all negative.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float[] result\
    \ = new float[numbers.length];\n    float min = Float.MAX_VALUE;\n    float max\
    \ = Float.MIN_VALUE;\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    float scale = (max - min) / (sum\
    \ - numbers[0]);\n    for (int i = 0; i < numbers.length; i++) {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=math,c#,rescale,arrays\
    \ |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| a tags=math,c#,rescale,arrays\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = Float.MAX_VALUE;\n    float\
    \ max = Float.MIN_VALUE;\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      ", "{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if\
    \ (numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n  \
    \      if (numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \   }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - 1);\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/10305394)\n\
    <|/ c |>\n<| c |>\nThis does provide an answer to the question. He wants to rescale\
    \ a list of numbers to [0,1]. He also wants to avoid using loops. He also wants\
    \ to avoid using any libraries. He also wants to avoid using any loops. He also\
    \ wants to avoid using any libraries. He also wants to avoid using any libraries.\
    \ He also wants to avoid using any libraries. He also wants to avoid using any\
    \ libraries. He also wants to avoid using any libraries. He also wants to avoid\
    \ using any libraries. He also wants to avoid using any libraries. He also wants\
    \ to avoid using any libraries. He also wants to avoid using any libraries. He\
    \ also wants to avoid using any libraries. He also wants to avoid using any libraries.\
    \ He also wants to avoid using any libraries. He also wants to avoid using any\
    \ libraries. He also wants to avoid using any libraries. He also wants to avoid\
    \ using any libraries. He also wants to avoid using any libraries. He also wants\
    \ to avoid using any libraries. He also wants to avoid using any libraries. He\
    \ also wants to avoid using any libraries. He also wants to avoid using any libraries.\
    \ He also wants to avoid using any libraries. He also wants to avoid using any\
    \ libraries. He also wants to avoid using any libraries. He also wants to avoid\
    \ using any libraries. He also wants to avoid using any libraries. He also wants\
    \ to avoid using any libraries. He also wants to avoid using any libraries. He\
    \ also wants to avoid using any libraries. He also ", "{\n    float[] result =\
    \ new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = 1.0f /\
    \ range;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`.\n<|/ c |>\n<| c |>\nIt does work. Try it again with the code I posted.\
    \ It returns `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\nI see it now.\
    \ Thanks for your help.\n<|/ c |>\n<| a tags=java,math,algorithm |>\nThis can\
    \ be done in O(n) time complexity by first sorting the array and then applying\
    \ the following algorithm:\n<code>\nfloat min = array[0];\nfloat max = array[0];",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (float)(sum - 1);\n    for (int i = 0; i < numbers.length; ++i)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n\
    \    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++)\n\
    \        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nI believe this answer should be the accepted one. Using\
    \ `float` instead of `double` will give the correct result for small numbers.\
    \ Using `double` will give the wrong result for large numbers. Using `float` will\
    \ give the wrong result for small numbers and large numbers. Using `double` will\
    \ give the correct result for small numbers and large numbers. Using `float` will\
    \ give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for small numbers and large numbers. Using `double`\
    \ will give the correct result for small numbers and large numbers. Using `float`\
    \ will give the correct result for ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This doesn't seem to work. Try it with `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I added the code to the answer.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work. Try it with `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])`\n<|/ c |>\n<| c |>\nI tested it and it works. I added\
    \ the code to the answer.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. Try it\
    \ with `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])`\n<|/ c |>\n<| a dscore=2 |>\n\
    I wrote a function that does this for me:\n<code>\nimport std.stdio;\nimport std.array;\n\
    import std.conv;\nimport std.math;\nimport std.typecons;", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] <\
    \ min)\n            min = numbers[i];\n        if (numbers[i] > max)\n       \
    \     max = numbers[i];\n    }\n    float scale = 1.0f / (max - min);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,java,math\
    \ |>\n<| c |>\nI like this solution, very elegant.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a list of numbers that is all zero. For example, if you have\
    \ an array of all zeros, it returns an array of all zeros.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have a list of numbers that is all zero. For example,\
    \ if you have an array of all zeros, it returns an array of all zeros.\n<|/ c\
    \ |>\n<| a tags=arrays,java,math |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n   \
    \     }\n        if (numbers[i] > max) {\n            max = numbers[i];\n    \
    \    }\n    }\n    float scale = 1.0f / (max - min);\n    for (int i = 0; i <\
    \ numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n    }\n   \
    \ return result;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if\
    \ you have a list of numbers that is all zero. For example, if you have an array\
    \ of all zeros, it returns an array of all zeros.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a list of numbers that is all zero. For example, if you have\
    \ an array of all zeros, it returns an array of all zeros.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] < min)\
    \ {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n\
    \            max = numbers[i];\n        }\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] =\
    \ numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,java,math\
    \ |>\n<| c ", "{\n    float[] result = new float[numbers.length];\n    float min\
    \ = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float sum = 0;\n \
    \   for (int i = 0; i < numbers.length; ++i) {\n        sum += numbers[i];\n \
    \       if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max)\
    \ max = numbers[i];\n    }\n    float scale = (max - min) / (float) sum;\n   \
    \ for (int i = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i] *\
    \ scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns\
    \ `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/\
    \ c |>\n<| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0, 5.0]` and it returns `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`. What do you mean by \"doesn't seem to work\"?\n<|/ c\
    \ |>\n<| c |>\nI mean it doesn't seem to work as intended. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI tested it on `[1.0, 2.0, 3.0, 4.0,\
    \ 5.0]` and it returns `[0.0, 0.25, 0.5, 0.75, 1.0]`. What do you mean by \"doesn't\
    \ seem to work\"?\n<|/ c |>\n<| c |>\nI mean it doesn't seem to work as intended.\
    \ `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a dscore=1 |>\n\
    I came up with this solution:\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    float sum = 0;\n   \
    \ for (int i = 0; i < numbers.length; ++i) {\n        sum += numbers[i];\n   \
    \     if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (float) sum;\n    for\
    \ (int i = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math,algorithm\
    \ |>\n<| a tags=java,arrays,", "{\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI came up with a simple\
    \ solution that uses only a for loop and a boolean to determine if the smallest\
    \ number should be set to 0 or 1. \n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    boolean\
    \ first = true;\n    for(int i = 1; i < numbers.length; i++) {\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n            first = false;\n      \
    \  }\n        if(numbers[i] > max) {\n            max = numbers[i];\n        }\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    float[] result\
    \ = new float[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n\
    \        if(first) {\n            result[i] = 0;\n        } else {\n         \
    \   result[i] = numbers[i] * scale;\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays |>\n<| a dscore=1 |>\n<code>\npublic static float[]\
    \ rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    boolean first = true;\n    for(int i = 1; i < numbers.length;\
    \ i++) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n    \
    \        first = false;\n        }\n        if(numbers[i] > max) {\n         \
    \   max = numbers[i];\n        }\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++) {\n        if(first) {\n            result[i] = 0;\n\
    \        } else {\n            result[i] = numbers[i] * scale;\n        }\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a dscore=1\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    boolean first = true;\n\
    \    for(int i = 1; i < numbers.length; i++) {\n        if(numbers[i] < min) {\n\
    \            min = numbers[i];\n            first = false;\n        }\n      \
    \  if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n \
    \   float scale = (max - min) / (numbers.length", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     sum += numbers[i];\n        if (numbers[i] > max)\n        {\n         \
    \   max = numbers[i];\n        }\n        if (numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like your answer, but I don't think it scales to large arrays.\
    \ I tested it on [this array](http://pastebin.com/raw.php?i=4zYj0Y6U) and it crashed\
    \ my computer with a stack overflow. Also, I think it would be better to use a\
    \ `for` loop instead of `foreach`.\n<|/ c |>\n<| c |>\nI tested it on [this array](http://pastebin.com/raw.php?i=4zYj0Y6U)\
    \ and it worked fine. Also, I think it would be better to use a `for` loop instead\
    \ of `foreach`.\n<|/ c |>\n<| c |>\nI tested it on [this array](http://pastebin.com/raw.php?i=4zYj0Y6U)\
    \ and it worked fine. Also, I think it would be better to use a `for` loop instead\
    \ of `foreach`.\n<|/ c |>\n<| c |>\nI tested it on [this array](http://pastebin.com/raw.php?i=4zYj0Y6U)\
    \ and it worked fine. Also, I think it would be better to use a `for` loop instead\
    \ of `foreach`.\n<|/ c |>\n<| c |>\nI tested it on [this array](http://pastebin.com/raw.php?i=4zYj0Y6U)\
    \ and it worked fine. Also, I think it would be better to use a `for` loop instead\
    \ of `foreach`.\n<|/ c |>\n<| a |>\nI believe this should work:\n<code>\npublic\
    \ static float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    float scale = 1.0f / (max - min);\n\
    \    float[] result = new float[number", "{\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        min = Math.min(min,\
    \ numbers[i]);\n        max = Math.max(max, numbers[i]);\n    }\n    float scale\
    \ = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        numbers[i] = numbers[i] - min;\n        numbers[i] *= scale;\n\
    \    }\n    return numbers;\n}\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c\
    \ |>\nI like your answer, but I think it would be better to use a `for` loop instead\
    \ of `foreach` since you know that `numbers` will contain at least two elements.\
    \ Also, `sum` should be initialized to `0` instead of `float.MIN_VALUE`.\n<|/\
    \ c |>\n<| c |>\n: I agree with you. I've edited my answer to reflect your suggestions.\n\
    <|/ c |>\n<| c |>\n: I agree with you. I've edited my answer to reflect your suggestions.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\npublic static IEnumerable<float> RescaleToUnit(this\
    \ IEnumerable<float> numbers)\n{\n    float min = numbers.Min();\n    float max\
    \ = numbers.Max();\n    float sum = numbers.Sum();\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    foreach (var number in numbers)\n    {\n        yield\
    \ return number - min;\n        yield return number * scale;\n    }\n}\n</code>\n\
    <|/ a tags=math,c#,algorithm |>\n<| c |>\nI like your answer, but I think it would\
    \ be better to use a `for` loop instead of `foreach` since you know that `numbers`\
    \ will contain at least two elements. Also, `sum` should be initialized to `0`\
    \ instead of `float.MIN_VALUE`.\n<|/ c |>\n<| c |>\n: I agree with you. I've edited\
    \ my answer to reflect your suggestions.\n<|/ c |>\n<| a tags=math,c#,algorithm\
    \ |>\n<code>\npublic static IEnumerable<float> RescaleToUnit(this IEnumerable<float>\
    \ numbers)\n{\n    float min = numbers.Min();\n    float max = numbers.Max();\n\
    \    float sum = numbers.Sum();\n    float scale = (max - min) / (sum - numbers[0]);\n\
    \    foreach (var number in numbers)\n    {", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length; i++)\n       \
    \ result[i] = numbers[i] * scale;\n    return result;\n}", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if you have negative numbers.\
    \ Try rescale_to_unit([-10.0, -20.0, -30.0, -40.0, -50.0])\n<|/ c |>\n<| c |>\n\
    I added a version that works with negative numbers. I didn't test it thoroughly\
    \ though.\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers.\
    \ Try rescale_to_unit([-10.0, -20.0, -30.0, -40.0, -50.0])\n<|/ c |>\n<| c |>\n\
    I added a version that works with negative numbers. I didn't test it thoroughly\
    \ though.\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers.\
    \ Try rescale_to_unit([-10.0, -20.0, -30.0, -40.0, -50.0])\n<|/ c |>\n<| a dscore=5\
    \ |>\nThe easiest way is to use the Math library:\n<code>\nfloat rescale_to_unit(float\
    \ numbers[])\n{\n    float min = numbers[0];\n    float max = numbers[0];\n  \
    \  float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n\
    <|/ a tags=arrays,algorithm,java,math |>\n<| c |>\nThis doesn't work if you have\
    \ negative numbers. Try rescale_to_unit([-10.0, -20.0, -30.0, -40.0, -50.0])\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers. Try rescale_to_unit([-10.0,\
    \ -20.0, -30.0, -40.0, -50.0])\n<|/ c |>\n<| c |>\nThis doesn't work", "{\n  \
    \  float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = (float)(1.0 / range);\n\
    \    float[] result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a library for doing this in Swift\
    \ called SwiftMath. It has some nice features like a range of different linear\
    \ transformations and a range of different types of interpolation. \n<code>\n\
    import SwiftMath", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        float number = numbers[i];\n        min = Math.min(min, number);\n\
    \        max = Math.max(max, number);\n        result[i] = (number - min) / (max\
    \ - min);\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>\npublic static void main(String[] args) {\n    int[] numbers = {1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    System.out.println(Arrays.toString(rescale_to_unit(numbers)));\n\
    }", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] < min)\n    \
    \        min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0;\
    \ i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,c#,math,algorithm |>\n<| c |>\nThis doesn't\
    \ seem to work when all numbers are negative.\n<|/ c |>\n<| c |>\nIt works fine\
    \ for me when all numbers are negative. Try it yourself with your data.\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work for me when all numbers are negative. Try it yourself\
    \ with your data.\n<|/ c |>\n<| c |>\nIt works for me when all numbers are negative.\
    \ Try it yourself with your data.\n<|/ c |>\n<| c |>\nIt doesn't work for me when\
    \ all numbers are negative. Try it yourself with your data.\n<|/ c |>\n<| a |>\n\
    This should work:\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n\
    {\n    float[] result = new float[numbers.Length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] < min)\n   \
    \         min = numbers[i];\n        if (numbers[i] > max)\n            max =\
    \ numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n  \
    \  for (int i = 0; i < numbers.Length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,math,algorithm\
    \ dscore=2 |>\n<| c |>\nThis doesn't seem to work when all numbers are negative.\n\
    <|/ c |>\n<| c |>\nIt works fine for me when all numbers are negative. Try it\
    \ yourself with your data.\n<|/ c |>\n<| c |>\nIt doesn't work for me when all\
    \ numbers are negative. Try it yourself with your data.\n<|/ c |>\n<| c |>\nIt\
    \ works for me when all numbers are negative. Try it yourself with your data.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for me when all numbers are negative. Try it ",
  "{\n    float[] result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        float number = numbers[i];\n        min = min(number, min);\n\
    \        max = max(number, max);\n        result[i] = (number - min) / (max -\
    \ min);\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. `rescale_to_unit([-10.0, -20.0, -30.0, -40.0,\
    \ -50.0])` returns `[-10.0, -20.0, -30.0, -40.0, -50.0]` instead of `[-10.0, -20.0,\
    \ -30.0, -40.0, -50.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers.\
    \ `rescale_to_unit([-10.0, -20.0, -30.0, -40.0, -50.0])` returns `[-10.0, -20.0,\
    \ -30.0, -40.0, -50.0]` instead of `[-10.0, -20.0, -30.0, -40.0, -50.0]`\n<|/\
    \ c |>\n<| c |>\nIt doesn't work for negative numbers. `rescale_to_unit([-10.0,\
    \ -20.0, -30.0, -40.0, -50.0])` returns `[-10.0, -20.0, -30.0, -40.0, -50.0]`\
    \ instead of `[-10.0, -20.0, -30.0, -40.0, -50.0]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for negative numbers. `rescale_to_unit([-10.0, -20.0, -30.0, -40.0, -50.0])`\
    \ returns `[-10.0, -20.0, -30.0, -40.0, -50.0]` instead of `[-10.0, -20.0, -30.0,\
    \ -40.0, -50.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers. `rescale_to_unit([-10.0,\
    \ -20.0, -30.0, -40.0, -50.0])` returns `[-10.0, -20.0, -30.0, -40.0, -50.0]`\
    \ instead of `[-10.0, -20.0, -30.0, -40.0, -50.0]`\n<|/ c |>\n<| a tags=math,c#,algorithm\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n    float[]\
    \ result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n    float\
    \ max = float.MIN_VALUE;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        float number = numbers[i];\n        min = min(number, min);\n       \
    \ max = max(number, max);\n        result[i] = (number - min", "{\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI believe\
    \ this answer should be the accepted one. While the other answers do work, they\
    \ don't explain why they work. Your answer does explain why they work and is much\
    \ more concise.\n<|/ c |>\n<| a dscore=2 |>\nThe other answers here are great,\
    \ but I thought I'd add my own answer that uses no loops at all:\n<code>\npublic\
    \ static float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n        if\
    \ (numbers[i] < min) {\n            result[i] = 0;\n        } else if (numbers[i]\
    \ > max) {\n            result[i] = 1;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,math |>\n<| a dscore=1 |>\n<code>\npublic static float[]\
    \ rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    float scale = (max - min) / (numbers.length - 1);\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        result[i] = numbers[i] * scale;\n        if (numbers[i] < min)\
    \ {\n            result[i] = 0;\n        } else if (numbers[i] > max) {\n    \
    \        result[i] = 1;\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a tags=java,math |>\n<| a dscore=1 |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n        if (numbers[i] < min) {\n            result[i] = 0;\n    \
    \    } else if (numbers[i] > max) {\n            result[i] = 1;\n        }\n \
    \   }\n    return result;\n}\n</code>\n<|/ a tags=java,math |>\n", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     float number = numbers[i];\n        if (number < min)\n            min =\
    \ number;\n        if (number > max)\n            max = number;\n        result[i]\
    \ = (number - min) / (max - min);\n    }\n    return result;\n}\n</code>\n<|/\
    \ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\nIt doesn't work because you divide by `max - min`\
    \ instead of `max - min+1`.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work.\
    \ I said it wouldn't work when all numbers are negative.\n<|/ c |>\n<| c |>\n\
    : I didn't say it wouldn't work. I said it wouldn't work when all numbers are\
    \ negative.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it wouldn't\
    \ work when all numbers are negative.\n<|/ c |>\n<| a |>\n<code>\npublic static\
    \ float Normalize(float value)\n{\n    float min = float.MaxValue;\n    float\
    \ max = float.MinValue;\n    float range = max - min;\n    float scale = (float)(value\
    \ - min) / range;\n    return scale * range + min;\n}\n</code>\n<|/ a dscore=5\
    \ tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\n: It doesn't work because you divide by `max -\
    \ min` instead of `max - min+1`.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't\
    \ work. I said it wouldn't work when all numbers are negative.\n<|/ c |>\n<| c\
    \ |>\n: I didn't say it wouldn't work. I said it wouldn't work when all numbers\
    \ are negative.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work. I said it\
    \ wouldn't work when all numbers are negative.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    public static float Normalize(float value)\n{\n    float min = float.MaxValue;\n\
    \    float max = float.MinValue;\n    float range = max - min;\n    float scale\
    \ = (float)(value - min) / range;\n    return scale * range + min;\n}", "{\n \
    \   float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i\
    \ < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    float[] result\
    \ = new float[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n\
    \        result[i] = numbers[i] - min;\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n        result[i] *= scale;\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm,.net\
    \ |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| c |>\nIt doesn't work if all numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if all numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all\
    \ numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all numbers are\
    \ negative.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    return (float)(value - min) / (max - min);\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't work if\
    \ the numbers are all negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all numbers\
    \ are negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all numbers are negative.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if all numbers are negative.\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work if all numbers are negative.\n<|/ c |>\n<| a tags=math,c#,algorithm,.net\
    \ |>\n<code>\npublic static float RescaleToUnit(float min, float max, float value)\n\
    {\n    return (float)(value - min) / (max - min);\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| c |>\nIt doesn't work if all numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if all numbers are negative.\n<|/ c |>\n<| c |>\nIt doesn't work if all\
    \ numbers are negative.\n<|/ c ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}", "{\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n        else if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    \n    float scale = (max -\
    \ min) / (numbers.length - 1);\n    \n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    \n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        float number = numbers[i];\n      \
    \  if(number < min)\n            min = number;\n        if(number > max)\n   \
    \         max = number;\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm,.net\
    \ |>\n<| c |>\nThis doesn't seem to work. Try rescale_to_unit([1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n<|/ c |>\n<| c |>\nIt works fine for me. Try it yourself. It returns\
    \ [0.0, 0.25, 0.5, 0.75, 1.0]\n<|/ c |>\n<| c |>\nI see what you mean. Your solution\
    \ works perfectly for me. Thanks!\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have a list of negative numbers. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, -5.0])\n\
    <|/ c |>\n<| c |>\nIt works fine for me. Try it yourself. It returns [0.0, 0.25,\
    \ 0.5, 0.75, 1.0]\n<|/ c |>\n<| a dscore=4 |>\nI believe that your problem is\
    \ that the algorithm is returning the wrong answer. \nThe algorithm is returning\
    \ the correct answer if you have numbers that are all positive. \nThe algorithm\
    \ is returning the wrong answer if you have numbers that are all negative. \n\
    The algorithm is returning the correct answer if you have numbers that are all\
    \ zero. \nThe algorithm is returning the wrong answer if you have numbers that\
    \ are all greater than zero. \nThe algorithm is returning the wrong answer if\
    \ you have numbers that are all less than zero. \nThe algorithm is returning the\
    \ correct answer if you have numbers that are all between zero and one. \nThe\
    \ algorithm is returning the wrong answer if you have numbers that are all between\
    \ one and zero. \nThe algorithm is returning the wrong answer if you have numbers\
    \ that are all between zero and one. \nThe algorithm is returning the wrong answer\
    \ if you have numbers that are all between one and zero. \nThe algorithm is returning\
    \ the wrong answer if you have numbers that are all between zero and one. \nThe\
    \ algorithm is returning the wrong answer if you have numbers that are all between\
    \ one and zero. \nThe algorithm is returning the wrong answer if you have numbers\
    \ that are all between zero and one. \nThe algorithm is returning the wrong answer\
    \ if you have numbers that are all between one and zero. \nThe algorithm is returning\
    \ the wrong ", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return result;\n\
    }", "{\n    float[] result = new float[numbers.length];\n    float minValue =\
    \ numbers[0];\n    float maxValue = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n            maxValue = numbers[i];\n\
    \        if(numbers[i] < minValue)\n            minValue = numbers[i];\n    }\n\
    \    float scale = (maxValue - minValue) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis\
    \ doesn't seem to work when numbers are very close to each other. For example,\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of\
    \ `[0.0, 0.5, 1.0, 1.5, 2.0]`.\n<|/ c |>\n<| c |>\nI tested it and it works fine\
    \ for me. Can you provide an example where it doesn't work?\n<|/ c |>\n<| c |>\n\
    I tested it on [this list](http://pastebin.com/raw.php?i=yU6qwN7q) and it gave\
    \ me `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.5, 1.0, 1.5, 2.0]`.\n<|/\
    \ c |>\n<| c |>\nI tested it on [this list](http://pastebin.com/raw.php?i=yU6qwN7q)\
    \ and it gave me `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.5, 1.0, 1.5,\
    \ 2.0]`.\n<|/ c |>\n<| c |>\nI tested it on [this list](http://pastebin.com/raw.php?i=yU6qwN7q)\
    \ and it gave me `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.5, 1.0, 1.5,\
    \ 2.0]`.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nThis can be done by finding\
    \ the minimum and maximum values, and then scaling the values by dividing them\
    \ by the difference between the maximum and minimum values.\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers)\n{\n    float minValue = numbers[0];\n\
    \    float maxValue = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > maxValue)\n            maxValue = numbers[i];\n\
    \        if(numbers[i] < minValue)\n            minValue = numbers[i];\n    }\n\
    \    float scale = (maxValue - minValue) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] * scale;\n\
    \    return numbers;", "{\n    float[] result = new float[numbers.length];\n \
    \   float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try it with `[-1.0, 0.0, 1.0]`.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have negative numbers. Try it with `[-1.0, 0.0,\
    \ 1.0]`.\n<|/ c |>\n<| c |>\nI added a version that works with negative numbers.\
    \ I tested it with `[-1.0, 0.0, 1.0]` and it worked fine.\n<|/ c |>\n<| c |>\n\
    I added a version that works with negative numbers. I tested it with `[-1.0, 0.0,\
    \ 1.0]` and it worked fine.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\n\
    public static class Math\n{\n    public static float Normalize(this float value)\n\
    \    {\n        return value / Max(Abs(value), 1);\n    }", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI believe this should work. Can you give an example\
    \ where it doesn't?\n<|/ c |>\n<| c |>\nI believe this should work. Can you give\
    \ an example where it doesn't?\n<|/ c |>\n<| c |>\n`rescale_to_unit([1.0, 2.0,\
    \ 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI believe this should work. Can you give\
    \ an example where it doesn't?\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nI believe\
    \ this should work. Can you give an example where it doesn't?\n<code>\npublic\
    \ static float[] rescale_to_unit(float[] numbers)\n{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns\
    \ `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/\
    \ c |>\n<| c |>\nI believe this should work. Can you give an example where it\
    \ doesn't?\n<|/ c |>\n<| c |>\nI ", "{\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    float[] result = new float[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,java,math |>\n<| c |>\nThis doesn't work\
    \ if you have negative numbers. Try rescale_to_unit([-10, -20, -30, -40, -50]).\n\
    <|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers. Try rescale_to_unit([-10,\
    \ -20, -30, -40, -50]).\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative\
    \ numbers. Try rescale_to_unit([-10, -20, -30, -40, -50]).\n<|/ c |>\n<| c |>\n\
    It doesn't work if you have negative numbers. Try rescale_to_unit([-10, -20, -30,\
    \ -40, -50]).\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers.\
    \ Try rescale_to_unit([-10, -20, -30, -40, -50]).\n<|/ c |>\n<| a |>\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n\
    \        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    float scale = 1.0f / (max - min);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,java,math\
    \ dscore=5 |>\n<| c |>\nThis doesn't work if you have negative numbers. Try rescale_to_unit([-10,\
    \ -20, -30, -40, -50]).\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative\
    \ numbers. Try rescale_to_unit([-10, -20, -30, -40, -50]).\n<|/ c |>\n<| c |>\n\
    It doesn't work if you have negative numbers. Try rescale_to_unit([-10, -20, -30,\
    \ -40, -50]).\n<|/", "{\n    float[] result = new float[numbers.length];\n   \
    \ float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    float sum\
    \ = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (float) sum;\n    for (int i = 0; i < numbers.length; i++)\n        result[i]\
    \ = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nIt does work, just tested it. The problem was that\
    \ I was using float.MAX_VALUE instead of float.MIN_VALUE.\n<|/ c |>\n<| c |>\n\
    I see what you mean. My bad. Thanks for your help.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a negative number in the list. `rescale_to_unit([1.0, 2.0,\
    \ 3.0, 4.0, -5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a tags=math,c#,algorithm |>\nI wrote this in\
    \ C#:\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n   \
    \ float min = float.MaxValue;\n    float max = float.MinValue;\n    float sum\
    \ = 0;\n    for (int i = 0; i < numbers.Length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (float) sum;\n    for (int i = 0; i < numbers.Length; i++)\n        numbers[i]\
    \ *= scale;\n    return numbers;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ doesn't work if you have a negative number in the list. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, -5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a tags=math,c#,algorithm |>\nThis should\
    \ work:\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n \
    \   float min = float.MaxValue;", "{\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n\
    \    return numbers;\n}", "{\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range\
    \ / numbers.length);\n    float[] result = new float[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm,.net |>\n<| c |>\n\
    This doesn't seem to work. Try rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]).\n<|/\
    \ c |>\n<| c |>\n: It does work. Try it yourself. It returns `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]`.\n<|/ c |>\n<| c |>\n: It doesn't work because you didn't understand\
    \ what it does. I explained what it does, and I gave you a working example. Try\
    \ it yourself. It returns `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\n\
    : I explained what it does, and I gave you a working example. Try it yourself.\
    \ It returns `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\n: I explained\
    \ what it does, and I gave you a working example. Try it yourself. It returns\
    \ `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| a tags=c#,math,algorithm,.net |>\n\
    <code>\npublic static float[] RescaleToUnit(float[] numbers)\n{\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.Length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = (float)(range / numbers.Length);\n   \
    \ float[] result = new float[numbers.Length];\n    for(int i = 0; i < numbers.Length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis doesn't seem to work. Try rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0]).\n<|/ c |>\n<| c |>\n: It does work. Try it yourself. It\
    \ returns `[0.0, 0.25, 0.5, 0.75, ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n           \
    \ max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (float) numbers.length;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis\
    \ doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`, which is not what OP wants.\n<|/ c |>\n<| c |>\n: I\
    \ see what you mean. I've updated my answer to include a fix for that.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what OP wants.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. I've updated my answer to include a\
    \ fix for that.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what\
    \ OP wants.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static float RescaleToUnit(this\
    \ float value)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n\
    \    float scale = (max - min) / (float) value.Length;\n    return value * scale;\n\
    }\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work.\
    \ `RescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`,\
    \ which is not what OP wants.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `RescaleToUnit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not what\
    \ OP wants.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static float\
    \ RescaleToUnit(this float value)\n{\n    float min = float.MaxValue;\n    float\
    \ max = float.MinValue;\n    float scale = (max - min", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        float number = numbers[i];\n\
    \        min = min(number, min);\n        max = max(number, max);\n        result[i]\
    \ = (number - min) / (max - min);\n    }\n    return result;\n}", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n    \
    \        max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0;\
    \ i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,java,algorithm |>\nThe\
    \ algorithm is simple:", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n        if (numbers[i] < min)\n   \
    \     {\n            min = numbers[i];\n        }\n    }\n    float range = max\
    \ - min;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= range;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you have a list of\
    \ negative numbers. For example, [-4, -2, -1, 0, 1, 2, 3, 4, 5] returns [-4, -2,\
    \ -1, 0, 1, 2, 3, 4, 5] instead of [0, 0.25, 0.5, 0.75, 1]\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have a list of negative numbers. For example, [-4, -2,\
    \ -1, 0, 1, 2, 3, 4, 5] returns [-4, -2, -1, 0, 1, 2, 3, 4, 5] instead of [0,\
    \ 0.25, 0.5, 0.75, 1]\n<|/ c |>\n<| a dscore=2 |>\nI wrote a small library to\
    \ solve this problem. \n<code>\nimport std.math;\nimport std.array;\nimport std.conv;\n\
    import std.algorithm;", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<|\
    \ c |>\nThis doesn't work. Try rescale_to_unit([-5, -10, -15, -20, -25]) and you'll\
    \ get [-0.5, -0.5, -0.5, -0.5, -0.5]\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I used the example you provided. What is the problem you are having?\n<|/ c\
    \ |>\n<| c |>\nI tested it and it works. I used the example you provided. What\
    \ is the problem you are having?\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I used the example you provided. What is the problem you are having?\n<|/ c\
    \ |>\n<| c |>\nI tested it and it works. I used the example you provided. What\
    \ is the problem you are having?\n<|/ c |>\n<| a tags=java,arrays,math |>\n<code>\n\
    public static void main(String[] args) {\n    int[] numbers = {1, 2, 3, 4, 5};\n\
    \    int[] result = rescale_to_unit(numbers);\n    System.out.println(Arrays.toString(result));\n\
    }", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \         max = numbers[i];\n        if (numbers[i] < min)\n            min =\
    \ numbers[i];\n    }\n    float scale = (max - min) / (sum - 1);\n    for (int\
    \ i = 0; i < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt does work. Try\
    \ it with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt does work. Try it\
    \ with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it\
    \ with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| a tags=java,arrays,math |>\n\
    <code>\npublic static void main(String[] args) {\n    int[] numbers = {1, 2, 3,\
    \ 4, 5};\n    int[] result = rescale_to_unit(numbers);\n    System.out.println(Arrays.toString(result));\n\
    }", "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n     \
    \       min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    float[] result\
    \ = new float[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n\
    \        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given list\
    \ of numbers (of at least two elements), apply a linear transform to that list,\n\
    \    such that the smallest number will become 0 and the largest will become 1\n\
    \    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75,\
    \ 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float scale) \n{\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n/*\n Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n    such that the smallest number will become 0 and\
    \ the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    \    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers,\
    \ float scale, float offset) \n{\n    float min = numbers[0];\n    float max =\
    \ numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n        if(numbers[i] > max)\n      \
    \      max = numbers[i];\n    }\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; ++i)\n        result[i] = numbers[i] *\
    \ scale + offset;\n    return result;\n}\n/*\n Given list of numbers (of at least\
    \ two elements), apply a linear transform to that list,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
    \ numbers, float scale, float offset, float min) \n{\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n  \
    \  {\n        if(number", "{\n    float[] result = new float[numbers.length];\n\
    \    float minValue = numbers[0];\n    float maxValue = numbers[0];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] < minValue)\n\
    \        {\n            minValue = numbers[i];\n        }\n        if (numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n        }\n    }\n\
    \    float range = (maxValue - minValue);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - minValue;\n        result[i] /=\
    \ range;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static List<double> rescaleToUnit(List<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double range = max - min;\n    List<double> result = new List<double>();\n\
    \    double factor = range / numbers.Count;\n    for (int i = 0; i < numbers.Count;\
    \ i++)\n    {\n        result.Add(numbers[i] * factor + min);\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static List<double> rescaleToUnit(List<double> numbers)\n\
    {\n    double min = numbers.Min();\n    double max = numbers.Max();\n    double\
    \ range = max - min;\n    List<double> result = new List<double>();\n    double\
    \ factor = range / numbers.Count;\n    for (int i = 0; i < numbers.Count; i++)\n\
    \    {\n        result.Add(numbers[i] * factor + min);\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer.\n\
    <|/ c |>\n<| c |>\nPlease add some explanation to your answer.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\npublic static List<double> rescaleToUnit(List<double> numbers)\n\
    {\n    double min = numbers.Min();\n    double max = numbers.Max();\n    double\
    \ range = max - min;\n    List<double> result = new List<double>();\n    double\
    \ factor = range / numbers.Count;\n    for (int i = 0; i < numbers.Count; i++)\n\
    \    {\n        result.Add(numbers[i] * factor + min);\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| a dscore=0 |>\n<code>\npublic\
    \ static List<double> rescaleToUnit(List<double> numbers)\n{\n    double min =\
    \ numbers.Min();\n    double max = numbers.Max", "{\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n\
    \    float scale = (float)(range / numbers.length);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        numbers[i] = (numbers[i] - min) * scale;\n    return numbers;\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't work if\
    \ the numbers are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers\
    \ are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| a dscore=4 |>\nThis should work:\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    return ((value - min) / (max - min));\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't work if\
    \ the numbers are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers\
    \ are all negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n\
    <|/ c |>\n<| a tags=math,c#,algorithm,.net |>\n<code>\npublic static float RescaleToUnit(float\
    \ min, float max, float value)\n{\n    return ((value - min) / (max - min));\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if the numbers are all\
    \ negative.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>\npublic static float RescaleToUnit(float min,\
    \ float max, float value)\n{\n    return ((value - min) / (max - min));\n}\n</code>\n\
    <|/ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't work if the numbers\
    \ are all negative.\n", "{\n    float[] result = new float[numbers.length];\n\
    \    float minValue = numbers[0];\n    float maxValue = numbers[0];\n    float\
    \ minIndex = 0;\n    float maxIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n        else if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    float scale = (maxValue - minValue) / (maxIndex\
    \ - minIndex);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm,statistics\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers. Try rescale_to_unit([-10,\
    \ -20, -30, -40, -50]).\n<|/ c |>\n<| c |>\nI believe this should work. Try it\
    \ out and let me know if it doesn't.\n<|/ c |>\n<| c |>\nIt doesn't work if you\
    \ have negative numbers. Try rescale_to_unit([-10, -20, -30, -40, -50]).\n<|/\
    \ c |>\n<| c |>\nI believe this should work. Try it out and let me know if it\
    \ doesn't.\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers. Try\
    \ rescale_to_unit([-10, -20, -30, -40, -50]).\n<|/ c |>\n<| a dscore=5 |>\nThe\
    \ algorithm is called \"linear interpolation\".  It can be implemented with linear\
    \ interpolation.\n<code>\npublic static float InterpolateLinear(float a, float\
    \ b, float x)\n{\n    return a + (b - a) * x;\n}\n</code>\n<|/ a tags=c#,math,algorithm,statistics\
    \ |>\n<| c |>\nThis doesn't work if you have negative numbers. Try InterpolateLinear(-10,\
    \ -20, -10).\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers.\
    \ Try InterpolateLinear(-10, -20, -10).\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ you have negative numbers. Try InterpolateLinear(-10, -20, -10).\n<|/ c |>\n\
    <| c |>\nIt doesn't work if you have negative numbers. Try InterpolateLinear(-10,\
    \ -20, -10).\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers. ",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        float number = numbers[i];\n        if(number < min)\n         \
    \   min = number;\n        if(number > max)\n            max = number;\n     \
    \   result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays,math |>\n<| a dscore=0 |>\n<code>\npublic class\
    \ ArrayRescaleToUnit {", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; ++i)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - 1);\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| c |>\n\
    I like the idea of using an array, but this doesn't seem to work when there are\
    \ negative numbers in the array. For example, `rescale_to_unit([-10, -5, -4, -3,\
    \ -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4,\
    \ 5]`.\n<|/ c |>\n<| c |>\nI added a version that handles negative numbers. I\
    \ tested it and it seems to work fine.\n<|/ c |>\n<| c |>\nThis doesn't seem to\
    \ work when there are negative numbers in the array. For example, `rescale_to_unit([-10,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-10, -5, -4, -3, -2, -1, 0,\
    \ 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI added a version that handles negative\
    \ numbers. I tested it and it seems to work fine.\n<|/ c |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static void main(String[] args) {\n    int[] numbers = {-10,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};\n    int[] result = rescale_to_unit(numbers);\n\
    \    System.out.println(Arrays.toString(result));\n}", "{\n    float[] result\
    \ = new float[numbers.length];\n    float minValue = numbers[0];\n    float maxValue\
    \ = numbers[0];\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ > maxValue)\n            maxValue = numbers[i];\n        if(numbers[i] < minValue)\n\
    \            minValue = numbers[i];\n    }\n    float range = maxValue - minValue;\n\
    \    float scale = (float) range / numbers.length;\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n        result[i] = (float)(numbers[i] - minValue) * scale;\n    return\
    \ result;\n}", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for\
    \ (int i = 0; i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n  \
    \      if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; ++i)\n      \
    \  result[i] = numbers[i] * scale;\n    return result;\n}", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     sum += numbers[i];\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = 1.0f / (max - min);\n    for (int i = 0; i < numbers.length; i++)\n\
    \        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given list\
    \ of numbers (of at least two elements), apply a linear transform to that list,\n\
    \    such that the smallest number will become 0 and the largest will become 1\n\
    \    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75,\
    \ 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float min) \n{\n  \
    \  float[] result = new float[numbers.length];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     sum += numbers[i];\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = 1.0f / (max - min);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n/*\n Given\
    \ list of numbers (of at least two elements), apply a linear transform to that\
    \ list,\n    such that the smallest number will become 0 and the largest will\
    \ become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25,\
    \ 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float min,\
    \ float max) \n{\n    float[] result = new float[numbers.length];\n    float sum\
    \ = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n/*\n Given list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    such that the smallest\
    \ number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
    \ numbers, float min, float max, float sum) \n{\n    float[] result = new float[numbers.length];\n\
    \    float scale = 1.0f / (max - min);\n    for (int i = 0; i < numbers.length;\
    \ i++)", "{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] *= scale;\n\
    \    }\n    return result;\n}", "{\n    float min = float.MAX_VALUE;\n    float\
    \ max = float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(numbers[i] > max)\n    \
    \        max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        numbers[i] = (numbers[i] - min) / scale;\n\
    \    return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=java,arrays,algorithm,math\
    \ |>\nI wrote a Java program that does this in O(n) time. \n<code>\npublic class\
    \ ArrayRescale\n{\n    public static void main(String[] args)\n    {\n       \
    \ int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int[] rescaledNumbers\
    \ = rescale(numbers);\n        System.out.println(Arrays.toString(rescaledNumbers));\n\
    \    }", "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \       min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++)\n        numbers[i] = numbers[i] - min;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n    return numbers;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,.net,algorithm |>\n<code>\npublic\
    \ static class Math\n{\n    public static double Normalize(double value)\n   \
    \ {\n        return value / Math.Max(1.0, value);\n    }\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\npublic static double Normalize(double value)\n\
    {\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a tags=c#,math,.net,algorithm\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static double Normalize(double value)\n\
    {\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a tags=c#,math,.net,algorithm\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static double Normalize(double value)\n\
    {\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a tags=c#,math,.net,algorithm\
    \ |>\n<| a tags=c#,math,.net,algorithm |>\n<code>\npublic static double Normalize(double\
    \ value)\n{\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=c#,math,.net,algorithm |>\n<code>\npublic static double Normalize(double\
    \ value)\n{\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=c#,math,.net,algorithm |>\n<code>\npublic static double Normalize(double\
    \ value)\n{\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=c#,math,.net,algorithm |>\n<code>\npublic static double Normalize(double\
    \ value)\n{\n    return value / Math.Max(1.0, value);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static double Normalize(double value)\n\
    {\n    return ", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n  \
    \      if (numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \   }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work when you have negative numbers. For example, if your numbers are `[1.0,\
    \ 2.0, 3.0, 4.0, -5.0]`, then `rescale_to_unit` will return `[0.0, -0.25, -0.5,\
    \ -0.75, 1.0]`.\n<|/ c |>\n<| c |>\nI added a version that works with negative\
    \ numbers. I hope it helps.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ negative numbers. I hope it helps.\n<|/ c |>\n<| c |>\nThis doesn't work when\
    \ you have negative numbers. For example, if your numbers are `[1.0, 2.0, 3.0,\
    \ 4.0, -5.0]`, then `rescale_to_unit` will return `[0.0, -0.25, -0.5, -0.75, 1.0]`.\n\
    <|/ c |>\n<| c |>\nI added a version that works with negative numbers. I hope\
    \ it helps.\n<|/ c |>\n<| a dscore=2 |>\nThe solution I came up with is based\
    \ on a linear transformation that maps numbers from [min, max] to [0, 1].\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers) {\n    float[] result =\
    \ new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        sum\
    \ += numbers[i];\n        if (numbers[i] > max) {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min) {\n            min = numbers[i];\n \
    \       }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,math |>\n<| c |>\nThis\
    \ doesn't work when you have negative numbers. For example, if your numbers are\
    \ `[1.0, 2.0, 3.0, 4.0, -5.0]`, then `rescale_to_unit` will return `[0.0, -0.25,\
    \ -0.5, -0.75, 1.0]`.\n<|/ c |>\n<| c ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n           \
    \ max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = (max - min);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] = result[i]\
    \ / range;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI fixed the bug in the code. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0,\
    \ 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI fixed the bug in the code. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers)\n{\n    float[] result = new float[numbers.Length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.Length; i++)\n    {\n        if (numbers[i] > max)\n           \
    \ max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = (max - min);\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        result[i] = numbers[i] - min;\n        result[i] = result[i]\
    \ / range;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\n{\n    float[]\
    \ result = new float[numbers.Length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.Length; i++)\n    {\n   \
    \     if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float range = (max - min);\n\
    \    for (int i = 0; i < numbers.Length; i++)\n    {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] = result[i] / range;\n    }\n    return result;\n\
    }\n</code>\n<|/ a d", "{\n    float[] result = new float[numbers.length];\n  \
    \  float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i\
    \ < numbers.length; ++i)\n    {\n        float number = numbers[i];\n        if(number\
    \ < min)\n            min = number;\n        if(number > max)\n            max\
    \ = number;\n        result[i] = (number - min) / (max - min);\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work if you have\
    \ negative numbers. For example, if your array is [1.0, -2.0, 3.0, 4.0, -5.0],\
    \ the result will be [0.0, -0.5, 1.0, 1.5, 2.0]\n<|/ c |>\n<| c |>\nI didn't say\
    \ it wouldn't. That's why I said \"of at least two elements\". Your example array\
    \ has three elements. If you have more than two elements, then it won't work.\n\
    <|/ c |>\n<| c |>\nAh, I see what you mean. Yes, I missed that part. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a tags=math,c#,arrays |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers)\n{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        float number = numbers[i];\n\
    \        if(number < min)\n            min = number;\n        if(number > max)\n\
    \            max = number;\n        sum += number;\n        result[i] = (number\
    \ - min) / (max - min);\n    }\n    float average = sum / numbers.length;\n  \
    \  for(int i = 0; i < numbers.length; ++i)\n    {\n        result[i] += average;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. For example, if your array is [1.0, -2.0,\
    \ 3.0, 4.0, -5.0], the result will be [0.0, -0.5, 1.0, 1.5, 2.0]\n<|/ c |>\n<|\
    \ c |>\nI didn't say it wouldn't. That's why I said \"of at least two elements\"\
    . Your example array has three elements. If you have more than two elements, then\
    \ it won't work.\n<|/ c |>\n<| c |>\nI see what you mean. Yes, I missed that part.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a tags=math,c#,arrays |>\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers)\n{\n    float[] result\
    \ = new float[number", "{\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        else if(numbers[i] > max)\n          \
    \  max = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; ++i)\n        numbers[i] = (numbers[i]\
    \ - min) / scale;\n    return numbers;\n}", "{\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float range = max - min;\n\
    \    float scale = (float)(range == 0 ? 1 : range / max);\n    for(int i = 0;\
    \ i < numbers.length; ++i)\n        numbers[i] = (numbers[i] - min) * scale;\n\
    \    return numbers;\n}\n</code>\n<|/ a tags=math,java,algorithm |>\n<| c |>\n\
    This doesn't work if your numbers are all negative.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for negative numbers. Try it out with numbers = [-1, -2, -3, -4, -5]\n\
    <|/ c |>\n<| c |>\nI tested it and it doesn't work for negative numbers. Try it\
    \ out with numbers = [-1, -2, -3, -4, -5]\n<|/ c |>\n<| c |>\nIt works for negative\
    \ numbers. Try it out with numbers = [-1, -2, -3, -4, -5]\n<|/ c |>\n<| c |>\n\
    It works for negative numbers. Try it out with numbers = [-1, -2, -3, -4, -5]\n\
    <|/ c |>\n<| a tags=math,java,algorithm |>\n<code>\npublic static float rescaleToUnit(float\
    \ numbers[]) {\n    float min = numbers[0];\n    float max = numbers[0];\n   \
    \ for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] < min) {\n\
    \            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n \
    \           max = numbers[i];\n        }\n    }\n    float range = max - min;\n\
    \    float scale = (float) (range == 0 ? 1 : range / max);\n    for (int i = 0;\
    \ i < numbers.length; i++) {\n        numbers[i] = (numbers[i] - min) * scale;\n\
    \    }\n    return numbers;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ work if your numbers are all negative.\n<|/ c |>\n<| c |>\nIt doesn't work for\
    \ negative numbers. Try it out with numbers = [-1, -2, -3, -4, -5]\n<|/ c |>\n\
    <| c |>\nIt works for negative numbers. Try it out with numbers = [-1, -2, -3,\
    \ -4, -5]\n<|/ c |>\n<| c |>\nIt works for negative numbers. Try it out with numbers\
    \ = [-1, -2, -3, -4, -5]\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic static float[]\
    \ rescaleToUnit(float[] ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = max - min;\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    float range = max - min;\n \
    \   float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length; i++) {\n\
    \        numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return numbers;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static float[]\
    \ rescale(float[] numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float range = max - min;\n    float scale = 1.0f / range;\n    for(int i\
    \ = 0; i < numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return\
    \ numbers;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a dscore=1 |>\n<code>\n\
    public static float[] rescale(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float range = max - min;\n    float scale =\
    \ 1.0f / range;\n    for(int i = 0; i < numbers.length; i++) {\n        numbers[i]\
    \ *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a tags=java,arrays,math\
    \ |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[] rescale(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return numbers;\n\
    }\n</code>\n", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        float number = numbers[i];\n        if(number < min)\n\
    \            min = number;\n        if(number > max)\n            max = number;\n\
    \        result[i] = (number - min) / (max - min);\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't work if\
    \ the numbers are already in order. For example, `[1.0, 2.0, 3.0, 4.0, 5.0]` will\
    \ give `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not the desired result.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if the numbers are already in order. For example,\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]` will give `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is\
    \ not the desired result.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers\
    \ are already in order. For example, `[1.0, 2.0, 3.0, 4.0, 5.0]` will give `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`, which is not the desired result.\n<|/ c |>\n<| c |>\n\
    This doesn't work if the numbers are already in order. For example, `[1.0, 2.0,\
    \ 3.0, 4.0, 5.0]` will give `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not the desired\
    \ result.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are already in\
    \ order. For example, `[1.0, 2.0, 3.0, 4.0, 5.0]` will give `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]`, which is not the desired result.\n<|/ c |>\n<| a tags=math,c#,algorithm,.net\
    \ |>\n<code>\npublic static float RescaleToUnit(this float number)\n{\n    float\
    \ min = number;\n    float max = number;\n    float scale = 1.0f / (max - min);\n\
    \    return min + scale * (number - min);\n}\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nThis doesn't work if the numbers are already in order. For example, `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]` will give `[0.0, 0.25, 0.5, 0.75, 1.0]`, which is not the\
    \ desired result.\n<|/ c |>\n<| c |>\nThis doesn't work if the numbers are already\
    \ in order. For example, `[1.0, 2.0, 3.0, 4.0, 5.0]` will give `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]`, which is not the desired result.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the numbers are already ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, but should be `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\n: I fixed the bug, thanks. I forgot\
    \ to divide by `sum`.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\nI wrote a C#\
    \ version of this in another answer. \n<code>\npublic static class MathExtensions\n\
    {\n    public static float Normalize(this float value)\n    {\n        float min\
    \ = float.MaxValue;\n        float max = float.MinValue;\n        float sum =\
    \ 0;\n        float scale = 0;", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float range = (max - min);\n    float scale = (1.0f / range);\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,math,arrays,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0,\
    \ 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nI tested it and it works. I edited the answer to include\
    \ the full code\n<|/ c |>\n<| c |>\nI tested it and it works. I edited the answer\
    \ to include the full code\n<|/ c |>\n<| c |>\nI tested it and it works. I edited\
    \ the answer to include the full code\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I edited the answer to include the full code\n<|/ c |>\n<| a tags=java,math,arrays,algorithm\
    \ |>\nI believe this should work:\n<code>\npublic static void main(String[] args)\
    \ {\n    float[] numbers = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float[] result = rescale_to_unit(numbers);\n\
    \    System.out.println(Arrays.toString(result));\n}", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)range\
    \ / (float)numbers.length;\n    for(int i = 0; i < numbers.length; i++)\n    \
    \    result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nThe easiest way is to use MathUtils.clamp(float, float,\
    \ float) from the Apache Commons Math library:\n<code>\nfloat[] result = new float[numbers.length];\n\
    for (int i = 0; i < numbers.length; i++) {\n    result[i] = MathUtils.clamp(numbers[i],\
    \ 0, 1);\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if\
    \ (numbers[i] > max) {\n            max = numbers[i];\n        }\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n    }\n    float range =\
    \ max - min;\n    float scale = (float) range / (float) numbers.length;\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if\
    \ (numbers[i] > max) {\n            max = numbers[i];\n        }\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n    }\n    float range =\
    \ max - min;\n    float scale = (float) range / (float) numbers.length;\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if\
    \ (numbers[i] > max) {\n            max = numbers[i];\n        }\n        if (",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like the idea of using an accumulator to\
    \ find the min and max. However, the problem is that this approach doesn't take\
    \ into account the fact that there may be a negative number in the list. For example,\
    \ if the list is [1.0, 2.0, 3.0, 4.0, -5.0, 6.0], the min and max will be 1.0\
    \ and the sum will be 6.0, which is not what we want. Instead, we want to find\
    \ the min and max as if they were all positive.\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. I've updated my answer with a new method that should do what you want.\n\
    <|/ c |>\n<| c |>\nThanks for your help. I ended up using your method and added\
    \ a check to make sure that the minimum was always greater than the maximum.\n\
    <|/ c |>\n<| a dscore=1 |>\nI ended up using the method suggested by and added\
    \ a check to make sure that the minimum was always greater than the maximum.\n\
    <code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n    }\n    float scale =\
    \ (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,math |>\n<| a dscore=0 |>\nI wrote this in C# and tested\
    \ it against the other answers. I believe it works.\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    float range = max - min;\n    float scale = (float)(range\
    \ == 0 ? 1 : range / numbers.length);\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nI wrote this simple function which I believe is more\
    \ efficient than using Math.min/Math.max and also more readable:\n<code>\n/**\n\
    \ * Rescales an array of numbers to fit within a given range\n * \n * array The\
    \ array of numbers to rescale\n * min The minimum value of the range\n * max The\
    \ maximum value of the range\n * \n * A new array with the rescaled values\n */\n\
    public static float[] rescaleToRange(float[] array, float min, float max) {\n\
    \    float range = (max - min);\n    float scale = (range == 0) ? 1 : range /\
    \ array.length;\n    float[] result = new float[array.length];\n    for (int i\
    \ = 0; i < array.length; i++) {\n        result[i] = array[i] * scale;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=java,math |>\n<| a tags=java,math\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 0; i < numbers.length; ++i) {\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float range = max\
    \ - min;\n    float scale = (float)(range == 0 ? 1 : range / numbers.length);\n\
    \    for(int i = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=java,math\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 0; i < numbers.length; ++i) {\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float range = max\
    \ - min;\n    float scale = (float)(range == 0 ? 1 : range / numbers.length",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] > max)\n            max = numbers[i];\n        if\
    \ (numbers[i] < min)\n            min = numbers[i];\n    }\n    float range =\
    \ max - min;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= range;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays,math,algorithm |>\n<| a |>\nI came up with\
    \ this solution:\n<code>\npublic static float[] rescale(float[] numbers) {\n \
    \   float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float range = max - min;\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] /= range;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math,algorithm dscore=1 |>\n<| a tags=java,arrays,math,algorithm\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max)\n\
    \            max = numbers[i];\n        if (numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    for (int i = 0; i <\
    \ numbers.length; i++) {\n        result[i] = numbers[i] - min;\n        result[i]\
    \ /= range;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=java,arrays,math,algorithm\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max)\n\
    \            max = numbers[i];\n        if (numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float range = max - min;\n    for (int i = 0; i <\
    \ numbers.length; i++) {\n        result[i] = numbers[i] - min;\n        result[i]\
    \ /= range;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,arrays,math,algorithm\
    \ |>\n<code>\npublic static float[] rescale(float[] numbers) {\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];", "{\n    float[]\
    \ result = new float[numbers.length];\n    float minValue = numbers[0];\n    float\
    \ maxValue = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > maxValue)\n            maxValue = numbers[i];\n     \
    \   if(numbers[i] < minValue)\n            minValue = numbers[i];\n    }\n   \
    \ float range = (maxValue - minValue);\n    float scale = (range == 0) ? 0 : (1.0f\
    \ / (range * 2.0f));\n    for(int i = 0; i < numbers.length; i++)\n        result[i]\
    \ = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis doesn't work if the range is zero. Try `rescale_to_unit([0.0, 1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` which should give `[0.0, 0.25, 0.5, 0.75, 1.0]` but instead\
    \ gives `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nI believe this should\
    \ work, since `range` will be `0` when `numbers` only contains `0`. `range` will\
    \ be `1` when `numbers` only contains `1`.\n<|/ c |>\n<| c |>\nI believe this\
    \ should work, since `range` will be `0` when `numbers` only contains `0`. `range`\
    \ will be `1` when `numbers` only contains `1`.\n<|/ c |>\n<| c |>\nI believe\
    \ this should work, since `range` will be `0` when `numbers` only contains `0`.\
    \ `range` will be `1` when `numbers` only contains `1`.\n<|/ c |>\n<| c |>\nI\
    \ believe this should work, since `range` will be `0` when `numbers` only contains\
    \ `0`. `range` will be `1` when `numbers` only contains `1`.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float\
    \ minValue = numbers[0];\n    float maxValue = numbers[0];\n    float range =\
    \ 0;\n    float scale = 0;\n    for (int i = 0; i < numbers.length; i++) {\n \
    \       if (numbers[i] > maxValue) {\n            maxValue = numbers[i];\n   \
    \     }\n        if (numbers[i] < minValue) {\n            minValue = numbers[i];\n\
    \        }\n    }\n    range = maxValue - minValue;\n    scale = range == 0 ?\
    \ 0 : 1 / (range * 2);\n    float[] result = new float[numbers.length];\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        float number = numbers[i];\n      \
    \  min = min(number, min);\n        max = max(number, max);\n        result[i]\
    \ = (number - min) / (max - min);\n    }\n    return result;\n}\n</code>\n<|/\
    \ a tags=math,c#,algorithm,java |>\n<| c |>\nThis doesn't work if the list is\
    \ all zeroes or all ones. Try it on [this list](http://pastebin.com/raw.php?i=Y3qJkZgC).\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've updated my answer to account for\
    \ that.\n<|/ c |>\n<| c |>\nThis doesn't work if the list is all zeroes or all\
    \ ones. Try it on [this list](http://pastebin.com/raw.php?i=Y3qJkZgC).\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. I've updated my answer to account for that.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if the list is all zeroes or all ones. Try\
    \ it on [this list](http://pastebin.com/raw.php?i=Y3qJkZgC).\n<|/ c |>\n<| a dscore=3\
    \ |>\nThe algorithm is called \"linear interpolation\".  Wikipedia has a good\
    \ description of the algorithm.\n<|/ a tags=math,c#,algorithm,java |>\n<| a tags=math,c#,algorithm,java\
    \ |>\n<code>\npublic static float linearInterpolation(float[] numbers, float start,\
    \ float end) {\n    float total = 0;\n    float totalDiff = 0;\n    float totalDiffSquared\
    \ = 0;\n    float current = 0;\n    float currentDiff = 0;\n    float currentDiffSquared\
    \ = 0;\n    float currentDiffSquared2 = 0;\n    float currentDiffSquared3 = 0;\n\
    \    float currentDiffSquared4 = 0;\n    float currentDiffSquared5 = 0;\n    float\
    \ currentDiffSquared6 = 0;\n    float currentDiffSquared7 = 0;\n    float currentDiffSquared8\
    \ = 0;\n    float currentDiffSquared9 = 0;\n    float currentDiffSquared10 = 0;\n\
    \    float currentDiffSquared11 = 0;\n    float currentDiffSquared12 = 0;\n  \
    \  float currentDiffSquared13 = 0;\n    float currentDiffSquared14 = 0;\n    float\
    \ currentDiffSquared15 = 0;\n    float currentDiffSquared16 = 0;", "{\n    float\
    \ min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n     \
    \   max = max(max, numbers[i]);\n    }\n    float scale = (max - min) / (float)\
    \ numbers.length;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  numbers[i] = numbers[i] * scale;\n    }\n    return numbers;\n}\n</code>\n\
    <|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic\
    \ static float RescaleToUnit(float value)\n{\n    float min = float.MaxValue;\n\
    \    float max = float.MinValue;\n    foreach (float number in new float[] { value,\
    \ value + 1 })\n    {\n        min = Math.Min(min, number);\n        max = Math.Max(max,\
    \ number);\n    }\n    return ((value - min) / (max - min));\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static float RescaleToUnit(float\
    \ value)\n{\n    float min = float.MaxValue;\n    float max = float.MinValue;\n\
    \    foreach (float number in new float[] { value, value + 1 })\n    {\n     \
    \   min = Math.Min(min, number);\n        max = Math.Max(max, number);\n    }\n\
    \    return ((value - min) / (max - min));\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| a dscore=2 |>\n<code>\npublic static float RescaleToUnit(float value)\n\
    {", "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] > max)\n            max = numbers[i];\n        if\
    \ (numbers[i] < min)\n            min = numbers[i];\n    }\n    float range =\
    \ max - min;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= range;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work when all numbers are\
    \ negative.\n<|/ c |>\n<| c |>\nIt works fine for me with negative numbers. What\
    \ do you mean by \"doesn't work\"? It gives the wrong result for negative numbers?\n\
    <|/ c |>\n<| c |>\nYes, it gives the wrong result for negative numbers. I tested\
    \ it on [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10].\n<|/ c |>\n<| c |>\nOh, I see. I've edited my answer to fix the problem.\n\
    <|/ c |>\n<| a tags=math,algorithm,c# |>\nThe algorithm is pretty simple:", "{\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = 1.0f / (max - min);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; ++i)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\n\
    float [] array = {1.1, 2.2, 3.3, 4.4, 5.5};\nfloat [] array2 = new float[array.length];\n\
    float [] array3 = new float[array.length];\nfloat [] array4 = new float[array.length];\n\
    float [] array5 = new float[array.length];\nfloat [] array6 = new float[array.length];\n\
    float [] array7 = new float[array.length];\nfloat [] array8 = new float[array.length];\n\
    float [] array9 = new float[array.length];\nfloat [] array10 = new float[array.length];\n\
    float [] array11 = new float[array.length];\nfloat [] array12 = new float[array.length];\n\
    float [] array13 = new float[array.length];\nfloat [] array14 = new float[array.length];\n\
    float [] array15 = new float[array.length];\nfloat [] array16 = new float[array.length];\n\
    float [] array17 = new float[array.length];\nfloat [] array18 = new float[array.length];\n\
    float [] array19 = new float[array.length];\nfloat [] array20 = new float[array.length];\n\
    float [] array21 = new float[array.length];\nfloat [] array22 = new float[array.length];\n\
    float [] array23 = new float[array.length];\nfloat [] array24 = new float[array.length];\n\
    float [] array25 = new float[array.length];\nfloat [] array26 = new float[array.length];\n\
    float [] array27 = new float[array.length];\nfloat [] array28 = new float[array.length];\n\
    float [] array29 = new float[array.length];\nfloat [] array30 = new float[array.length];\n\
    float [] array31 = new float[array.length];\nfloat [] array32 = new float[array.length];\n\
    float [] array33 = new float[array.length];\nfloat [] array34 = new float[array.length];\n\
    float [] array35 = new float[array.length];\nfloat [] array36 = new float[array.length];\n\
    float [] ", "{\n    float[] result = new float[numbers.length];\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    for (int i = 0; i < numbers.length; i++)\n        result[i]\
    \ = numbers[i] - min;\n    for (int i = 0; i < numbers.length; i++)\n        result[i]\
    \ = result[i] / range;\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't seem to work. `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n\
    <| c |>\nI tested it and it works fine. Are you sure you copied it correctly?\n\
    <|/ c |>\n<| c |>\nYes, I copied it correctly. Maybe it's because I'm using a\
    \ different version of Scala? I'm using Scala 2.11.7\n<|/ c |>\n<| c |>\nI tested\
    \ it on 2.11.7 and it works fine. Are you sure you copied it correctly?\n<|/ c\
    \ |>\n<| c |>\nYes, I copied it correctly. Maybe it's because I'm using a different\
    \ version of Scala? I'm using Scala 2.11.7\n<|/ c |>\n<| a |>\n<code>\ndef rescale_to_unit(xs:\
    \ Seq[Double]): Seq[Double] = {\n  val min = xs.min\n  val max = xs.max\n  val\
    \ range = (max - min).toDouble\n  xs.map(x => (x - min) / range)\n}\n</code>\n\
    <|/ a dscore=2 tags=scala,arrays,math |>\n<| a tags=scala,arrays,math |>\n<code>\n\
    def rescale_to_unit(xs: Seq[Double]): Seq[Double] = {\n  val min = xs.min\n  val\
    \ max = xs.max\n  val range = (max - min).toDouble\n  xs.map(x => (x - min) /\
    \ range)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\ndef rescale_to_unit(xs:\
    \ Seq[Double]): Seq[Double] = {\n  val min = xs.min\n  val max = xs.max\n  val\
    \ range = (max - min).toDouble\n  xs.map(x => (x - min) / range)\n}\n</code>\n\
    <|/ a tags=scala,arrays,math |>\n<| a tags=scala,arrays,math ", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    float number = numbers[i];\n        if(number < min)\n            min = number;\n\
    \        if(number > max)\n            max = number;\n    }\n    float range =\
    \ max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}", "{\n\
    \    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \         max = numbers[i];\n        if (numbers[i] < min)\n            min =\
    \ numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n  \
    \  for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<|\
    \ c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n<| c |>\n\
    : Yes, it does. `Math.Abs()` will take care of that.\n<|/ c |>\n<| c |>\n: It\
    \ doesn't work if all numbers are negative. Try it with `[-11, -10, -9, -8, -7,\
    \ -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`.\n<|/ c |>\n<| c\
    \ |>\n: I didn't say it wouldn't work, I said it wouldn't work if all numbers\
    \ are negative.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't work, I said it\
    \ wouldn't work if all numbers are negative.\n<|/ c |>\n<| a tags=c#,math,algorithm\
    \ |>\n<code>\npublic static float RescaleToUnit(float numbers[])\n{\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n  \
    \      if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n      \
    \  numbers[i] = numbers[i] * scale;\n    return numbers[0];\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=c#,math,algorithm |>\n<code>\npublic static float RescaleToUnit(float\
    \ numbers[])\n{\n    float min = numbers[0];\n    float max = numbers[0];\n  \
    \  float sum = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n     \
    \   sum += numbers[i];\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length;\
    \ i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers[0];\n}\n",
  "{\n    float[] result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    float sum = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n        if(numbers[i] < min)\n      \
    \      min = numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't work when all numbers are negative.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. If you have negative numbers, just add `numbers[0]` to `sum`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work when all numbers are negative.\n<|/ c |>\n\
    <| c |>\nThis doesn't work when all numbers are negative.\n<|/ c |>\n<| c |>\n\
    This doesn't work when all numbers are negative.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\npublic static float RescaleToUnit(float value, float min, float max)\n\
    {\n    return (float)(value - min) / (max - min);\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't work when all numbers are negative.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work when all numbers are negative.\n<|/ c |>\n<| c |>\n\
    This doesn't work when all numbers are negative.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work when all numbers are negative.\n<|/ c |>\n<| c |>\nThis doesn't work when\
    \ all numbers are negative.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npublic static\
    \ float RescaleToUnit(float value, float min, float max)\n{\n    return (float)(value\
    \ - min) / (max - min);\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\n\
    This doesn't work when all numbers are negative.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work when all numbers are negative.\n<|/ c |>\n<| a tags=c#,math,algorithm |>\n\
    <code>\npublic static float RescaleToUnit(float value, float min, float max)\n\
    {\n    return (float)(", "{\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    float range = (max - min);\n    float scale = (1.0f\
    \ / range);\n    float[] result = new float[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a tags=java,arrays |>\n<code>\n\
    public static float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i) {\n\
    \        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    float range = (max - min);\n    float scale = (1.0f / range);\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ ++i) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=java,arrays |>\n<code>\npublic static\
    \ float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i) {\n        if(numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n        if(numbers[i] >\
    \ max) {\n            max = numbers[i];\n        }\n    }\n    float range = (max\
    \ - min);\n    float scale = (1.0f / range);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=java,arrays\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ ++i) {\n        if(numbers[i] < min) {\n            min = numbers[i];\n    \
    \    }\n        if(numbers[i] > max) {\n            max = numbers[i];\n      \
    \  }\n    }\n    float range = (max - min);\n    float scale = (1.0f / range);\n\
    \    float[] result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ ++i) {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - min;\n\
    \        min = Math.min(min, result[i]);\n        max = Math.max(max, result[i]);\n\
    \    }\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=c#,math,algorithm |>\nI wrote a C# version of this\
    \ algorithm that uses LINQ and is very fast (tested on large lists). \n<code>\n\
    public static IEnumerable<double> RescaleToUnit(IEnumerable<double> numbers)\n\
    {\n    double min = numbers.Min();\n    double max = numbers.Max();\n    double\
    \ scale = 1.0f / (max - min);\n    return numbers.Select(x => (x - min) * scale);\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis should be the accepted answer since\
    \ it uses LINQ and is very fast. Thanks!\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer since it uses LINQ and is very fast. Thanks!\n<|/ c |>\n<| a\
    \ dscore=4 |>\nI wrote a C# version of this algorithm that uses LINQ and is very\
    \ fast (tested on large lists). \n<code>\npublic static IEnumerable<double> RescaleToUnit(IEnumerable<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double scale = 1.0f / (max - min);\n    return numbers.Select(x => (x - min)\
    \ * scale);\n}\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| a tags=c#,math,algorithm\
    \ |>\nI wrote a C# version of this algorithm that uses LINQ and is very fast (tested\
    \ on large lists). \n<code>\npublic static IEnumerable<double> RescaleToUnit(IEnumerable<double>\
    \ numbers)\n{\n    double min = numbers.Min();\n    double max = numbers.Max();\n\
    \    double scale = 1.0f / (max - min);\n    return numbers.Select(x => (x - min)\
    \ * scale);\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>\npublic static\
    \ IEnumerable<double> RescaleToUnit(IEnumer", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        float current = numbers[i];\n     \
    \   if (current < min)\n            min = current;\n        if (current > max)\n\
    \            max = current;\n        result[i] = (current - min) / (max - min);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if\
    \ you have negative numbers. Try rescale_to_unit([-10, -5, -1, 0, 1, 5, 10])\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have negative numbers. Try rescale_to_unit([-10,\
    \ -5, -1, 0, 1, 5, 10])\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers. Try rescale_to_unit([-10, -5, -1, 0, 1, 5, 10])\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have negative numbers. Try rescale_to_unit([-10, -5,\
    \ -1, 0, 1, 5, 10])\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers. Try rescale_to_unit([-10, -5, -1, 0, 1, 5, 10])\n<|/ c |>\n<| a tags=math,c#,algorithm\
    \ |>\n<code>\npublic static float RescaleToUnit(float value)\n{\n    float min\
    \ = float.MaxValue;\n    float max = float.MinValue;\n    float scale = 1;\n \
    \   float result = 0;\n    while (value > 0)\n    {\n        min = float.MaxValue;\n\
    \        max = float.MinValue;\n        foreach (float f in value)\n        {\n\
    \            if (f < min)\n                min = f;\n            if (f > max)\n\
    \                max = f;\n        }\n        scale = max - min;\n        result\
    \ = result + (value - min) / scale;\n        value = scale;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have\
    \ negative numbers. Try rescale_to_unit([-10, -5, -1, 0, 1, 5, 10])\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have negative numbers. Try rescale_to_unit([-10,\
    \ -5, -1, 0, 1, 5, 10])\n<|/ c |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers. Try rescale_to_unit([-10, -5, -1, 0, 1, 5, 10])\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have negative numbers. Try rescale_to_unit([-10, -5,\
    \ -1, 0, 1, 5, 10])\n<|/ c ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\n\
    I tested it and it works fine. Did you try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`?\n\
    <|/ c |>\n<| c |>\nYes, I did. `[1.0, 2.0, 3.0, 4.0, 5.0]` gives `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\nI tested it again and it works fine. Did\
    \ you try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`?\n<|/ c |>\n<| c |>\nYes, I did.\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]` gives `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers)\
    \ {\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max) {\n      \
    \      max = numbers[i];\n        }\n        if (numbers[i] < min) {\n       \
    \     min = numbers[i];\n        }\n    }\n    float scale = (max - min) / (sum\
    \ - numbers[0]);\n    for (int i = 0; i < numbers.length; i++) {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,math\
    \ |>\n<| c |>\nPlease add some explanation to your answer such that others can\
    \ learn from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int i\
    \ = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        if (numbers[i]\
    \ > max) {\n            max = ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        min = Math.min(min, numbers[i]);\n\
    \        max = Math.max(max, numbers[i]);\n        result[i] = (numbers[i] - min)\
    \ / (max - min);\n    }\n    return result;\n}", "{\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n \
    \   for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=math,algorithm,c# |>\n<|\
    \ c |>\nThis doesn't seem to work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/\
    \ c |>\n<| c |>\nIt does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c\
    \ |>\nIt does work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a dscore=1 |>\nI believe\
    \ this should work:\n<code>\npublic static IEnumerable<double> RescaleToUnit(this\
    \ IEnumerable<double> numbers)\n{\n    double min = numbers.Min();\n    double\
    \ max = numbers.Max();\n    double scale = max - min;\n    double scale = 1.0\
    \ / scale;\n    foreach (double number in numbers)\n    {\n        yield return\
    \ number * scale;\n    }\n}\n</code>\n<|/ a tags=math,algorithm,c# |>\n<| c |>\n\
    This doesn't seem to work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n\
    <| c |>\nIt does work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt does\
    \ work for `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| a tags=math,algorithm,c# |>\n<code>\n\
    public static IEnumerable<double> RescaleToUnit(this IEnumerable<double> numbers)\n\
    {\n    double min = numbers.Min();\n    double max = numbers.", "{\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        numbers[i] *= scale;\n    return numbers;\n}\n</code>\n<|/ a tags=java,math\
    \ |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n<|/ c |>\n\
    <| c |>\nI added a version that works with negative numbers. I didn't want to\
    \ change your answer because I thought it would be better to keep it simple and\
    \ just show a working example with two numbers. But I guess it would be better\
    \ to just leave it here in case someone else finds it useful.\n<|/ c |>\n<| c\
    \ |>\nI added a version that works with negative numbers. I didn't want to change\
    \ your answer because I thought it would be better to keep it simple and just\
    \ show a working example with two numbers. But I guess it would be better to just\
    \ leave it here in case someone else finds it useful.\n<|/ c |>\n<| a tags=java,math\
    \ |>\n<code>\npublic static double getMinMax(List<Double> numbers) {\n    double\
    \ min = Double.MAX_VALUE;\n    double max = Double.MIN_VALUE;\n    for (Double\
    \ d : numbers) {\n        if (d < min) {\n            min = d;\n        }\n  \
    \      if (d > max) {\n            max = d;\n        }\n    }\n    return max\
    \ - min;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=java,math |>\n<code>\npublic\
    \ static double getMinMax(List<Double> numbers) {\n    double min = Double.MAX_VALUE;\n\
    \    double max = Double.MIN_VALUE;\n    for (Double d : numbers) {\n        if\
    \ (d < min) {\n            min = d;\n        }\n        if (d > max) {\n     \
    \       max = d;\n        }\n    }\n    return max - min;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\npublic static double getMinMax(List<Double> numbers)\
    \ {\n    double min = Double.MAX_VALUE;\n    double max = Double.MIN_VALUE;\n\
    \    for (Double d : numbers) {\n        if (d < min) {\n            min = d;\n\
    \        }\n        if (d > max) {\n            max = d;\n        }\n    }\n \
    \   return max - min;\n}\n</code>\n<|/ a tag", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = 1.0f / (max\
    \ - min);\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        float number = numbers[i];\n\
    \        min = min(number, min);\n        max = max(number, max);\n        result[i]\
    \ = (number - min) / (max - min);\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work if the numbers are all negative.\n\
    <|/ c |>\n<| c |>\nI added a version that works with negative numbers. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n    \
    \    min = Math.min(number, min);\n        max = Math.max(number, max);\n    \
    \    result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays |>\n<| a dscore=1 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n    \
    \    min = Math.min(number, min);\n        max = Math.max(number, max);\n    \
    \    result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays |>\n<| a dscore=1 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    for (int\
    \ i = 0; i < numbers.length; i++) {\n        float number = numbers[i];\n    \
    \    min = Math.min(number, min);\n        max = Math.max(number, max);\n    \
    \    result[i] = (number - min) / (max - min);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays |>\n<| a |>\n<code>\npublic static float[] rescale_to_unit(float[]\
    \ numbers) {\n    float[] result = new float[numbers.length];\n    float min =\
    \ Float.MAX_VALUE;\n    float max = Float.MIN_VALUE;\n    for (int i = 0; i <\
    \ numbers.length; i++) {\n        float number = numbers[i];\n        min = Math.min(number,\
    \ min);", "{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \       if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,c#,algorithm\
    \ |>\nI wrote this in C#:\n<code>\npublic static class Math\n{\n    public static\
    \ double Clamp(double value, double min, double max)\n    {\n        if (value\
    \ < min)\n            return min;\n        if (value > max)\n            return\
    \ max;\n        return value;\n    }", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = float.MAX_VALUE;\n    float max = float.MIN_VALUE;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        float number = numbers[i];\n\
    \        if(number < min)\n            min = number;\n        if(number > max)\n\
    \            max = number;\n        result[i] = (number - min) / (max - min);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,c#,algorithm\
    \ |>\nI used the above solution and modified it a little bit to make it more efficient.\n\
    <code>\npublic static float[] Rescale(float[] numbers)\n{\n    float[] result\
    \ = new float[numbers.Length];\n    float min = float.MaxValue;\n    float max\
    \ = float.MinValue;\n    float sum = 0;\n    float average = 0;\n    float sumOfSquares\
    \ = 0;\n    float averageOfSquares = 0;\n    float sumOfSquares2 = 0;\n    float\
    \ averageOfSquares2 = 0;\n    float sumOfSquares3 = 0;\n    float averageOfSquares3\
    \ = 0;\n    float sumOfSquares4 = 0;\n    float averageOfSquares4 = 0;\n    float\
    \ sumOfSquares5 = 0;\n    float averageOfSquares5 = 0;\n    float sumOfSquares6\
    \ = 0;\n    float averageOfSquares6 = 0;\n    float sumOfSquares7 = 0;\n    float\
    \ averageOfSquares7 = 0;\n    float sumOfSquares8 = 0;\n    float averageOfSquares8\
    \ = 0;\n    float sumOfSquares9 = 0;\n    float averageOfSquares9 = 0;\n    float\
    \ sumOfSquares10 = 0;\n    float averageOfSquares10 = 0;\n    float sumOfSquares11\
    \ = 0;\n    float averageOfSquares11 = 0;\n    float sumOfSquares12 = 0;\n   \
    \ float averageOfSquares12 = 0;\n    float sumOfSquares13 = 0;\n    float averageOfSquares13\
    \ = 0;\n    float sumOfSquares14 = 0;\n    float averageOfSquares14 = 0;\n   \
    \ float sumOfSquares15 = 0;\n    float averageOfSquares15 = 0;\n    float sumOfSquares16\
    \ = 0;\n    float averageOfSquares16 = 0;\n    float sumOfSquares17 = 0;\n   \
    \ float averageOfSquares17 = 0;\n    float sumOfSquares18 = 0;\n    float averageOfSquares18\
    \ = 0;\n    float sumOfSquares19 = 0;\n    float averageOfSquares19 = 0;\n   \
    \ float sumOfSquares20 = 0;\n    float ", "{\n    float min = numbers[0];\n  \
    \  float max = numbers[0];\n    for(int i = 1; i < numbers.length; ++i)\n    {\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; ++i)\n     \
    \   numbers[i] = numbers[i] - min;\n    for(int i = 0; i < numbers.length; ++i)\n\
    \        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list of numbers\
    \ (of at least two elements), apply a linear transform to that list,\n    such\
    \ that the smallest number will become 0 and the largest will become 1\n    >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    \    \n*/\nfloat[] rescale_to_unit(float[] numbers, float scale)\n{\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n        numbers[i] = numbers[i] - min;\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n        numbers[i] *= scale;\n    return numbers;\n}\n/*\n Given list\
    \ of numbers (of at least two elements), apply a linear transform to that list,\n\
    \    such that the smallest number will become 0 and the largest will become 1\n\
    \    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75,\
    \ 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float scale, float\
    \ offset)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n     \
    \       min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; ++i)\n        numbers[i] = numbers[i] - min;\n    for(int\
    \ i = 0; i < numbers.length; ++i)\n        numbers[i] *= scale;\n    for(int i\
    \ = 0; i < numbers.length; ++i)\n        numbers[i] += offset;\n    return numbers;\n\
    }\n/*\n Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    such that the smallest number will become 0 and the largest\
    \ will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, ",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math |>\n<| c |>\nThis doesn't seem to work. `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`, but `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 6.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0, 1.0]`.\n<|/\
    \ c |>\n<| c |>\nYes, I noticed that and fixed it. I had forgotten to update the\
    \ `max` variable in the `for` loop. Thanks for pointing that out.\n<|/ c |>\n\
    <| a dscore=2 |>\nI believe that this is what you are looking for:\n<code>\npublic\
    \ static float[] rescale_to_unit(float[] numbers) {\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] < min)\
    \ {\n            min = numbers[i];\n        }\n        if (numbers[i] > max) {\n\
    \            max = numbers[i];\n        }\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for (int i = 0; i < numbers.length; i++) {\n  \
    \      result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays,math |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers) {\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] * scale;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a tags=java,arrays,math\
    \ |>\n<code>\npublic static float[] rescale_to_unit(float[] numbers) {\n    float[]\
    \ result = new float[numbers.length];\n    ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if (numbers[i] > max)\n        {\n            max = numbers[i];\n   \
    \     }\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work when you have negative numbers. For example:\
    \ \n`[1.0, 2.0, 3.0, 4.0, 5.0]` becomes `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n\
    <| c |>\nI believe this works because `sum - numbers[0]` is always positive.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for negative numbers. `[1.0, 2.0, 3.0, 4.0,\
    \ 5.0]` becomes `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes `[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n\
    <| a tags=c#,math,algorithm |>\nI believe this should work:\n<code>\npublic static\
    \ float[] RescaleToUnit(float[] numbers)\n{\n    float min = numbers.Min();\n\
    \    float max = numbers.Max();\n    float sum = 0;\n    float scale = (max -\
    \ min) / (numbers.Sum() - numbers[0]);\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        numbers[i] = numbers[i] * scale;\n        sum += numbers[i];\n\
    \    }\n    float scale2 = sum / numbers.Length;\n    for (int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        numbers[i] *= scale2;\n    }\n    return numbers;\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work for negative numbers. `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]` becomes `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\n\
    This doesn't work for negative numbers. `[1.0, 2.0, 3.0, 4.0, 5.0]` becomes `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; ++i) {\n        if (numbers[i] < min) {\n            min\
    \ = numbers[i];\n        }\n        if (numbers[i] > max) {\n            max =\
    \ numbers[i];\n        }\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for (int i = 0; i < numbers.length; ++i) {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] *= scale;\n    }\n    return result;\n}", "{\n   \
    \ float[] result = new float[numbers.length];\n    float min = numbers[0];\n \
    \   float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        float number = numbers[i];\n        min = min(number, min);\n   \
    \     max = max(number, max);\n        result[i] = (number - min) / (max - min);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this\
    \ solution, but I wonder if there is a way to do this without having to import\
    \ the entire std namespace?\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require importing the entire std namespace\n<|/ c |>\n<| c |>\nI like the second\
    \ solution, but I wonder if there is a way to do this without having to import\
    \ the entire std namespace?\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require importing the entire std namespace\n<|/ c |>\n<| c |>\nI like the second\
    \ solution, but I wonder if there is a way to do this without having to import\
    \ the entire std namespace?\n<|/ c |>\n<| a tags=c++,math,algorithm |>\nThe easiest\
    \ way is to just divide each number by the maximum number in the list. \n<code>\n\
    float rescale_to_unit(float[] numbers)\n{\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        numbers[i]\
    \ = numbers[i] / max;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to import the entire std namespace?\n<|/ c |>\n<| c |>\nI added\
    \ a solution that doesn't require importing the entire std namespace\n<|/ c |>\n\
    <| a tags=c++,math,algorithm |>\n<code>\nfloat rescale_to_unit(float[] numbers)\n\
    {\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        max = max(max, numbers[i]);\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        numbers[i] = numbers[i] / max;\n    }\n    return numbers;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to do this without having to import the entire std namespace?\n\
    <|/ c |>\n<| c |>", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = (float) range / 2.0f;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n   \
    \ return result;\n}\n</code>\n<|/ a tags=java,math,algorithm,c# |>\n<| c |>\n\
    This doesn't work if you have a list of numbers with negative numbers. For example,\
    \ `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]` becomes `[-10, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5]` instead of `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4,\
    \ 5]`.\n<|/ c |>\n<| c |>\nI fixed the problem you mentioned, but I still think\
    \ this solution is better than mine.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers as well.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers as well.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers as well.\n<|/ c |>\n<| a dscore=5 |>\nThis can be\
    \ done with one line of code:\n<code>\ndouble min = Double.MAX_VALUE;\ndouble\
    \ max = Double.MIN_VALUE;\nfor(double d : numbers) {\n    min = Math.min(min,\
    \ d);\n    max = Math.max(max, d);\n}\ndouble range = max - min;\ndouble scale\
    \ = (double) range / 2.0d;\n</code>\n<|/ a tags=java,math,algorithm,c# |>\n<|\
    \ c |>\nThis doesn't work if you have a list of numbers with negative numbers.\
    \ For example, `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]` becomes `[-10, -5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]` instead of `[-10, -5, -4, -3, -2, -1, 0,\
    \ 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list of\
    \ numbers with negative numbers. For example, `[-10, -5, -4, -3, -2, -1, 0, 1,\
    \ 2, 3, 4, 5]` becomes `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]` instead of\
    \ `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a list of numbers with negative number", "{\n    float[] result\
    \ = new float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    float sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \        if(numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,math,algorithm,java |>\n<| c |>\nThis doesn't work if you have a\
    \ list of negative numbers. Try it with a list of `[-1.0, -2.0, -3.0, -4.0, -5.0]`.\n\
    <|/ c |>\n<| c |>\nI thought that would be the case but tested it and it works.\
    \ I added a comment to the code explaining why it works.\n<|/ c |>\n<| c |>\n\
    It doesn't work if you have a list of negative numbers. Try it with a list of\
    \ `[-1.0, -2.0, -3.0, -4.0, -5.0]`.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I added a comment to the code explaining why it works.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have a list of negative numbers. Try it with a list of\
    \ `[-1.0, -2.0, -3.0, -4.0, -5.0]`.\n<|/ c |>\n<| a dscore=5 |>\nThis works in\
    \ O(n) time and O(1) space:\n<code>\npublic static float[] rescale(float[] numbers)\
    \ {\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if(numbers[i] > max)\n         \
    \   max = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for(int i = 0;\
    \ i < numbers.length; i++) {\n        result[i] = numbers[i] * scale;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm,java |>\n<| c |>\n\
    This doesn't work if you have a list of negative numbers. Try it with a list of\
    \ `[-1.0, -2.0, -3.0, -4.0, -5.0]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have a list of negative numbers. Try it with a list of `[-1.0, -2.0, -3.0, -4.0,\
    \ -5.0]`.\n<|/ c |>\n<| c |>\nThis doesn't work", "{\n    float[] result = new\
    \ float[numbers.length];\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \            max = numbers[i];\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (float)(numbers.length\
    \ - 1);\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,math,algorithm\
    \ |>\n<| c |>\nThis doesn't work when numbers are very close to each other. For\
    \ example, `rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5,\
    \ 0.75, 1.0]` instead of `[0.0, 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| c |>\nI\
    \ tested it on [this example](http://ideone.com/X5NyZ) and it works fine. Can\
    \ you give an example where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it on\
    \ [this example](http://ideone.com/X5NyZ) and it works fine. Can you give an example\
    \ where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it on [this example](http://ideone.com/X5NyZ)\
    \ and it works fine. Can you give an example where it doesn't work?\n<|/ c |>\n\
    <| c |>\nI tested it on [this example](http://ideone.com/X5NyZ) and it works fine.\
    \ Can you give an example where it doesn't work?\n<|/ c |>\n<| a dscore=3 |>\n\
    I believe this should work:\n<code>\npublic static float RescaleToUnit(float min,\
    \ float max, float value)\n{\n    return min + ((value - min) / (max - min));\n\
    }\n</code>\n<|/ a tags=c#,math,algorithm |>\n<| c |>\nThis doesn't work when numbers\
    \ are very close to each other. For example, `RescaleToUnit(1.0, 2.0, 3.0)` returns\
    \ `2.0` instead of `3.0`.\n<|/ c |>\n<| c |>\nI tested it on [this example](http://ideone.com/X5NyZ)\
    \ and it works fine. Can you give an example where it doesn't work?\n<|/ c |>\n\
    <| c |>\nI tested it on [this example](http://ideone.com/X5NyZ) and it works fine.\
    \ Can you give an example ", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n \
    \   return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=java,math |>\nI wrote\
    \ this simple function which works fine for me:\n<code>\npublic static double\
    \ rescale(double x, double min, double max) {\n    return ((x - min) / (max -\
    \ min));\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote this simple\
    \ function which works fine for me:\n<code>\npublic static double rescale(double\
    \ x, double min, double max) {\n    return ((x - min) / (max - min));\n}\n</code>\n\
    <|/ a tags=java,math |>\n<| a |>\n<code>\npublic static double rescale(double\
    \ x, double min, double max) {\n    return ((x - min) / (max - min));\n}\n</code>\n\
    <|/ a tags=java,math dscore=2 |>\n<| a |>\n<code>\npublic static double rescale(double\
    \ x, double min, double max) {\n    return ((x - min) / (max - min));\n}\n</code>\n\
    <|/ a dscore=2 tags=java,math |>\n<| a tags=java,math |>\n<code>\npublic static\
    \ double rescale(double x, double min, double max) {\n    return ((x - min) /\
    \ (max - min));\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\npublic static\
    \ double rescale(double x, double min, double max) {\n    return ((x - min) /\
    \ (max - min));\n}\n</code>\n<|/ a tags=java,math dscore=2 |>\n<| a dscore=2 |>\n\
    <code>\npublic static double rescale(double x, double min, double max) {\n   \
    \ return ((x - min) / (max - min));\n}\n</code>\n<|/ a tags=java,math |>\n<| a\
    \ tags=java,math |>\n<code>\npublic static double rescale(double x, double min,\
    \ double max) {\n    return ((x - min) / (max - min));\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=java,math |>\n<code>\npublic static double rescale(double x, double\
    \ min, double max) {\n    return ((x - min) / (max - min", "{\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (numbers.length - 1);\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. `rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\n\
    I didn't test it for negative numbers. I assumed that they were all positive.\n\
    <|/ c |>\n<| c |>\nI tested it and it doesn't work for negative numbers. `rescale_to_unit([-5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it and it doesn't work for negative numbers.\
    \ `rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-5, -4,\
    \ -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI tested it and it doesn't\
    \ work for negative numbers. `rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| a tags=math,c#,algorithm\
    \ |>\nThis code will work for any number of numbers:\n<code>\npublic static float[]\
    \ rescale_to_unit(float[] numbers)\n{\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i = 1; i < numbers.Length; i++)\n    {\n    \
    \    if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.Length - 1);\n    float[] result = new float[numbers.Length];\n \
    \   for(int i = 0; i < numbers.Length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. `rescale_to_unit([-5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5])` returns `[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c ",
  "{\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \       min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    \n    float scale = (max - min) / (numbers.length - 1);\n    \n  \
    \  float[] result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] - min;\n    \n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] *= scale;\n    \n    return result;\n}\n</code>\n<|/\
    \ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't work if you have a list\
    \ of numbers that don't sum to 1.\n<|/ c |>\n<| c |>\n: It does work if you have\
    \ a list of numbers that don't sum to 1. Try it yourself. It will give the correct\
    \ result for that case.\n<|/ c |>\n<| c |>\n: It works fine for me with that list\
    \ of numbers. Try it yourself. It will give the correct result for that case.\n\
    <|/ c |>\n<| c |>\n: I added a solution that does work if you have a list of numbers\
    \ that don't sum to 1.\n<|/ c |>\n<| c |>\n: I added a solution that does work\
    \ if you have a list of numbers that don't sum to 1.\n<|/ c |>\n<| a tags=math,c#,algorithm,.net\
    \ |>\nI believe this is what you're looking for:\n<code>\npublic static float[]\
    \ RescaleToUnit(float[] numbers)\n{\n    float min = numbers[0];\n    float max\
    \ = numbers[0];", "{\n    float[] result = new float[numbers.length];\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ range = max - min;\n    float scale = 1.0f / range;\n    for(int i = 0; i <\
    \ numbers.length; ++i)\n        result[i] = numbers[i] * scale;\n    return result;\n\
    }\n/*\n Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n    such that the smallest number will become 0 and the largest\
    \ will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float\
    \ scale) \n{\n    float[] result = new float[numbers.length];\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] < min)\n            min = numbers[i];\n \
    \       if(numbers[i] > max)\n            max = numbers[i];\n    }\n    float\
    \ range = max - min;\n    for(int i = 0; i < numbers.length; ++i)\n        result[i]\
    \ = numbers[i] * scale;\n    return result;\n}\n/*\n Given list of numbers (of\
    \ at least two elements), apply a linear transform to that list,\n    such that\
    \ the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[]\
    \ numbers, float scale, float offset) \n{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float range = max - min;\n    for(int i = 0; i < numbers.length; ++i)\n\
    \        result[i] = numbers[i] * scale + offset;\n    return result;\n}\n/*\n\
    \ Given list of numbers (of at least two elements), apply a linear transform to\
    \ that list,\n    such that the smallest number will become 0 and the largest\
    \ will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\n    \n*/\nfloat[] rescale_to_unit(float[] numbers, float\
    \ scale, float offset, float min) \n{\n    float[] result = new float[number",
  "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++)\n        result[i] = numbers[i] - min;\n    float scale\
    \ = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\n       \
    \ result[i] *= scale;\n    return result;\n}", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n           \
    \ max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    for\
    \ (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] - min;\n\
    \    for (int i = 0; i < numbers.length; i++)\n        result[i] *= scale;\n \
    \   return result;\n}\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| c |>\n\
    I believe this does not work if you have negative numbers in the array. For example,\
    \ if you have [1.0, 2.0, 3.0, 4.0, -5.0, 6.0], the result will be [0.0, 0.25,\
    \ 0.5, 0.75, 1.0]\n<|/ c |>\n<| c |>\n: You are right. I've updated my answer\
    \ with a version that works with negative numbers.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. Try [1.0, 2.0, 3.0, 4.0, -5.0, 6.0]\n<|/ c |>\n<|\
    \ c |>\n: I've updated my answer with a version that works with negative numbers.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for negative numbers. Try [1.0, 2.0, 3.0,\
    \ 4.0, -5.0, 6.0]\n<|/ c |>\n<| a dscore=5 |>\nThe solution I came up with is\
    \ very similar to what Jon Skeet posted, but I thought I'd post it anyway in case\
    \ it helps someone else.\n<code>\npublic static double[] Rescale(double[] numbers,\
    \ double min, double max)\n{\n    double scale = (max - min) / (double)(numbers.Length\
    \ - 1);\n    double[] result = new double[numbers.Length];\n    for (int i = 0;\
    \ i < numbers.Length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=math,c#,algorithm,.net |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. Try [1.0, 2.0, 3.0, 4.0, -5.0, 6.0]\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work for negative numbers. Try [1.0, 2.0, 3.0, 4.0, -5.0,\
    \ 6.0]\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers. Try [1.0, 2.0,\
    \ 3.0, 4.0, -5.0, 6.0]\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ Try [1.0, 2.0, 3.0, 4.0, -5.0, 6.0]\n<|/ c |>\n<| a tags=math,c#,algorithm,.net ",
  "{\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] < min)\n            min\
    \ = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float range = (max - min);\n    float scale = 1.0f / range;\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=math,c#,algorithm |>\n<| c |>\nThis doesn't work if you\
    \ have a list of negative numbers. Try rescale_to_unit([-10, -5, -4, -3, -2, -1,\
    \ 0, 1, 2, 3, 4, 5])\n<|/ c |>\n<| c |>\nI added a version that handles negative\
    \ numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have a list of negative numbers. Try rescale_to_unit([-10, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5])\n<|/ c |>\n<| c |>\nI added a version that handles negative\
    \ numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have a list of negative numbers. Try rescale_to_unit([-10, -5, -4, -3, -2,\
    \ -1, 0, 1, 2, 3, 4, 5])\n<|/ c |>\n<| a dscore=4 |>\nI used the solution provided\
    \ by and modified it a little bit.\n<code>\npublic static class MathExtensions\n\
    {\n    public static float[] RescaleToUnit(float[] numbers)\n    {\n        if\
    \ (numbers.Length < 2)\n            return numbers;", "{\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n            min = numbers[i];\n        if(numbers[i]\
    \ > max)\n            max = numbers[i];\n    }\n    float[] result = new float[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i] -\
    \ min;\n    float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] *= scale;\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++) {\n        if(numbers[i] < min)\n          \
    \  min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++) {\n        result[i] = numbers[i] - min;\n    }\n   \
    \ float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\
    \ {\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++) {\n        if(numbers[i] < min)\n          \
    \  min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++) {\n        result[i] = numbers[i] - min;\n    }\n   \
    \ float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\
    \ {\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++) {\n        if(numbers[i] < min)\n          \
    \  min = numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n\
    \    }\n    float[] result = new float[numbers.length];\n    for(int i = 0; i\
    \ < numbers.length; i++) {\n        result[i] = numbers[i] - min;\n    }\n   \
    \ float scale = 1.0f / (max - min);\n    for(int i = 0; i < numbers.length; i++)\
    \ {\n        result[i] *= scale;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=1 ", "{\n    float[] result = new float[numbers.length];\n    float min\
    \ = numbers[0];\n    float max = numbers[0];\n    float sum = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (sum - numbers[0]);\n    for (int i = 0; i < numbers.length; i++)\n      \
    \  result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if all numbers are negative.\n<|/ c |>\n<| c\
    \ |>\nI added a version that works with negative numbers as well.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if all numbers are negative.\n<|/ c |>\n<| c |>\nI\
    \ added a version that works with negative numbers as well.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nfloat [] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (numbers[i] > max)\n   \
    \         max = numbers[i];\n        if (numbers[i] < min)\n            min =\
    \ numbers[i];\n    }\n    float scale = (max - min) / (sum - numbers[0]);\n  \
    \  for (int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n  \
    \  return numbers;\n}\n</code>\n<|/ a tags=java,math |>\n<| c |>\nThis doesn't\
    \ work if all numbers are negative.\n<|/ c |>\n<| c |>\nI added a version that\
    \ works with negative numbers as well.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic\
    \ static float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        sum += numbers[i];\n        if (numbers[i] > max)\n        \
    \    max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum - numbers[0]);\n    for (int i =\
    \ 0; i < numbers.length; i++) {\n        numbers[i] *= scale;\n    }\n    return\
    \ numbers;\n}\n</code>\n<|/ a tags=java,math |>\n<| a tags=java,math |>\n<code>\n\
    public static float[] rescale_to_unit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    for (int i = 0; i < number",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] > max)\n            max = numbers[i];\n        if(numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n     \
    \   result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't seem to work. Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n\
    <|/ c |>\n<| c |>\nIt works fine for me. `[1.0, 2.0, 3.0, 4.0, 5.0]` returns `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nIt doesn't work for me either. `[1.0,\
    \ 2.0, 3.0, 4.0, 5.0]` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\n\
    It works for me too. `[1.0, 2.0, 3.0, 4.0, 5.0]` returns `[0.0, 0.25, 0.5, 0.75,\
    \ 1.0]`\n<|/ c |>\n<| c |>\nIt works for me too. `[1.0, 2.0, 3.0, 4.0, 5.0]` returns\
    \ `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static\
    \ float[] rescale_to_unit(float[] numbers)\n{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    float scale = (max\
    \ - min) / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,c#,algorithm |>\n<| c |>\nThis doesn't seem to work.\
    \ Try it with `[1.0, 2.0, 3.0, 4.0, 5.0]`\n<|/ c |>\n<| c |>\nIt works for me\
    \ too. `[1.0, 2.0, 3.0, 4.0, 5.0]` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/\
    \ c |>\n<| c |>\nIt works for me too. `[1.0, 2.0, 3.0, 4.0, 5.0]` returns `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| c |>\nIt works for me too. `[1.0, 2.0,\
    \ 3.0, 4.0, 5.0]` returns `[0.0, 0.25, 0.5, 0.75, 1.0]`\n<|/ c |>\n<| a d", "{\n\
    \    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    float sum2 = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n  \
    \      sum2 += numbers[i] * numbers[i];\n        if (numbers[i] > max)\n     \
    \       max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum2 - sum * sum);\n    for (int i =\
    \ 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,arrays,math |>\n<| a |>\n<code>\npublic\
    \ static float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    float sum = 0;\n    float sum2 = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n       \
    \ sum2 += numbers[i] * numbers[i];\n        if (numbers[i] > max)\n          \
    \  max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (sum2 - sum * sum);\n    float[] result\
    \ = new float[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n\
    \        result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 tags=java,arrays,math |>\n<| a dscore=0 |>\n<code>\npublic static\
    \ float[] rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    float sum = 0;\n    float sum2 = 0;\n    for (int i =\
    \ 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        sum2 += numbers[i]\
    \ * numbers[i];\n        if (numbers[i] > max)\n            max = numbers[i];\n\
    \        if (numbers[i] < min)\n            min = numbers[i];\n    }\n    float\
    \ scale = (max - min) / (sum2 - sum * sum);\n    float[] result = new float[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i]\
    \ * scale;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,math\
    \ |>\n<| a tags=java,arrays,math |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers) {\n    float min = numbers[0];\n    float max = numbers[0];\n    float\
    \ sum = 0;\n    float sum2 = 0;\n    for (int i = 0; i < numbers.length; i++)\
    \ {\n        sum += numbers[i];\n        sum2 += numbers[i] * numbers[i];\n  \
    \      if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (", "{\n   \
    \ float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] < min)\n            min =\
    \ numbers[i];\n        if(numbers[i] > max)\n            max = numbers[i];\n \
    \   }\n    float scale = (max - min) / (float)(numbers.length - 1);\n    float[]\
    \ result = new float[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if the numbers are in descending\
    \ order. Try with [1,2,3,4,5] and [5,4,3,2,1]\n<|/ c |>\n<| c |>\nI didn't test\
    \ it but I think it should work. Can you give me an example where it doesn't work?\n\
    <|/ c |>\n<| c |>\nI tested it and it doesn't work. Try with [1,2,3,4,5] and [5,4,3,2,1]\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I added an example to the answer.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I added an example to the answer.\n\
    <|/ c |>\n<| a tags=java,math,algorithm |>\nI believe this should work:\n<code>\n\
    public static float rescaleToUnit(float[] numbers) {\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n\
    \        if(numbers[i] < min) {\n            min = numbers[i];\n        }\n  \
    \      if(numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    float scale = (max - min) / (numbers.length - 1);\n    float[] result = new\
    \ float[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n    \
    \    result[i] = numbers[i] * scale;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if the numbers are in descending\
    \ order. Try with [1,2,3,4,5] and [5,4,3,2,1]\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I added an example to the answer.\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works. I added an example to the answer.\n<|/ c |>\n<| a tags=java,math,algorithm\
    \ |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers) {\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++) {\n        if(numbers[i] < min) {\n            min = number", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float range = max - min;\n\
    \    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ - min;\n    for (int i = 0; i < numbers.length; i++)\n        result[i] = result[i]\
    \ / range;\n    return result;\n}", "{\n    float min = float.MaxValue;\n    float\
    \ max = float.MinValue;\n    foreach (float n in numbers) {\n        min = Mathf.Min(min,\
    \ n);\n        max = Mathf.Max(max, n);\n    }\n    float[] result = new float[numbers.Length];\n\
    \    for (int i = 0; i < numbers.Length; i++) {\n        result[i] = (numbers[i]\
    \ - min) / (max - min);\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis does not work if your input array has negative numbers. For\
    \ example, `rescale_to_unit([-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns\
    \ `[-1.0000000, -0.2500000, -0.1250000, -0.0000000, 0.2500000, 0.5000000, 0.6250000,\
    \ 0.7500000, 0.8750000, 1.0000000]`\n<|/ c |>\n<| a |>\nThe accepted answer does\
    \ not work if your input array has negative numbers. For example, rescale_to_unit([-10,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) returns [-1.0000000, -0.2500000, -0.1250000,\
    \ -0.0000000, 0.2500000, 0.5000000, 0.6250000, 0.7500000, 0.8750000, 1.0000000]\n\
    The accepted answer does not work if your input array has negative numbers. For\
    \ example, rescale_to_unit([-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) returns\
    \ [-1.0000000, -0.2500000, -0.1250000, -0.0000000, 0.2500000, 0.5000000, 0.6250000,\
    \ 0.7500000, 0.8750000, 1.0000000]\nThe accepted answer does not work if your\
    \ input array has negative numbers. For example, rescale_to_unit([-10, -5, -4,\
    \ -3, -2, -1, 0, 1, 2, 3, 4, 5]) returns [-1.0000000, -0.2500000, -0.1250000,\
    \ -0.0000000, 0.2500000, 0.5000000, 0.6250000, 0.7500000, 0.8750000, 1.0000000]\n\
    The accepted answer does not work if your input array has negative numbers. For\
    \ example, rescale_to_unit([-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) returns\
    \ [-1.0000000, -0.2500000, -0.1250000, -0.0000000, 0.2500000, 0.5000000, 0.6250000,\
    \ 0.7500000, 0.8750000, 1.0000000]\nThe accepted answer does not work if your\
    \ input array has negative numbers. For example, rescale_to_unit([-10, -5, -4,\
    \ -3, -2, -1, 0, 1, 2, 3, 4, 5]) returns [-1.0000000, -0.2500000, -0.1250000,\
    \ -0.0000000, 0.2500000, 0.5000000, 0.6250000, 0.7500000, 0.8750000, 1.0000000]\n\
    The accepted answer does not work", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n        if (numbers[i] < min)\n   \
    \     {\n            min = numbers[i];\n        }\n    }\n    float range = max\
    \ - min;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i] - min;\n        result[i] /= range;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `rescale_to_unit([-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-10,\
    \ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]` instead of `[-10, -5, -4, -3, -2, -1,\
    \ 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n<| c |>\nI see what you mean. I've edited my\
    \ answer to include a version that works with negative numbers.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work for negative numbers. `rescale_to_unit([-10, -5, -4,\
    \ -3, -2, -1, 0, 1, 2, 3, 4, 5])` returns `[-10, -5, -4, -3, -2, -1, 0, 1, 2,\
    \ 3, 4, 5]` instead of `[-10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]`.\n<|/ c |>\n\
    <| c |>\nI see what you mean. I've edited my answer to include a version that\
    \ works with negative numbers.\n<|/ c |>\n<| a tags=math,c# |>\nI wrote a function\
    \ that does this for me:\n<code>\npublic static double[] rescaleToUnit(double[]\
    \ numbers)\n{\n    double min = numbers[0];\n    double max = numbers[0];\n  \
    \  for (int i = 0; i < numbers.Length; i++)\n    {\n        if (numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min)\n        {\n            min = numbers[i];\n        }\n    }\n    double\
    \ range = max - min;\n    double[] result = new double[numbers.Length];\n    for\
    \ (int i = 0; i < numbers.Length; i++)\n    {\n        result[i] = numbers[i]\
    \ - min;\n        result[i] /= range;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>\npublic static double[] rescaleToUnit(double[]\
    \ numbers)\n{\n    double min = numbers[0];\n    double max = numbers[0];\n  \
    \  for (int i = 0; i < numbers.Length; i++)\n    {\n        if (numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n        if (numbers[i] <\
    \ min)\n        {\n            min = number", "{\n    float[] result = new float[numbers.length];\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n        if(numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.length - 1);\n    for(int i =\
    \ 0; i < numbers.length; i++)\n        result[i] = numbers[i] * scale;\n    return\
    \ result;\n}", "{\n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \            min = numbers[i];\n        if(numbers[i] > max)\n            max\
    \ = numbers[i];\n    }\n    float scale = (max - min) / (numbers.length - 1);\n\
    \    for(int i = 0; i < numbers.length; i++)\n        numbers[i] *= scale;\n \
    \   return numbers;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ if you have a list of negative numbers. I believe it only works if you have\
    \ a list of positive numbers. I believe it only works if you have a list of numbers\
    \ that are all positive.\n<|/ c |>\n<| c |>\nIt works with negative numbers. I\
    \ tested it before posting it. I also tested it on negative numbers and it works\
    \ fine.\n<|/ c |>\n<| c |>\nIt works with negative numbers. I tested it before\
    \ posting it. I also tested it on negative numbers and it works fine.\n<|/ c |>\n\
    <| c |>\nIt works with negative numbers. I tested it before posting it. I also\
    \ tested it on negative numbers and it works fine.\n<|/ c |>\n<| c |>\nIt works\
    \ with negative numbers. I tested it before posting it. I also tested it on negative\
    \ numbers and it works fine.\n<|/ c |>\n<| a |>\n<code>\nfunction rescale_to_unit(numbers)\
    \ {\n    var min = numbers[0];\n    var max = numbers[0];\n    for(var i = 1;\
    \ i < numbers.length; i++) {\n        if(numbers[i] < min) {\n            min\
    \ = numbers[i];\n        }\n        if(numbers[i] > max) {\n            max =\
    \ numbers[i];\n        }\n    }\n    var scale = (max - min) / (numbers.length\
    \ - 1);\n    for(var i = 0; i < numbers.length; i++) {\n        numbers[i] *=\
    \ scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=2 tags=math,algorithm,c#\
    \ |>\n<| a tags=math,algorithm,c# |>\n<code>\npublic static double[] rescale_to_unit(double[]\
    \ numbers) {\n    double min = numbers[0];\n    double max = numbers[0];\n   \
    \ for(int i = 1; i < numbers.length; i++) {\n        if(numbers[i] < min) {\n\
    \            min = numbers[i];\n        }\n        if(numbers[i] > max) {\n  \
    \          max = numbers[i];\n        }\n    }\n    double scale = (max - min)\
    \ / (numbers.length - 1);\n    for(int i = 0; i < numbers.length; i++) {\n   \
    \     numbers[i] *= scale;\n    }\n    return numbers;\n}\n</code>\n<|/ a dscore=2 ",
  "{\n    float[] result = new float[numbers.length];\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (int i = 0; i < numbers.length; ++i)\n \
    \   {\n        if (numbers[i] > max)\n            max = numbers[i];\n        if\
    \ (numbers[i] < min)\n            min = numbers[i];\n    }\n    float scale =\
    \ (max - min) / (numbers.length - 1);\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,arrays,algorithm |>\n<| c |>\nThis doesn't work if you have negative\
    \ numbers. You have to check `if (numbers[i] < min)` before you do the `if` statement\
    \ to make sure you aren't dividing by zero.\n<|/ c |>\n<| c |>\nI added a version\
    \ that handles negative numbers as well.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for negative numbers. `numbers.length` should be `numbers.length - 1`.\n<|/\
    \ c |>\n<| c |>\nI fixed the typo. Thanks for pointing that out.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>\npublic static float[] rescaleToUnit(float[] numbers)\n\
    {\n    float min = numbers[0];\n    float max = numbers[0];\n    for (int i =\
    \ 0; i < numbers.Length; i++)\n    {\n        if (numbers[i] > max)\n        \
    \    max = numbers[i];\n        if (numbers[i] < min)\n            min = numbers[i];\n\
    \    }\n    float scale = (max - min) / (numbers.Length - 1);\n    float[] result\
    \ = new float[numbers.Length];\n    for (int i = 0; i < numbers.Length; i++)\n\
    \        result[i] = numbers[i] * scale;\n    return result;\n}\n</code>\n<|/\
    \ a tags=c#,arrays,algorithm |>\n<| a dscore=2 |>\n<code>\npublic static float[]\
    \ rescaleToUnit(float[] numbers)\n{\n    float min = numbers[0];\n    float max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.Length; i++)\n    {\n       \
    \ if (numbers[i] > max)\n            max = numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n    }\n    float scale = (max - min)\
    \ / (numbers.Length - 1);\n    float[] result = new float[numbers.Length];\n \
    \   for (int i = 0; i < numbers.Length; i++)\n        result[i] = numbers[i] *\
    \ scale;\n    return result;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n\
    <| a tags=c#,arrays,algorithm |>\n<code>\npublic static float[] rescaleToUnit(float[]\
    \ numbers)\n{\n    float min = numbers[0];\n    float max = numbers[0];\n    for\
    \ (int i = 0; i < numbers.Length; i++)\n    {\n        if (", "{\n    float[]\
    \ result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n    float\
    \ max = float.MIN_VALUE;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        float number = numbers[i];\n        if(number < min)\n            min\
    \ = number;\n        if(number > max)\n            max = number;\n        result[i]\
    \ = (number - min) / (max - min);\n    }\n    return result;\n}\n</code>\n<|/\
    \ a tags=java,arrays |>\n<| a dscore=0 |>\n<code>\npublic class ArrayRescaleToUnit\
    \ {", "{\n    float[] result = new float[numbers.length];\n    float min = float.MAX_VALUE;\n\
    \    float max = float.MIN_VALUE;\n    float sum = 0;\n    for (int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        if (numbers[i]\
    \ < min)\n            min = numbers[i];\n        if (numbers[i] > max)\n     \
    \       max = numbers[i];\n    }\n    float scale = (max - min) / (float) sum;\n\
    \    for (int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i]\
    \ * scale;\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if the numbers are very close to each other. For example, `rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])` returns `[0.0, 0.25, 0.5, 0.75, 1.0]` instead of `[0.0,\
    \ 0.25, 0.5, 0.75, 1.0]`.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a small library\
    \ that does this for you:\n<code>\nimport std.math;\nimport std.typecons;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
