name: HumanEval_2_truncate_number
language: humaneval_to_dlang.py
results:
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number - floor(number);\n    float result = floor(number);\n    \n    if (decimals\
    \ > 0.0f)\n    {\n        result += decimals;\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkn9nix5e.d(29): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ef5]\\n??:? void tmpkn9nix5e.__unittest_L25_C1()\
    \ [0x427c06]\\n??:? void tmpkn9nix5e.__modtest() [0x427c74]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd5f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abf2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430234]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42abc9]\\n??:? runModuleUnitTests [0x42bb35]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428344]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282cb]\\n??:? _d_run_main [0x428236]\\n??:? main [0x427c87]\\\
    n??:? __libc_start_main [0x5ad04554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjtwexnm3.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjtwexnm3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long) number;\n    long long int decimalPart = (intPart % 1);\n\
    \    \n    return (float) decimalPart;\n}\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwn11btgy.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmpwn11btgy.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmpwn11btgy.d(15): Error: found `long` when expecting `.` following\
    \ long\\n/tmp/tmpwn11btgy.d(15): Error: found `)` when expecting identifier following\
    \ `long`.\\n/tmp/tmpwn11btgy.d(15): Error: found `number` when expecting `)`\\\
    n/tmp/tmpwn11btgy.d(16): Error: use `long` for a 64 bit integer instead of `long\
    \ long`\\n/tmp/tmpwn11btgy.d(16): Error: no identifier for declarator `long`\\\
    n/tmp/tmpwn11btgy.d(18): Error: C style cast illegal, use `cast(float)decimalPart`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwn11btgy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgx_zsh9a.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpgx_zsh9a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part = number - truncate_number(floorf(number));\n    integer_part\
    \ = trunc(number);\n    return decimal_part + integer_part;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzg20bloj.d(16): Error: undefined identifier `floorf`, did you\
    \ mean function `floor`?\\n/tmp/tmpzg20bloj.d(17): Error: cannot implicitly convert\
    \ expression `trunc(cast(real)number)` of type `real` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzg20bloj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq50_s5ru.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpq50_s5ru.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ * pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv7bczw7g.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpv7bczw7g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    float\
    \ quotient = 0.0;\n    float quotient2 = 0.0;\n    float quotient3 = 0.0;\n  \
    \  float quotient4 = 0.0;\n    float quotient5 = 0.0;\n    float quotient6 = 0.0;\n\
    \    float quotient7 = 0.0;\n    float quotient8 = 0.0;\n    float quotient9 =\
    \ 0.0;\n    float quotient10 = 0.0;\n    float quotient11 = 0.0;\n    float quotient12\
    \ = 0.0;\n    float quotient13 = 0.0;\n    float quotient14 = 0.0;\n    float\
    \ quotient15 = 0.0;\n    float quotient16 = 0.0;\n    float quotient17 = 0.0;\n\
    \    float quotient18 = 0.0;\n    float quotient19 = 0.0;\n    float quotient20\
    \ = 0.0;\n    float quotient21 = 0.0;\n    float quotient22 = 0.0;\n    float\
    \ quotient23 = 0.0;\n    float quotient24 = 0.0;\n    float quotient25 = 0.0;\n\
    \    float quotient26 = 0.0;\n    float quotient27 = 0.0;\n    float quotient28\
    \ = 0.0;\n    float quotient29 = 0.0;\n    float quotient30 = 0.0;\n    float\
    \ quotient31 = 0.0;\n    float quotient32 = 0.0;\n    float quotient33 = 0.0;\n\
    \    float quotient34 = 0.0;\n    float quotient35 = 0.0;\n    float quotient36\
    \ = 0.0;\n    float quotient37 = 0.0;\n    float quotient38 = 0.0;\n    float\
    \ quotient39 = 0.0;\n    float quotient40 = 0.0;\n    float quotient41 = 0.0;\n\
    \    float quotient42 = 0.0;\n    float quotient43 = 0.0;\n    float quotient44\
    \ = 0.0;\n    float quotient45 = 0.0;\n    float quotient46 = 0.0;\n    float\
    \ quotient47 = 0.0;\n    float quotient48 = 0.0;\n    float quotient49 = 0.0;\n\
    \    float quotient50 = 0.0;\n    float quotient51 = 0.0;\n    float quotient52\
    \ = 0.0;\n    float quotient53 = 0.0;\n    float quotient54 = 0.0;\n    float\
    \ quotient55 = 0.0;\n    float quotient56 = 0.0;\n    float quotient57 = 0.0;\n\
    \    float quotient58 = 0.0;\n    float quotient59 = 0.0;\n    float quotient60\
    \ = 0.0;\n    float \nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph8bdsjaj.d(79): Error: no identifier for declarator `float`\\\
    n/tmp/tmph8bdsjaj.d(79): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph8bdsjaj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwzgermud.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpwzgermud.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ffcmtz_.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmp6ffcmtz_.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmp6ffcmtz_.d(16): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmp6ffcmtz_.d(16): Error: no identifier for declarator\
    \ `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ffcmtz_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl70babj3.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpl70babj3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) \n\
    \    {\n        remainder = number - integerPart - decimalPart;\n    }\n    else\
    \ \n    {\n        remainder = 0.0f;\n    }\n    \n    return remainder;\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp68ddbbwh.d(19): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\n/tmp/tmp68ddbbwh.d(20): Error: cannot implicitly\
    \ convert expression `number - cast(float)integerPart` of type `float` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp68ddbbwh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo1mn8kwa.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpo1mn8kwa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number / float(10);\n    remainder = number % float(10);\n    decimals = remainder\
    \ * float(10);\n    \n    result = quotient + decimals;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmps6gr0lt1.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dcd]\\n??:? void tmps6gr0lt1.__unittest_L27_C1()\
    \ [0x427ade]\\n??:? void tmps6gr0lt1.__modtest() [0x427b4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a986]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a95d]\\n??:? runModuleUnitTests [0x42b8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42821c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281a3]\\n??:? _d_run_main [0x42810e]\\n??:? main [0x427b5f]\\\
    n??:? __libc_start_main [0x49589554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\n    int decimal_places =\
    \ 1;\n    \n    while(number > 0)\n    {\n        remainder = number % 10;\n \
    \       number = number / 10;\n        exponent = decimal_places - 1;\n      \
    \  \n        if(exponent < 0)\n        {\n            exponent = 0;\n        }\n\
    \        \n        if(remainder > 0)\n        {\n            result += remainder\
    \ * pow(10.0, exponent);\n        }\n        \n        decimal_places++;\n   \
    \ }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuhcigisc.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f8d]\\n??:? void tmpuhcigisc.__unittest_L41_C1()\
    \ [0x427b7a]\\n??:? void tmpuhcigisc.__modtest() [0x427d10]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bcb3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ab46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fcd9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430188]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fc65]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab1d]\\n??:? runModuleUnitTests [0x42ba89]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4283dc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428363]\\n??:? _d_run_main [0x4282ce]\\n??:? main [0x427d23]\\\
    n??:? __libc_start_main [0x4b1c7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp82xrwo79.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp82xrwo79.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = trunc(frac_part);\n\
    \    return frac_part - int_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3q8j4_2.d(17): Error: cannot implicitly convert expression `trunc(cast(real)frac_part)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpf3q8j4_2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm21q9osn.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpm21q9osn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1h608zb7.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp1h608zb7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0cv6tfjr.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp0cv6tfjr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmoc2w2wa.d(23): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmoc2w2wa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder = 0;\n    float decimal_part = 0;\n    float\
    \ int_part = 0;\n    \n    while(trunc_number > 0)\n    {\n        remainder =\
    \ trunc_number % 10;\n        decimal_part = trunc_number - remainder;\n     \
    \   int_part = remainder;\n        trunc_number = trunc_number / 10;\n    }\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9mdi0xda.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dc5]\\n??:? void tmp9mdi0xda.__unittest_L30_C1()\
    \ [0x427ada]\\n??:? void tmp9mdi0xda.__modtest() [0x427b48]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baeb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a97e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb11]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa9d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a955]\\n??:? runModuleUnitTests [0x42b8c1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428214]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42819b]\\n??:? _d_run_main [0x428106]\\n??:? main [0x427b5b]\\\
    n??:? __libc_start_main [0xc8909554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqo2bdem3.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmpqo2bdem3.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmpqo2bdem3.d(16): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmpqo2bdem3.d(16): Error: no identifier for declarator\
    \ `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqo2bdem3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integerPart;\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpka83qufm.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpka83qufm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvjwdz8yy.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpvjwdz8yy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder = 0;\n    float decimal_part = 0;\n    float\
    \ decimal_part_remainder = 0;\n    float decimal_part_remainder_magnitude = 0;\n\
    \    float decimal_part_remainder_magnitude2 = 0;\n    float decimal_part_remainder_magnitude3\
    \ = 0;\n    float decimal_part_remainder_magnitude4 = 0;\n    float decimal_part_remainder_magnitude5\
    \ = 0;\n    float decimal_part_remainder_magnitude6 = 0;\n    float decimal_part_remainder_magnitude7\
    \ = 0;\n    float decimal_part_remainder_magnitude8 = 0;\n    float decimal_part_remainder_magnitude9\
    \ = 0;\n    float decimal_part_remainder_magnitude10 = 0;\n    float decimal_part_remainder_magnitude11\
    \ = 0;\n    float decimal_part_remainder_magnitude12 = 0;\n    float decimal_part_remainder_magnitude13\
    \ = 0;\n    float decimal_part_remainder_magnitude14 = 0;\n    float decimal_part_remainder_magnitude15\
    \ = 0;\n    float decimal_part_remainder_magnitude16 = 0;\n    float decimal_part_remainder_magnitude17\
    \ = 0;\n    float decimal_part_remainder_magnitude18 = 0;\n    float decimal_part_remainder_magnitude19\
    \ = 0;\n    float decimal_part_remainder_magnitude20 = 0;\n    float decimal_part_remainder_magnitude21\
    \ = 0;\n    float decimal_part_remainder_magnitude22 = 0;\n    float decimal_part_remainder_magnitude23\
    \ = 0;\n    float decimal_part_remainder_magnitude24 = 0;\n    float decimal_part_remainder_magnitude25\
    \ = 0;\n    float decimal_part_remainder_magnitude26 = 0;\n    float decimal_part_remainder_magnitude27\
    \ = 0;\n    float decimal_part_remainder_magnitude28 = 0;\n    float decimal_part_remainder_magnitude29\
    \ = 0;\n    float decimal_part_remainder_magnitude30 = 0;\n    float decimal_part_remainder_magnitude31\
    \ = 0;\n    float decimal_part_remainder_magnitude32 = 0;\n    float decimal_part_remainder_magnitude33\
    \ = 0;\n    float decimal_part_remainder_magnitude34 = 0;\n    float decimal_part_remainder_magnitude35\
    \ = 0;\n    float decimal_part_remainder_magnitude36 = 0;\n    float decimal_part_remainder_magnitude37\
    \ = 0;\n    float decimal_part_remainder_magnitude38 = 0;\n    float decimal_part_remainder_magnitude39\
    \ = 0;\n    float decimal_part_remainder_magnitude40 = 0;\n    float decimal_part_remainder_magnitude41\
    \ = 0;\n    float decimal_part_remainder_magnitude42 = 0;\n    float decimal_part_remainder_magnitude43\
    \ = 0;\n    float decimal_part_remainder_magnitude44 = 0;\n    float decimal_part_remainder_magnitude45\
    \ = 0;\n    float decimal_part_remainder_magnitude46 = 0;\n    float decimal_part_remainder_magnitude47\
    \ = 0;\n    float decimal_part_remainder_magnitude48 = 0;\n    float decimal_part_remainder_magnitude49\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3kt4bb5m.d(68): Error: semicolon expected, not `unittest`\\n/tmp/tmp3kt4bb5m.d(68):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp3kt4bb5m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part = (long long) number;\n    long long int decimal_part = number - int_part;\n\
    \    \n    if (decimal_part > 0)\n    {\n        return number;\n    }\n    else\n\
    \    {\n        return int_part;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7azy0irs.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmp7azy0irs.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmp7azy0irs.d(15): Error: found `long` when expecting `.` following\
    \ long\\n/tmp/tmp7azy0irs.d(15): Error: found `)` when expecting identifier following\
    \ `long`.\\n/tmp/tmp7azy0irs.d(15): Error: found `number` when expecting `)`\\\
    n/tmp/tmp7azy0irs.d(16): Error: use `long` for a 64 bit integer instead of `long\
    \ long`\\n/tmp/tmp7azy0irs.d(16): Error: no identifier for declarator `long`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7azy0irs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float quotient2\
    \ = 0.0;\n    float quotient3 = 0.0;\n    float quotient4 = 0.0;\n    float quotient5\
    \ = 0.0;\n    float quotient6 = 0.0;\n    float quotient7 = 0.0;\n    float quotient8\
    \ = 0.0;\n    float quotient9 = 0.0;\n    float quotient10 = 0.0;\n    float quotient11\
    \ = 0.0;\n    float quotient12 = 0.0;\n    float quotient13 = 0.0;\n    float\
    \ quotient14 = 0.0;\n    float quotient15 = 0.0;\n    float quotient16 = 0.0;\n\
    \    float quotient17 = 0.0;\n    float quotient18 = 0.0;\n    float quotient19\
    \ = 0.0;\n    float quotient20 = 0.0;\n    float quotient21 = 0.0;\n    float\
    \ quotient22 = 0.0;\n    float quotient23 = 0.0;\n    float quotient24 = 0.0;\n\
    \    float quotient25 = 0.0;\n    float quotient26 = 0.0;\n    float quotient27\
    \ = 0.0;\n    float quotient28 = 0.0;\n    float quotient29 = 0.0;\n    float\
    \ quotient30 = 0.0;\n    float quotient31 = 0.0;\n    float quotient32 = 0.0;\n\
    \    float quotient33 = 0.0;\n    float quotient34 = 0.0;\n    float quotient35\
    \ = 0.0;\n    float quotient36 = 0.0;\n    float quotient37 = 0.0;\n    float\
    \ quotient38 = 0.0;\n    float quotient39 = 0.0;\n    float quotient40 = 0.0;\n\
    \    float quotient41 = 0.0;\n    float quotient42 = 0.0;\n    float quotient43\
    \ = 0.0;\n    float quotient44 = 0.0;\n    float quotient45 = 0.0;\n    float\
    \ quotient46 = 0.0;\n    float quotient47 = 0.0;\n    float quotient48 = 0.0;\n\
    \    float quotient49 = 0.0;\n    float quotient50 = 0.0;\n    float quotient51\
    \ = 0.0;\n    float quotient52 = 0.0;\n    float quotient53 = 0.0;\n    float\
    \ quotient54 = 0.0;\n    float quotient55 = 0.0;\n    float quotient56 = 0.0;\n\
    \    float quotient57 = 0.0;\n    float quotient58 = 0.0;\n    float quotient59\
    \ = 0.0;\n    float quotient60 = 0.0;\n    float quotient61 = 0.\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnqx75jk2.d(78): Error: semicolon expected, not `unittest`\\n/tmp/tmpnqx75jk2.d(78):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnqx75jk2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpimd9fuek.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpimd9fuek.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_b4kmylj.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp_b4kmylj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ float(number) - float(integer_part);\n    \n    return float(remainder);\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplorsf89s.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmplorsf89s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    \n    integerPart = floor(number);\n    decimalPart\
    \ = number - integerPart;\n    \n    return decimalPart;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float int_part = 0.0;\n    float remainder = 0.0;\n    \n    int_part\
    \ = floor(number);\n    \n    while(number > int_part)\n    {\n        number\
    \ = number - int_part;\n        decimals = decimals + 1.0;\n    }\n    \n    remainder\
    \ = number - int_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbzdi2c9x.d(35): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f2d]\\n??:? void tmpbzdi2c9x.__unittest_L31_C1()\
    \ [0x427c42]\\n??:? void tmpbzdi2c9x.__modtest() [0x427cb0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd97]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ac2a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fdbd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43026c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd49]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ac01]\\n??:? runModuleUnitTests [0x42bb6d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42837c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428303]\\n??:? _d_run_main [0x42826e]\\n??:? main [0x427cc3]\\\
    n??:? __libc_start_main [0xceb04554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcgwm67fl.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpcgwm67fl.d(23): Error: cannot implicitly convert\
    \ expression `remainder` of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpcgwm67fl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpac1ys2s5.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpac1ys2s5.__unittest_L23_C1()\
    \ [0x427a7e]\\n??:? void tmpac1ys2s5.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0x70aca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart =\
    \ (int) number;\n    float decimalPart = number - intPart;\n    return decimalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpytwq_aay.d(15): Error: C style cast illegal, use `cast(int)number`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpytwq_aay.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integer_part;\n    float decimal_part;\n    \n    integer_part = floor(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    if (decimal_part ==\
    \ 0.0f)\n    {\n        return integer_part;\n    }\n    \n    remainder = number\
    \ - integer_part;\n    \n    if (remainder > 0.0f)\n    {\n        return integer_part\
    \ + 1.0f;\n    }\n    \n    return integer_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfydu7g3l.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f2d]\\n??:? void tmpfydu7g3l.__unittest_L37_C1()\
    \ [0x427c3e]\\n??:? void tmpfydu7g3l.__modtest() [0x427cac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd97]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ac2a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fdbd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43026c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd49]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ac01]\\n??:? runModuleUnitTests [0x42bb6d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42837c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428303]\\n??:? _d_run_main [0x42826e]\\n??:? main [0x427cbf]\\\
    n??:? __libc_start_main [0x7202f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part = number - truncate_number(number);\n    \n    integer_part\
    \ = int(number);\n    \n    return decimal_part + integer_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp95xq8vro.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp95xq8vro.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    \n   \
    \ while(number > 0.0)\n    {\n        remainder = number % 10.0;\n        number\
    \ = number / 10.0;\n        decimals = decimals + remainder;\n    }\n    \n  \
    \  result = result - decimals;\n    \n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb1bp2d5q.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpb1bp2d5q.__unittest_L30_C1()\
    \ [0x427af6]\\n??:? void tmpb1bp2d5q.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0xa70b8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyyumkf43.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpyyumkf43.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu4vydh72.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpu4vydh72.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ert18kx.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp_ert18kx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) {\n\
    \        remainder = truncate_number(decimalPart);\n    } else {\n        remainder\
    \ = 0.0f;\n    }\n    \n    return remainder + integerPart;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2u2z1see.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp2u2z1see.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp82gl_9e_.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp82gl_9e_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1.0f) \n    {\n        result -= 1.0f;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpotccsq5q.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpotccsq5q.__unittest_L24_C1()\
    \ [0x427ad9]\\n??:? void tmpotccsq5q.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0x65f3e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8osg0ada.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp8osg0ada.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyzskglkz.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpyzskglkz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimalPart;\n    \n    decimalPart = number - int(number);\n\
    \    \n    if (decimalPart > 0.0f)\n        result = number - decimalPart;\n \
    \   \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2p8vtdm.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmps2p8vtdm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphggtjhgw.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmphggtjhgw.d(21): Error: cannot implicitly convert\
    \ expression `number - cast(float)integer_part` of type `float` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphggtjhgw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    \n   \
    \ while(number > 0.0)\n    {\n        remainder = number % 10.0;\n        number\
    \ = number / 10.0;\n        decimals = decimals + remainder;\n    }\n    \n  \
    \  result = result - decimals;\n    \n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo0dve8uo.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpo0dve8uo.__unittest_L30_C1()\
    \ [0x427af6]\\n??:? void tmpo0dve8uo.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0xa2a57554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integerPart;\n    \n    integerPart = number;\n\
    \    \n    decimals = number - integerPart;\n    \n    remainder = decimals;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprdh5k6vj.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d75]\\n??:? void tmprdh5k6vj.__unittest_L27_C1()\
    \ [0x427a8a]\\n??:? void tmprdh5k6vj.__modtest() [0x427af8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba9b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a92e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fac1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff70]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa4d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a905]\\n??:? runModuleUnitTests [0x42b871]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281c4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42814b]\\n??:? _d_run_main [0x4280b6]\\n??:? main [0x427b0b]\\\
    n??:? __libc_start_main [0x5d482554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoe8fxjt8.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpoe8fxjt8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimal;\n    float intpart;\n    \n    intpart = floor(number);\n\
    \    decimal = number - intpart;\n    \n    if (intpart == number) {\n       \
    \ return decimal;\n    }\n    \n    remainder = truncate_number(decimal);\n  \
    \  \n    return remainder + decimal;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    \n   \
    \ while(number > 0.0) {\n        remainder = number % 10.0;\n        number =\
    \ number / 10.0;\n        decimals = decimals + remainder;\n    }\n    \n    result\
    \ = result + decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr0anprbt.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpr0anprbt.__unittest_L29_C1()\
    \ [0x427af6]\\n??:? void tmpr0anprbt.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x91726554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = int(number - integerPart);\n    \n    remainder = number -\
    \ integerPart;\n    \n    return remainder / decimalPart;\n}\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_vn343t.d(19): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\n/tmp/tmpq_vn343t.d(20): Error: cannot implicitly\
    \ convert expression `number - cast(float)integerPart` of type `float` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq_vn343t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuerdw4lt.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpuerdw4lt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkd2yxv9p.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpkd2yxv9p.d(21): Error: cannot implicitly convert\
    \ expression `number - cast(float)integer_part` of type `float` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkd2yxv9p.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5i9be073.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp5i9be073.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph_c8fb1n.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmph_c8fb1n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number - floor(number);\n    return floor(number) + decimals;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmps_q5vp_q.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ec5]\\n??:? void tmps_q5vp_q.__unittest_L18_C1()\
    \ [0x427bda]\\n??:? void tmps_q5vp_q.__modtest() [0x427c48]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bd2f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42abc2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fd55]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430204]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fce1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ab99]\\n??:? runModuleUnitTests [0x42bb05]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428314]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42829b]\\n??:? _d_run_main [0x428206]\\n??:? main [0x427c5b]\\\
    n??:? __libc_start_main [0xca513554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart =\
    \ (int) number;\n    float fractionalPart = number - intPart;\n    return fractionalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43449a89.d(15): Error: C style cast illegal, use `cast(int)number`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43449a89.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyauimfnu.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpyauimfnu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp36bps3l0.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmp36bps3l0.__unittest_L23_C1()\
    \ [0x427a7e]\\n??:? void tmp36bps3l0.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0x198cc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int int_part;\n\
    \    long int decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return float(decimal_part);\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbb3vmxbm.d(15): Error: no identifier for declarator `long`\\\
    n/tmp/tmpbb3vmxbm.d(16): Error: no identifier for declarator `long`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbb3vmxbm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = number - truncate_number(number);\n    \n  \
    \  if (decimals > 0.0f)\n    {\n        result = number - decimals;\n    }\n \
    \   \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4l5hpqwq.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmp4l5hpqwq.d(23): Error: cannot implicitly convert\
    \ expression `remainder` of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4l5hpqwq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float integer_part;\n    float\
    \ decimal_part;\n    \n    integer_part = floor(number);\n    \n    quotient =\
    \ number - integer_part;\n    \n    decimals = modf(quotient, &remainder);\n \
    \   \n    decimal_part = remainder;\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5xhgdpkw.d(25): Error: function `std.math.modf(real x, ref real\
    \ i)` is not callable using argument types `(float, float*)`\\n/tmp/tmp5xhgdpkw.d(25):\
    \        cannot pass rvalue argument `& remainder` of type `float*` to parameter\
    \ `ref real i`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5xhgdpkw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float temp\
    \ = 0.0;\n    int exponent = 0;\n    \n    temp = number;\n    \n    while(temp\
    \ != 0.0)\n    {\n        quotient = temp / 10.0;\n        temp = temp - quotient\
    \ * 10.0;\n        \n        exponent++;\n    }\n    \n    temp = number;\n  \
    \  \n    while(temp != 0.0)\n    {\n        remainder = temp % 10.0;\n       \
    \ temp = temp / 10.0;\n        \n        decimals = decimals + remainder;\n  \
    \  }\n    \n    decimals = decimals / 10.0;\n    \n    return decimals;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    int_part = int(number);\n    frac_part = number - int_part;\n\
    \    return frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq7lp540m.d(17): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpq7lp540m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp043eew7k.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp043eew7k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    \n    quotient\
    \ = number / 10.0;\n    remainder = number % 10.0;\n    \n    decimals = remainder;\n\
    \    \n    return quotient;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpczz2q27_.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427da5]\\n??:? void tmpczz2q27_.__unittest_L26_C1()\
    \ [0x427ab6]\\n??:? void tmpczz2q27_.__modtest() [0x427b24]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bacb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a95e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faf1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa7d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a935]\\n??:? runModuleUnitTests [0x42b8a1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281f4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42817b]\\n??:? _d_run_main [0x4280e6]\\n??:? main [0x427b37]\\\
    n??:? __libc_start_main [0x6f794554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    if (decimal_part ==\
    \ 0.0f)\n    {\n        return integer_part;\n    }\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpebrz4yyi.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpebrz4yyi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    \n    while (result > 1) {\n       \
    \ result /= 10;\n        decimals++;\n    }\n    \n    return result - decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5quuu6y0.d(29): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d9d]\\n??:? void tmp5quuu6y0.__unittest_L25_C1()\
    \ [0x427aae]\\n??:? void tmp5quuu6y0.__modtest() [0x427b1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bac3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a956]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fae9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a92d]\\n??:? runModuleUnitTests [0x42b899]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ec]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428173]\\n??:? _d_run_main [0x4280de]\\n??:? main [0x427b2f]\\\
    n??:? __libc_start_main [0xa9fbe554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpia529ywt.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpia529ywt.d(21): Error: cannot implicitly convert\
    \ expression `number - cast(float)integer_part` of type `float` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpia529ywt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5r9v6e68.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp5r9v6e68.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0) {\n      \
    \  remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    return decimals;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf71idvs3.d(29): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dcd]\\n??:? void tmpf71idvs3.__unittest_L25_C1()\
    \ [0x427ade]\\n??:? void tmpf71idvs3.__modtest() [0x427b4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a986]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a95d]\\n??:? runModuleUnitTests [0x42b8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42821c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281a3]\\n??:? _d_run_main [0x42810e]\\n??:? main [0x427b5f]\\\
    n??:? __libc_start_main [0x25a3c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1.0f) {\n        result -= 1.0f;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl5mpd8v8.d(29): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpl5mpd8v8.__unittest_L23_C1()\
    \ [0x427ad9]\\n??:? void tmpl5mpd8v8.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0x2b3af554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu745pg9r.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpu745pg9r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnszv2nhq.d(19): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnszv2nhq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integerPart;\n    \n    integerPart = int(number);\n\
    \    decimals = number - integerPart;\n    \n    if (decimals < 0.0) \n    {\n\
    \        remainder = decimals;\n        decimals = 0.0;\n    }\n    else\n   \
    \ {\n        remainder = 0.0;\n    }\n    \n    return remainder + decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4x0z05mb.d(19): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4x0z05mb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    if (decimal_part >\
    \ 0.0f)\n    {\n        remainder = decimal_part - trunc(decimal_part);\n    }\n\
    \    else\n    {\n        remainder = 0.0f;\n    }\n    \n    return remainder;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc7bysqwn.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpc7bysqwn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / FLT_EPSILON;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcspo13x6.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpcspo13x6.d(23): Error: undefined identifier\
    \ `FLT_EPSILON`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcspo13x6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpke2z8z83.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpke2z8z83.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj0rc82my.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpj0rc82my.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\n    \n    exponent = std.math.frexp(number,\
    \ &remainder);\n    \n    if (exponent > 0)\n    {\n        result = remainder;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyanr8qpp.d(19): Error: template `std.math.frexp` cannot deduce\
    \ function from argument types `!()(float, float*)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(2829):\
    \        `std.math.frexp(T)(const T value, out int exp) if (isFloatingPoint!T)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyanr8qpp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp68vjp3d4.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp68vjp3d4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpors0ui9c.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpors0ui9c.__unittest_L29_C1()\
    \ [0x427af6]\\n??:? void tmpors0ui9c.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x81219554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = int(number - integerPart);\n    \n    remainder = number -\
    \ integerPart;\n    \n    return remainder + decimalPart / decimalPart * decimalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpixyta1ex.d(19): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\n/tmp/tmpixyta1ex.d(20): Error: cannot implicitly\
    \ convert expression `number - cast(float)integerPart` of type `float` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpixyta1ex.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph5nzrxfg.d(19): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph5nzrxfg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\n    int sign;\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0xzf9x36.d(20): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0xzf9x36.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\n    \n    exponent = std.math.frexp(number,\
    \ &remainder);\n    \n    if (exponent == 0)\n    {\n        result = remainder;\n\
    \    }\n    else\n    {\n        result = remainder * pow(10.0, exponent - 1);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq013nrba.d(19): Error: template `std.math.frexp` cannot deduce\
    \ function from argument types `!()(float, float*)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(2829):\
    \        `std.math.frexp(T)(const T value, out int exp) if (isFloatingPoint!T)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq013nrba.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result = result / 10;\n  \
    \  }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb0dmbpu7.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpb0dmbpu7.__unittest_L23_C1()\
    \ [0x427a7e]\\n??:? void tmpb0dmbpu7.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0xb24c4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result = result / 10;\n  \
    \  }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo76_xedx.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpo76_xedx.__unittest_L23_C1()\
    \ [0x427a7e]\\n??:? void tmpo76_xedx.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0x9290b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmpy3tze9.d(19): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpy3tze9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6py8uoze.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp6py8uoze.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv1ckvcu7.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpv1ckvcu7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    \n    quotient = number / float.pow(10,\
    \ decimals);\n    remainder = number % float.pow(10, decimals);\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdwae13ai.d(19): Error: cannot pass type `float` as a function\
    \ argument\\n/tmp/tmpdwae13ai.d(20): Error: cannot pass type `float` as a function\
    \ argument\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdwae13ai.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0f)\n\
    \    {\n        remainder = truncate_number(decimalPart);\n    }\n    else\n \
    \   {\n        remainder = 0.0f;\n    }\n    \n    return remainder;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfbjyr8rm.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpfbjyr8rm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw9ca400l.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpw9ca400l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptjd8a3kt.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmptjd8a3kt.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmptjd8a3kt.d(16): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmptjd8a3kt.d(16): Error: no identifier for declarator\
    \ `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptjd8a3kt.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integer_part;\n    float decimal_part;\n    \n    integer_part = floor(number);\n\
    \    decimal_part = number - integer_part;\n    \n    if(decimal_part < 0.0000001)\n\
    \    {\n        decimal_part = 0.0000001;\n    }\n    \n    remainder = number\
    \ - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp07afngn8.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp07afngn8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float remainder = 0.0;\n    \n   \
    \ while(number > 0.0) {\n        remainder = number % 10.0;\n        decimals\
    \ += remainder;\n        number /= 10.0;\n    }\n    \n    result = number + decimals;\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz5z55ddu.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpz5z55ddu.__unittest_L29_C1()\
    \ [0x427af6]\\n??:? void tmpz5z55ddu.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x5b402554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmphhsfut.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpmphhsfut.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1g42a1ad.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp1g42a1ad.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjcre27of.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpjcre27of.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpraghwkw2.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpraghwkw2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\n/*\n Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe3ujpo4v.d(27): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe3ujpo4v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 1;\n        number = number / 1;\n        decimals\
    \ = decimals + remainder;\n    }\n    return decimals;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float remainder = number - decimal_part;\n    return remainder;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn1sn98lj.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpn1sn98lj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4qvsaja1.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4qvsaja1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1zh5tv4w.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp1zh5tv4w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd355kc6w.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpd355kc6w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyg9ekag6.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpyg9ekag6.d(23): Error: cannot implicitly convert\
    \ expression `remainder` of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpyg9ekag6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float int_part;\n    float decimal_part;\n    \n    int_part\
    \ = trunc_number - trunc_number % 1;\n    decimal_part = trunc_number - int_part;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float quotient2\
    \ = 0.0;\n    float quotient3 = 0.0;\n    float quotient4 = 0.0;\n    float quotient5\
    \ = 0.0;\n    float quotient6 = 0.0;\n    float quotient7 = 0.0;\n    float quotient8\
    \ = 0.0;\n    float quotient9 = 0.0;\n    float quotient10 = 0.0;\n    float quotient11\
    \ = 0.0;\n    float quotient12 = 0.0;\n    float quotient13 = 0.0;\n    float\
    \ quotient14 = 0.0;\n    float quotient15 = 0.0;\n    float quotient16 = 0.0;\n\
    \    float quotient17 = 0.0;\n    float quotient18 = 0.0;\n    float quotient19\
    \ = 0.0;\n    float quotient20 = 0.0;\n    float quotient21 = 0.0;\n    float\
    \ quotient22 = 0.0;\n    float quotient23 = 0.0;\n    float quotient24 = 0.0;\n\
    \    float quotient25 = 0.0;\n    float quotient26 = 0.0;\n    float quotient27\
    \ = 0.0;\n    float quotient28 = 0.0;\n    float quotient29 = 0.0;\n    float\
    \ quotient30 = 0.0;\n    float quotient31 = 0.0;\n    float quotient32 = 0.0;\n\
    \    float quotient33 = 0.0;\n    float quotient34 = 0.0;\n    float quotient35\
    \ = 0.0;\n    float quotient36 = 0.0;\n    float quotient37 = 0.0;\n    float\
    \ quotient38 = 0.0;\n    float quotient39 = 0.0;\n    float quotient40 = 0.0;\n\
    \    float quotient41 = 0.0;\n    float quotient42 = 0.0;\n    float quotient43\
    \ = 0.0;\n    float quotient44 = 0.0;\n    float quotient45 = 0.0;\n    float\
    \ quotient46 = 0.0;\n    float quotient47 = 0.0;\n    float quotient48 = 0.0;\n\
    \    float quotient49 = 0.0;\n    float quotient50 = 0.0;\n    float quotient51\
    \ = 0.0;\n    float quotient52 = 0.0;\n    float quotient53 = 0.0;\n    float\
    \ quotient54 = 0.0;\n    float quotient55 = 0.0;\n    float quotient56 = 0.0;\n\
    \    float quotient57 = 0.0;\n    float quotient58 = 0.0;\n    float quotient59\
    \ = 0.0;\n    float quotient60 = 0.0;\n    float quotient61 = 0.\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplml9l1ec.d(78): Error: semicolon expected, not `unittest`\\n/tmp/tmplml9l1ec.d(78):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplml9l1ec.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3zxa_jaw.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp3zxa_jaw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpio50kiph.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpio50kiph.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int integer_part;\n    float decimal_part;\n    \n \
    \   integer_part = trunc(number);\n    \n    decimal_part = number - integer_part;\n\
    \    \n    quotient = integer_part / 10;\n    \n    remainder = integer_part %\
    \ 10;\n    \n    return decimal_part + quotient * 10 + remainder;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1knzn1na.d(20): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp1knzn1na.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart =\
    \ (int) number;\n    float decimalPart = number - intPart;\n    return decimalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyqb9ism9.d(15): Error: C style cast illegal, use `cast(int)number`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqb9ism9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpohjq63no.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpohjq63no.d(23): Error: cannot implicitly convert\
    \ expression `remainder` of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpohjq63no.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    float decimals = number - truncate_number(number);\n  \
    \  \n    if (decimals > 0.0f)\n    {\n        result = truncate_number(number\
    \ * 100) / 100;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9kqgy2rh.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp9kqgy2rh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf2l0u6_0.d(19): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf2l0u6_0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg3i9wnc6.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg3i9wnc6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\n    \n    exponent = floor(log10(number));\n\
    \    \n    if (exponent < -2)\n        throw new Exception(\"Number too small\"\
    );\n    \n    remainder = number - (float)pow(10.0, -exponent);\n    \n    if\
    \ (remainder < 0.5)\n        result = remainder;\n    else\n        result = remainder\
    \ - 0.5;\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp06m5bd48.d(24): Error: C style cast illegal, use `cast(float)pow(10.0000,\
    \ -exponent)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp06m5bd48.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = int(frac_part);\n\
    \    frac_part = frac_part - int_part;\n    return frac_part;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy9tmexr3.d(17): Error: cannot implicitly convert expression `frac_part`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpy9tmexr3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn9if3i2v.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpn9if3i2v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqtkx4_k6.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpqtkx4_k6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float result = 0.0;\n    \n    while(number > 0.0) {\n        float\
    \ remainder = number % 1.0;\n        number /= 1.0;\n        decimals += remainder;\n\
    \    }\n    \n    result = number - decimals;\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqi_08kyr.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpqi_08kyr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj79yfg9z.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj79yfg9z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder = 0;\n    \n    while(number > 0)\n    {\n  \
    \      remainder = number % 10;\n        number = number / 10;\n        result\
    \ = result * 10 + remainder;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7aknva7q.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dbd]\\n??:? void tmp7aknva7q.__unittest_L27_C1()\
    \ [0x427ace]\\n??:? void tmp7aknva7q.__modtest() [0x427b3c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bae3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a976]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb09]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffb8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa95]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a94d]\\n??:? runModuleUnitTests [0x42b8b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42820c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428193]\\n??:? _d_run_main [0x4280fe]\\n??:? main [0x427b4f]\\\
    n??:? __libc_start_main [0x9dbf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplry7bn2q.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmplry7bn2q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_part\
    \ = number;\n    float int_part;\n    float decimal_part;\n    \n    int_part\
    \ = trunc_part;\n    decimal_part = trunc_part - int_part;\n    \n    return decimal_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9pqohivr.d(28): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmp9pqohivr.__unittest_L24_C1()\
    \ [0x427a82]\\n??:? void tmp9pqohivr.__modtest() [0x427af0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427b03]\\\
    n??:? __libc_start_main [0x3d45f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_pbs1j8s.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmp_pbs1j8s.__unittest_L23_C1()\
    \ [0x427a7e]\\n??:? void tmp_pbs1j8s.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0xdd8ae554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = int(frac_part);\n\
    \    return frac_part - int_part;\n}\n/*\n Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3xnaujtj.d(20): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3xnaujtj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float result = 0.0;\n    float temp\
    \ = 0.0;\n    \n    temp = number;\n    \n    while(temp > 0)\n    {\n       \
    \ remainder = temp % 10.0;\n        temp = temp / 10.0;\n        decimals = decimals\
    \ + remainder;\n    }\n    \n    result = number - decimals;\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2qduioku.d(37): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427df5]\\n??:? void tmp2qduioku.__unittest_L33_C1()\
    \ [0x427b0a]\\n??:? void tmp2qduioku.__modtest() [0x427b78]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42fff0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42facd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a985]\\n??:? runModuleUnitTests [0x42b8f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428244]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281cb]\\n??:? _d_run_main [0x428136]\\n??:? main [0x427b8b]\\\
    n??:? __libc_start_main [0xb3c11554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8tk7__k1.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8tk7__k1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfq0sb7e7.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpfq0sb7e7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while\
    \ (number > 0)\n    {\n        remainder = number % 10;\n        number = number\
    \ / 10;\n        decimals = decimals * 10 + remainder;\n    }\n    \n    result\
    \ = result / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp37jcvekq.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmp37jcvekq.__unittest_L29_C1()\
    \ [0x427af6]\\n??:? void tmp37jcvekq.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x52800554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part = number - truncate_number(floorf(number));\n    int_part\
    \ = trunc(number);\n    return decimal_part + int_part;\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwdegiww4.d(20): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwdegiww4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpahfb50v9.d(28): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpahfb50v9.__unittest_L24_C1()\
    \ [0x427a7e]\\n??:? void tmpahfb50v9.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0xab7ad554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder;\n    int decimal_places = 1;\n    \n    while(trunc_number\
    \ >= 1)\n    {\n        remainder = trunc_number % 10;\n        trunc_number =\
    \ trunc_number / 10;\n        decimal_places++;\n    }\n    \n    return trunc_number;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi6ryil7i.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d9d]\\n??:? void tmpi6ryil7i.__unittest_L28_C1()\
    \ [0x427aae]\\n??:? void tmpi6ryil7i.__modtest() [0x427b1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bac3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a956]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fae9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a92d]\\n??:? runModuleUnitTests [0x42b899]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ec]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428173]\\n??:? _d_run_main [0x4280de]\\n??:? main [0x427b2f]\\\
    n??:? __libc_start_main [0x8a97554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgi32c6rf.d(28): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpgi32c6rf.__unittest_L24_C1()\
    \ [0x427a7e]\\n??:? void tmpgi32c6rf.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0xc820f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyg146t82.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpyg146t82.__unittest_L29_C1()\
    \ [0x427af6]\\n??:? void tmpyg146t82.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x25841554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_5086yn2.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp_5086yn2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    while (result > 1) {\n        result\
    \ /= 10;\n        decimals++;\n    }\n    return result - decimals;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxte3f5hb.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d9d]\\n??:? void tmpxte3f5hb.__unittest_L23_C1()\
    \ [0x427aae]\\n??:? void tmpxte3f5hb.__modtest() [0x427b1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bac3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a956]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fae9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a92d]\\n??:? runModuleUnitTests [0x42b899]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281ec]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428173]\\n??:? _d_run_main [0x4280de]\\n??:? main [0x427b2f]\\\
    n??:? __libc_start_main [0x2319a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    decimal_part = number - integer_part;\n    \n    if (decimal_part == 0.0)\
    \ \n    {\n        return integer_part;\n    }\n    \n    remainder = number -\
    \ integer_part;\n    return remainder;\n}\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9t6gprn5.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmp9t6gprn5.d(20): Error: cannot implicitly convert\
    \ expression `number - cast(float)integer_part` of type `float` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9t6gprn5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(number > 0.0) {\n    \
    \    float remainder = number % 10.0;\n        number = number / 10.0;\n     \
    \   decimals = decimals + remainder;\n    }\n    \n    return result + decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4brk314g.d(30): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dcd]\\n??:? void tmp4brk314g.__unittest_L26_C1()\
    \ [0x427ade]\\n??:? void tmp4brk314g.__modtest() [0x427b4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a986]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a95d]\\n??:? runModuleUnitTests [0x42b8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42821c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281a3]\\n??:? _d_run_main [0x42810e]\\n??:? main [0x427b5f]\\\
    n??:? __libc_start_main [0xaa4a2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp77gs6ha9.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dcd]\\n??:? void tmp77gs6ha9.__unittest_L27_C1()\
    \ [0x427ade]\\n??:? void tmp77gs6ha9.__modtest() [0x427b4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a986]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a95d]\\n??:? runModuleUnitTests [0x42b8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42821c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281a3]\\n??:? _d_run_main [0x42810e]\\n??:? main [0x427b5f]\\\
    n??:? __libc_start_main [0x6585e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    int integerPart;\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyvnq70yx.d(17): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyvnq70yx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(result > 0.0) {\n    \
    \    result += 1.0;\n        decimals += 1.0;\n    }\n    \n    return result\
    \ - decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integer_part;\n    float decimal_part;\n    \n\
    \    integer_part = floor(number);\n    \n    remainder = number - integer_part;\n\
    \    \n    decimals = remainder * pow(10.0, floor(log10(remainder)));\n    \n\
    \    decimal_part = floor(decimals);\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9ug5dilf.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428be5]\\n??:? void tmp9ug5dilf.__unittest_L30_C1()\
    \ [0x427ffe]\\n??:? void tmp9ug5dilf.__modtest() [0x428968]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cc23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bab6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430c49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4310f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430bd5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42ba8d]\\n??:? runModuleUnitTests [0x42c9f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429034]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428fbb]\\n??:? _d_run_main [0x428f26]\\n??:? main [0x42897b]\\\
    n??:? __libc_start_main [0xef502554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long) number;\n    long long int decimalPart = (intPart % 1);\n\
    \    return (float) decimalPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpabx5j6d9.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmpabx5j6d9.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmpabx5j6d9.d(15): Error: found `long` when expecting `.` following\
    \ long\\n/tmp/tmpabx5j6d9.d(15): Error: found `)` when expecting identifier following\
    \ `long`.\\n/tmp/tmpabx5j6d9.d(15): Error: found `number` when expecting `)`\\\
    n/tmp/tmpabx5j6d9.d(16): Error: use `long` for a 64 bit integer instead of `long\
    \ long`\\n/tmp/tmpabx5j6d9.d(16): Error: no identifier for declarator `long`\\\
    n/tmp/tmpabx5j6d9.d(17): Error: C style cast illegal, use `cast(float)decimalPart`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpabx5j6d9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals;\n    \n    while(result\
    \ > 1)\n    {\n        remainder = result % 10;\n        decimals = 10 - remainder;\n\
    \        result = result / 10;\n        \n        if(decimals > remainder)\n \
    \       {\n            result = result - remainder;\n            decimals = decimals\
    \ - remainder;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptj00y6vg.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e05]\\n??:? void tmptj00y6vg.__unittest_L34_C1()\
    \ [0x427b1a]\\n??:? void tmptj00y6vg.__modtest() [0x427b88]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb51]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430000]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fadd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a995]\\n??:? runModuleUnitTests [0x42b901]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428254]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281db]\\n??:? _d_run_main [0x428146]\\n??:? main [0x427b9b]\\\
    n??:? __libc_start_main [0x995eb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg669yxq4.d(28): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpg669yxq4.__unittest_L24_C1()\
    \ [0x427a7e]\\n??:? void tmpg669yxq4.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0x8c64b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int decimals;\n    \n    quotient = number / float.pow(10,\
    \ decimals);\n    remainder = number % float.pow(10, decimals);\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpopmkqjmf.d(19): Error: cannot pass type `float` as a function\
    \ argument\\n/tmp/tmpopmkqjmf.d(20): Error: cannot pass type `float` as a function\
    \ argument\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpopmkqjmf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx4iqtbtu.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpx4iqtbtu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\n    int decimal_places = 1;\n    \n \
    \   quotient = number;\n    \n    while(quotient > 1)\n    {\n        remainder\
    \ = quotient % 1;\n        quotient = quotient / 1;\n        exponent = decimal_places\
    \ - 1;\n        \n        if(remainder > 0)\n        {\n            decimal_places\
    \ = decimal_places - 1;\n        }\n        else\n        {\n            decimal_places\
    \ = decimal_places + 1;\n        }\n    }\n    \n    return quotient;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcnvdsjs4.d(19): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\n/tmp/tmpcnvdsjs4.d(20): Error: cannot implicitly\
    \ convert expression `number - cast(float)integerPart` of type `float` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcnvdsjs4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpluk1yqjp.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpluk1yqjp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47iyjeab.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp47iyjeab.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimal;\n    float intPart;\n    \n    intPart = trunc(number);\n\
    \    \n    decimal = number - intPart;\n    \n    remainder = number - intPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgytgqa5_.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpgytgqa5_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprbtbo67r.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmprbtbo67r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplfv_d5dq.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmplfv_d5dq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(result > 1)\n    {\n      \
    \  remainder = result % 1;\n        result = result / 1;\n    }\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkn6oofb3.d(27): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427d6d]\\n??:? void tmpkn6oofb3.__unittest_L23_C1()\
    \ [0x427a7e]\\n??:? void tmpkn6oofb3.__modtest() [0x427aec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ba93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a926]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fab9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a8fd]\\n??:? runModuleUnitTests [0x42b869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428143]\\n??:? _d_run_main [0x4280ae]\\n??:? main [0x427aff]\\\
    n??:? __libc_start_main [0xd40f0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    \n    integerPart = trunc(number);\n    decimalPart\
    \ = number - integerPart;\n    \n    return decimalPart;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float remainder_float;\n    float\
    \ quotient_float;\n    float decimal_float;\n    \n    quotient = number / 10;\n\
    \    remainder = number % 10;\n    \n    quotient_float = std.math.trunc(quotient);\n\
    \    remainder_float = std.math.trunc(remainder);\n    \n    decimal_float = std.math.trunc(quotient_float\
    \ * 10.0 + remainder_float);\n    \n    return decimal_float;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdamigal7.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ecd]\\n??:? void tmpdamigal7.__unittest_L32_C1()\
    \ [0x427bde]\\n??:? void tmpdamigal7.__modtest() [0x427c4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bc0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42aa9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fc31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4300e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fbbd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42aa75]\\n??:? runModuleUnitTests [0x42b9e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42831c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4282a3]\\n??:? _d_run_main [0x42820e]\\n??:? main [0x427c5f]\\\
    n??:? __libc_start_main [0x616ab554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgvt4qs3h.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427de5]\\n??:? void tmpgvt4qs3h.__unittest_L29_C1()\
    \ [0x427af6]\\n??:? void tmpgvt4qs3h.__modtest() [0x427b64]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb0b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a99e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a975]\\n??:? runModuleUnitTests [0x42b8e1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428234]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281bb]\\n??:? _d_run_main [0x428126]\\n??:? main [0x427b77]\\\
    n??:? __libc_start_main [0x97005554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ual38z2.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp2ual38z2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number / 10;\n    remainder = number % 10;\n    decimals = remainder;\n  \
    \  \n    if (remainder > 0)\n    {\n        result = quotient + decimals;\n  \
    \  }\n    else\n    {\n        result = quotient;\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0n1sr_el.d(39): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427ddd]\\n??:? void tmp0n1sr_el.__unittest_L35_C1()\
    \ [0x427af2]\\n??:? void tmp0n1sr_el.__modtest() [0x427b60]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb03]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a996]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb29]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffd8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fab5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a96d]\\n??:? runModuleUnitTests [0x42b8d9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42822c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281b3]\\n??:? _d_run_main [0x42811e]\\n??:? main [0x427b73]\\\
    n??:? __libc_start_main [0x3e2a1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdeul_80x.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpdeul_80x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1jl71kyn.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp1jl71kyn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr94jir4o.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpr94jir4o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuik8ccg7.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpuik8ccg7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcqjlo3c8.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpcqjlo3c8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptmmnw10g.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmptmmnw10g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    \n    integerPart = trunc(number);\n    decimalPart\
    \ = number - integerPart;\n    \n    return decimalPart;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgsgj293y.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpgsgj293y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8sxsadn_.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmp8sxsadn_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = remainder;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6i1786gq.d(32): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427da5]\\n??:? void tmp6i1786gq.__unittest_L28_C1()\
    \ [0x427aba]\\n??:? void tmp6i1786gq.__modtest() [0x427b28]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bacb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a95e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42faf1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fa7d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a935]\\n??:? runModuleUnitTests [0x42b8a1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4281f4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42817b]\\n??:? _d_run_main [0x4280e6]\\n??:? main [0x427b3b]\\\
    n??:? __libc_start_main [0xdffce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integerPart;\n    int decimalPart;\n    \n    integerPart\
    \ = int(number);\n    decimalPart = number - integerPart;\n    \n    remainder\
    \ = decimalPart % 1;\n    decimalPart = decimalPart / 1;\n    \n    return remainder\
    \ + decimalPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n \
    \   assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n   \
    \ assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxh6nejos.d(20): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\n/tmp/tmpxh6nejos.d(21): Error: cannot implicitly\
    \ convert expression `number - cast(float)integerPart` of type `float` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxh6nejos.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsu6vfn5g.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpsu6vfn5g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0933zhhi.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0933zhhi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwzf4g_zt.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpwzf4g_zt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\n/*\n Given a\
    \ positive floating point number, it can be decomposed into\n    and integer part\
    \ (largest integer smaller than given number) and decimals\n    (leftover part\
    \ always smaller than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr6xu91mb.d(27): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr6xu91mb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpupgfm7hj.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpupgfm7hj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaxsny15y.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpaxsny15y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / FLT_EPSILON;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx3y7spg_.d(19): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\n/tmp/tmpx3y7spg_.d(23): Error: undefined identifier\
    \ `FLT_EPSILON`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx3y7spg_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integerPart;\n    \n    integerPart = int(number);\n\
    \    \n    remainder = number - integerPart;\n    \n    decimals = remainder;\n\
    \    \n    return decimals;\n}\n/*\n Given a positive floating point number, it\
    \ can be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv8um27lf.d(27): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv8um27lf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjeg1r_6k.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjeg1r_6k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = int(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe5x21q0v.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpe5x21q0v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals;\n    int exponent;\n  \
    \  \n    exponent = std.math.frexp(number, &remainder);\n    \n    decimals =\
    \ remainder * pow(10.0, exponent);\n    \n    result = result - decimals;\n  \
    \  \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmniqoyvp.d(20): Error: template `std.math.frexp` cannot deduce\
    \ function from argument types `!()(float, float*)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(2829):\
    \        `std.math.frexp(T)(const T value, out int exp) if (isFloatingPoint!T)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmniqoyvp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
