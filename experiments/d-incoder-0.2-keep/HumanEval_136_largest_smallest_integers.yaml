name: HumanEval_136_largest_smallest_integers
language: humaneval_to_dlang.py
prompt: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
  \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and\
  \ 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative\
  \ or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2,\
  \ 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n\
  \    largest_smallest_integers([0]) == (None, None)\n    \n*/\nTuple!(Nullable!(long),\
  \ Nullable!(long)) largest_smallest_integers(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
  \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
  \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get ==\
  \ 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
  \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
  \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
  \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n\
  \        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto\
  \ result = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
  }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
  \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
  \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
  \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
  \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
  \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
  \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
  \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get ==\
  \ 1L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < smallest) {\n            smallest = Nullable!(long);\n\
    \        }\n        if (lst[i] > largest) {\n            largest = Nullable!(long);\n\
    \        }\n        if (lst[i] < 0 && lst[i] > largest) {\n            largest\
    \ = Nullable!(long);\n        }\n        if (lst[i] > 0 && lst[i] < smallest)\
    \ {\n            smallest = Nullable!(long);\n        }\n        i += 1;\n   \
    \ }\n    return (largest, smallest);\n}", "{\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "{\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n  \
    \  var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < 0) {\n            largest = Nullable!(long);\n\
    \            smallest = Nullable!(long);\n            while (j < n) {\n      \
    \          if (lst[j] < 0) {\n                    largest = Nullable!(long);\n\
    \                    smallest = Nullable!(long);\n                    while (k\
    \ < n) {\n                        if (lst[k] < 0) {\n                        \
    \    largest = Nullable!(long);\n                            smallest = Nullable!(long);\n\
    \                            while (k < n) {\n                               \
    \ if (lst[k] < 0) {\n                                    largest = Nullable!(long);\n\
    \                                    smallest = Nullable!(long);\n           \
    \                         while (k < n) {\n                                  \
    \      if (lst[k] < 0) {\n                                            largest\
    \ = Nullable!(long);\n                                            smallest = Nullable!(long);\n\
    \                                            while (k < n) {\n               \
    \                                 if (lst[k] < 0) {\n                        \
    \                            largest = Nullable!(long);\n                    \
    \                                smallest = Nullable!(long);\n               \
    \                                     while (k < n) {\n                      \
    \                                  if (lst[k] < 0) {\n                       \
    \                                     largest = Nullable!(long);\n           \
    \                                                 smallest = Nullable!(long);\n\
    \                                                            while (k < n) {\n\
    \                                                                if (lst[k] <\
    \ 0) {\n                                                                    largest\
    \ = Nullable!(long);\n                                                       \
    \             smallest = Nullable!(long);\n                                  \
    \                                  while (k < n) {\n                         \
    \                                               if (lst[k] < 0) {\n          \
    \                                                                  largest = Nullable!(long);\n\
    \                                                                            smallest\
    \ = Nullable!(long);\n                                                       \
    \                     while (k < n) {\n                                      \
    \                                          if (lst[k] < 0) {\n               \
    \                                                                     largest\
    \ = Nullable!(long);\n                                                       \
    \                             smallest = Nullable!(long);\n                  \
    \                                                                  while (k <\
    \ n) {\n                                                                     \
    \                   if (lst[k] < 0) {\n                                      \
    \                                                      largest = Nullable!(long);\n\
    \                                                                            \
    \                smallest = Nullable!(long);\n                               \
    \                                                             while (k < n) {\n\
    \                                                                            \
    \                    if (lst[k] < 0) {\n                                     \
    \                                                               largest = Nullable!(long);\n\
    \                                                                            \
    \                        smallest = Nullable!(long);\n                       \
    \                                                                            \
    \ while (k < n) {\n                                                          \
    \                                              if (lst[k] < 0) {\n           \
    \                                                                            \
    \                     largest = Nullable!(long);\n                           \
    \                                                                            \
    \     smallest = Nullable!(long);\n                                          \
    \                                                                  while (k <\
    \ n) {\n                                                                     \
    \                                           if (lst[k] < 0) {\n              \
    \                                                                            \
    \                          largest = Nullable!(long);\n                      \
    \                                                                            \
    \                  smallest = Nullable!(long);\n                             \
    \                                                                            \
    \           while (k < n) {\n                                                \
    \                                                                        if (lst[k]\
    \ < 0) {\n                                                                   \
    \                                                         largest = Null", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n        if hd\
    \ < 0L then hd\n        else if hd > 0L then tl |> List.head |> long\n       \
    \ else (None, None)\n    )\n}", "{\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n   \
    \ foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else if (x > 0)\n        {\n            result.b =\
    \ x;\n        }\n        else\n        {\n            result.a = null;\n     \
    \       result.b = null;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd < 0 then\
    \ Some(-1) else Some(-1) and Some(-1) and Some(tl) \n    | _ => (None, None)\n\
    }", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if (lst.is_empty())\n\
    \        return result;\n    \n    long largest = lst.iter().max().unwrap();\n\
    \    long smallest = lst.iter().min().unwrap();\n    \n    if (largest < 0)\n\
    \    {\n        result.a = null;\n        result.b = smallest;\n    }\n    else\n\
    \    {\n        result.a = largest;\n        result.b = smallest;\n    }\n   \
    \ \n    return result;\n}", "{\n    var largest = Nullable!(long);\n    var smallest\
    \ = Nullable!(long);\n    foreach(i : lst, \n        largest = max!(largest, i);\n\
    \        smallest = min!(smallest, i);\n    );\n    return Tuple!(largest, smallest);\n\
    }", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n   \
    \ foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n  \
    \      } else if (x > 0) {\n            result.b = x;\n        }\n    }\n    \n\
    \    if (result.a == null) {\n        result.a = result.b;\n    }\n    \n    return\
    \ result;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n            result.b = null;\n        }\n        else\n        {\n   \
    \         result.a = null;\n            result.b = x;\n        }\n    }\n    \n\
    \    return result;\n}", "{\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (max,min)\
    \ = if hd < 0 then hd else hd ; min <- min(tl);\n        (max,min)\nend\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert largest_smallest_integers([2, 4, 1,\
    \ 3, 5, 7]) == (None, None)\n@assert largest_smallest_integers([]) == (None, None)\n\
    @assert largest_smallest_integers([0]) == (None, None)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the largest and smallest integers in a list.",
  "{\n    var max: long = lst.max;\n    var min: long = lst.min;\n    if (max == min)\
    \ return (null, null);\n    if (max < 0) return (null, max);\n    if (min > 0)\
    \ return (min, null);\n    return (max, min);\n}", "{\n    var largest = Nullable!(long);\n\
    \    var smallest = Nullable!(long);\n    var i = 0;\n    var j = 0;\n    var\
    \ k = 0;\n    var n = lst.len();\n    while(i < n && j < n) {\n        if(lst[i]\
    \ < lst[j]) {\n            smallest = Nullable!(long);\n            smallest =\
    \ lst[i];\n            i++;\n        } else {\n            largest = Nullable!(long);\n\
    \            largest = lst[j];\n            j++;\n        }\n    }\n    if(i <\
    \ n) {\n        smallest = Nullable!(long);\n        smallest = lst[i];\n    }\n\
    \    if(j < n) {\n        largest = Nullable!(long);\n        largest = lst[j];\n\
    \    }\n    return Tuple!(largest, smallest);\n}", "{\n    \n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst)\n    {\n        if(x\
    \ < 0)\n        {\n            result.a = x;\n            result.b = null;\n \
    \       }\n        else\n        {\n            result.a = null;\n           \
    \ result.b = x;\n        }\n    }\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach (i, e) in lst {\n        if (e <\
    \ 0)\n            result.a = e;\n        else if (e > 0)\n            result.b\
    \ = e;\n        else\n            result.a = e;\n        result.b = e;\n    }\n\
    \    \n    return result;\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl =>\n        let (max_int, min_int) = if hd < 0 then hd else hd +\
    \ 1; \n        (max_int, min_int)\n        | _ => (None, None)\nend\n    \n/*",
  "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (smallest,\
    \ largest) = if hd < 0L then \n            (Nullable!(long), Nullable!(long))\n\
    \        else \n            (Nullable!(long), Nullable!(long))\n        smallest_smallest_integers(tl,\
    \ smallest, largest)\n    end\n}", "{\n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl\
    \ =>\n        let (smallest, largest) = largest_smallest_integers(tl)\n      \
    \  if smallest < hd then (smallest, hd)\n        else (largest, hd)\n    end\n\
    }", "{\n    match lst with\n    | [] => (None, None)\n    | x::xs => (\n     \
    \   if x < 0 then (None, x)\n        else (Some(x), xs)\n    )\nend\n</cell>\n\
    <code language=julia-1.5>\n@test largest_smallest_integers([2, 4, 1, 3, 5, 7])\
    \ == (None, None)\n@test largest_smallest_integers([]) == (None, None)\n@test\
    \ largest_smallest_integers([0]) == (None, None)\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the sum of the integers in a list.\nIf there are\
    \ no integers, return 0.", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n\
    \    \n    foreach(i : lst, \n        Tuple!(Nullable!(long), Nullable!(long))\
    \ t = \n            Tuple!(Nullable!(long), Nullable!(long)) (\n             \
    \   ifelse(i < 0, None, i),\n                ifelse(i > 0, None, i)\n        \
    \    )\n    )\n    {\n        result = ifelse(\n            Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n                ifelse(result.a > t.a, result.a, t.a),\n\
    \                ifelse(result.b < t.b, result.b, t.b)\n            ),\n     \
    \       Tuple!(Nullable!(long), Nullable!(long)) (\n                ifelse(result.a\
    \ > t.a, t.a, result.a),\n                ifelse(result.b < t.b, t.b, result.b)\n\
    \            ),\n            result\n        );\n    }\n    \n    return result;\n\
    }", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n   \
    \ foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n  \
    \          result.b = null;\n        } else {\n            result.a = null;\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd < 0L then\
    \ \n                    (Some(hd), None) \n                else \n           \
    \         (None, Some(hd))\n    end\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl => if hd > 0 then Some((hd, tl)) else None\n    | hd::tl\
    \ => if hd < 0 then Some((hd, tl)) else None\n    | _ => None\n    end\n}", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (max_int,\
    \ min_int) = if hd < 0 then hd else hd \n                            (max_int,\
    \ min_int) \n                            in \n                            let\
    \ (max_int, min_int) = if min_int > hd then min_int else hd \n               \
    \             (max_int, min_int) \n                            in \n         \
    \                   let (max_int, min_int) = if max_int < min_int then max_int\
    \ else min_int \n                            (max_int, min_int) \n           \
    \                 in \n                            (max_int, min_int)\nend\nend\n\
    </code>\n<|/ a tags=ocaml,functional-programming |>\n<| a |>\n<code>\nlet rec\
    \ max_min lst = \n    match lst with\n    | [] -> (None, None)\n    | hd::tl ->\n\
    \        let (max_int, min_int) = if hd < 0 then hd else hd \n               \
    \             (max_int, min_int) \n                            in \n         \
    \                   let (max_int, min_int) = if min_int > hd then min_int else\
    \ hd \n                            (max_int, min_int) \n                     \
    \       in \n                            let (max_int, min_int) = if max_int <\
    \ min_int then max_int else min_int \n                            (max_int, min_int)\n\
    </code>\n<|/ a tags=ocaml,functional-programming dscore=2 |>\n<| a dscore=2 |>\n\
    <code>\nlet rec max_min lst = \n    match lst with\n    | [] -> (None, None)\n\
    \    | hd::tl ->\n        let (max_int, min_int) = if hd < 0 then hd else hd \n\
    \                            (max_int, min_int) \n                           \
    \ in \n                            let (max_int, min_int) = if min_int > hd then\
    \ min_int else hd \n                            (max_int, min_int) \n        \
    \                    in \n                            let (max_int, min_int) =\
    \ if max_int < min_int then max_int else min_int \n                          \
    \  (max_int, min_int)\n</code>\n<|/ a tags=ocaml,functional-programming |>\n<|\
    \ a tags=ocaml,functional-programming |>\n<code>\nlet rec max_min lst = \n   \
    \ match lst with\n    | [] -> (None, None)\n    | hd::tl ->\n        let (max_int,\
    \ min_int) = if hd < 0 then hd else hd \n                            (max_int,\
    \ min_int) \n                            in \n                            let\
    \ (max_int, min_int) = if min_int > hd then min_int else h", "{\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(i : lst, \n        Tuple!(Nullable!(long), Nullable!(long))\
    \ t = \n            Tuple!(Nullable!(long), Nullable!(long)) (\n             \
    \   if(i<0) Tuple!(Nullable!(long), Nullable!(long)) (None,None) \n          \
    \      else Tuple!(Nullable!(long), Nullable!(long)) (\n                    if(i>0)\
    \ Tuple!(Nullable!(long), Nullable!(long)) (None,None) \n                    else\
    \ Tuple!(Nullable!(long), Nullable!(long)) (i, None)\n                )\n    \
    \        )\n    )\n    \n    foreach(t : result, \n        Tuple!(Nullable!(long),\
    \ Nullable!(long)) t = \n            Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n                if((t.f0.isSome) && (t.f0.isSome)) (\n                  \
    \  if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n                        if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                            if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                    if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                        if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                            if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                                if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                                \
    \    if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n                      \
    \                                  if((t.f0.get().isSome) && (t.f0.get().isSome))\
    \ (\n                                                            if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                                \
    \                if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n          \
    \                                                          if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (\n                                                \
    \                        if((t.f0.get().isSome) && (t.f0.get().isSome)) (\n  \
    \                                                                          if((t.f0.get().isSome)\
    \ && (t.f0.get().isSome)) (", "{\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n   \
    \ \n    foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n         \
    \   result.a = x;\n        }\n        else\n        {\n            result.b =\
    \ x;\n        }\n    }\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    if (lst.is_empty())\n    {\n        result.first\
    \ = None;\n        result.second = None;\n        return result;\n    }\n    \n\
    \    long smallest = lst.min();\n    long largest = lst.max();\n    \n    if (smallest\
    \ < 0)\n    {\n        result.first = None;\n        result.second = None;\n \
    \       return result;\n    }\n    \n    if (largest > 0)\n    {\n        result.first\
    \ = largest;\n        result.second = smallest;\n        return result;\n    }\n\
    \    \n    result.first = None;\n    result.second = None;\n    return result;\n\
    }", "{\n    \n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    \n    var i = 0;\n    var j = 0;\n    \n    while (i < lst.len) {\n     \
    \   \n        if (lst[i] < smallest) {\n            smallest = lst[i];\n     \
    \   }\n        \n        if (lst[i] > largest) {\n            largest = lst[i];\n\
    \        }\n        \n        i += 1;\n        j += 1;\n    }\n    \n    return\
    \ (largest, smallest);\n}", "{\n    \n    bool isNegative = false;\n    long max\
    \ = 0;\n    long min = 0;\n    foreach(long i in lst)\n    {\n        if (i <\
    \ 0)\n        {\n            isNegative = true;\n        }\n        if (i > max)\n\
    \        {\n            max = i;\n        }\n        if (i < min)\n        {\n\
    \            min = i;\n        }\n    }\n    if (isNegative)\n    {\n        return\
    \ (None, max);\n    }\n    else\n    {\n        return (Some(min), max);\n   \
    \ }\n}", "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst) {\n        if(i < 0) {\n            largest = i;\n     \
    \   } else {\n            smallest = i;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n \
    \   \n    foreach(i : lst, \n        Tuple!(Nullable!(long), Nullable!(long))\
    \ t = \n            Tuple!(Nullable!(long), Nullable!(long)) \n            ((std.math.max(std.math.min(i),\
    \ std.math.max(i)), std.math.min(i)));\n        result = std.tuple.unsafeAppend(result,\
    \ t);\n    );\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(i : lst, \n           if (i < 0) result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n           else if (i > 0) result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n           else result = Tuple!(Nullable!(long), Nullable!(long)));\n\
    \    \n    return result;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(long x, lst)\n    {\n        if (x < 0)\n       \
    \ {\n            result.a = x;\n            result.b = Nullable!(long);\n    \
    \    }\n        else\n        {\n            result.b = x;\n            result.a\
    \ = Nullable!(long);\n        }\n    }\n    \n    return result;\n}", "{\n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "{\n    match lst with\n \
    \   | [] => (None, None)\n    | hd::tl =>\n        let (max_val, min_val) = if\
    \ hd < 0 then hd else hd ; min_val = hd\n        (max_val, min_val) :: largest_smallest_integers(tl)\n\
    \    end\n}", "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < smallest) {\n            smallest = lst[i];\n\
    \        }\n        if (lst[i] > largest) {\n            largest = lst[i];\n \
    \       }\n        i += 1;\n    }\n    if (smallest == Nullable!(long)) {\n  \
    \      return (None, Nullable!(long));\n    }\n    if (largest == Nullable!(long))\
    \ {\n        return (smallest, None);\n    }\n    while (j < n) {\n        if\
    \ (lst[j] > largest) {\n            largest = lst[j];\n        }\n        j +=\
    \ 1;\n    }\n    while (k < n) {\n        if (lst[k] < smallest) {\n         \
    \   smallest = lst[k];\n        }\n        k += 1;\n    }\n    return (smallest,\
    \ largest);\n}\n/*", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl\
    \ =>\n        let (max_int, min_int) = if hd < 0L then hd::(-1L, hd) else hd::(0L,\
    \ hd);\n        Tuple!(max_int, min_int) largest_smallest_integers(tl)\n    end;\n\
    }", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd < 0L then\
    \ Some((hd, tl.min)) else Some((tl.max, hd))\n    end\n}", "{\n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl => if hd < 0 then Some(None) else None\n               \
    \  else if hd > 0 then Some(Some(Long.MinValue)) else None\n                 else\
    \ largest_smallest_integers(tl)\n    end;\n}", "{\n    match lst with\n    | []\
    \ => (None, None)\n    | hd::tl =>\n        let (max,min) = if hd < 0 then hd\
    \ else hd ; min\n        (\n            if max < min then \n                (max,\
    \ min) \n            else \n                (min, max) \n        )\n    end\n\
    }\n/*", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(i : lst, \n        \n        \n        \n        \n        \n   \
    \     \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        ", "{\n   \
    \ match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (max_int,\
    \ min_int) = if hd < 0 then hd else hd + 1\n        (max_int, min_int)\n     \
    \   | _ => (None, None)\nend;\n/*", "{\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl\
    \ => \n        let (max_val, min_val) = hd.max(), hd.min()\n        match max_val,\
    \ min_val with\n        | None, None => (None, None)\n        | None, Some(None)\
    \ => (None, None)\n        | Some(None), None => (None, None)\n        | Some(None),\
    \ Some(None) => (None, None)\n        | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n            let (max_val, min_val) = max_val, min_val\n            match\
    \ max_val, min_val with\n            | None, None => (None, None)\n          \
    \  | None, Some(None) => (None, None)\n            | Some(None), None => (None,\
    \ None)\n            | Some(None), Some(None) => (None, None)\n            | Some(Some(max_val)),\
    \ Some(Some(min_val)) => \n                let (max_val, min_val) = max_val, min_val\n\
    \                match max_val, min_val with\n                | None, None =>\
    \ (None, None)\n                | None, Some(None) => (None, None)\n         \
    \       | Some(None), None => (None, None)\n                | Some(None), Some(None)\
    \ => (None, None)\n                | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n                    let (max_val, min_val) = max_val, min_val\n       \
    \             match max_val, min_val with\n                    | None, None =>\
    \ (None, None)\n                    | None, Some(None) => (None, None)\n     \
    \               | Some(None), None => (None, None)\n                    | Some(None),\
    \ Some(None) => (None, None)\n                    | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n                        let (max_val, min_val) = max_val, min_val\n   \
    \                     match max_val, min_val with\n                        | None,\
    \ None => (None, None)\n                        | None, Some(None) => (None, None)\n\
    \                        | Some(None), None => (None, None)\n                \
    \        | Some(None), Some(None) => (None, None)\n                        | Some(Some(max_val)),\
    \ Some(Some(min_val)) => \n                            let (max_val, min_val)\
    \ = max_val, min_val\n                            match max_val, min_val with\n\
    \                            | None, None => (None, None)\n                  \
    \          | None, Some(None) => (None, None)\n                            | Some(None),\
    \ None => (None, None)\n                            | Some(None), Some(None) =>\
    \ (None, None)\n                            | Some(Some(max_val)), Some(Some(min_val))\
    \ => \n                                let (max_val, min_val) = max_val, min_val\n\
    \                                match max_val, min_val with\n               \
    \                 | None, None => (None, None)\n                             \
    \   | None, Some(None", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n\
    \    \n    foreach(long x, lst) {\n        if (x < 0) {\n            result.a\
    \ = x;\n        } else {\n            result.b = x;\n        }\n    }\n    \n\
    \    return result;\n}", "{\n    \n    bool isNegative = false;\n    long largest\
    \ = Long.MinValue;\n    long smallest = Long.MaxValue;\n    \n    for (long i\
    \ : lst)\n    {\n        if (i < 0)\n        {\n            isNegative = true;\n\
    \        }\n        if (i > 0)\n        {\n            if (isNegative)\n     \
    \       {\n                largest = i;\n            }\n            else\n   \
    \         {\n                smallest = i;\n            }\n        }\n    }\n\
    \    \n    return Tuple!(Nullable!(long), Nullable!(long))(largest, smallest);\n\
    }", "{\n    var smallest = Long.min;\n    var largest = Long.max;\n    foreach\
    \ (x in lst) {\n        if (x < smallest) smallest = x;\n        if (x > largest)\
    \ largest = x;\n    }\n    return Tuple!(Nullable!(long), Nullable!(long))(Nullable!(long),\
    \ Nullable!(long))(smallest, largest);\n}", "{\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "{\n    match lst with\n    | [] => (None, None)\n    |\
    \ _ =>\n        let mutable smallest = Long.MinValue;\n        let mutable largest\
    \ = Long.MaxValue;\n        for elt in lst do\n            if elt < smallest then\n\
    \                smallest = elt\n            elseif elt > largest then\n     \
    \           largest = elt\n            else\n                None\n        end\n\
    \        (smallest, largest)\nend", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(long x, lst) {\n        if (x < 0) {\n          \
    \  result.a = x;\n        } else {\n            result.b = x;\n        }\n   \
    \ }\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl => if hd < 0L then \n                    (Some(hd), None)\
    \ \n                else\n                    (None, Some(tl))\n    end\n}", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (isneg,\
    \ imin) = if hd < 0 then Some(True, 0) else Some(False, hd)\n        match largest_smallest_integers(tl)\
    \ with\n        | None => (None, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n     \
    \   | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin) => (isneg,\
    \ imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg, imin)\
    \ => (isneg, imin)\n        | Some(isneg, imin) => (isneg, imin)\n        | Some(isneg,\
    \ imin) => (isneg, imin)\n        | Some(isneg", "{\n    match lst with\n    |\
    \ [] => (None, None)\n    | hd::tl => (\n        if hd < 0L then Some(hd, 0L)\
    \ else Some(hd, tl.max())\n    )\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, None)\n@assert largest_smallest_integers([])\
    \ == (None, None)\n@assert largest_smallest_integers([0]) == (None, None)\n</cell>\n\
    <text>\nExercise: Write a function that takes a list and a predicate as arguments,\
    \ and returns a new list with the elements that satisfy the predicate.", "{\n\
    \    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i : lst,\
    \ \n        Tuple!(Nullable!(long), Nullable!(long)) tuple = \n            Tuple!(Nullable!(long),\
    \ Nullable!(long)) \n                largest_smallest_integers(\n            \
    \        Array!(int) \n                        {\n                           \
    \ i\n                        }\n                )\n        )\n    {\n        result\
    \ = tuple;\n    }\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach (i, &lst) {\n        if (i < 0)\
    \ {\n            result.a = i;\n            result.b = null;\n        } else {\n\
    \            result.a = null;\n            result.b = i;\n        }\n    }\n \
    \   \n    return result;\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl =>\n        let (max_int, min_int) = if hd < 0 then Some(-1L, hd)\
    \ else Some(hd, 0L);\n        Tuple!(max_int, min_int) largest_smallest_integers(tl);\n\
    \    | _ => unreachable!();\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl =>\n        let (max_int, min_int) = if hd < 0 then hd else hd \n\
    \                            (max_int, min_int)\n            in \n           \
    \     let (max_int, min_int) = if min_int < 0 then min_int else min_int \n   \
    \                                 (max_int, min_int)\n                in \n  \
    \                  let (max_int, min_int) = if max_int < 0 then max_int else max_int\
    \ \n                                        (max_int, min_int)\n             \
    \       in \n                        (max_int, min_int)\nend\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=ocaml,functional-programming |>\n<code>\nlet rec largest_smallest_integers\
    \ lst =\n  match lst with\n  | [] -> (None, None)\n  | hd::tl ->\n    let (max_int,\
    \ min_int) = if hd < 0 then hd else hd in\n    let (max_int, min_int) = if min_int\
    \ < 0 then min_int else min_int in\n    let (max_int, min_int) = if max_int <\
    \ 0 then max_int else max_int in\n    (max_int, min_int)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nlet rec largest_smallest_integers lst =\n  match\
    \ lst with\n  | [] -> (None, None)\n  | hd::tl ->\n    let (max_int, min_int)\
    \ = if hd < 0 then hd else hd in\n    let (max_int, min_int) = if min_int < 0\
    \ then min_int else min_int in\n    let (max_int, min_int) = if max_int < 0 then\
    \ max_int else max_int in\n    (max_int, min_int)\n</code>\n<|/ a tags=ocaml,functional-programming\
    \ |>\n<| a dscore=0 |>\n<code>\nlet rec largest_smallest_integers lst =\n  match\
    \ lst with\n  | [] -> (None, None)\n  | hd::tl ->\n    let (max_int, min_int)\
    \ = if hd < 0 then hd else hd in\n    let (max_int, min_int) = if min_int < 0\
    \ then min_int else min_int in\n    let (max_int, min_int) = if max_int < 0 then\
    \ max_int else max_int in\n    (max_int, min_int)\n</code>\n<|/ a tags=ocaml,functional-programming\
    \ |>\n<| a |>\n<code>\nlet rec largest_smallest_integers lst =\n", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst) {\n        if (x <\
    \ 0) {\n            result.a = x;\n        } else {\n            result.b = x;\n\
    \        }\n    }\n    \n    return result;\n}", "{\n    match lst with\n    |\
    \ [] => (None, None)\n    | hd::tl => (\n        match hd with\n        | None\
    \ => (None, None)\n        | Some x => (\n            match tl with\n        \
    \    | [] => (None, None)\n            | hd::tl => (\n                match hd\
    \ with\n                | None => (None, None)\n                | Some y => (\n\
    \                    match tl with\n                    | [] => (None, None)\n\
    \                    | hd::tl => (\n                        match hd with\n  \
    \                      | None => (None, None)\n                        | Some\
    \ z => (\n                            match tl with\n                        \
    \    | [] => (None, None)\n                            | hd::tl => (\n       \
    \                         match hd with\n                                | None\
    \ => (None, None)\n                                | Some a => (\n           \
    \                         match tl with\n                                    |\
    \ [] => (None, None)\n                                    | hd::tl => (\n    \
    \                                    match hd with\n                         \
    \               | None => (None, None)\n                                     \
    \   | Some b => (\n                                            match tl with\n\
    \                                            | [] => (None, None)\n          \
    \                                  | hd::tl => (\n                           \
    \                     match hd with\n                                        \
    \        | None => (None, None)\n                                            \
    \    | Some c => (\n                                                    match\
    \ tl with\n                                                    | [] => (None,\
    \ None)\n                                                    | hd::tl => (\n \
    \                                                       match hd with\n      \
    \                                                  | None => (None, None)\n  \
    \                                                      | Some d => (\n       \
    \                                                     match tl with\n        \
    \                                                    | [] => (None, None)\n  \
    \                                                          | hd::tl => (\n   \
    \                                                             match hd with\n\
    \                                                                | None => (None,\
    \ None)\n                                                                | Some\
    \ e => (\n                                                                   \
    \ match tl with\n                                                            \
    \        | [] => (None, None)\n                                              \
    \                      | hd::tl => (\n                                       \
    \                                 match hd with\n                            \
    \                                            | None => (None, None)\n        \
    \                                                                | Some f => (\n\
    \                                                                            match\
    \ tl with\n                                                                  \
    \          | [] => (None, None)\n                                            \
    \                                | hd::tl => (\n                             \
    \                                                   match hd with\n          \
    \                                                                      | None\
    \ => (None, None)\n                                                          \
    \                      | Some g => (\n                                       \
    \                                             match tl with\n                \
    \                                                                    | [] => (None,\
    \ None)\n                                                                    \
    \                | hd::tl => (\n                                             \
    \                                           match hd with\n                  \
    \                                                                      | None\
    \ => (None, None)\n                                                          \
    \                              | Some h => (\n                               \
    \                                                             match tl with\n\
    \                                                                            \
    \                | [] => (None, None)\n                                      \
    \                                                      | hd::tl => (\n       \
    \                                                                            \
    \             match hd with\n                                                \
    \                                                | None => (None, None)\n    \
    \                                                                            \
    \                | Some i => (\n                                             \
    \                                                       match tl with\n      \
    \                                                                            \
    \                  | [] => (None, None)\n                                    \
    \                                                                | hd::tl => (\n\
    \                                                                            \
    \                            match hd with\n                                 \
    \                                                                       | None ",
  "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl => if hd < 0 then\
    \ Some(Some(hd), None) else Some(None, Some(tl))\n    end\n}", "{\n    var max:\
    \ long = Long.min;\n    var min: long = Long.max;\n    foreach(i : lst, \n   \
    \ {\n        if (i < min)\n        {\n            min = i;\n        }\n      \
    \  if (i > max)\n        {\n            max = i;\n        }\n    });\n    return\
    \ Tuple!(Nullable!(long), Nullable!(long))(max, min);\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst) {\n        if(x < 0)\
    \ {\n            result.a = x;\n        } else {\n            result.b = x;\n\
    \        }\n    }\n    \n    if(result.a == null) {\n        result.a = result.b;\n\
    \    }\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    if (lst.is_empty())\n    {\n        result.first = None;\n\
    \        result.second = None;\n    }\n    else\n    {\n        auto min_value\
    \ = lst.min();\n        auto max_value = lst.max();\n        \n        if (min_value\
    \ < 0)\n        {\n            result.first = None;\n            result.second\
    \ = None;\n        }\n        else if (max_value > 0)\n        {\n           \
    \ result.first = max_value;\n            result.second = min_value;\n        }\n\
    \        else\n        {\n            result.first = max_value;\n            result.second\
    \ = None;\n        }\n    }\n    \n    return result;\n}", "{\n    \n    bool\
    \ positive = true;\n    long max = 0;\n    long min = 0;\n    \n    for (long\
    \ i : lst) {\n        if (i < 0) {\n            positive = false;\n        }\n\
    \        if (i > max) {\n            max = i;\n        }\n        if (i < min)\
    \ {\n            min = i;\n        }\n    }\n    \n    if (positive && max > min)\
    \ {\n        return (max, min);\n    }\n    \n    if (positive && !max && min\
    \ > 0) {\n        return (min, 0);\n    }\n    \n    if (positive && !max && !min)\
    \ {\n        return (null, null);\n    }\n    \n    return (null, null);\n}",
  "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach (i,\
    \ e) in lst {\n        if (e < 0)\n            result.a = e;\n        else if\
    \ (e > 0)\n            result.b = e;\n        else\n            result.a = e;\n\
    \        result.b = e;\n    }\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(i : lst, \n            if(i<0) result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n            else result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    );\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst) {\n        if (x <\
    \ 0) {\n            result.a = x;\n            result.b = Nullable!(long);\n \
    \       } else {\n            result.b = x;\n            result.a = Nullable!(long);\n\
    \        }\n    }\n    \n    return result;\n}", "{\n    var largest = Nullable!(long);\n\
    \    var smallest = Nullable!(long);\n    foreach(i : lst) {\n        if (i <\
    \ 0) {\n            largest = i;\n        } else {\n            smallest = i;\n\
    \        }\n    }\n    return Tuple!(largest, smallest);\n}", "{\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(long x, lst) {\n        if (x < 0) {\n          \
    \  result.a = x;\n        } else {\n            result.b = x;\n        }\n   \
    \ }\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl =>\n        let a = if hd < 0 then None else Some(hd)\n\
    \        let b = if hd > 0 then None else Some(hd)\n        Tuple!(a, b)\nend;\n\
    /*", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n  \
    \  foreach(long x, lst)\n    {\n        if(x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    return result;\n}", "{\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "{\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "{\n    match lst with\n    | [] => (None, None)\n    | x::xs => (\n        if x\
    \ < 0 then Some(None) \n        else if x > 0 then Some(x) \n        else largest_smallest_integers(xs)\n\
    \        )\n    end\n}\n/*", "{\n    var largest = Nullable!(long);\n    var smallest\
    \ = Nullable!(long);\n    foreach(i : lst, \n        largest = i if i > largest,\
    \ \n        smallest = i if i < smallest);\n    return Tuple!(largest, smallest);\n\
    }", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n   \
    \ foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    return result;\n}", "{\n    match lst with\n    | [] =>\
    \ (None, None)\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n                 else if hd > 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (hd, None)\n                 else if hd == 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n                 else Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n    end;\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl => \n        match hd with\n        | None => (None, None)\n   \
    \     | Some(None) => (None, None)\n        | Some(Some(None)) => (None, None)\n\
    \        | Some(Some(Some(None))) => (None, None)\n        | Some(Some(Some(Some(None))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(",
  "{\n    \n    bool isNegative = false;\n    long max = 0;\n    long min = 0;\n \
    \   \n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n         \
    \   isNegative = true;\n        }\n        if (i > 0)\n        {\n           \
    \ if (isNegative)\n            {\n                if (max < i)\n             \
    \   {\n                    max = i;\n                }\n            }\n      \
    \      else\n            {\n                if (min > i)\n                {\n\
    \                    min = i;\n                }\n            }\n        }\n \
    \   }\n    \n    if (isNegative)\n    {\n        return (None, max);\n    }\n\
    \    else\n    {\n        return (Some(min), None);\n    }\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst) {\n        if (x <\
    \ 0) result.a = x;\n        if (x > 0) result.b = x;\n    }\n    \n    return\
    \ result;\n}", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "{\n   \
    \ Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long x,\
    \ lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "{\n    match lst with\n \
    \   | [] => (None, None)\n    | hd::tl =>\n        let (max_int, min_int) = if\
    \ hd < 0 then hd else hd;\n        (max_int, min_int) :: largest_smallest_integers(tl);\n\
    \    | _ => unreachable!();\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl =>\n        let (max_val, min_val) = if hd < 0L then hd::(-1L, hd)\
    \ else hd::(hd, 0L);\n        (max_val, min_val) ||> List.fold_left((max_val,\
    \ min_val), |(max_val, min_val), x| \n            if x < 0L then max_val\n   \
    \         else min_val)\n    end\n}", "{\n    var max: long = 0;\n    var min:\
    \ long = 0;\n    foreach (var i in lst) {\n        if (i < 0) {\n            max\
    \ = i;\n        } else {\n            min = i;\n        }\n    }\n    return Tuple!(Nullable!(long),\
    \ Nullable!(long));\n}", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    if (lst.is_empty)\n    {\n        result.first = null;\n\
    \        result.second = null;\n    }\n    else\n    {\n        auto largest =\
    \ std.math.to.max(lst);\n        auto smallest = std.math.to.min(lst);\n     \
    \   result.first = largest;\n        result.second = smallest;\n    }\n    \n\
    \    return result;\n}", "{\n    var largest = Nullable!(long);\n    var smallest\
    \ = Nullable!(long);\n    foreach(i : lst, \n        largest = max!(largest, i);\n\
    \        smallest = min!(smallest, i));\n    return Tuple!(largest, smallest);\n\
    }", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n   \
    \ foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n  \
    \      } else {\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach (i, e) in lst {\n        if (e < 0)\n            result.a = e;\n\
    \        else\n            result.b = e;\n    }\n    \n    return result;\n}",
  "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) result.a = x;\n        if (x > 0) result.b = x;\n\
    \    }\n    \n    if (result.a == null && result.b == null)\n        return result;\n\
    \    \n    return Tuple!(Nullable!(long), Nullable!(long));\n}", "{\n    match\
    \ lst with\n    | [] => (None, None)\n    | hd::tl => (\n        match hd with\n\
    \        | None => (None, None)\n        | Some(None) => (None, None)\n      \
    \  | Some(Some(None)) => (None, None)\n        | Some(Some(Some(None))) => (None,\
    \ None)\n        | Some(Some(Some(Some(None)))) => (None, None)\n        | Some(Some(Some(Some(Some(Some(None)))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(None)))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(None)))))))))))\
    \ => (None, None)\n        | Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some",
  "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n  \
    \  foreach(i : lst, \n        largest = max!(largest, i);\n        smallest =\
    \ min!(smallest, i));\n    return Tuple!(largest, smallest);\n}\n/*", "{\n   \
    \ match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let a = if\
    \ hd < 0 then None else Some(hd)\n        let b = if hd > 0 then None else Some(hd)\n\
    \        (a, b)\nend\n    \n/*", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach (i, x) in lst {\n        if x < 0 {\n           \
    \ result.0 = x;\n            result.1 = i;\n        }\n    }\n    \n    if result.0\
    \ == null && result.1 == null {\n        return Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    \n    return result;\n}", "{\n    match lst with\n    | [] -> None\n\
    \    | hd::tl -> if hd < 0 then Some(-1 * hd) else Some(hd)\n    \n}", "{\n  \
    \  Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i : lst,\
    \ \n           if (i < 0) \n           {\n               result.a = i;\n     \
    \          result.b = null;\n           }\n           else \n           {\n  \
    \             result.a = null;\n               result.b = i;\n           }\n \
    \   );\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl => (\n        if hd < 0L then hd\n        else if hd > 0L\
    \ then tl |> List.head |> long\n        else (None, None)\n    )\nend;\n/*", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl => (\n        if hd\
    \ < 0L then Some(hd, 0L)\n        else Some(hd, tl.min())\n    )\nend;\n</cell>\n\
    <code language=ocaml-jupyter>\nlet _ = \n    Printf.printf \"(%s, %s)\\n\" (\n\
    \        largest_smallest_integers([2, 4, 1, 3, 5, 7]).0;\n        largest_smallest_integers([]).0;\n\
    \        largest_smallest_integers([0]).0;\n    );;\n</cell>\n<text>\nExercise:\
    \ Write a function that takes a list and returns a tuple where the first element\
    \ is the sum of the elements in the list, and the second element is the product\
    \ of the elements in the list.", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,\
    \ None)\n                   else if hd > 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (hd, None)\n                   else if hd == 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None, None)\n                   else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (hd, hd)\n    end;\n}", "{\n    var largest = Nullable!(long);\n\
    \    var smallest = Nullable!(long);\n    var i = 0;\n    while(i < lst.len) {\n\
    \        if(lst[i] < 0 && largest == Nullable!(long)) {\n            largest =\
    \ Nullable!(long);\n        }\n        if(lst[i] > 0 && smallest == Nullable!(long))\
    \ {\n            smallest = Nullable!(long);\n        }\n        if(largest ==\
    \ Nullable!(long) && smallest == Nullable!(long)) {\n            break;\n    \
    \    }\n        if(lst[i] < 0 && largest == Nullable!(long)) {\n            largest\
    \ = Nullable!(long);\n        }\n        if(lst[i] > 0 && smallest == Nullable!(long))\
    \ {\n            smallest = Nullable!(long);\n        }\n        i += 1;\n   \
    \ }\n    return (largest, smallest);\n}", "{\n    match lst with\n    | [] =>\
    \ (None, None)\n    | hd::tl =>\n        let (max,min) = largest_smallest_integers(tl)\n\
    \        if max > hd then Some(max,hd)\n        elif min < hd then Some(min,hd)\n\
    \        else None\n    end\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl => if hd < 0L then \n                    let (a, b) = (hd, hd -\
    \ 1L) \n                    else \n                    let (a, b) = (hd + 1L,\
    \ hd)\n                    (a, b) \n    | _ => (None, None)\n}\n/*", "{\n    match\
    \ lst with\n    | [] => (None, None)\n    | hd::tl => \n        let a = if hd\
    \ < 0 then None else Some(hd)\n        let b = if hd > 0 then None else Some(hd)\n\
    \        (a, b)\n    | _ => (None, None)\n}\n/*", "{\n    \n    bool isNegative\
    \ = true;\n    long max = 0;\n    long min = 0;\n    \n    for (long i : lst)\n\
    \    {\n        if (i < 0)\n        {\n            isNegative = false;\n     \
    \   }\n        \n        if (i > max)\n        {\n            max = i;\n     \
    \   }\n        \n        if (i < min)\n        {\n            min = i;\n     \
    \   }\n    }\n    \n    if (isNegative)\n    {\n        return (None, max);\n\
    \    }\n    else\n    {\n        return (min, None);\n    }\n}", "{\n    match\
    \ lst with\n    | [] => (None, None)\n    | hd::tl => \n        match hd with\n\
    \        | None => (None, None)\n        | Some x => \n            match tl with\n\
    \            | [] => (None, None)\n            | hd::tl => \n                match\
    \ hd with\n                | None => (None, None)\n                | Some y =>\
    \ \n                    if x < y then (x, y)\n                    else (None,\
    \ None)\n            end\n        end\n    end\n}", "{\n    var largest = Nullable!(long);\n\
    \    var smallest = Nullable!(long);\n    foreach (i, el) in lst {\n        if\
    \ (el < 0) largest = el;\n        else if (el > 0) smallest = el;\n    }\n   \
    \ return Tuple!(largest, smallest);\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(long x, lst) {\n        if (x < 0) {\n          \
    \  result.a = x;\n        } else {\n            result.b = x;\n        }\n   \
    \ }\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl =>\n        let (smallest, largest) = largest_smallest_integers(tl)\n\
    \        if smallest < hd then (smallest, hd)\n        else (largest, hd)\n  \
    \  end\n}", "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.len();\n    while\
    \ (i < n) {\n        if (lst[i] < 0) {\n            if (largest == Nullable!(long))\
    \ {\n                largest = Nullable!(long);\n                smallest = Nullable!(long);\n\
    \            }\n            largest = Nullable!(long);\n            smallest =\
    \ Nullable!(long);\n        } else if (lst[i] > 0) {\n            if (smallest\
    \ == Nullable!(long)) {\n                largest = Nullable!(long);\n        \
    \        smallest = Nullable!(long);\n            }\n            largest = Nullable!(long);\n\
    \            smallest = Nullable!(long);\n        } else {\n            if (largest\
    \ == Nullable!(long)) {\n                largest = Nullable!(long);\n        \
    \        smallest = Nullable!(long);\n            }\n            largest = Nullable!(long);\n\
    \            smallest = Nullable!(long);\n        }\n        i++;\n    }\n   \
    \ return Tuple!(largest, smallest);\n}\n/*", "{\n    match lst with\n    | []\
    \ => (None, None)\n    | hd::tl => (\n        if hd < 0L then hd\n        else\
    \ if hd > 0L then tl |> List.head |> long\n        else (None, None)\n    )\n\
    end\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([2, 4, 1, 3,\
    \ 5, 7])\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.3>\nlargest_smallest_integers([0])\n</cell>\n\
    <text>\nExercise: Write a function that takes a string and returns the number\
    \ of vowels in it.", "{\n    match lst with\n    | [] -> None\n    | hd::tl ->\
    \ \n        let (smallest, largest) = if hd < 0 then Some(hd, -hd) else None\n\
    \        smallest, largest\nend;\n/*", "{\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long,\
    \ Nullable!(long)))\n    | _ -> let mutable smallest = Long.MinValue; mutable\
    \ largest = Long.MaxValue;\n        for n in lst do\n            if n < smallest\
    \ then smallest = n\n            if n > largest then largest = n\n    \n    Tuple!(Nullable!(long),\
    \ Nullable!(long))(smallest, largest)\nend\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype largest_smallest_integers([])\n</cell>\n<code language=julia-1.3>\n\
    @code_warntype largest_smallest_integers([0])\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a list as input and returns a tuple where the first element\
    \ is the sum of the positive integers in the list, and the second element is the\
    \ sum of the negative integers in the list.", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(i : lst, \n           {\n      \
    \         if (i < 0) \n               {\n                   result.a = i;\n  \
    \                 result.b = null;\n               }\n               else \n \
    \              {\n                   result.a = null;\n                   result.b\
    \ = i;\n               }\n           });\n    \n    return result;\n}", "{\n \
    \   \n    long a = null;\n    long b = null;\n    \n    foreach(long x, lst)\n\
    \    {\n        if (x < 0)\n        {\n            a = x;\n        }\n       \
    \ else if (x > 0)\n        {\n            b = x;\n        }\n    }\n    \n   \
    \ return Tuple!(a, b);\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (hd, tl.min())\n    end;\n}",
  "{\n    var max: long = Long.min;\n    var min: long = Long.max;\n    var i: long\
    \ = 0;\n    while (i<lst.len) {\n        if (lst[i] < min) {\n            min\
    \ = lst[i];\n        }\n        if (lst[i] > max) {\n            max = lst[i];\n\
    \        }\n        i += 1;\n    }\n    return (max, min);\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    if (lst.is_empty())\n    {\n        result.first\
    \ = null;\n        result.second = null;\n        return result;\n    }\n    \n\
    \    long largest = lst.max();\n    long smallest = lst.min();\n    \n    if (largest\
    \ < 0)\n    {\n        result.first = null;\n        result.second = null;\n \
    \       return result;\n    }\n    \n    if (smallest > 0)\n    {\n        result.first\
    \ = smallest;\n        result.second = largest;\n        return result;\n    }\n\
    \    \n    result.first = null;\n    result.second = null;\n    return result;\n\
    }", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if (lst.is_empty())\n\
    \    {\n        result.a = result.b = null;\n        return result;\n    }\n \
    \   \n    long max_negative = lst.iter().max().unwrap();\n    long min_positive\
    \ = lst.iter().min().unwrap();\n    \n    if (max_negative < 0)\n    {\n     \
    \   result.a = null;\n        result.b = max_negative;\n    }\n    else if (min_positive\
    \ > 0)\n    {\n        result.a = min_positive;\n        result.b = null;\n  \
    \  }\n    else\n    {\n        result.a = max_negative;\n        result.b = min_positive;\n\
    \    }\n    \n    return result;\n}", "{\n    var largest = Nullable!(long);\n\
    \    var smallest = Nullable!(long);\n    var i = 0;\n    var j = 0;\n    var\
    \ k = 0;\n    var n = lst.Length;\n    while (i < n) {\n        if (lst[i] < 0)\
    \ {\n            if (largest == Nullable!(long)) {\n                largest =\
    \ Nullable!(long);\n                smallest = Nullable!(long);\n            }\n\
    \            largest = Nullable!(long);\n            smallest = Nullable!(long);\n\
    \        }\n        else if (lst[i] > 0) {\n            if (smallest == Nullable!(long))\
    \ {\n                largest = Nullable!(long);\n                smallest = Nullable!(long);\n\
    \            }\n            largest = Nullable!(long);\n            smallest =\
    \ Nullable!(long);\n        }\n        else {\n            if (largest == Nullable!(long))\
    \ {\n                largest = Nullable!(long);\n                smallest = Nullable!(long);\n\
    \            }\n            largest = Nullable!(long);\n            smallest =\
    \ Nullable!(long);\n        }\n        i++;\n    }\n    if (largest == Nullable!(long))\
    \ {\n        return (Nullable!(long), Nullable!(long));\n    }\n    if (smallest\
    \ == Nullable!(long)) {\n        return (Nullable!(long), Nullable!(long));\n\
    \    }\n    return (largest, smallest);\n}", "{\n    match lst with\n    | []\
    \ => (None, None)\n    | hd::tl => \n        let (max_int, min_int) = largest_smallest_integers(tl)\n\
    \        match max_int with\n        | None => (None, None)\n        | Some x\
    \ => \n            if x < 0 then \n                (Some(max_int), Some(min_int))\n\
    \            else\n                (Some(x), None)\n        end\n    end\n}\n\
    /*", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0)\n            result.a = e;\n        else\n\
    \            result.b = e;\n    }\n    \n    if (result.a == result.b)\n     \
    \   return result;\n    else\n        return Tuple!(Nullable!(long), Nullable!(long));\n\
    }", "{\n    \n    bool negative = false;\n    long max = 0;\n    long min = 0;\n\
    \    \n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n        \
    \    negative = true;\n        }\n        \n        if (i > max)\n        {\n\
    \            max = i;\n        }\n        \n        if (i < min)\n        {\n\
    \            min = i;\n        }\n    }\n    \n    if (negative == false)\n  \
    \  {\n        return (max, min);\n    }\n    else\n    {\n        return (None,\
    \ None);\n    }\n}", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl\
    \ => if hd < 0 then Some(Some(hd), None) else Some(None, Some(tl))\n    end;\n\
    }", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n      \
    \  let (isNegative, smallest) = largest_smallest_integers(tl)\n        if isNegative\
    \ then (hd, smallest)\n        else (smallest, hd)\n    end\n}", "{\n    \n  \
    \  Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i : lst,\
    \ \n           {\n               if (i < 0) \n               {\n             \
    \      result.a = i;\n                   result.b = null;\n               }\n\
    \               else\n               {\n                   result.a = null;\n\
    \                   result.b = i;\n               }\n           });\n    \n  \
    \  return result;\n}", "{\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n  \
    \  var i = 0;\n    var j = 0;\n    \n    while (i < lst.len) {\n        if (lst[i]\
    \ < 0)\n            smallest = Nullable!(long);\n        else\n            smallest\
    \ = Nullable!(long);\n        \n        while (j < lst.len) {\n            if\
    \ (lst[j] > 0)\n                largest = Nullable!(long);\n            else\n\
    \                largest = Nullable!(long);\n            \n            if (largest\
    \ != Nullable!(long) && smallest != Nullable!(long))\n                break;\n\
    \            \n            if (lst[j] < 0)\n                smallest = Nullable!(long);\n\
    \            else\n                smallest = Nullable!(long);\n            \n\
    \            j++;\n        }\n        \n        if (largest != Nullable!(long)\
    \ && smallest != Nullable!(long))\n            break;\n        \n        i++;\n\
    \    }\n    \n    return Tuple!(largest, smallest);\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(i : lst, \n        Tuple!(Nullable!(long),\
    \ Nullable!(long)) t = largest_smallest_integer(i)) {\n        result = t if t.a\
    \ > result.a else result;\n    }\n    \n    result.a = result.a if result.a !=\
    \ None else None;\n    result.b = result.b if result.b != None else None;\n  \
    \  \n    return result;\n}", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl =>\n        let (max,min) = if hd < 0 then (None,None) else (Some(hd),Some(tl))\n\
    \        (Some(max), Some(min))\nend\n}", "{\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n\
    \    \n    foreach(i : lst, \n        Tuple!(Nullable!(long), Nullable!(long))\
    \ t = largest_smallest_integers([i]))\n    {\n        result = max!(result, t);\n\
    \    }\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl => \n        let (small, large) = largest_smallest_integers(tl)\n\
    \        match small, large with\n        | None, None => (None, None)\n     \
    \   | None, hd::tl => (None, hd)\n        | hd::small, None => (hd, None)\n  \
    \      | hd::small, hd::large => (hd, hd::small)\n        | hd::small, hd::large\
    \ => (hd::small, hd)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small, hd::large\
    \ => (hd, hd::small)\n        | hd::small, hd::large => (hd::large, hd)\n    \
    \    | hd::small, hd::large => (hd, hd::large)\n        | hd::small", "{\n   \
    \ match lst with\n    | [] => (None, None)\n    | hd::tl => if hd < 0 then (None,\
    \ hd) else (Some(hd), Some(tl))\n    end\n}", "{\n    match lst with\n    | []\
    \ => (None, None)\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (None,None) else Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n    | hd::tl\
    \ => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else\
    \ Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n    | hd::tl => if\
    \ hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (Some(hd),None)\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) else Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n    | hd::tl\
    \ => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else\
    \ Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n    | hd::tl => if\
    \ hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (Some(hd),None)\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None,None) else Tuple!(Nullable!(long), Nullable!(long)) (None,Some(hd))\n\
    \    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (Some(hd),None)\n    | hd::tl\
    \ => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long)) (None,None) else\
    \ Tuple!(Nullable!(long", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n\
    \    \n    foreach(long x, lst) {\n        if (x < 0) {\n            result.a\
    \ = x;\n        } else {\n            result.b = x;\n        }\n    }\n    \n\
    \    return result;\n}", "{\n    match lst with\n    | [] => (None, None)\n  \
    \  | hd::tl =>\n        let (smallest, largest) = if hd < 0 then hd else hd ::\
    \ tl in\n        (smallest, largest)\nend;\n/*", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(i : lst, \n           {\n      \
    \         if (i < 0) \n               {\n                   result.a = i;\n  \
    \                 result.b = null;\n               }\n               else if (i\
    \ > 0) \n               {\n                   result.a = null;\n             \
    \      result.b = i;\n               }\n               else \n               {\n\
    \                   result.a = null;\n                   result.b = null;\n  \
    \             }\n           });\n    \n    return result;\n}", "{\n    match lst\
    \ with\n    | [] => (None, None)\n    | hd::tl =>\n        let a = if hd < 0 then\
    \ None else Some(hd)\n        let b = if hd > 0 then None else Some(hd)\n    \
    \    Tuple!(a, b)\nend\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=julia-1.3>\nlargest_smallest_integers([0])\n</cell>\n\
    <text>\nExercise: Write a function that takes a vector of integers and returns\
    \ a tuple where the first element is the sum of the positive integers in the vector,\
    \ and the second element is the sum of the negative integers in the vector.",
  "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i :\
    \ lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t : Tuple!(Nullable!(long),\
    \ Nullable!(long))) \n    {\n        if (t.0 == null || t.1 == null) \n      \
    \  {\n            result = t;\n        }\n        else if (t.0 < 0 && t.1 < 0)\
    \ \n        {\n            result = t;\n        }\n    }\n    \n    return result;\n\
    }", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if(x < 0)\n        {\n            result.a = x;\n  \
    \          result.b = null;\n        }\n        else\n        {\n            result.b\
    \ = x;\n            result.a = null;\n        }\n    }\n    \n    return result;\n\
    }", "{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach (i, x) in lst {\n        if x < 0 {\n            largest = x;\n \
    \       } else {\n            smallest = x;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}", "{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Null", "{\n    match lst with\n\
    \    | [] => (None, None)\n    | hd::tl => (\n        if hd < 0L then hd\n   \
    \     else if hd > 0L then tl |> List.head |> long\n        else (None, None)\n\
    \    )\n}", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\
    \ if hd < 0 then Some(Some(hd), None) else Some(None, Some(tl))\n    end;\n}\n\
    /*", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n     \
    \   let (max_int, min_int) = if hd < 0 then hd else hd + 1\n        (max_int,\
    \ min_int)\n        |> List.foldBack((max_int, min_int), tl, fun (max_int, min_int)\
    \ (x) -> if x < 0 then max_int else min_int)\n        |> fst\n        |> Some\n\
    \    | _ => (None, None)\n}\n/*", "{\n    match lst with\n    | [] => (None, None)\n\
    \    | hd::tl =>\n        let (isNegative, smallest) = largest_smallest_integers(tl)\n\
    \        if isNegative then\n            (Some(hd), smallest)\n        else\n\
    \            (None, Some(hd))\n    end\n}", "{\n    match lst with\n    | [] =>\
    \ (None, None)\n    | hd::tl =>\n        let a = if hd < 0 then None else Some(hd)\n\
    \        let b = if hd > 0 then None else Some(hd)\n        (a, b)\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype largest_smallest_integers([2, 4, 1,\
    \ 3, 5, 7])\n</cell>\n<text>\nExercise: Write a function that returns the largest\
    \ and smallest numbers in a list.", "{\n    var largest = Nullable!(long);\n \
    \   var smallest = Nullable!(long);\n    var i = 0;\n    var j = 0;\n    var n\
    \ = lst.len();\n    while (i < n) {\n        if (lst[i] < 0)\n            smallest\
    \ = Nullable!(long);\n        else\n            largest = Nullable!(long);\n \
    \       j = 0;\n        while (j < i) {\n            if (lst[j] > 0)\n       \
    \         smallest = Nullable!(long);\n            else\n                largest\
    \ = Nullable!(long);\n            if (largest < smallest)\n                largest\
    \ = Nullable!(long);\n            else\n                smallest = Nullable!(long);\n\
    \            j++;\n        }\n        i++;\n    }\n    return Tuple!(largest,\
    \ smallest);\n}", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl\
    \ =>\n        let a = if hd < 0 then None else Some(hd)\n        let b = if hd\
    \ > 0 then None else Some(hd)\n        (a, b)\nend\n</cell>\n<code language=julia-1.3>\n\
    largest_smallest_integers([2, 4, 1, 3, 5, 7])\n</cell>\n<code language=julia-1.3>\n\
    largest_smallest_integers([])\n</cell>\n<code language=julia-1.3>\nlargest_smallest_integers([0])\n\
    </cell>\n<text>\nExercise: Write a function that takes a vector of integers and\
    \ returns a tuple where the first element is the sum of the positive integers\
    \ and the second element is the sum of the negative integers. If the vector is\
    \ empty, return (None, None). Otherwise, return (sum_positive_integers(v), sum_negative_integers(v)).\
    \ Test your function with various inputs. What happens when you pass in an empty\
    \ vector?", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl =>\
    \ if hd < 0 then Some(Some(hd), None) else None\n                 |> List.foldBack((Some(Some(-1)),\
    \ None))\n                 |> fst\n                 |> Some\n                \
    \ |> Some\n                 |> fst\n                 |> Some\n               \
    \  |> Some\n                 |> fst\n                 |> Some\n              \
    \   |> Some\n                 |> Some\n                 |> Some\n            \
    \     |> Some\n                 |> Some\n                 |> Some\n          \
    \       |> Some\n                 |> Some\n                 |> Some\n        \
    \         |> Some\n                 |> Some\n                 |> Some\n      \
    \           |> Some\n                 |> Some\n                 |> Some\n    \
    \             |> Some\n                 |> Some\n                 |> Some\n  \
    \               |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |> Some\n                 |> Some\n                 |> Some\n\
    \                 |>", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(long x, lst) {\n        if (x < 0) {\n          \
    \  result.a = x;\n        } else {\n            result.b = x;\n        }\n   \
    \ }\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | x::xs => {\n        let (smallest, largest) = largest_smallest_integers(xs);\n\
    \        if smallest < x && largest > x then (smallest, largest)\n        else\
    \ (None, None)\n    }\n}", "{\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "{\n    match lst with\n    | [] -> Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Null", "{\n    var largest = Nullable!(long);\n\
    \    var smallest = Nullable!(long);\n    foreach(i : lst, \n    {\n        if\
    \ (i.isNegative)\n        {\n            if (largest == Nullable!(long))\n   \
    \             largest = i;\n            else\n                smallest = i;\n\
    \        }\n        else\n        {\n            if (smallest == Nullable!(long))\n\
    \                smallest = i;\n            else\n                largest = i;\n\
    \        }\n    });\n    return Tuple!(largest, smallest);\n}", "{\n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst)\n    {\n        if\
    \ (x < 0)\n        {\n            result.a = x;\n            result.b = Nullable!(long);\n\
    \        }\n        else\n        {\n            result.b = x;\n            result.a\
    \ = Nullable!(long);\n        }\n    }\n    \n    return result;\n}", "{\n   \
    \ match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (max_int,\
    \ min_int) = if hd > 0 then Some(hd, -hd) else None;\n        let (max_int, min_int)\
    \ = if min_int > 0 then Some(max_int, min_int) else None;\n        largest_smallest_integers(tl);\n\
    \        (max_int, min_int)\n    end;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(i : lst, \n           {\n               if (i < 0)\
    \ \n               {\n                   result.a = i;\n                   result.b\
    \ = null;\n               }\n               else \n               {\n        \
    \           result.a = null;\n                   result.b = i;\n             \
    \  }\n           });\n    \n    return result;\n}", "{\n    match lst with\n \
    \   | [] => (None, None)\n    | hd::tl =>\n        let (max_int, min_int) = if\
    \ hd < 0 then hd else hd \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else hd) \n                               (if hd <\
    \ 0 then hd else hd) \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else hd) \n                               (if hd <\
    \ 0 then hd else hd) \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else hd) \n                               (if hd <\
    \ 0 then hd else hd) \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else hd) \n                               (if hd <\
    \ 0 then hd else hd) \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else hd) \n                               (if hd <\
    \ 0 then hd else hd) \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else hd) \n                               (if hd <\
    \ 0 then hd else hd) \n                               (if hd < 0 then hd else\
    \ hd) \n                               (if hd < 0 then hd else hd) \n        \
    \                       (if hd < 0 then hd else hd) \n                       \
    \        (if hd < 0 then hd else ", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | x::xs => (if x < 0 then x else None, if x > 0 then x else None)\n\
    \    end;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n\
    \    foreach(long x, lst) {\n        if (x < 0) {\n            result.a = x;\n\
    \        } else {\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}", "{\n    match lst with\n    | [] => (None, None)\n    | hd::tl\
    \ => if hd < 0L then Some((hd, 0L)) else Some((0L, hd))\n                 |> List.maxBy(fun\
    \ (a, b) -> b)\n                 |> Some\n    | _ => (None, None)\n}\n/*", "{\n\
    \    match lst with\n    | [] => (None, None)\n    | hd::tl =>\n        let (small,\
    \ large) = largest_smallest_integers(tl)\n        match small with\n        |\
    \ None => (hd, large)\n        | Some small' => (small', large)\n    end\n}",
  "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if (lst.is_empty())\n\
    \    {\n        result.first = null;\n        result.second = null;\n    }\n \
    \   else\n    {\n        auto largest = std.math::max_element(lst);\n        auto\
    \ smallest = std.math::min_element(lst);\n        result.first = largest;\n  \
    \      result.second = smallest;\n    }\n    \n    return result;\n}", "{\n  \
    \  match lst with\n    | [] -> None\n    | h::t -> if h < 0 then None else if\
    \ h > 0 then Some(h, t) else largest_smallest_integers(t)\nend\n    \n/*", "{\n\
    \    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i : lst,\
    \ \n        Tuple!(Nullable!(long), Nullable!(long)) t : Tuple!(Nullable!(long),\
    \ Nullable!(long))) \n    {\n        if (t.0 == null || t.1 == null) \n      \
    \  {\n            result.0 = t.0;\n            result.1 = t.1;\n        }\n  \
    \      else if (t.0 < 0 && t.1 < 0) \n        {\n            result.0 = t.0;\n\
    \            result.1 = t.1;\n        }\n        else if (t.0 < 0 && t.1 > 0)\
    \ \n        {\n            result.0 = t.0;\n            result.1 = t.1;\n    \
    \    }\n        else if (t.0 > 0 && t.1 < 0) \n        {\n            result.0\
    \ = t.0;\n            result.1 = t.1;\n        }\n        else if (t.0 > 0 &&\
    \ t.1 > 0) \n        {\n            result.0 = t.0;\n            result.1 = t.1;\n\
    \        }\n        else \n        {\n            result.0 = null;\n         \
    \   result.1 = null;\n        }\n    }\n    \n    return result;\n}", "{\n   \
    \ match lst with\n    | [] => (None, None)\n    | hd::tl => \n        let (max_int,\
    \ min_int) = if hd < 0 then \n            (Nullable!(long), Nullable!(long))\n\
    \            else \n            (Nullable!(long), Nullable!(long))\n        in\
    \ \n            match max_int with\n            | None => \n                let\
    \ (max_int, min_int) = if min_int < 0 then \n                    (Nullable!(long),\
    \ Nullable!(long))\n                    else \n                    (Nullable!(long),\
    \ Nullable!(long))\n                in \n                    match min_int with\n\
    \                    | None => \n                        let (max_int, min_int)\
    \ = if hd < 0 then \n                            (Nullable!(long), Nullable!(long))\n\
    \                            else \n                            (Nullable!(long),\
    \ Nullable!(long))\n                        in \n                            match\
    \ max_int with\n                            | None => \n                     \
    \           let (max_int, min_int) = if min_int < 0 then \n                  \
    \                  (Nullable!(long), Nullable!(long))\n                      \
    \              else \n                                    (Nullable!(long), Nullable!(long))\n\
    \                                in \n                                    match\
    \ min_int with\n                                    | None => \n             \
    \                           let (max_int, min_int) = if hd < 0 then \n       \
    \                                     (Nullable!(long), Nullable!(long))\n   \
    \                                         else \n                            \
    \                (Nullable!(long), Nullable!(long))\n                        \
    \                in \n                                            match max_int\
    \ with\n                                            | None => \n             \
    \                                   let (max_int, min_int) = if min_int < 0 then\
    \ \n                                                    (Nullable!(long), Nullable!(long))\n\
    \                                                    else \n                 \
    \                                   (Nullable!(long), Nullable!(long))\n     \
    \                                           in \n                            \
    \                        match min_int with\n                                \
    \                    | None => \n                                            \
    \            let (max_int, min_int) = if hd < 0 then \n                      \
    \                                      (Nullable!(long), Nullable!(long))\n  \
    \                                                          else \n           \
    \                                                 (Nullable!(long), Nullable!(long))\n\
    \                                                        in \n               \
    \                                             match max_int with\n           \
    \                                                 | None => \n               \
    \                                                 let (max_int, min_int) = if\
    \ min_int < 0 then \n                                                        \
    \            (Nullable!(long), Nullable!(long))\n                            \
    \                                        else \n                             \
    \                                       (Nullable!(long), Nullable!(long))\n \
    \                                                               in \n        \
    \                                                            match min_int with\n\
    \                                                                    | None =>\
    \ \n                                                                        let\
    \ (max_int, min_int) = if hd < 0 then \n                                     \
    \                                       (Nullable!(long), Nullable!(long))\n",
  "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i :\
    \ lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n            Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n                if(i<0) Tuple!(Nullable!(long), Nullable!(long))\
    \ (None,None) \n                else Tuple!(Nullable!(long), Nullable!(long))\
    \ (None,i)\n            )\n    )\n    \n    result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n        Tuple!(Nullable!(long), Nullable!(long)) (\n            if((result.f0.f0\
    \ != None) && (result.f0.f0 > result.f1.f0)) result.f0 \n            else result.f1\n\
    \        ),\n        Tuple!(Nullable!(long), Nullable!(long)) (\n            if((result.f0.f0\
    \ != None) && (result.f0.f0 < result.f1.f0)) result.f1 \n            else result.f0\n\
    \        )\n    );\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(long x, lst) {\n        if(x < 0)\
    \ {\n            result.a = x;\n        } else {\n            result.b = x;\n\
    \        }\n    }\n    \n    if(result.a == null) {\n        result.a = result.b;\n\
    \    }\n    \n    return result;\n}", "{\n    match lst with\n    | [] => (None,\
    \ None)\n    | hd::tl => if hd < 0 then Tuple!(Nullable!(long), Nullable!(long))\
    \ (None, None)\n                   else if hd > 0 then Tuple!(Nullable!(long),\
    \ Nullable!(long)) (hd, None)\n                   else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (None, None)\n    end;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    if (lst.is_empty())\n    {\n        result.first\
    \ = null;\n        result.second = null;\n    }\n    else\n    {\n        long\
    \ a = lst.min();\n        long b = lst.max();\n        if ((a < 0) && (b > 0))\n\
    \        {\n            result.first = null;\n            result.second = null;\n\
    \        }\n        else if ((a > 0) && (b < 0))\n        {\n            result.first\
    \ = a;\n            result.second = b;\n        }\n        else\n        {\n \
    \           result.first = a;\n            result.second = b;\n        }\n   \
    \ }\n    \n    return result;\n}", "{\n    \n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(i : lst, \n           if(i < 0) result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n           else result = Tuple!(Nullable!(long), Nullable!(long)));\n\
    \    \n    return result;\n}", "{\n    var largest = Nullable!(long);\n    var\
    \ smallest = Nullable!(long);\n    foreach (i, el) in lst {\n        if el < 0\
    \ {\n            largest = el;\n        } else {\n            smallest = el;\n\
    \        }\n    }\n    return Tuple!(largest, smallest);\n}", "{\n    match lst\
    \ with\n    | [] => (None, None)\n    | hd::tl =>\n        let (max,min) = hd.max()\
    \ in \n        let (max,min) = min.max() in \n        (max, min)\nend\n}", "{\n\
    \    \n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i : lst,\
    \ \n           if (i < 0) \n           {\n               result.a = i;\n     \
    \          result.b = Nullable!(long);\n           }\n           else\n      \
    \     {\n               result.a = Nullable!(long);\n               result.b =\
    \ i;\n           }\n    );\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long),\
    \ Nullable!(long)) result;\n    \n    foreach(i : lst, \n        Tuple!(Nullable!(long),\
    \ Nullable!(long)) tuple = \n            Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n                if(i<0) Tuple!(Nullable!(long), Nullable!(long)) (None,None)\
    \ \n                else Tuple!(Nullable!(long), Nullable!(long)) (\n        \
    \            if(i>0) Tuple!(Nullable!(long), Nullable!(long)) (None,None) \n \
    \                   else Tuple!(Nullable!(long), Nullable!(long)) (i, None) \n\
    \                )\n            )\n    )\n    \n    result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n        Tuple!(Nullable!(long), Nullable!(long)) (\n   \
    \         ifelse(result.f0.f0 > result.f0.f1, result.f0, result.f1),\n       \
    \     ifelse(result.f0.f0 > result.f0.f1, result.f1, result.f0)\n        )\n \
    \   );\n    \n    return result;\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long))\
    \ result;\n    \n    foreach(long x, lst) {\n        if(x < 0) {\n           \
    \ result.a = x;\n        } else {\n            result.b = x;\n        }\n    }\n\
    \    \n    if(!result.a && !result.b) {\n        return result;\n    } else {\n\
    \        return Tuple!(Nullable!(long), Nullable!(long));\n    }\n}", "{\n   \
    \ match lst with\n    | [] => (None, None)\n    | x::xs => (\n        if x < 0\
    \ then (None, x)\n        else (Some(x), xs)\n    )\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, None)\n@assert\
    \ largest_smallest_integers([]) == (None, None)\n@assert largest_smallest_integers([0])\
    \ == (None, None)\n</cell>\n<text>\nExercise\nWrite a function that returns the\
    \ largest and smallest numbers in a list.", "{\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n\
    \    \n    if (lst.is_empty())\n    {\n        result.first = None;\n        result.second\
    \ = None;\n    }\n    else\n    {\n        long largest = std.math.to.max(lst);\n\
    \        long smallest = std.math.to.min(lst);\n        result.first = None;\n\
    \        result.second = None;\n        if (largest < smallest)\n        {\n \
    \           result.first = largest;\n            result.second = smallest;\n \
    \       }\n    }\n    \n    return result;\n}", "{\n    match lst with\n    |\
    \ [] => (None, None)\n    | hd::tl =>\n        let (max_int, min_int) = if hd\
    \ < 0 then \n            (Nullable!(hd), Nullable!(hd))\n        else \n     \
    \       (Nullable!(hd), Nullable!(tl))\n        \n        (max_int, min_int)\n\
    end\n    \n/*", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "{\n\
    \    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i : lst,\
    \ \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integers(i))\n\
    \    {\n        if(!t.v1)\n        {\n            result.v1 = null;\n        \
    \    result.v2 = t.v2;\n        }\n        else if(t.v1 > result.v1)\n       \
    \ {\n            result.v1 = t.v1;\n            result.v2 = t.v2;\n        }\n\
    \    }\n    \n    return result;\n}", "{\n    match lst with\n    | [] -> Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long,\
    \ Nullable!(long, Nullable!(long, Nullable!(long, Nullable!(long, Null", "{\n\
    \    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if (lst.is_empty())\n\
    \        return result;\n    \n    long a = lst.iter().max().unwrap();\n    long\
    \ b = lst.iter().min().unwrap();\n    \n    if (a < 0)\n        return result;\n\
    \    \n    if (b > 0)\n        return result;\n    \n    return Tuple!(Nullable!(long),\
    \ Nullable!(long));\n}", "{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n\
    \    \n    foreach(i : lst, \n        Tuple!(Nullable!(long), Nullable!(long))\
    \ tuple = \n            Tuple!(Nullable!(long), Nullable!(long)) (\n         \
    \       if(i<0) None else Some(i), \n                if(i>0) None else Some(i)));\n\
    \    \n    foreach(i : lst, \n        Tuple!(Nullable!(long), Nullable!(long))\
    \ tuple = \n            Tuple!(Nullable!(long), Nullable!(long)) (\n         \
    \       if(i<0) None else Some(i), \n                if(i>0) None else Some(i)));\n\
    \    \n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
