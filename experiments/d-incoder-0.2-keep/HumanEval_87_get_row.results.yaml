name: HumanEval_87_get_row
language: humaneval_to_dlang.py
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][lst[0].length];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i][j] = 1;\n            }\n            else\n            {\n       \
    \         res[i][j] = 0;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) -> {\n        if(a[0] == b[0])\n        {\n     \
    \       return a[1] < b[1] ? -1 : 1;\n        }\n        else\n        {\n   \
    \         return a[0] < b[0] ? -1 : 1;\n        }\n    });\n    \n    long[] row\
    \ = new long[res.length];\n    for(int i = 0; i < res.length; i++)\n    {\n  \
    \      row[i] = res[i][0];\n    }\n    \n    Arrays.sort(row, (a, b) -> {\n  \
    \      if(a[0] == b[0])\n        {\n            return a[1] < b[1] ? -1 : 1;\n\
    \        }\n        else\n        {\n            return a[0] < b[0] ? -1 : 1;\n\
    \        }\n    });\n    \n    long[] col = new long[res.length];\n    for(int\
    \ i = 0; i < res.length; i++)\n    {\n        col[i] = res[i][1];\n    }\n   \
    \ \n    Arrays.sort(col, (a, b) -> {\n        if(a[0] == b[0])\n        {\n  \
    \          return a[1] < b[1] ? -1 : 1;\n        }\n        else\n        {\n\
    \            return a[0] < b[0] ? -1 : 1;\n        }\n    });\n    \n    Tuple!(long,\
    \ long)[] ret = new Tuple!(long, long)[res.length];\n    for(int i = 0; i < res.length;\
    \ i++)\n    {\n        ret[i] = Tuple!(long, long)((row[i], col[i]));\n    }\n\
    \    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5isja_us.d(43): Error: expression expected, not `>`\\n/tmp/tmp5isja_us.d(43):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmp5isja_us.d(44): Error: expression\
    \ expected, not `if`\\n/tmp/tmp5isja_us.d(45): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmp5isja_us.d(46): Error: expression expected, not `return`\\n/tmp/tmp5isja_us.d(46):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmp5isja_us.d(46): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmp5isja_us.d(47): Error: expression expected, not\
    \ `}`\\n/tmp/tmp5isja_us.d(48): Error: found `else` when expecting `,`\\n/tmp/tmp5isja_us.d(52):\
    \ Error: found `}` when expecting `,`\\n/tmp/tmp5isja_us.d(60): Error: expression\
    \ expected, not `>`\\n/tmp/tmp5isja_us.d(60): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmp5isja_us.d(61): Error: expression expected, not `if`\\n/tmp/tmp5isja_us.d(62):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmp5isja_us.d(63): Error: expression\
    \ expected, not `return`\\n/tmp/tmp5isja_us.d(63): Error: found `a` when expecting\
    \ `,`\\n/tmp/tmp5isja_us.d(63): Error: found `;` when expecting `,`\\n/tmp/tmp5isja_us.d(64):\
    \ Error: expression expected, not `}`\\n/tmp/tmp5isja_us.d(65): Error: found `else`\
    \ when expecting `,`\\n/tmp/tmp5isja_us.d(69): Error: found `}` when expecting\
    \ `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5isja_us.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n     \
    \   {\n            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[](Tuple!(0, i), Tuple!(0, j));\n                break;\n            }\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb1ofxj2b.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpb1ofxj2b.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpb1ofxj2b.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpb1ofxj2b.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpb1ofxj2b.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpb1ofxj2b.d(29): Error: found `:` when expecting `;`\\n/tmp/tmpb1ofxj2b.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpb1ofxj2b.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpb1ofxj2b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    \n    for(i = 0; i < n; i++)\n    {\n\
    \        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n \
    \           {\n                return Tuple!((long) i, (long) j);\n          \
    \  }\n        }\n    }\n    return Tuple!(0, 0);\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_no90ih3.d(36): Error: C style cast illegal, use `cast(long)i`\\\
    n/tmp/tmp_no90ih3.d(36): Error: C style cast illegal, use `cast(long)j`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_no90ih3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j\
    \ : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res.add((i, j));\n            }\n        }\n    }\n    \n   \
    \ sort(res, (i, j) -> {\n        if(j == 0)\n            return 1;\n        else\
    \ if(j == lst[i].len())\n            return -1;\n        else\n            return\
    \ 0;\n    });\n    \n    sort(res, (i, j) -> {\n        if(j == 0)\n         \
    \   return -1;\n        else if(j == lst[i].len())\n            return 1;\n  \
    \      else\n            return 0;\n    });\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoxmk4hla.d(28): Error: no identifier for declarator `i`\\n/tmp/tmpoxmk4hla.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpoxmk4hla.d(30): Error: no identifier\
    \ for declarator `j`\\n/tmp/tmpoxmk4hla.d(30): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpoxmk4hla.d(39): Error: expression expected, not `>`\\n/tmp/tmpoxmk4hla.d(39):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpoxmk4hla.d(40): Error: expression\
    \ expected, not `if`\\n/tmp/tmpoxmk4hla.d(41): Error: found `return` when expecting\
    \ `,`\\n/tmp/tmpoxmk4hla.d(41): Error: found `;` when expecting `,`\\n/tmp/tmpoxmk4hla.d(42):\
    \ Error: expression expected, not `else`\\n/tmp/tmpoxmk4hla.d(42): Error: found\
    \ `if` when expecting `,`\\n/tmp/tmpoxmk4hla.d(43): Error: found `return` when\
    \ expecting `,`\\n/tmp/tmpoxmk4hla.d(43): Error: found `;` when expecting `,`\\\
    n/tmp/tmpoxmk4hla.d(44): Error: expression expected, not `else`\\n/tmp/tmpoxmk4hla.d(45):\
    \ Error: found `return` when expecting `,`\\n/tmp/tmpoxmk4hla.d(45): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmpoxmk4hla.d(46): Error: expression expected,\
    \ not `}`\\n/tmp/tmpoxmk4hla.d(48): Error: expression expected, not `>`\\n/tmp/tmpoxmk4hla.d(48):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpoxmk4hla.d(49): Error: expression\
    \ expected, not `if`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoxmk4hla.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: 0) {\n        foreach(col: row, j: 0) {\n          \
    \  if(col == x) {\n                res = Tuple!(long, long)[](Tuple!(0, i), Tuple!(0,\
    \ j));\n                break;\n            }\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaw6v88p5.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpaw6v88p5.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpaw6v88p5.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpaw6v88p5.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpaw6v88p5.d(28): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpaw6v88p5.d(28): Error: found `:` when expecting `;`\\n/tmp/tmpaw6v88p5.d(28):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpaw6v88p5.d(28): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpaw6v88p5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(column:\
    \ row) \n        {\n            if(column == x) \n            {\n            \
    \    result.push(Tuple!(long, long)((row), column));\n            }\n        }\n\
    \    }\n    \n    result.sort(function(a, b) -> a.0 < b.0 ? -1 : a.0 > b.0 ? 1\
    \ : 0);\n    result.sort(function(a, b) -> a.1 < b.1 ? -1 : a.1 > b.1 ? 1 : 0);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyym8jt7_.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpyym8jt7_.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpyym8jt7_.d(30): Error: no identifier\
    \ for declarator `column`\\n/tmp/tmpyym8jt7_.d(30): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpyym8jt7_.d(39): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpyym8jt7_.d(39): Error: expression expected, not `>`\\n/tmp/tmpyym8jt7_.d(39):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpyym8jt7_.d(39): Error: found `0.00000`\
    \ when expecting `,`\\n/tmp/tmpyym8jt7_.d(39): Error: expression expected, not\
    \ `?`\\n/tmp/tmpyym8jt7_.d(39): Error: found `:` when expecting `,`\\n/tmp/tmpyym8jt7_.d(39):\
    \ Error: found `0.00000` when expecting `,`\\n/tmp/tmpyym8jt7_.d(39): Error: expression\
    \ expected, not `>`\\n/tmp/tmpyym8jt7_.d(39): Error: found `b` when expecting\
    \ `,`\\n/tmp/tmpyym8jt7_.d(40): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpyym8jt7_.d(40): Error: expression expected, not `>`\\n/tmp/tmpyym8jt7_.d(40):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpyym8jt7_.d(40): Error: found `0.1`\
    \ when expecting `,`\\n/tmp/tmpyym8jt7_.d(40): Error: expression expected, not\
    \ `?`\\n/tmp/tmpyym8jt7_.d(40): Error: found `:` when expecting `,`\\n/tmp/tmpyym8jt7_.d(40):\
    \ Error: found `0.1` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpyym8jt7_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, i: int)\n    {\n        foreach(col:\
    \ row, j: int)\n        {\n            if(col == x)\n            {\n         \
    \       res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n   \
    \ \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6skh5icf.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp6skh5icf.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp6skh5icf.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp6skh5icf.d(28): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmp6skh5icf.d(28): Error: found `)` instead of statement\\n/tmp/tmp6skh5icf.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp6skh5icf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n     \
    \   {\n            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n        if(res\
    \ != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmidvgvd6.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpmidvgvd6.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpmidvgvd6.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpmidvgvd6.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpmidvgvd6.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpmidvgvd6.d(29): Error: found `:` when expecting `;`\\n/tmp/tmpmidvgvd6.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpmidvgvd6.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpmidvgvd6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index:\
    \ 0) \n        {\n            if(col == x) \n            {\n                res\
    \ = Tuple!(long, long)[](row_index, col_index);\n                break;\n    \
    \        }\n        }\n        if(res != null) break;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphth0owgd.d(27): Error: no identifier for declarator `row`\\n/tmp/tmphth0owgd.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmphth0owgd.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmphth0owgd.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmphth0owgd.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmphth0owgd.d(29): Error: found `:` when expecting `;`\\n/tmp/tmphth0owgd.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmphth0owgd.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmphth0owgd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    for(int i =\
    \ 0; i < lst.Length; i++)\n    {\n        if(lst[i][col[x]] == x)\n        {\n\
    \            return Tuple!(long, long)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[]]]]]]]]]];\n\
    \        }\n    }\n    return Tuple!(long, long)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[]]]]]]]]];\n\
    }\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpomkldq2q.d(38): Error: found `]` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpomkldq2q.d(38): Deprecation: use `{ }` for an empty\
    \ statement, not `;`\\n/tmp/tmpomkldq2q.d(41): Error: found `]` when expecting\
    \ `;` following `return` statement\\n/tmp/tmpomkldq2q.d(41): Deprecation: use\
    \ `{ }` for an empty statement, not `;`\\n/tmp/tmpomkldq2q.d(43): Error: unterminated\
    \ /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpomkldq2q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[lst.Length];\n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        if(lst[i][col[i]] == x)\n        {\n            res[i]\
    \ = Tuple!(long, long)[i, col[i]];\n        }\n    }\n    Array.Sort(res);\n \
    \   Array.Sort(row, col, res);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ra1zigm.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmp5ra1zigm.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmp5ra1zigm.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmp5ra1zigm.d(33): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmp5ra1zigm.d(34): Error: no\
    \ property `Length` for type `long[][]`\\n/tmp/tmp5ra1zigm.d(38): Error: no `[]`\
    \ operator overload for type `Tuple!(long, long)`\\n/tmp/tmp5ra1zigm.d(41): Error:\
    \ undefined identifier `Array`\\n/tmp/tmp5ra1zigm.d(42): Error: undefined identifier\
    \ `Array`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ra1zigm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            res[i] = i;\n        }\n    }\n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) => b - a);\n    return Tuple!(long, long)[](res,\
    \ n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_xjf9wbe.d(35): Error: undefined identifier `Arrays`\\n/tmp/tmp_xjf9wbe.d(36):\
    \ Error: undefined identifier `Arrays`\\n/tmp/tmp_xjf9wbe.d(37): Error: function\
    \ expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_xjf9wbe.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long[][] res = new long[n][m];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n          \
    \  if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n       \
    \     }\n            else\n            {\n                res[i][j] = 0;\n   \
    \         }\n        }\n    }\n    \n    Arrays.sort(res, 0, n, 1, Compare(CompareLong(),\
    \ CompareLong()));\n    Arrays.sort(res, 0, n, 1, Compare(CompareLong(), CompareLong(),\
    \ CompareLong(), CompareLong()));\n    \n    return Tuple!(long, long)[](res);\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_h0j1ud0.d(28): Error: variable `n` cannot be read at compile\
    \ time\\n/tmp/tmp_h0j1ud0.d(44): Error: undefined identifier `Arrays`\\n/tmp/tmp_h0j1ud0.d(45):\
    \ Error: undefined identifier `Arrays`\\n/tmp/tmp_h0j1ud0.d(47): Error: function\
    \ expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_h0j1ud0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    while(true)\n\
    \    {\n        int minRow = -1;\n        for(int i = 0; i < lst.Length; i++)\n\
    \        {\n            if(row[i] != i)\n            {\n                col[minRow]\
    \ = i;\n                minRow = i;\n            }\n        }\n        if(minRow\
    \ == -1)\n        {\n            break;\n        }\n        \n        for(int\
    \ i = 0; i < lst.Length; i++)\n        {\n            if(row[i] == minRow)\n \
    \           {\n                row[i] = i;\n                col[i] = 0;\n    \
    \        }\n        }\n        \n        for(int i = 0; i < lst.Length; i++)\n\
    \        {\n            if(row[i] != i)\n            {\n                col[minRow]\
    \ = i;\n                minRow = i;\n            }\n        }\n    }\n    \n \
    \   Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        res[i] = Tuple!(long, long)[\n \
    \           Tuple!(int,int)[\n                row[i],\n                col[i]\n\
    \            ],\n            Tuple!(int,int)[\n                lst[minRow][i],\n\
    \                lst[minRow][col[i]]\n            ]\n        ];\n    }\n    \n\
    \    Array.Sort(res);\n    Array.Sort(res, (o1, o2) => o1.Item2.Item1 - o2.Item2.Item1);\n\
    \    Array.Sort(res, (o1, o2) => o1.Item2.Item2 - o2.Item2.Item2);\n    \n   \
    \ return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpenx_55n6.d(90): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpenx_55n6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long result[][] = new long[n][m];\n    long row = 0;\n\
    \    long col = 0;\n    for(long i = 0; i < n; i++)\n    {\n        for(long j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[row][col] = i;\n                result[col][row] = j;\n\
    \                row++;\n                col++;\n            }\n        }\n  \
    \  }\n    \n    Tuple!(long, long)[] result = new Tuple!(long, long)[result.len()];\n\
    \    for(long i = 0; i < result.len(); i++)\n    {\n        result[i] = new Tuple!(long,\
    \ long)[result[i].len()];\n        for(long j = 0; j < result[i].len(); j++)\n\
    \        {\n            result[i][j] = new Tuple!(long, long)[result[i][j].len()];\n\
    \            for(long k = 0; k < result[i][j].len(); k++)\n            {\n   \
    \             result[i][j][k] = new Tuple!(long, long)[result[i][j][k].len()];\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < result.len();\
    \ i++)\n    {\n        for(long j = 0; j < result[i].len(); j++)\n        {\n\
    \            for(long k = 0; k < result[i][j].len(); k++)\n            {\n   \
    \             result[i][j][k] = new Tuple!(long, long)[result[i][j][k].len()];\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < result.len();\
    \ i++)\n    {\n        for(long j = 0; j < result[i].len(); j++)\n        {\n\
    \            for(long k = 0; k < result[i][j].len(); k++)\n            {\n   \
    \             result[i][j][k] = new Tuple!(long, long)[result[i][j][k].len()];\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < result.len();\
    \ i++)\n    {\n        for(long j = 0; j < result[i].len(); j++)\n        {\n\
    \            for(long k = 0; k < result[i][j].len(); k++)\n            {\n   \
    \             result[i][j][k] = new Tuple!(long, long)[result[i][j][k].len()];\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < result.len();\
    \ i++)\n    {\n        for(long j = 0; j < result[i].len(); j++)\n        {\n\
    \            for(long k = 0; k < result[i][j].len(); k++)\n            {\n   \
    \             result[i][j][k] = new Tuple!(long, long)[result[i][j][k].len()];\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < result.len();\
    \ i++)\n    {\n        for(long j = 0; j < result[i].len(); j++)\n        {\n\
    \            for(long k = 0; k < result[i][j].len\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_vd5auu.d(28): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[][] result`\\n/tmp/tmpz_vd5auu.d(108): Error: found `unittest`\
    \ when expecting `;` following `for` condition\\n/tmp/tmpz_vd5auu.d(119): Error:\
    \ found `void` when expecting `)`\\n/tmp/tmpz_vd5auu.d(119): Error: found `{`\
    \ when expecting `;` following statement\\n/tmp/tmpz_vd5auu.d(119): Error: found\
    \ `End of File` when expecting `}` following compound statement\\n/tmp/tmpz_vd5auu.d(119):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_vd5auu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] result = new long[lst.length][];\n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i].length == x)\n\
    \        {\n            result[i] = lst[i];\n        }\n    }\n    \n    Arrays.sort(result,\
    \ (a, b) => a[0] - b[0]);\n    Arrays.sort(result, (a, b) => a[1] - b[1]);\n \
    \   \n    return Arrays.toList(result);\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbybew6yh.d(26): Error: variable `lst` cannot be read at compile\
    \ time\\n/tmp/tmpbybew6yh.d(35): Error: undefined identifier `Arrays`\\n/tmp/tmpbybew6yh.d(36):\
    \ Error: undefined identifier `Arrays`\\n/tmp/tmpbybew6yh.d(38): Error: undefined\
    \ identifier `Arrays`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbybew6yh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long result[][] = new long[n][m];\n    long row = 0;\n\
    \    long col = 0;\n    long i = 0;\n    long j = 0;\n    while(i < n && j < m)\
    \ {\n        if(lst[i][j] == x) {\n            result[row][col] = Tuple!(long,\
    \ long)[i, j];\n            i++;\n            j++;\n        }\n        else if(lst[i][j]\
    \ < x) {\n            i++;\n        }\n        else {\n            j++;\n    \
    \    }\n    }\n    while(i < n) {\n        result[row][col] = Tuple!(long, long)[i,\
    \ j];\n        i++;\n        j++;\n    }\n    while(j < m) {\n        result[row][col]\
    \ = Tuple!(long, long)[i, j];\n        j++;\n    }\n    sort(result, 0, result.len(),\
    \ 0, result.len());\n    sort(result, 0, result.len(), 1, result.len());\n   \
    \ return result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp08ui4qk6.d(28): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[][] result`\\n/tmp/tmp08ui4qk6.d(59): Error: unterminated /* */\
    \ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp08ui4qk6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp15tyc8zg.d(29): Error: no identifier for declarator `long`\\\
    n/tmp/tmp15tyc8zg.d(29): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp15tyc8zg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j\
    \ : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[res.len()] = Tuple!(i, j);\n            }\n        }\n  \
    \  }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    \n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyqs_nukl.d(28): Error: no identifier for declarator `i`\\n/tmp/tmpyqs_nukl.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpyqs_nukl.d(30): Error: no identifier\
    \ for declarator `j`\\n/tmp/tmpyqs_nukl.d(30): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyqs_nukl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[i].get(x);\n\
    \    }\n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) => b[0] - a[0]);\n\
    \    return Tuple!(long, long)[](\n        Tuple!(long, long)[](\n           \
    \ Tuple!(0, res[0][0]),\n            Tuple!(0, res[0][1]),\n            Tuple!(0,\
    \ res[0][2]),\n            Tuple!(0, res[0][3]),\n            Tuple!(0, res[0][4]),\n\
    \            Tuple!(0, res[0][5])\n        ),\n        Tuple!(long, long)[](\n\
    \            Tuple!(res[0][0], res[1][0]),\n            Tuple!(res[0][1], res[1][1]),\n\
    \            Tuple!(res[0][2], res[1][2]),\n            Tuple!(res[0][3], res[1][3]),\n\
    \            Tuple!(res[0][4], res[1][4]),\n            Tuple!(res[0][5], res[1][5])\n\
    \        )\n    );\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe6rlcnut.d(26): Error: variable `lst` cannot be read at compile\
    \ time\\n/tmp/tmpe6rlcnut.d(29): Error: template `object.get` cannot deduce function\
    \ from argument types `!()(long[], long)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(3094):\
    \        `object.get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/druntime/import/object.d(3100):\
    \        `object.get(K, V)(inout(V[K])* aa, K key, lazy inout(V) defaultValue)`\\\
    n/tmp/tmpe6rlcnut.d(31): Error: undefined identifier `Arrays`\\n/tmp/tmpe6rlcnut.d(32):\
    \ Error: undefined identifier `Arrays`\\n/tmp/tmpe6rlcnut.d(35): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(36): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(37): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(38): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(39): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(40): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(43): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(43): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(44): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(44): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(45): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(45): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(46): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(46): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(47): Error: variable\
    \ `res` cannot be read at compile time\\n/tmp/tmpe6rlcnut.d(47): Error: variable\
    \ `res` cannot be read at c"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; ++i)\n    {\n        for(j = 0; j < m;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(long, long)[i, j];\n                break;\n           \
    \ }\n        }\n    }\n    \n    for(i = 0; i < n; ++i)\n    {\n        for(j\
    \ = 0; j < m; ++j)\n        {\n            if(lst[i][j] > x)\n            {\n\
    \                res[i] = Tuple!(long, long)[i, j];\n                break;\n\
    \            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplqnnr8qm.d(37): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmplqnnr8qm.d(49): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmplqnnr8qm.d(55): Error: undefined identifier `sort`, did you\
    \ mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmplqnnr8qm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.Length; i++)\n \
    \   {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].Length;\
    \ j++)\n            {\n                if(lst[i][j] == x)\n                {\n\
    \                    result.Add(Tuple!(long, long)[i, j]);\n                }\n\
    \            }\n        }\n    }\n    \n    result.Sort();\n    \n    for(int\
    \ i = 0; i < result.Length; i++)\n    {\n        result[i].Sort();\n    }\n  \
    \  \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp35w10wrp.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmp35w10wrp.d(28): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmp35w10wrp.d(32): Error: no\
    \ property `Length` for type `long[]`\\n/tmp/tmp35w10wrp.d(36): Error: no property\
    \ `Add` for type `Tuple!(long, long)[]`\\n/tmp/tmp35w10wrp.d(42): Error: no property\
    \ `Sort` for type `Tuple!(long, long)[]`\\n/tmp/tmp35w10wrp.d(44): Error: no property\
    \ `Length` for type `Tuple!(long, long)[]`\\n/tmp/tmp35w10wrp.d(46): Error: no\
    \ property `Sort` for type `Tuple!(long, long)`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp35w10wrp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n      \
    \      if(col == x) \n            {\n                res = Tuple!(long, long)[](row,\
    \ col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n  \
    \  alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn8wmvzp8.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpn8wmvzp8.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpn8wmvzp8.d(27): Error: expression\
    \ expected, not `:`\\n/tmp/tmpn8wmvzp8.d(27): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpn8wmvzp8.d(27): Error: found `)` instead of statement\\n/tmp/tmpn8wmvzp8.d(35):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpn8wmvzp8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    \n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n  \
    \          if(col == x) \n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res,1,-1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvjfhzdhz.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmpvjfhzdhz.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpvjfhzdhz.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpvjfhzdhz.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpvjfhzdhz.d(38): Error: found `}` when expecting `)`\\n/tmp/tmpvjfhzdhz.d(45):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpvjfhzdhz.d(56): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvjfhzdhz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n \
    \   \n    foreach(row: lst, i: int)\n    {\n        foreach(col: row, j: int)\n\
    \        {\n            if(col == x)\n            {\n                res[i] =\
    \ Tuple!(long, long)((i, j));\n                break;\n            }\n       \
    \ }\n    }\n    \n    foreach(row: lst, i: int)\n    {\n        foreach(col: row,\
    \ j: int)\n        {\n            if(col != x)\n            {\n              \
    \  res[i] = Tuple!(long, long)((i, j));\n                break;\n            }\n\
    \        }\n    }\n    \n    foreach(row: lst, i: int)\n    {\n        foreach(col:\
    \ row, j: int)\n        {\n            if(col == x)\n            {\n         \
    \       res[i] = Tuple!(long, long)((i, j));\n                break;\n       \
    \     }\n        }\n    }\n    \n    foreach(row: lst, i: int)\n    {\n      \
    \  foreach(col: row, j: int)\n        {\n            if(col != x)\n          \
    \  {\n                res[i] = Tuple!(long, long)((i, j));\n                break;\n\
    \            }\n        }\n    }\n    \n    foreach(row: lst, i: int)\n    {\n\
    \        foreach(col: row, j: int)\n        {\n            if(col != x)\n    \
    \        {\n                res[i] = Tuple!(long, long)((i, j));\n           \
    \     break;\n            }\n        }\n    }\n    \n    foreach(row: lst, i:\
    \ int)\n    {\n        foreach(col: row, j: int)\n        {\n            if(col\
    \ != x)\n            {\n                res[i] = Tuple!(long, long)((i, j));\n\
    \                break;\n            }\n        }\n    }\n    \n    foreach(row:\
    \ lst, i: int)\n    {\n        foreach(col: row, j: int)\n        {\n        \
    \    if(col != x)\n            {\n                res[i] = Tuple!(long, long)((i,\
    \ j));\n                break;\n            }\n        }\n    }\n    \n    foreach(row:\
    \ lst, i: int)\n    {\n        foreach(col: row, j: int)\n        {\n        \
    \    if(col != x)\n            {\n                res[i] = Tuple!(long, long)((i,\
    \ j));\n                break;\n            }\n        }\n    }\n    \n    foreach(row:\
    \ lst, i: int)\n    {\n        foreach(col: row, j: int)\n        {\n        \
    \    if(col != x)\n            {\n                res[i] = Tuple!(long, long)((i,\
    \ j));\n                break;\n            }\n        }\n    }\n    \n    foreach(row:\
    \ lst, i: int)\n    {\n        foreach(col: row, j: int)\n\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp515_8ctd.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp515_8ctd.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp515_8ctd.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp515_8ctd.d(28): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmp515_8ctd.d(28): Error: found `)` instead of statement\\n/tmp/tmp515_8ctd.d(37):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp515_8ctd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    \n    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n\
    \        {\n            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n        if(res\
    \ != null) break;\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpae7qy4ur.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpae7qy4ur.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpae7qy4ur.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpae7qy4ur.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpae7qy4ur.d(30): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpae7qy4ur.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpae7qy4ur.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpae7qy4ur.d(30): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpae7qy4ur.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    foreach(row,lst)\n    {\n        foreach(column,row)\n        {\n\
    \            if(column == x)\n            {\n                result = Tuple!(long,\
    \ long)[Tuple!(0, column), Tuple!(1, column)];\n                break;\n     \
    \       }\n        }\n        if(result != null)\n            break;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb57_n5t0.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpb57_n5t0.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpb57_n5t0.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpb57_n5t0.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpb57_n5t0.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpb57_n5t0.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpb57_n5t0.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpb57_n5t0.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpb57_n5t0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    \n    foreach(row: lst, rowIndex: 0) \n    {\n        foreach(column:\
    \ row, columnIndex: 0) \n        {\n            if(column == x) \n           \
    \ {\n                result = Tuple!(long, long)[](rowIndex, columnIndex);\n \
    \               break;\n            }\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyw3p3ldc.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpyw3p3ldc.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpyw3p3ldc.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpyw3p3ldc.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpyw3p3ldc.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpyw3p3ldc.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpyw3p3ldc.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpyw3p3ldc.d(30): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpyw3p3ldc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res.add((i, j));\n            }\n    \
    \    }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdscq3nxm.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpdscq3nxm.d(33): Error:\
    \ no property `add` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpdscq3nxm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9egwz0yn.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp9egwz0yn.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp9egwz0yn.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp9egwz0yn.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp9egwz0yn.d(37): Error: found `if` when expecting `)`\\n/tmp/tmp9egwz0yn.d(37):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmp9egwz0yn.d(37):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp9egwz0yn.d(39):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp9egwz0yn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, row_index: 0) \n    {\n \
    \       foreach(col: row, col_index: 0) \n        {\n            if(col == x)\
    \ \n            {\n                foreach(coord: row, coord_index: 0) \n    \
    \            {\n                    res[coord_index] = Tuple!(row_index, col_index);\n\
    \                }\n            }\n        }\n    }\n    \n    foreach(coord:\
    \ res, coord_index: 0) \n    {\n        sort(coord, coord, Tuple!(long, long)[](),\
    \ (a, b) -> a.first > b.first);\n    }\n    \n    foreach(coord: res, coord_index:\
    \ 0) \n    {\n        sort(coord, coord, Tuple!(long, long)[](), (a, b) -> a.second\
    \ > b.second);\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3f31p4cw.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp3f31p4cw.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp3f31p4cw.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp3f31p4cw.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp3f31p4cw.d(30): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmp3f31p4cw.d(30): Error: found `:` when expecting `;`\\n/tmp/tmp3f31p4cw.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp3f31p4cw.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmp3f31p4cw.d(34): Error: no identifier\
    \ for declarator `coord`\\n/tmp/tmp3f31p4cw.d(34): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmp3f31p4cw.d(34): Error: found `:` when expecting `)`\\n/tmp/tmp3f31p4cw.d(34):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmp3f31p4cw.d(42):\
    \ Error: no identifier for declarator `coord`\\n/tmp/tmp3f31p4cw.d(42): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmp3f31p4cw.d(42): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmp3f31p4cw.d(42): Error: found `)` when expecting `;`\
    \ following statement\\n/tmp/tmp3f31p4cw.d(44): Error: expression expected, not\
    \ `>`\\n/tmp/tmp3f31p4cw.d(44): Error: found `a` when expecting `,`\\n/tmp/tmp3f31p4cw.d(47):\
    \ Error: no identifier for declarator `coord`\\n/tmp/tmp3f31p4cw.d(47): Error:\
    \ found `:` when expecting `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp3f31p4cw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = new Tuple!(i, j);\n                break;\n            }\n    \
    \    }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j <\
    \ m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n         \
    \       res[i] = new Tuple!(i, j);\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] < x)\n            {\n       \
    \         res[i] = new Tuple!(i, j);\n                break;\n            }\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n    \
    \            res[i] = new Tuple!(i, j);\n                break;\n            }\n\
    \        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(614):\
    \ Error: CTFE failed because of previous errors in `injectNamedFields`\\n/tmp/tmptmkmjj2j.d(37):\
    \ Error: template instance `tmptmkmjj2j.get_row.Tuple!(i, j)` error instantiating\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmkmjj2j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[(n + 1) * (m + 1)];\n    \n    for(i = 0; i < n; i++)\n    {\n       \
    \ for(j = 0; j < m; j++)\n        {\n            if(i == j)\n            {\n \
    \               res[(i * m) + j] = Tuple!(0, 0);\n            }\n            else\n\
    \            {\n                for(k = 0; k < m; k++)\n                {\n  \
    \                  if(lst[i][k] == x)\n                    {\n               \
    \         res[(i * m) + j] = Tuple!(i, j);\n                        break;\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  \n    Arrays.sort(res, (a, b) => (a.f0 > b.f0) ? 1 : ((b.f0 > a.f0) ? -1 :\
    \ 0));\n    \n    Arrays.sort(res, (a, b) => (a.f1 > b.f1) ? 1 : ((b.f1 > a.f1)\
    \ ? -1 : 0));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcxf6npec.d(26): Error: no property `len` for type `long[][]`\\\
    n/tmp/tmpcxf6npec.d(27): Error: no property `len` for type `long[]`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(490):\
    \ Error: static assert:  \"Attempted to instantiate Tuple with an invalid argument:\
    \ 0\"\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \        instantiated from here: `parseSpecs!(0, 0)`\\n/tmp/tmpcxf6npec.d(37):\
    \        instantiated from here: `Tuple!(0, 0)`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpcxf6npec.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] ans;\n    \n\
    \    for(i = 0; i < n; i++)\n    {\n        ans[i] = Tuple!(0, 0);\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                ans[i] = Tuple!(i, j);\n                break;\n            }\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n     \
    \           k = j;\n                break;\n            }\n        }\n       \
    \ \n        for(j = k; j < m; j++)\n        {\n            if(lst[i][j] < x)\n\
    \            {\n                k = j;\n                break;\n            }\n\
    \        }\n        \n        ans[i] = Tuple!(i, j);\n    }\n    \n    sort(ans,\
    \ (a, b) => a.1 < b.1);\n    sort(ans, (a, b) => a.2 < b.2);\n    \n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp860hpia5.d(67): Error: found `0.1` when expecting `,`\\n/tmp/tmp860hpia5.d(67):\
    \ Error: expression expected, not `<`\\n/tmp/tmp860hpia5.d(67): Error: found `b`\
    \ when expecting `,`\\n/tmp/tmp860hpia5.d(68): Error: found `0.2` when expecting\
    \ `,`\\n/tmp/tmp860hpia5.d(68): Error: expression expected, not `<`\\n/tmp/tmp860hpia5.d(68):\
    \ Error: found `b` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp860hpia5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(col:\
    \ row)\n        {\n            if(col == x)\n            {\n                res.add((row,\
    \ col));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpogp5zyjw.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpogp5zyjw.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpogp5zyjw.d(30): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmpogp5zyjw.d(30): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpogp5zyjw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols\
    \ = 0;\n    for(long i = 0; i < lst.length; ++i)\n    {\n        rows = lst[i][0];\n\
    \        cols = lst[i][1];\n        if(rows == x)\n        {\n            Tuple!(long,\
    \ long)[] ret = new Tuple!(long, long)[rows];\n            for(long j = 0; j <\
    \ rows; ++j)\n            {\n                ret[j] = new Tuple!(long, long)[j,\
    \ cols];\n            }\n            return ret;\n        }\n    }\n    return\
    \ null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpef5wdf5q.d(37): Error: found `,` when expecting `]`\\n/tmp/tmpef5wdf5q.d(37):\
    \ Error: found `cols` when expecting `;` following statement\\n/tmp/tmpef5wdf5q.d(37):\
    \ Error: found `]` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpef5wdf5q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][lst[0].length];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i][j] = i;\n                res[j][i] = j;\n            }\n        }\n\
    \    }\n    \n    Arrays.sort(res);\n    \n    Tuple!(long, long)[] ret = new\
    \ Tuple!(long, long)[res.length];\n    for(int i = 0; i < res.length; i++)\n \
    \   {\n        ret[i] = new Tuple!(long, long)(res[i][0], res[i][1]);\n    }\n\
    \    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjbsntar3.d(26): Error: variable `lst` cannot be read at compile\
    \ time\\n/tmp/tmpjbsntar3.d(39): Error: undefined identifier `Arrays`\\n/tmp/tmpjbsntar3.d(44):\
    \ Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce\
    \ function from argument types `!()(Tuple!(long, long)*)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjbsntar3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            res[i] = 0;\n        }\n    }\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxx9k2ihc.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpxx9k2ihc.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpxx9k2ihc.d(34):\
    \ Error: cannot implicitly convert expression `res` of type `long[]` to `ulong`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxx9k2ihc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpha7kozds.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpha7kozds.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpha7kozds.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpha7kozds.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpha7kozds.d(37): Error: found `}` when expecting `)`\\n/tmp/tmpha7kozds.d(40):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpha7kozds.d(51): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpha7kozds.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.length-1)\n    {\n     \
    \   foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                res[res.length] = Tuple!(i, j);\n            }\n\
    \        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpexmks5u6.d(28): Error: no identifier for declarator `i`\\n/tmp/tmpexmks5u6.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpexmks5u6.d(30): Error: no identifier\
    \ for declarator `j`\\n/tmp/tmpexmks5u6.d(30): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpexmks5u6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    for(int i =\
    \ 0; i < lst.Length; i++)\n    {\n        for(int j = 0; j < lst[i].Length; j++)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[lst.Length];\n                res[row[i]]\
    \ = Tuple!(long, long)[lst[i].Length];\n                res[col[i]] = Tuple!(long,\
    \ long)[lst[i].Length];\n                return res;\n            }\n        }\n\
    \    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb4ru1p9x.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpb4ru1p9x.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpb4ru1p9x.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpb4ru1p9x.d(34): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpb4ru1p9x.d(36): Error: no\
    \ property `Length` for type `long[]`\\n/tmp/tmpb4ru1p9x.d(40): Error: no property\
    \ `Length` for type `long[][]`\\n/tmp/tmpb4ru1p9x.d(41): Error: no property `Length`\
    \ for type `long[]`\\n/tmp/tmpb4ru1p9x.d(42): Error: no property `Length` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb4ru1p9x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: 0) {\n        foreach(col: row, j: 0) {\n          \
    \  if(col == x) {\n                res = Tuple!(long, long)[i, j];\n         \
    \   }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc700ie3l.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpc700ie3l.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpc700ie3l.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpc700ie3l.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpc700ie3l.d(28): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpc700ie3l.d(28): Error: found `:` when expecting `;`\\n/tmp/tmpc700ie3l.d(28):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpc700ie3l.d(28): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpc700ie3l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                if(res == null)\n            \
    \    {\n                    res = Tuple!(long, long)[](row, col);\n          \
    \      }\n                else\n                {\n                    res = Tuple!(long,\
    \ long)[](row, col);\n                }\n            }\n        }\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpms59bjmi.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpms59bjmi.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpms59bjmi.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpms59bjmi.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpms59bjmi.d(43): Error: found `}` when expecting `)`\\n/tmp/tmpms59bjmi.d(46):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpms59bjmi.d(57): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpms59bjmi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    \n    long[][] res = new long[n][m];\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n\
    \            }\n            else\n            {\n                res[i][j] = 0;\n\
    \            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b) -> {\n   \
    \     if(a[0] == b[0])\n        {\n            return a[1] - b[1];\n        }\n\
    \        else\n        {\n            return a[0] - b[0];\n        }\n    });\n\
    \    \n    Arrays.sort(res, (a, b) -> {\n        if(a[0] == b[0])\n        {\n\
    \            return a[1] - b[1];\n        }\n        else\n        {\n       \
    \     return a[0] - b[0];\n        }\n    });\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfy9wv6k2.d(46): Error: expression expected, not `>`\\n/tmp/tmpfy9wv6k2.d(46):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpfy9wv6k2.d(47): Error: expression\
    \ expected, not `if`\\n/tmp/tmpfy9wv6k2.d(48): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmpfy9wv6k2.d(49): Error: expression expected, not `return`\\n/tmp/tmpfy9wv6k2.d(49):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpfy9wv6k2.d(49): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpfy9wv6k2.d(50): Error: expression expected, not\
    \ `}`\\n/tmp/tmpfy9wv6k2.d(51): Error: found `else` when expecting `,`\\n/tmp/tmpfy9wv6k2.d(55):\
    \ Error: found `}` when expecting `,`\\n/tmp/tmpfy9wv6k2.d(57): Error: expression\
    \ expected, not `>`\\n/tmp/tmpfy9wv6k2.d(57): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmpfy9wv6k2.d(58): Error: expression expected, not `if`\\n/tmp/tmpfy9wv6k2.d(59):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpfy9wv6k2.d(60): Error: expression\
    \ expected, not `return`\\n/tmp/tmpfy9wv6k2.d(60): Error: found `a` when expecting\
    \ `,`\\n/tmp/tmpfy9wv6k2.d(60): Error: found `;` when expecting `,`\\n/tmp/tmpfy9wv6k2.d(61):\
    \ Error: expression expected, not `}`\\n/tmp/tmpfy9wv6k2.d(62): Error: found `else`\
    \ when expecting `,`\\n/tmp/tmpfy9wv6k2.d(66): Error: found `}` when expecting\
    \ `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfy9wv6k2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m1 = m;\n    long n1 = n;\n    long r1 = m;\n    long r2 =\
    \ n;\n    long r3 = n;\n    long r4 = n;\n    long r5 = n;\n    long r6 = n;\n\
    \    long r7 = n;\n    long r8 = n;\n    long r9 = n;\n    long r10 = n;\n   \
    \ long r11 = n;\n    long r12 = n;\n    long r13 = n;\n    long r14 = n;\n   \
    \ long r15 = n;\n    long r16 = n;\n    long r17 = n;\n    long r18 = n;\n   \
    \ long r19 = n;\n    long r20 = n;\n    long r21 = n;\n    long r22 = n;\n   \
    \ long r23 = n;\n    long r24 = n;\n    long r25 = n;\n    long r26 = n;\n   \
    \ long r27 = n;\n    long r28 = n;\n    long r29 = n;\n    long r30 = n;\n   \
    \ long r31 = n;\n    long r32 = n;\n    long r33 = n;\n    long r34 = n;\n   \
    \ long r35 = n;\n    long r36 = n;\n    long r37 = n;\n    long r38 = n;\n   \
    \ long r39 = n;\n    long r40 = n;\n    long r41 = n;\n    long r42 = n;\n   \
    \ long r43 = n;\n    long r44 = n;\n    long r45 = n;\n    long r46 = n;\n   \
    \ long r47 = n;\n    long r48 = n;\n    long r49 = n;\n    long r50 = n;\n   \
    \ long r51 = n;\n    long r52 = n;\n    long r53 = n;\n    long r54 = n;\n   \
    \ long r55 = n;\n    long r56 = n;\n    long r57 = n;\n    long r58 = n;\n   \
    \ long r59 = n;\n    long r60 = n;\n    long r61 = n;\n    long r62 = n;\n   \
    \ long r63 = n;\n    long r64 = n;\n    long r65 = n;\n    long r66 = n;\n   \
    \ long r67 = n;\n    long r68 = n;\n    long r69\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxafft172.d(103): Error: semicolon expected, not `unittest`\\\
    n/tmp/tmpxafft172.d(103): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxafft172.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k, l, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n,\
    \ m, n, m, n, m, n, m, n, m, n, m, \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp07ux83ki.d(29): Error: no identifier for declarator `long`\\\
    n/tmp/tmp07ux83ki.d(29): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp07ux83ki.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] result = new long[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = i;\n        }\n    }\n    Array.Sort(result);\n\
    \    Array.Sort(result, (x, y) => { return lst[y][x] - lst[x][y]; });\n    return\
    \ result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkhfbmm33.d(38): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkhfbmm33.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    foreach(row: lst, i: 0) {\n        foreach(column: row, j: 0) {\n\
    \            if(column == x) {\n                if(i == 0) result = Tuple!(long,\
    \ long)[Tuple!(0, j)];\n                else {\n                    result = Tuple!(long,\
    \ long)[Tuple!(i-1, j), Tuple!(i-1, j+1)];\n                }\n            }\n\
    \        }\n    }\n    \n    foreach(row: result, i: 0) {\n        foreach(column:\
    \ row, j: 0) {\n            if(j == 0) result = Tuple!(long, long)[Tuple!(i+1,\
    \ 0)];\n            else {\n                result = Tuple!(long, long)[Tuple!(i+1,\
    \ j-1), Tuple!(i+1, j)];\n            }\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo3817yp1.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpo3817yp1.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpo3817yp1.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpo3817yp1.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpo3817yp1.d(28): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpo3817yp1.d(28): Error: found `:` when expecting `;`\\n/tmp/tmpo3817yp1.d(28):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpo3817yp1.d(28): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmpo3817yp1.d(38): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpo3817yp1.d(38): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpo3817yp1.d(38): Error: found `:` when expecting `)`\\n/tmp/tmpo3817yp1.d(38):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmpo3817yp1.d(39):\
    \ Error: no identifier for declarator `column`\\n/tmp/tmpo3817yp1.d(39): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmpo3817yp1.d(39): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmpo3817yp1.d(39): Error: found `)` when expecting `;`\
    \ following statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo3817yp1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] row = new long[lst.Length][];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i] = lst[i];\n  \
    \  }\n    \n    long[] rowSorted = new long[row[0].Length];\n    for(int i = 0;\
    \ i < row[0].Length; i++)\n    {\n        rowSorted[i] = row[i][i];\n    }\n \
    \   Array.Sort(rowSorted, (x, y) => { return y - x; });\n    Array.Sort(rowSorted,\
    \ (x, y) => { return y - x; });\n    \n    long[] colSorted = new long[row[0].Length];\n\
    \    for(int i = 0; i < row[0].Length; i++)\n    {\n        colSorted[i] = rowSorted[i];\n\
    \    }\n    Array.Sort(colSorted, (x, y) => { return y - x; });\n    Array.Sort(colSorted,\
    \ (x, y) => { return y - x; });\n    \n    Tuple!(long, long)[] result = new Tuple!(long,\
    \ long)[row.Length];\n    for(int i = 0; i < row.Length; i++)\n    {\n       \
    \ result[i] = Tuple!(long, long)((row[i][0], colSorted[i]));\n    }\n    return\
    \ result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7od1f6j7.d(55): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7od1f6j7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long result[][] = new long[n][m];\n    long row = 0;\n\
    \    long col = 0;\n    long minRow = -1;\n    long minCol = -1;\n    long maxRow\
    \ = -1;\n    long maxCol = -1;\n    for(long i = 0; i < n; i++)\n    {\n     \
    \   for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n \
    \           {\n                result[row][col] = i;\n                result[col][row]\
    \ = j;\n                row++;\n                col++;\n                if(row\
    \ == n)\n                {\n                    row = 0;\n                   \
    \ col++;\n                }\n                if(col == m)\n                {\n\
    \                    col = 0;\n                    row++;\n                }\n\
    \                if(row == minRow)\n                {\n                    minRow\
    \ = i;\n                    minCol = j;\n                }\n                if(col\
    \ == minCol)\n                {\n                    minCol = j;\n           \
    \     }\n                if(row == maxRow)\n                {\n              \
    \      maxRow = i;\n                    maxCol = j;\n                }\n     \
    \           if(col == maxCol)\n                {\n                    maxCol =\
    \ j;\n                }\n            }\n        }\n    }\n    \n    Tuple!(long,\
    \ long)[] result = new Tuple!(long, long)[](maxRow, maxCol);\n    for(long i =\
    \ 0; i < maxRow; i++)\n    {\n        for(long j = 0; j < maxCol; j++)\n     \
    \   {\n            result[i][j] = Tuple!(long, long)[](i, j);\n        }\n   \
    \ }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j <\
    \ m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n        \
    \        result[row][col] = i;\n                result[col][row] = j;\n      \
    \          row++;\n                col++;\n                if(row == n)\n    \
    \            {\n                    row = 0;\n                    col++;\n   \
    \             }\n                if(col == m)\n                {\n           \
    \         col = 0;\n                    row++;\n                }\n          \
    \      if(row == minRow)\n                {\n                    minRow = i;\n\
    \                    minCol = j;\n                }\n                if(col ==\
    \ minCol)\n                {\n                    minCol = j;\n              \
    \  }\n                if(row == maxRow)\n                {\n                 \
    \   maxRow = i;\n                    maxCol = j;\n                }\n        \
    \        if(col == maxCol)\n                {\n                    maxCol = j;\n\
    \                }\n            }\n        }\n    }\n    \n    for(long i = 0;\
    \ i < maxRow; i++)\n    {\n        for(long j = 0; j < maxCol; j++)\n        {\n\
    \            result[i][j] = Tuple!(long, long)[](i, j);\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpga9hfp7o.d(28): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[][] result`\\n/tmp/tmpga9hfp7o.d(133): Error: found `unittest`\
    \ instead of statement\\n/tmp/tmpga9hfp7o.d(144): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpga9hfp7o.d(144): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpga9hfp7o.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    foreach(row,lst) \n    {\n        foreach(column,row) \n        {\n\
    \            if(column == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row,column);\n                break;\n            }\n        }\n   \
    \     if(result != null) break;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi2f1sh9a.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpi2f1sh9a.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpi2f1sh9a.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpi2f1sh9a.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpi2f1sh9a.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpi2f1sh9a.d(37):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpi2f1sh9a.d(37):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpi2f1sh9a.d(39):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpi2f1sh9a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n \
    \   {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length;\
    \ j++)\n            {\n                if(lst[i][j] == x)\n                {\n\
    \                    result.add(Tuple!(long, long)(i + 1, j + 1));\n         \
    \       }\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) -> a.first > b.first);\n    result.sort(function(a, b) -> a.second > b.second);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpca45uqtg.d(42): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpca45uqtg.d(42): Error: expression expected, not `>`\\n/tmp/tmpca45uqtg.d(42):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpca45uqtg.d(43): Error: missing\
    \ `{ ... }` for function literal\\n/tmp/tmpca45uqtg.d(43): Error: expression expected,\
    \ not `>`\\n/tmp/tmpca45uqtg.d(43): Error: found `a` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpca45uqtg.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long[][] res = new long[n][m];\n    \n    for(long i\
    \ = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n  \
    \          if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n\
    \            }\n            else\n            {\n                res[i][j] = 0;\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n\
    \        for(long j = 0; j < m; j++)\n        {\n            if(res[i][j] == 1)\n\
    \            {\n                res[i][j] = Tuple!(long, long)((i, j));\n    \
    \        }\n        }\n    }\n    \n    res[0][0] = Tuple!(long, long)(0, 0);\n\
    \    \n    for(long i = 1; i < n; i++)\n    {\n        for(long j = 1; j < m;\
    \ j++)\n        {\n            if(res[i][j] == 1)\n            {\n           \
    \     res[i][j] = Tuple!(long, long)((i, j));\n            }\n        }\n    }\n\
    \    \n    res[n-1][m-1] = Tuple!(long, long)(n-1, m-1);\n    \n    for(long i\
    \ = n-2; i >= 0; i--)\n    {\n        for(long j = m-2; j >= 0; j--)\n       \
    \ {\n            if(res[i][j] == 1)\n            {\n                res[i][j]\
    \ = Tuple!(long, long)((i, j));\n            }\n        }\n    }\n    \n    res[0][0]\
    \ = Tuple!(long, long)(0, 0);\n    \n    for(long i = 1; i < n; i++)\n    {\n\
    \        for(long j = 1; j < m; j++)\n        {\n            if(res[i][j] == 1)\n\
    \            {\n                res[i][j] = Tuple!(long, long)((i, j));\n    \
    \        }\n        }\n    }\n    \n    res[n-1][m-1] = Tuple!(long, long)(n-1,\
    \ m-1);\n    \n    for(long i = n-2; i >= 0; i--)\n    {\n        for(long j =\
    \ m-2; j >= 0; j--)\n        {\n            if(res[i][j] == 1)\n            {\n\
    \                res[i][j] = Tuple!(long, long)((i, j));\n            }\n    \
    \    }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzgoop0b_.d(28): Error: variable `n` cannot be read at compile\
    \ time\\n/tmp/tmpzgoop0b_.d(51): Error: Using the result of a comma expression\
    \ is not allowed\\n/tmp/tmpzgoop0b_.d(51): Error: none of the overloads of `this`\
    \ are callable using argument types `(long)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(668):\
    \        `std.typecons.Tuple!(long, long).Tuple.this(long, long)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(689):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U, ulong n)(U[n] values)\
    \ if (n == Types.length && allSatisfy!(isBuildableFrom!U, Types))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(715):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U)(U another) if (areBuildCompatibleTuples!(typeof(this),\
    \ U))`\\n/tmp/tmpzgoop0b_.d(56): Error: cannot implicitly convert expression `Tuple(0L,\
    \ 0L).this(0L, 0L)` of type `Tuple!(long, long)` to `long`\\n/tmp/tmpzgoop0b_.d(64):\
    \ Error: Using the result of a comma expression is not allowed\\n/tmp/tmpzgoop0b_.d(64):\
    \ Error: none of the overloads of `this` are callable using argument types `(long)`,\
    \ candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(668):\
    \        `std.typecons.Tuple!(long, long).Tuple.this(long _param_0, long _param_1)`\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(689):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U, ulong n)(U[n] values)\
    \ if (n == Types.length && allSatisfy!(isBuildableFrom!U, Types))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvu"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row::lst) \n    {\n        foreach(col::row)\
    \ \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, Tuple!(long, long)((-1, -1)));\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbhb_e1_o.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpbhb_e1_o.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpbhb_e1_o.d(28): Error: expression\
    \ expected, not `:`\\n/tmp/tmpbhb_e1_o.d(28): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpbhb_e1_o.d(28): Error: found `)` instead of statement\\n/tmp/tmpbhb_e1_o.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpbhb_e1_o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long[][] res = new long[n][m];\n    for(long i = 0; i\
    \ < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n         \
    \   if(lst[i][j] == x)\n            {\n                res[i][j] = i;\n      \
    \          res[i][m-1] = j;\n                return Tuple!(long, long)[](res);\n\
    \            }\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4wb56gmo.d(26): Error: no property `len` for type `long[][]`\\\
    n/tmp/tmp4wb56gmo.d(27): Error: no property `len` for type `long[]`\\n/tmp/tmp4wb56gmo.d(28):\
    \ Error: variable `n` cannot be read at compile time\\n/tmp/tmp4wb56gmo.d(37):\
    \ Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long,\
    \ long)[]`\\n/tmp/tmp4wb56gmo.d(41): Error: function expected before `()`, not\
    \ `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp4wb56gmo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res[res.length]\
    \ = Tuple!(long, long)((row,col));\n            }\n        }\n    }\n    sort(res);\n\
    \    sort(res,1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpviiveefr.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpviiveefr.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpviiveefr.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpviiveefr.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpviiveefr.d(36): Error: found `}` when expecting `)`\\n/tmp/tmpviiveefr.d(41):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpviiveefr.d(52): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpviiveefr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, row_index: 0) \n    {\n \
    \       foreach(column: row, column_index: 0) \n        {\n            if(column\
    \ == x) \n            {\n                foreach(coor: row, coor_index: 0) \n\
    \                {\n                    if(coor == row_index) \n             \
    \       {\n                        foreach(coor2: row, coor_index: 1) \n     \
    \                   {\n                            if(coor2 == column_index) \n\
    \                            {\n                                res.add((row_index,\
    \ column_index));\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    foreach(coor: res, coor_index: 0) \n    {\n        foreach(coor2: res,\
    \ coor_index: 1) \n        {\n            if(coor2 > coor) \n            {\n \
    \               coor2.swap(coor);\n            }\n        }\n    }\n    \n   \
    \ foreach(coor: res, coor_index: 0) \n    {\n        foreach(coor2: res, coor_index:\
    \ 1) \n        {\n            if(coor2 == coor) \n            {\n            \
    \    coor2.swap(coor);\n            }\n        }\n    }\n    \n    foreach(coor:\
    \ res, coor_index: 0) \n    {\n        foreach(coor2: res, coor_index: 1) \n \
    \       {\n            if(coor2 == coor) \n            {\n                coor2.swap(coor);\n\
    \            }\n        }\n    }\n    \n    foreach(coor: res, coor_index: 0)\
    \ \n    {\n        foreach(coor2: res, coor_index: 1) \n        {\n          \
    \  if(coor2 == coor) \n            {\n                coor2.swap(coor);\n    \
    \        }\n        }\n    }\n    \n    foreach(coor: res, coor_index: 0) \n \
    \   {\n        foreach(coor2: res, coor_index: 1) \n        {\n            if(coor2\
    \ == coor) \n            {\n                coor2.swap(coor);\n            }\n\
    \        }\n    }\n    \n    foreach(coor: res, coor_index: 0) \n    {\n     \
    \   foreach(coor2: res, coor_index: 1) \n        {\n            if(coor2 == coor)\
    \ \n            {\n                coor2.swap(coor);\n            }\n        }\n\
    \    }\n    \n    foreach(coor: res, coor_index: 0) \n    {\n        foreach(coor2:\
    \ res, coor_index: 1) \n        {\n            if(coor2 == coor) \n          \
    \  {\n                coor2.swap(coor);\n            }\n        }\n    }\n   \
    \ \n    foreach(coor: res, coor_index: 0) \n    {\n        foreach(coor2: res,\
    \ coor_index: 1) \n        {\n            if(coor2 == coor) \n            {\n\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp95geigxc.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp95geigxc.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp95geigxc.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp95geigxc.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp95geigxc.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmp95geigxc.d(30): Error: found `:` when expecting `;`\\n/tmp/tmp95geigxc.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp95geigxc.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmp95geigxc.d(34): Error: no identifier\
    \ for declarator `coor`\\n/tmp/tmp95geigxc.d(34): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmp95geigxc.d(34): Error: found `:` when expecting `)`\\n/tmp/tmp95geigxc.d(34):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmp95geigxc.d(38):\
    \ Error: no identifier for declarator `coor2`\\n/tmp/tmp95geigxc.d(38): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmp95geigxc.d(38): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmp95geigxc.d(38): Error: found `)` when expecting `;`\
    \ following statement\\n/tmp/tmp95geigxc.d(51): Error: no identifier for declarator\
    \ `coor`\\n/tmp/tmp95geigxc.d(51): Error: found `:` when expecting `;`\\n/tmp/tmp95geigxc.d(51):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp95geigxc.d(51): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp95geigxc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long[][] res = new long[n][m];\n    for(long i = 0; i\
    \ < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n         \
    \   if(lst[i][j] == x)\n            {\n                res[i][j] = i;\n      \
    \          res[i][m-1] = j;\n            }\n        }\n    }\n    \n    sort!(res,\
    \ (a, b) => (a[0] > b[0]) ? 1 : (a[0] == b[0]) ? 0 : -1);\n    sort!(res, (a,\
    \ b) => (a[1] > b[1]) ? 1 : (a[1] == b[1]) ? 0 : -1);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpikzc0ia6.d(26): Error: no property `len` for type `long[][]`\\\
    n/tmp/tmpikzc0ia6.d(27): Error: no property `len` for type `long[]`\\n/tmp/tmpikzc0ia6.d(28):\
    \ Error: variable `n` cannot be read at compile time\\n/tmp/tmpikzc0ia6.d(41):\
    \ Error: template instance `sort!(res, (a, b) => a[0] > b[0] ? 1 : a[0] == b[0]\
    \ ? 0 : -1)` template `sort` is not defined, did you mean sqrt?\\n/tmp/tmpikzc0ia6.d(42):\
    \ Error: template instance `sort!(res, (a, b) => a[1] > b[1] ? 1 : a[1] == b[1]\
    \ ? 0 : -1)` template `sort` is not defined, did you mean sqrt?\\n/tmp/tmpikzc0ia6.d(44):\
    \ Error: cannot implicitly convert expression `res` of type `long[][]` to `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpikzc0ia6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols\
    \ = 0;\n    foreach(row,lst) \n    {\n        cols += row.length;\n        if(cols\
    \ == x) \n        {\n            return Tuple!(long, long)[](rows,row);\n    \
    \    }\n        rows++;\n    }\n    return Tuple!(long, long)[](0,0);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsjn4nhto.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmpsjn4nhto.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpsjn4nhto.d(37): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsjn4nhto.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, rowIndex: 0) \n    {\n  \
    \      foreach(col: row, colIndex: 0) \n        {\n            if(col == x) \n\
    \            {\n                foreach(coor: row, coorIndex: 0) \n          \
    \      {\n                    res[coorIndex] = (rowIndex, colIndex);\n       \
    \         }\n            }\n        }\n    }\n    \n    foreach(coor: res, coorIndex:\
    \ 0) \n    {\n        foreach(row: lst, rowIndex: coorIndex) \n        {\n   \
    \         foreach(col: row, colIndex: 0) \n            {\n                if(col\
    \ == x) \n                {\n                    foreach(coor: row, coorIndex:\
    \ 0) \n                    {\n                        res[coorIndex] = (rowIndex,\
    \ colIndex);\n                    }\n                }\n            }\n      \
    \  }\n    }\n    \n    foreach(coor: res, coorIndex: 0) \n    {\n        foreach(row:\
    \ lst, rowIndex: coorIndex) \n        {\n            foreach(col: row, colIndex:\
    \ 0) \n            {\n                if(col == x) \n                {\n     \
    \               foreach(coor: row, coorIndex: 0) \n                    {\n   \
    \                     res[coorIndex] = (rowIndex, colIndex);\n               \
    \     }\n                }\n            }\n        }\n    }\n    \n    foreach(coor:\
    \ res, coorIndex: 0) \n    {\n        foreach(row: lst, rowIndex: coorIndex) \n\
    \        {\n            foreach(col: row, colIndex: 0) \n            {\n     \
    \           if(col == x) \n                {\n                    foreach(coor:\
    \ row, coorIndex: 0) \n                    {\n                        res[coorIndex]\
    \ = (rowIndex, colIndex);\n                    }\n                }\n        \
    \    }\n        }\n    }\n    \n    foreach(coor: res, coorIndex: 0) \n    {\n\
    \        foreach(row: lst, rowIndex: coorIndex) \n        {\n            foreach(col:\
    \ row, colIndex: 0) \n            {\n                if(col == x) \n         \
    \       {\n                    foreach(coor: row, coorIndex: 0) \n           \
    \         {\n                        res[coorIndex] = (rowIndex, colIndex);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    foreach(coor: res, coorIndex: 0) \n    {\n        foreach(row: lst,\
    \ rowIndex: coorIndex) \n        {\n            foreach(col: row, colIndex: 0)\
    \ \n            {\n                if(col == x) \n                {\n        \
    \            foreach(coor: row, coorIndex: 0) \n                    {\n      \
    \                  res[coorIndex] = (rowIndex, colIndex);\n                  \
    \  }\n                }\n            }\n        }\n    }\n    \n    \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx9d0tfwz.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpx9d0tfwz.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpx9d0tfwz.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpx9d0tfwz.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpx9d0tfwz.d(30): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpx9d0tfwz.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpx9d0tfwz.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpx9d0tfwz.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmpx9d0tfwz.d(34): Error: no identifier\
    \ for declarator `coor`\\n/tmp/tmpx9d0tfwz.d(34): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpx9d0tfwz.d(34): Error: found `:` when expecting `)`\\n/tmp/tmpx9d0tfwz.d(34):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmpx9d0tfwz.d(42):\
    \ Error: no identifier for declarator `coor`\\n/tmp/tmpx9d0tfwz.d(42): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmpx9d0tfwz.d(42): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmpx9d0tfwz.d(42): Error: found `)` when expecting `;`\
    \ following statement\\n/tmp/tmpx9d0tfwz.d(44): Error: no identifier for declarator\
    \ `row`\\n/tmp/tmpx9d0tfwz.d(44): Error: found `:` when expecting `;`\\n/tmp/tmpx9d0tfwz.d(44):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpx9d0tfwz.d(44): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpx9d0tfwz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.Length][];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        res[i] = lst[i].Where(x\
    \ => x == lst[i][i]).ToArray();\n    }\n    Array.Sort(res);\n    Array.Sort(res,\
    \ (x, y) => y.CompareTo(x));\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpclk6xbgk.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpclk6xbgk.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpclk6xbgk.d(29):\
    \ Error: no property `Where` for type `long[]`\\n/tmp/tmpclk6xbgk.d(31): Error:\
    \ undefined identifier `Array`\\n/tmp/tmpclk6xbgk.d(32): Error: undefined identifier\
    \ `Array`\\n/tmp/tmpclk6xbgk.d(33): Error: cannot implicitly convert expression\
    \ `res` of type `long[][]` to `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpclk6xbgk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    \n    long i, j;\n    \n    Tuple!(long, long)[] result\
    \ = new Tuple!(long, long)[n];\n    \n    for (i = 0; i < n; i++)\n    {\n   \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[m];\n        \n      \
    \  for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n     \
    \       {\n                row[j] = (i, j);\n                break;\n        \
    \    }\n        }\n        \n        if (j == m)\n        {\n            throw\
    \ new Exception(\"No such element in matrix\");\n        }\n        \n       \
    \ result[i] = row;\n    }\n    \n    sort!(result, (a, b) => (a[1], b[1]));\n\
    \    sort!(result, (a, b) => (a[0], b[0]));\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgs4iq5ab.d(41): Error: Using the result of a comma expression\
    \ is not allowed\\n/tmp/tmpgs4iq5ab.d(41): Error: template `std.typecons.Tuple!(long,\
    \ long).Tuple.opAssign` cannot deduce function from argument types `!()(long)`,\
    \ candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\n/tmp/tmpgs4iq5ab.d(51): Error:\
    \ template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function\
    \ from argument types `!()(Tuple!(long, long)[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\n/tmp/tmpgs4iq5ab.d(54): Error:\
    \ template instance `sort!(result, (a, b) => a[1] , b[1])` template `sort` is\
    \ not defined, did you mean sqrt?\\n/tmp/tmpgs4iq5ab.d(55): Error: template instance\
    \ `sort!(result, (a, b) => a[0] , b[0])` template `sort` is not defined, did you\
    \ mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgs4iq5ab.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp567bzzbu.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp567bzzbu.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp567bzzbu.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp567bzzbu.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp567bzzbu.d(37): Error: found `if` when expecting `)`\\n/tmp/tmp567bzzbu.d(37):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmp567bzzbu.d(37):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp567bzzbu.d(39):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp567bzzbu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.Length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][x]\
    \ == x)\n        {\n            res[i] = i;\n        }\n    }\n    Array.Sort(res);\n\
    \    Array.Sort(res, (i, j) => lst[res[i]][res[j]]);\n    return Tuple!(long,\
    \ long)[](res, 0);\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3vde0qsa.d(39): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3vde0qsa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n \
    \   foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n           \
    \ if(col == x)\n            {\n                res[res.length] = Tuple!(long,\
    \ long)((row,col));\n            }\n        }\n    }\n    sort(res);\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcz1do_zx.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpcz1do_zx.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpcz1do_zx.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpcz1do_zx.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpcz1do_zx.d(36): Error: found `}` when expecting `)`\\n/tmp/tmpcz1do_zx.d(40):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpcz1do_zx.d(51): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcz1do_zx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column:\
    \ row, column_index: 0) \n        {\n            if(column == x) \n          \
    \  {\n                result = Tuple!(long, long)[](row_index, column_index);\n\
    \                break;\n            }\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp56jr3j56.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp56jr3j56.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp56jr3j56.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp56jr3j56.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp56jr3j56.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmp56jr3j56.d(30): Error: found `:` when expecting `;`\\n/tmp/tmp56jr3j56.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp56jr3j56.d(30): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp56jr3j56.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] result = new long[lst[0].Length];\n\
    \    for(int i = 0; i < lst[0].Length; i++)\n    {\n        result[i] = lst[0][i];\n\
    \    }\n    for(int i = 1; i < lst.Length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].Length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                for(int k = 0; k < lst[0].Length; k++)\n            \
    \    {\n                    result[k] = lst[i][k];\n                }\n      \
    \          break;\n            }\n        }\n    }\n    Array.Sort(result);\n\
    \    Array.Sort(result, (x, y) => { return y - x; });\n    Array.Sort(result,\
    \ (x, y) => { return y - x; });\n    return Tuple!(long, long)[result];\n}\n/*\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoq2krywr.d(50): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoq2krywr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    \n    long[][] res = new long[n][m];\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(lst[i][j] == x)\n            {\n                res[i][j] = i;\n\
    \                res[i][m-1] = j;\n                res[n-1][m-1] = n;\n      \
    \      }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpadrzivla.d(29): Error: variable `n` cannot be read at compile\
    \ time\\n/tmp/tmpadrzivla.d(44): Error: undefined identifier `Arrays`\\n/tmp/tmpadrzivla.d(46):\
    \ Error: cannot implicitly convert expression `res` of type `long[][]` to `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpadrzivla.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[i].subarray(0,\
    \ x);\n    }\n    \n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) => b[0]\
    \ - a[0]);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = new Tuple!(long,\
    \ long)((int)res[i][0], (int)res[i][1]);\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkpmqbk0h.d(38): Error: C style cast illegal, use `cast(int)res[i][0]`\\\
    n/tmp/tmpkpmqbk0h.d(38): Error: C style cast illegal, use `cast(int)res[i][1]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkpmqbk0h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row);\n\
    \    Array.Sort(col);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == x)\n   \
    \     {\n            res[i] = Tuple!(long, long)[i, col[i]];\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsifm4p4j.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpsifm4p4j.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpsifm4p4j.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpsifm4p4j.d(33): Error:\
    \ undefined identifier `Array`\\n/tmp/tmpsifm4p4j.d(34): Error: undefined identifier\
    \ `Array`\\n/tmp/tmpsifm4p4j.d(36): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpsifm4p4j.d(37): Error: no property `Length` for type `long[][]`\\n/tmp/tmpsifm4p4j.d(41):\
    \ Error: no `[]` operator overload for type `Tuple!(long, long)`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsifm4p4j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[n];\n    while(i < n && j < m) {\n        if(lst[i][j]\
    \ == x) {\n            res[i] = Tuple!(long, long)[i, j];\n            i += 1;\n\
    \            j += 1;\n        }\n        else if(lst[i][j] < x) {\n          \
    \  i += 1;\n        }\n        else {\n            j += 1;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzfsinh4y.d(33): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzfsinh4y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n\
    \    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n    \
    \        if(col == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    \n    result.sort(function(a,b){return\
    \ a.0>b.0;});\n    result.sort(function(a,b){return b.0>a.0;});\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpadwuh9jh.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmpadwuh9jh.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpadwuh9jh.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpadwuh9jh.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpadwuh9jh.d(37): Error: found `}` when expecting `)`\\n/tmp/tmpadwuh9jh.d(39):\
    \ Error: found `0.00000` when expecting `;` following `return` statement\\n/tmp/tmpadwuh9jh.d(39):\
    \ Error: found `>` instead of statement\\n/tmp/tmpadwuh9jh.d(40): Error: found\
    \ `0.00000` when expecting `;` following `return` statement\\n/tmp/tmpadwuh9jh.d(40):\
    \ Error: found `>` instead of statement\\n/tmp/tmpadwuh9jh.d(44): Error: found\
    \ `unittest` when expecting `)`\\n/tmp/tmpadwuh9jh.d(55): Error: found `End of\
    \ File` when expecting `}` following compound statement\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpadwuh9jh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col,\
    \ (x, y) => { return x > y; });\n    Array.Sort(col, row, (x, y) => { return y\
    \ > x; });\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        res[i] = Tuple!(long,\
    \ long)[\n            Tuple!(long, long)[\n                row[i],\n         \
    \       col[i]\n            ],\n            Tuple!(long, long)[\n            \
    \    row[i],\n                col[i]\n            ]\n        ];\n    }\n    return\
    \ res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8b6ib_wb.d(51): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8b6ib_wb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    foreach(row,lst){\n        if(row.length == x){\n            foreach(col,row){\n\
    \                if(col == x){\n                    result = Tuple!(long, long)[Tuple!(0,\
    \ row), Tuple!(1, col)];\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprx5jwdrm.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmprx5jwdrm.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmprx5jwdrm.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmprx5jwdrm.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmprx5jwdrm.d(34): Error: found `}` when expecting `)`\\n/tmp/tmprx5jwdrm.d(35):\
    \ Error: found `}` instead of statement\\n/tmp/tmprx5jwdrm.d(38): Error: found\
    \ `unittest` when expecting `)`\\n/tmp/tmprx5jwdrm.d(49): Error: found `End of\
    \ File` when expecting `}` following compound statement\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmprx5jwdrm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row: lst, row_index: 0) \n    {\n\
    \        foreach(column: row, column_index: 0) \n        {\n            if(column\
    \ == x) \n            {\n                foreach(coordinate: row, coordinate_index:\
    \ 0) \n                {\n                    result.push(new Tuple!(long, long)((row_index,\
    \ coordinate_index), (column_index, coordinate_index)));\n                }\n\
    \            }\n        }\n    }\n    \n    result.sort(function(a, b) { return\
    \ a.1 < b.1; });\n    result.sort(function(a, b) { return a.2 < b.2; });\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw7ma8ral.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpw7ma8ral.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpw7ma8ral.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpw7ma8ral.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpw7ma8ral.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpw7ma8ral.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpw7ma8ral.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpw7ma8ral.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmpw7ma8ral.d(34): Error: no identifier\
    \ for declarator `coordinate`\\n/tmp/tmpw7ma8ral.d(34): Error: found `:` when\
    \ expecting `;`\\n/tmp/tmpw7ma8ral.d(34): Error: found `:` when expecting `)`\\\
    n/tmp/tmpw7ma8ral.d(34): Error: found `)` when expecting `;` following statement\\\
    n/tmp/tmpw7ma8ral.d(42): Error: found `0.1` when expecting `;` following `return`\
    \ statement\\n/tmp/tmpw7ma8ral.d(42): Error: found `<` instead of statement\\\
    n/tmp/tmpw7ma8ral.d(43): Error: found `0.2` when expecting `;` following `return`\
    \ statement\\n/tmp/tmpw7ma8ral.d(43): Error: found `<` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7ma8ral.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!((long)i, (long)j);\n                break;\n           \
    \ }\n        }\n    }\n    \n    sort(res);\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        res[i] = res[i].swap;\n    }\n    \n    sort(res);\n    \n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgp80wug_.d(37): Error: C style cast illegal, use `cast(long)i`\\\
    n/tmp/tmpgp80wug_.d(37): Error: C style cast illegal, use `cast(long)j`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgp80wug_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.Length][];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i].Length > x)\n\
    \        {\n            throw new Exception(\"Invalid input\");\n        }\n \
    \       res[i] = lst[i].Take(x).ToArray();\n    }\n    return Tuple!(long, long)[](res,\
    \ lst.Length);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdng0mcaz.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpdng0mcaz.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpdng0mcaz.d(29):\
    \ Error: no property `Length` for type `long[]`\\n/tmp/tmpdng0mcaz.d(33): Error:\
    \ no property `Take` for type `long[]`\\n/tmp/tmpdng0mcaz.d(35): Error: no property\
    \ `Length` for type `long[][]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpdng0mcaz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n \
    \   {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n           \
    \ if(lst[i][j] == x)\n            {\n                result.push(new Tuple!(long,\
    \ long)(i + 1, j + 1));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b){return a.first > b.first;});\n    result.sort(function(a, b){return a.second\
    \ > b.second;});\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbcdio13r.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpbcdio13r.d(34): Error:\
    \ no property `push` for type `Tuple!(long, long)[]`\\n/tmp/tmpbcdio13r.d(39):\
    \ Error: no property `sort` for type `Tuple!(long, long)[]`\\n/tmp/tmpbcdio13r.d(40):\
    \ Error: no property `sort` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbcdio13r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    int[] row_index = new int[lst.Length];\n\
    \    int[] col_index = new int[lst.Length];\n    \n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        row_index[i] = i;\n        col_index[i] = i;\n    }\n \
    \   \n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][x] ==\
    \ x)\n        {\n            row[i] = i;\n            col[i] = x;\n          \
    \  break;\n        }\n    }\n    \n    for(int i = 0; i < lst.Length; i++)\n \
    \   {\n        if(lst[row_index[i]][col_index[i]] == x)\n        {\n         \
    \   row[i] = row_index[i];\n            col[i] = col_index[i];\n            break;\n\
    \        }\n    }\n    \n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.Length];\n\
    \    \n    for(int i = 0; i < lst.Length; i++)\n    {\n        result[i] = new\
    \ Tuple!(long, long)();\n        result[i].Item1 = row[i];\n        result[i].Item2\
    \ = col[i];\n    }\n    \n    Array.Sort(result, (a, b) => a.Item1.CompareTo(b.Item1));\n\
    \    Array.Sort(result, (a, b) => a.Item2.CompareTo(b.Item2));\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzgygkgrx.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpzgygkgrx.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(29): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(31): Error: no\
    \ property `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(37): Error: no property\
    \ `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(42): Error: cannot implicitly\
    \ convert expression `x` of type `long` to `int`\\n/tmp/tmpzgygkgrx.d(47): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(57): Error: no\
    \ property `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(59): Error: no property\
    \ `Length` for type `long[][]`\\n/tmp/tmpzgygkgrx.d(61): Error: template `std.typecons.Tuple!(long,\
    \ long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long,\
    \ long)*)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\n/tmp/tmpzgygkgrx.d(62): Error:\
    \ no property `Item1` for type `Tuple!(long, long)`\\n/tmp/tmpzgygkgrx.d(63):\
    \ Error: no property `Item2` for type `Tuple!(long, long)`\\n/tmp/tmpzgygkgrx.d(66):\
    \ Error: undefined identifier `Array`\\n/tmp/tmpzgygkgrx.d(67): Error: undefined\
    \ identifier `Array`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgygkgrx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(col:\
    \ row)\n        {\n            if(col == x)\n            {\n                res.push(Tuple!(long,\
    \ long)((row), col));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, (a, b) => a.first > b.first);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5xmbe205.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp5xmbe205.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp5xmbe205.d(30): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmp5xmbe205.d(30): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5xmbe205.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            res[i] = i;\n            break;\n        }\n \
    \   }\n    return Tuple!(long, long)[](res, res);\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkuek63qo.d(36): Error: function expected before `()`, not `Tuple!(long,\
    \ long)[]` of type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpkuek63qo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index:\
    \ 0) \n        {\n            if(col == x) \n            {\n                res\
    \ = Tuple!(long, long)[](row_index, col_index);\n                break;\n    \
    \        }\n        }\n        if(res != null) break;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpje5hrmw_.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpje5hrmw_.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpje5hrmw_.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpje5hrmw_.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpje5hrmw_.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpje5hrmw_.d(29): Error: found `:` when expecting `;`\\n/tmp/tmpje5hrmw_.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpje5hrmw_.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpje5hrmw_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: int) \n    {\n        foreach(col: row, j: int) \n \
    \       {\n            if(col == x) \n            {\n                if(res ==\
    \ null) \n                {\n                    res = Tuple!(long, long)[]();\n\
    \                }\n                res[res.length] = Tuple!(i, j);\n        \
    \    }\n        }\n    }\n    \n    foreach(row: lst, i: int) \n    {\n      \
    \  foreach(col: row, j: int) \n        {\n            if(col != x) \n        \
    \    {\n                if(res == null) \n                {\n                \
    \    res = Tuple!(long, long)[]();\n                }\n                res[res.length]\
    \ = Tuple!(i, j);\n            }\n        }\n    }\n    \n    return res;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9vjm6gqu.d(27): Error: no identifier for declarator `row`\\n/tmp/tmp9vjm6gqu.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp9vjm6gqu.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp9vjm6gqu.d(27): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmp9vjm6gqu.d(27): Error: found `)` instead of statement\\n/tmp/tmp9vjm6gqu.d(37):\
    \ Error: no identifier for declarator `res[res.length]`\\n/tmp/tmp9vjm6gqu.d(37):\
    \ Error: declaration expected, not `=`\\n/tmp/tmp9vjm6gqu.d(38): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9vjm6gqu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                if(res == null)\n            \
    \    {\n                    res = Tuple!(long, long)[](row,col);\n           \
    \     }\n                else\n                {\n                    res = Tuple!(long,\
    \ long)[](row,col);\n                    foreach(row2,lst)\n                 \
    \   {\n                        foreach(col2,row2)\n                        {\n\
    \                            if(col2 == col)\n                            {\n\
    \                                res = Tuple!(long, long)[](row,col);\n      \
    \                          break;\n                            }\n           \
    \             }\n                    }\n                }\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0kge229x.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp0kge229x.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp0kge229x.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp0kge229x.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp0kge229x.d(40): Error: no identifier for declarator `lst`\\n/tmp/tmp0kge229x.d(40):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp0kge229x.d(42): Error: no identifier\
    \ for declarator `row2`\\n/tmp/tmp0kge229x.d(42): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp0kge229x.d(50): Error: found `}` when expecting `)`\\n/tmp/tmp0kge229x.d(51):\
    \ Error: found `}` instead of statement\\n/tmp/tmp0kge229x.d(52): Error: found\
    \ `break` when expecting `)`\\n/tmp/tmp0kge229x.d(52): Error: use `{ }` for an\
    \ empty statement, not `;`\\n/tmp/tmp0kge229x.d(56): Error: found `return` when\
    \ expecting `)`\\n/tmp/tmp0kge229x.d(58): Error: found `unittest` when expecting\
    \ `)`\\n/tmp/tmp0kge229x.d(69): Error: found `End of File` when expecting `}`\
    \ following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0kge229x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n\
    \    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row,\
    \ column_index: 0) \n        {\n            if(column == x) \n            {\n\
    \                foreach(coord: row, coord_index: 0) \n                {\n   \
    \                 result = append(result, Tuple!(long, long)((row_index, coord_index),\
    \ (column_index, coord_index)));\n                }\n            }\n        }\n\
    \    }\n    \n    sort(result, (a, b) => a.1 < b.1);\n    sort(result, (a, b)\
    \ => a.2 < b.2);\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcqxjw82j.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpcqxjw82j.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpcqxjw82j.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpcqxjw82j.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpcqxjw82j.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpcqxjw82j.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpcqxjw82j.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpcqxjw82j.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmpcqxjw82j.d(34): Error: no identifier\
    \ for declarator `coord`\\n/tmp/tmpcqxjw82j.d(34): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpcqxjw82j.d(34): Error: found `:` when expecting `)`\\n/tmp/tmpcqxjw82j.d(34):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmpcqxjw82j.d(42):\
    \ Error: found `0.1` when expecting `,`\\n/tmp/tmpcqxjw82j.d(42): Error: expression\
    \ expected, not `<`\\n/tmp/tmpcqxjw82j.d(42): Error: found `b` when expecting\
    \ `,`\\n/tmp/tmpcqxjw82j.d(43): Error: found `0.2` when expecting `,`\\n/tmp/tmpcqxjw82j.d(43):\
    \ Error: expression expected, not `<`\\n/tmp/tmpcqxjw82j.d(43): Error: found `b`\
    \ when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcqxjw82j.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv4n7ct6z.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpv4n7ct6z.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpv4n7ct6z.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpv4n7ct6z.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpv4n7ct6z.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpv4n7ct6z.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpv4n7ct6z.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpv4n7ct6z.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpv4n7ct6z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(long, long)[i, j];\n                break;\n           \
    \ }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n\
    \                res[i] = Tuple!(long, long)[i, j];\n                break;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptc5v1zi9.d(37): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmptc5v1zi9.d(49): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptc5v1zi9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.length];\n\
    \    int[] col = new int[lst[0].length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        row[i] = i;\n        for(int j = 0; j < lst[i].length; j++)\n\
    \        {\n            col[j] = j;\n        }\n    }\n    Arrays.sort(row);\n\
    \    Arrays.sort(col);\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = Tuple!(long,\
    \ long)((row[i]), col[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk4e5oggy.d(36): Error: undefined identifier `Arrays`\\n/tmp/tmpk4e5oggy.d(37):\
    \ Error: undefined identifier `Arrays`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpk4e5oggy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row);\n\
    \    Array.Sort(col);\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == x)\n   \
    \     {\n            res[i] = Tuple!(long, long)[i, col[i]];\n        }\n    }\n\
    \    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp93n4fian.d(45): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93n4fian.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, i: 0) {\n        foreach(col:\
    \ row, j: 0) {\n            if(col == x) {\n                res.push(Tuple!(long,\
    \ long)[i, j]);\n            }\n        }\n    }\n    \n    sort(res, (row1, row2)\
    \ => row1._1 > row2._1);\n    sort(res, (row1, row2) => row1._2 > row2._2);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp31pjhadm.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp31pjhadm.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp31pjhadm.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp31pjhadm.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp31pjhadm.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmp31pjhadm.d(29): Error: found `:` when expecting `;`\\n/tmp/tmp31pjhadm.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp31pjhadm.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp31pjhadm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,\
    \ col);\n                break;\n            }\n        }\n        if(res != null)\n\
    \            break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmm1qpb4b.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpmm1qpb4b.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpmm1qpb4b.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpmm1qpb4b.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpmm1qpb4b.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpmm1qpb4b.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpmm1qpb4b.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpmm1qpb4b.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpmm1qpb4b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, row_index: 0) \n    {\n \
    \       foreach(col: row, col_index: 0) \n        {\n            if(col == x)\
    \ \n            {\n                foreach(coord: row, coord_index: 0) \n    \
    \            {\n                    if(coord_index == row_index) \n          \
    \          {\n                        foreach(coord2: row, coord2_index: 0) \n\
    \                        {\n                            if(coord2_index == col_index)\
    \ \n                            {\n                                res.add(new\
    \ Tuple!(long, long)((row_index, col_index), (coord2_index, coord_index)));\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9lxahrb_.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp9lxahrb_.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp9lxahrb_.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp9lxahrb_.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp9lxahrb_.d(30): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmp9lxahrb_.d(30): Error: found `:` when expecting `;`\\n/tmp/tmp9lxahrb_.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp9lxahrb_.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmp9lxahrb_.d(34): Error: no identifier\
    \ for declarator `coord`\\n/tmp/tmp9lxahrb_.d(34): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmp9lxahrb_.d(34): Error: found `:` when expecting `)`\\n/tmp/tmp9lxahrb_.d(34):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmp9lxahrb_.d(38):\
    \ Error: no identifier for declarator `coord2`\\n/tmp/tmp9lxahrb_.d(38): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmp9lxahrb_.d(38): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmp9lxahrb_.d(38): Error: found `)` when expecting `;`\
    \ following statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9lxahrb_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(i, row) \n    {\n        foreach(j, col)\
    \ \n        {\n            if(row[j] == x) \n            {\n                res.push(Tuple!(long,\
    \ long)[i, j]);\n            }\n        }\n    }\n    sort(res);\n    sort(res,\
    \ (a, b) => -cmp(a.i, b.i));\n    return res;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2bbb955.d(27): Error: no identifier for declarator `row`\\n/tmp/tmps2bbb955.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmps2bbb955.d(29): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmps2bbb955.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmps2bbb955.d(36): Error: found `}` when expecting `)`\\n/tmp/tmps2bbb955.d(41):\
    \ Error: unterminated /* */ comment\\n/tmp/tmps2bbb955.d(53): Error: found `End\
    \ of File` when expecting `)`\\n/tmp/tmps2bbb955.d(53): Error: found `End of File`\
    \ instead of statement\\n/tmp/tmps2bbb955.d(53): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmps2bbb955.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe5l927wu.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpe5l927wu.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpe5l927wu.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpe5l927wu.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpe5l927wu.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpe5l927wu.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpe5l927wu.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpe5l927wu.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpe5l927wu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n     \
    \   {\n            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, j), Tuple!(1, j)];\n                break;\n            }\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprimigxsa.d(27): Error: no identifier for declarator `row`\\n/tmp/tmprimigxsa.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmprimigxsa.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmprimigxsa.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmprimigxsa.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmprimigxsa.d(29): Error: found `:` when expecting `;`\\n/tmp/tmprimigxsa.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmprimigxsa.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmprimigxsa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, i: int) \n    {\n       \
    \ foreach(col: row, j: int) \n        {\n            if(col == x) \n         \
    \   {\n                res.push(Tuple!(long, long)(i + 1, j + 1));\n         \
    \   }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first\
    \ > b.first);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1o354pls.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp1o354pls.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp1o354pls.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp1o354pls.d(28): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmp1o354pls.d(28): Error: found `)` instead of statement\\n/tmp/tmp1o354pls.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp1o354pls.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row: lst) {\n        foreach(column:\
    \ row) {\n            if(column == x) {\n                result.push(Tuple!(long,\
    \ long)((row), column));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) {\n        return a.row > b.row;\n    });\n    \n    result.sort(function(a,\
    \ b) {\n        return a.column > b.column;\n    });\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvs9av7r_.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpvs9av7r_.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpvs9av7r_.d(29): Error: no identifier\
    \ for declarator `column`\\n/tmp/tmpvs9av7r_.d(29): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvs9av7r_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, i: 0) {\n        foreach(col:\
    \ row, j: 0) {\n            if(col == x) {\n                res.add((i, j));\n\
    \            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk2lk3mod.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpk2lk3mod.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpk2lk3mod.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpk2lk3mod.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpk2lk3mod.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpk2lk3mod.d(29): Error: found `:` when expecting `;`\\n/tmp/tmpk2lk3mod.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpk2lk3mod.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpk2lk3mod.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[][]\
    \ res = new long[n][];\n    for(int i = 0; i < n; i++) {\n        res[i] = lst[i];\n\
    \    }\n    Arrays.sort(res, (int i, int j) -> {\n        int cmp = res[i][0]\
    \ - res[j][0];\n        if(cmp == 0) {\n            cmp = res[i][1] - res[j][1];\n\
    \        }\n        return cmp;\n    });\n    Arrays.sort(res, (a, b) -> {\n \
    \       int cmp = res[a][1] - res[b][1];\n        if(cmp == 0) {\n           \
    \ cmp = res[a][0] - res[b][0];\n        }\n        return cmp;\n    });\n    Arrays.sort(res,\
    \ (a, b) -> {\n        int cmp = res[a][1] - res[b][1];\n        if(cmp == 0)\
    \ {\n            cmp = res[a][0] - res[b][0];\n        }\n        return cmp;\n\
    \    });\n    Arrays.sort(res, (a, b) -> {\n        int cmp = res[a][1] - res[b][1];\n\
    \        if(cmp == 0) {\n            cmp = res[a][0] - res[b][0];\n        }\n\
    \        return cmp;\n    });\n    Arrays.sort(res, (a, b) -> {\n        int cmp\
    \ = res[a][1] - res[b][1];\n        if(cmp == 0) {\n            cmp = res[a][0]\
    \ - res[b][0];\n        }\n        return cmp;\n    });\n    Arrays.sort(res,\
    \ (a, b) -> {\n        int cmp = res[a][1] - res[b][1];\n        if(cmp == 0)\
    \ {\n            cmp = res[a][0] - res[b][0];\n        }\n        return cmp;\n\
    \    });\n    Arrays.sort(res, (a, b) -> {\n        int cmp = res[a][1] - res[b][1];\n\
    \        if(cmp == 0) {\n            cmp = res[a][0] - res[b][0];\n        }\n\
    \        return cmp;\n    });\n    Arrays.sort(res, (a, b) -> {\n        int cmp\
    \ = res[a][1] - res[b][1];\n        if(cmp == 0) {\n            cmp = res[a][0]\
    \ - res[b][0];\n        }\n        return cmp;\n    });\n    Arrays.sort(res,\
    \ (a, b) -> {\n        int cmp = res[a][1] - res[b][1];\n        if(cmp == 0)\
    \ {\n            cmp = res[a][0] - res[b][0];\n        }\n        return cmp;\n\
    \    });\n    Arrays.sort(res, (a, b) -> {\n        int cmp = res[a][1] - res[b][1];\n\
    \        if(cmp == 0) {\n            cmp = res[a][0] - res[b][0];\n        }\n\
    \        return cmp;\n    });\n    Arrays.sort(res, (a, b) -> {\n        int cmp\
    \ = res[a][1] - res[b][1];\n        if(cmp == 0) {\n            cmp = res\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqz9p897x.d(31): Error: found `i` when expecting `.` following\
    \ int\\n/tmp/tmpqz9p897x.d(31): Error: found `,` when expecting identifier following\
    \ `int`.\\n/tmp/tmpqz9p897x.d(31): Error: found `int` when expecting `)`\\n/tmp/tmpqz9p897x.d(31):\
    \ Error: found `j` when expecting `,`\\n/tmp/tmpqz9p897x.d(31): Error: expression\
    \ expected, not `>`\\n/tmp/tmpqz9p897x.d(31): Error: found `{` when expecting\
    \ `;` following statement\\n/tmp/tmpqz9p897x.d(37): Error: declaration expected,\
    \ not `)`\\n/tmp/tmpqz9p897x.d(38): Error: unexpected `(` in declarator\\n/tmp/tmpqz9p897x.d(38):\
    \ Error: basic type expected, not `(`\\n/tmp/tmpqz9p897x.d(38): Error: function\
    \ declaration without return type. (Note that constructors are always named `this`)\\\
    n/tmp/tmpqz9p897x.d(38): Error: found `-` when expecting `)`\\n/tmp/tmpqz9p897x.d(38):\
    \ Error: no identifier for declarator `Arrays.sort(res, _error_(a, b))`\\n/tmp/tmpqz9p897x.d(38):\
    \ Error: semicolon expected following function declaration\\n/tmp/tmpqz9p897x.d(38):\
    \ Error: declaration expected, not `>`\\n/tmp/tmpqz9p897x.d(40): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpqz9p897x.d(42): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz9p897x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[i].slice(x);\n\
    \    }\n    return Tuple!(long, long)[](sort(res), sort(res).reverse());\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr1g03c7t.d(26): Error: variable `lst` cannot be read at compile\
    \ time\\n/tmp/tmpr1g03c7t.d(29): Error: no property `slice` for type `long[]`\\\
    n/tmp/tmpr1g03c7t.d(31): Error: undefined identifier `sort`, did you mean function\
    \ `sqrt`?\\n/tmp/tmpr1g03c7t.d(31): Error: undefined identifier `sort`, did you\
    \ mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmpr1g03c7t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row: lst, i: int) \n    {\n   \
    \     foreach(col: row, j: int) \n        {\n            if(col == x) \n     \
    \       {\n                result.add((i, j));\n            }\n        }\n   \
    \ }\n    \n    result.sort(function(a, b) -> a.0 < b.0 ? -1 : a.0 > b.0 ? 1 :\
    \ 0);\n    result.sort(function(a, b) -> a.1 < b.1 ? -1 : a.1 > b.1 ? 1 : 0);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpye7cwkuq.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpye7cwkuq.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpye7cwkuq.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpye7cwkuq.d(28): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmpye7cwkuq.d(28): Error: found `)` instead of statement\\n/tmp/tmpye7cwkuq.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpye7cwkuq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    while(true)\n\
    \    {\n        for(int i = 0; i < lst.Length; i++)\n        {\n            if(lst[row[i]][col[i]]\
    \ == x)\n            {\n                return Tuple!(long, long)[Tuple!(int,int)[row,\
    \ col]];\n            }\n        }\n        \n        if(col[lst.Length-1] ==\
    \ lst.Length-1)\n        {\n            return Tuple!(long, long)[Tuple!(int,int)[row,\
    \ col]];\n        }\n        \n        col[lst.Length-1]++;\n    }\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp0_bzb2w.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpp0_bzb2w.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpp0_bzb2w.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpp0_bzb2w.d(36): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpp0_bzb2w.d(40): Error: no\
    \ `[]` operator overload for type `Tuple!(int, int)`\\n/tmp/tmpp0_bzb2w.d(44):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpp0_bzb2w.d(44): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpp0_bzb2w.d(46): Error: no\
    \ `[]` operator overload for type `Tuple!(int, int)`\\n/tmp/tmpp0_bzb2w.d(49):\
    \ Error: no property `Length` for type `long[][]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpp0_bzb2w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.length];\n\
    \    int[] col = new int[lst[0].length];\n    \n    for(int i = 0; i < lst.length;\
    \ i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j]\
    \ == x){\n                row[i] = j;\n                col[j] = i;\n         \
    \   }\n        }\n    }\n    \n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[lst.length];\n    \n    for(int i = 0; i < lst.length; i++){\n       \
    \ res[i] = Tuple!(long, long)((row[i], col[i]));\n    }\n    \n    sort(res);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6d3cg3ar.d(41): Error: Using the result of a comma expression\
    \ is not allowed\\n/tmp/tmp6d3cg3ar.d(41): Error: none of the overloads of `this`\
    \ are callable using argument types `(int)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(668):\
    \        `std.typecons.Tuple!(long, long).Tuple.this(long, long)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(689):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U, ulong n)(U[n] values)\
    \ if (n == Types.length && allSatisfy!(isBuildableFrom!U, Types))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(715):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U)(U another) if (areBuildCompatibleTuples!(typeof(this),\
    \ U))`\\n/tmp/tmp6d3cg3ar.d(44): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6d3cg3ar.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    \n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n  \
    \          if(col == x) \n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkhhoy2po.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmpkhhoy2po.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpkhhoy2po.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpkhhoy2po.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpkhhoy2po.d(38): Error: found `if` when expecting `)`\\n/tmp/tmpkhhoy2po.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpkhhoy2po.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpkhhoy2po.d(41):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpkhhoy2po.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, row: row) \n    {\n        foreach(col: row, col: col)\
    \ \n        {\n            if(col == x) \n            {\n                if(res\
    \ == null) \n                {\n                    res = Tuple!(long, long)[](row,\
    \ 0);\n                }\n                else\n                {\n          \
    \          res = Tuple!(long, long)[](row, col + 1);\n                }\n    \
    \        }\n        }\n    }\n    \n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col > x) \n \
    \           {\n                if(res == null) \n                {\n         \
    \           res = Tuple!(long, long)[](row, 0);\n                }\n         \
    \       else\n                {\n                    res = Tuple!(long, long)[](row,\
    \ col - 1);\n                }\n            }\n        }\n    }\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptc_f4agy.d(27): Error: no identifier for declarator `row`\\n/tmp/tmptc_f4agy.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmptc_f4agy.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmptc_f4agy.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmptc_f4agy.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmptc_f4agy.d(29): Error: found `:` when expecting `;`\\n/tmp/tmptc_f4agy.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmptc_f4agy.d(29): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmptc_f4agy.d(45): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmptc_f4agy.d(45): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmptc_f4agy.d(45): Error: found `:` when expecting `)`\\n/tmp/tmptc_f4agy.d(45):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmptc_f4agy.d(47):\
    \ Error: no identifier for declarator `col`\\n/tmp/tmptc_f4agy.d(47): Error: found\
    \ `:` when expecting `;`\\n/tmp/tmptc_f4agy.d(47): Error: found `:` when expecting\
    \ `)`\\n/tmp/tmptc_f4agy.d(47): Error: found `)` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptc_f4agy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(row::lst) {\n        foreach(col::row) {\n\
    \            if(col == x) {\n                res.push(Tuple!(long, long)((row,col)));\n\
    \            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) => a.1\
    \ < b.1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf__sa53q.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpf__sa53q.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpf__sa53q.d(27): Error: expression\
    \ expected, not `:`\\n/tmp/tmpf__sa53q.d(27): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpf__sa53q.d(27): Error: found `)` instead of statement\\n/tmp/tmpf__sa53q.d(32):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpf__sa53q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            res[i] = i;\n        }\n    }\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8flbdocc.d(35): Error: cannot implicitly convert expression `res`\
    \ of type `long[]` to `ulong`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp8flbdocc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j\
    \ = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n  \
    \          {\n                res[i] = j;\n                break;\n          \
    \  }\n        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpidhic4wl.d(39): Error: cannot implicitly convert expression `res`\
    \ of type `long[]` to `ulong`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpidhic4wl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.Length;\n    long\
    \ m = lst[0].Length;\n    long[,] res = new long[n, m];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n          \
    \  res[i, j] = lst[i][j];\n        }\n    }\n    Array.Sort(res, 0, n, 0, m, (x,\
    \ y) => { return y - x; });\n    Array.Sort(res, 0, n, 0, m, (x, y) => { return\
    \ y - x; });\n    return Tuple!(long, long)[](\n        Tuple!(long, long)[](\n\
    \            Tuple!(long, long)[](0, 0),\n            Tuple!(long, long)[](0,\
    \ m),\n            Tuple!(long, long)[](n, 0),\n            Tuple!(long, long)[](n,\
    \ m)\n        )\n    );\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8s7fc0un.d(28): Error: expression expected, not `,`\\n/tmp/tmp8s7fc0un.d(28):\
    \ Error: found `,` when expecting `]`\\n/tmp/tmp8s7fc0un.d(28): Error: semicolon\
    \ expected, not `m`\\n/tmp/tmp8s7fc0un.d(28): Error: found `]` when expecting\
    \ `;` following statement\\n/tmp/tmp8s7fc0un.d(28): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\n/tmp/tmp8s7fc0un.d(47): Error: unterminated /*\
    \ */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8s7fc0un.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf8oqch1e.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpf8oqch1e.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpf8oqch1e.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpf8oqch1e.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpf8oqch1e.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpf8oqch1e.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpf8oqch1e.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpf8oqch1e.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpf8oqch1e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row);\n\
    \    Array.Sort(col);\n    for(int i = 0; i < lst.Length; i++)\n    {\n      \
    \  if(lst[i][row[i]] == x)\n        {\n            Tuple!(long, long)[] res =\
    \ new Tuple!(long, long)[lst.Length];\n            for(int j = 0; j < lst.Length;\
    \ j++)\n            {\n                res[j] = (row[j], col[j]);\n          \
    \  }\n            return res;\n        }\n    }\n    return new Tuple!(long, long)[0];\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3mqgtsc.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpu3mqgtsc.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpu3mqgtsc.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpu3mqgtsc.d(33): Error:\
    \ undefined identifier `Array`\\n/tmp/tmpu3mqgtsc.d(34): Error: undefined identifier\
    \ `Array`\\n/tmp/tmpu3mqgtsc.d(35): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpu3mqgtsc.d(39): Error: no property `Length` for type `long[][]`\\n/tmp/tmpu3mqgtsc.d(40):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpu3mqgtsc.d(42): Error:\
    \ Using the result of a comma expression is not allowed\\n/tmp/tmpu3mqgtsc.d(42):\
    \ Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce\
    \ function from argument types `!()(int)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpu3mqgtsc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n \
    \   {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length;\
    \ j++)\n            {\n                result.add((i, j));\n            }\n  \
    \      }\n    }\n    \n    result.sort(function(a, b) {\n        return a.0 <\
    \ b.0;\n    });\n    \n    result.sort(function(a, b) {\n        return b.1 <\
    \ a.1;\n    });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi8izr9em.d(40): Error: found `0.00000` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpi8izr9em.d(40): Error: found `<` instead of statement\\\
    n/tmp/tmpi8izr9em.d(44): Error: found `0.1` when expecting `;` following `return`\
    \ statement\\n/tmp/tmpi8izr9em.d(44): Error: found `<` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi8izr9em.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    \n    result.sort(function(a,b){return\
    \ a.1 > b.1;});\n    result.sort(function(a,b){return a.1 < b.1;});\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1e45c741.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmp1e45c741.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp1e45c741.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp1e45c741.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp1e45c741.d(37): Error: found `}` when expecting `)`\\n/tmp/tmp1e45c741.d(39):\
    \ Error: found `0.1` when expecting `;` following `return` statement\\n/tmp/tmp1e45c741.d(39):\
    \ Error: found `>` instead of statement\\n/tmp/tmp1e45c741.d(40): Error: found\
    \ `0.1` when expecting `;` following `return` statement\\n/tmp/tmp1e45c741.d(40):\
    \ Error: found `<` instead of statement\\n/tmp/tmp1e45c741.d(44): Error: found\
    \ `unittest` when expecting `)`\\n/tmp/tmp1e45c741.d(55): Error: found `End of\
    \ File` when expecting `}` following compound statement\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp1e45c741.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst) {\n        foreach(col,row) {\n            if(col == x)\
    \ {\n                res = Tuple!(long, long)[](row,col);\n                break;\n\
    \            }\n        }\n        if(res != null) {\n            break;\n   \
    \     }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb6fjitqu.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpb6fjitqu.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpb6fjitqu.d(28): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpb6fjitqu.d(28): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpb6fjitqu.d(34): Error: found `if` when expecting `)`\\n/tmp/tmpb6fjitqu.d(34):\
    \ Error: found `!=` when expecting `)`\\n/tmp/tmpb6fjitqu.d(34): Error: missing\
    \ `{ ... }` for function literal\\n/tmp/tmpb6fjitqu.d(34): Error: found `null`\
    \ when expecting `;` following statement\\n/tmp/tmpb6fjitqu.d(34): Error: found\
    \ `)` instead of statement\\n/tmp/tmpb6fjitqu.d(37): Error: found `}` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb6fjitqu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    \n    for(i = 0; i < n; i++)\n    {\n\
    \        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n \
    \           {\n                return Tuple!(long, long)[](Tuple!(0, j), Tuple!(i,\
    \ 0));\n            }\n        }\n    }\n    return Tuple!(long, long)[](Tuple!(0,\
    \ m), Tuple!(0, n));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(0, j)` cannot use local `j` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(614):\
    \ Error: CTFE failed because of previous errors in `injectNamedFields`\\n/tmp/tmpw4k6l8n3.d(36):\
    \ Error: template instance `tmpw4k6l8n3.get_row.Tuple!(0, j)` error instantiating\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, 0)` cannot use local `i` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(614):\
    \ Error: CTFE failed because of previous errors in `injectNamedFields`\\n/tmp/tmpw4k6l8n3.d(36):\
    \ Error: template instance `tmpw4k6l8n3.get_row.Tuple!(i, 0)` error instantiating\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(0, m)` cannot use local `m` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(614):\
    \ Error: CTFE failed because of previous errors in `injectNamedFields`\\n/tmp/tmpw4k6l8n3.d(40):\
    \ Error: template instance `tmpw4k6l8n3.get_row.Tuple!(0, m)` error instantiating\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(0, n)` cannot use lo"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols\
    \ = 0;\n    foreach(row,lst) \n    {\n        cols = cols + 1;\n        foreach(col,row)\
    \ \n        {\n            if(col == x) \n            {\n                return\
    \ Tuple!(long, long)[](rows,cols);\n            }\n        }\n        rows = rows\
    \ + 1;\n    }\n    return Tuple!(long, long)[](rows,cols);\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkbqabx5_.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmpkbqabx5_.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpkbqabx5_.d(31): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpkbqabx5_.d(31): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpkbqabx5_.d(38): Error: found `rows` when expecting `)`\\n/tmp/tmpkbqabx5_.d(38):\
    \ Error: found `=` instead of statement\\n/tmp/tmpkbqabx5_.d(40): Error: found\
    \ `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpkbqabx5_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m1 = m;\n    long n1 = n;\n    long m2 = m;\n    long n2 =\
    \ n;\n    long m3 = m;\n    long n3 = n;\n    long m4 = m;\n    long n4 = n;\n\
    \    long m5 = m;\n    long n5 = n;\n    long m6 = m;\n    long n6 = n;\n    long\
    \ m7 = m;\n    long n7 = n;\n    long m8 = m;\n    long n8 = n;\n    long m9 =\
    \ m;\n    long n9 = n;\n    long m10 = m;\n    long n10 = n;\n    long m11 = m;\n\
    \    long n11 = n;\n    long m12 = m;\n    long n12 = n;\n    long m13 = m;\n\
    \    long n13 = n;\n    long m14 = m;\n    long n14 = n;\n    long m15 = m;\n\
    \    long n15 = n;\n    long m16 = m;\n    long n16 = n;\n    long m17 = m;\n\
    \    long n17 = n;\n    long m18 = m;\n    long n18 = n;\n    long m19 = m;\n\
    \    long n19 = n;\n    long m20 = m;\n    long n20 = n;\n    long m21 = m;\n\
    \    long n21 = n;\n    long m22 = m;\n    long n22 = n;\n    long m23 = m;\n\
    \    long n23 = n;\n    long m24 = m;\n    long n24 = n;\n    long m25 = m;\n\
    \    long n25 = n;\n    long m26 = m;\n    long n26 = n;\n    long m27 = m;\n\
    \    long n27 = n;\n    long m28 = m;\n    long n28 = n;\n    long m29 = m;\n\
    \    long n29 = n;\n    long m30 = m;\n    long n30 = n;\n    long m31 = m;\n\
    \    long n31 = n;\n    long m32 = m;\n    long n32 = n;\n    long m33 = m;\n\
    \    long n33 = n;\n    long m34 = m;\n    long n34 = n;\n    long m35 = m;\n\
    \    long n35 = n;\n    long m36 = m;\n    long n36 = n;\n    \nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1radiufx.d(105): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1radiufx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    \n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[i] = Tuple!(long, long)[i, j];\n                break;\n\
    \            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp73268oub.d(38): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp73268oub.d(44): Error: undefined identifier `sort`, did you\
    \ mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp73268oub.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(column:\
    \ row)\n        {\n            if(column == x)\n            {\n              \
    \  result.push(Tuple!(long, long)((row), column));\n            }\n        }\n\
    \    }\n    \n    result.sort(function(a, b) -> a.1 < b.1);\n    result.sort(function(a,\
    \ b) -> a.2 < b.2);\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpao7mmi84.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpao7mmi84.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpao7mmi84.d(30): Error: no identifier\
    \ for declarator `column`\\n/tmp/tmpao7mmi84.d(30): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpao7mmi84.d(39): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpao7mmi84.d(39): Error: expression expected, not `>`\\n/tmp/tmpao7mmi84.d(39):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpao7mmi84.d(39): Error: found `0.1`\
    \ when expecting `,`\\n/tmp/tmpao7mmi84.d(40): Error: missing `{ ... }` for function\
    \ literal\\n/tmp/tmpao7mmi84.d(40): Error: expression expected, not `>`\\n/tmp/tmpao7mmi84.d(40):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpao7mmi84.d(40): Error: found `0.2`\
    \ when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpao7mmi84.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, Tuple!(long, long)((0,0),1));\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptxniz8n_.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmptxniz8n_.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmptxniz8n_.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmptxniz8n_.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmptxniz8n_.d(37): Error: found `}` when expecting `)`\\n/tmp/tmptxniz8n_.d(44):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmptxniz8n_.d(55): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptxniz8n_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    \n    foreach(row: lst, i: 0) \n    {\n        foreach(col: row,\
    \ j: 0) \n        {\n            if(col == x) \n            {\n              \
    \  result = Tuple!(long, long)[](Tuple!(0, j), Tuple!(i + 1, j + 1));\n      \
    \      }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdvaomziu.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpdvaomziu.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpdvaomziu.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpdvaomziu.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpdvaomziu.d(30): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpdvaomziu.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpdvaomziu.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpdvaomziu.d(30): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpdvaomziu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.Length][];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i].Length == x)\n\
    \        {\n            res[i] = lst[i];\n        }\n    }\n    Array.Sort(res);\n\
    \    Array.Sort(res, (x, y) => { return y[0] - x[0]; });\n    Array.Sort(res,\
    \ (x, y) => { return y[1] - x[1]; });\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeuj8_fba.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpeuj8_fba.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpeuj8_fba.d(29):\
    \ Error: no property `Length` for type `long[]`\\n/tmp/tmpeuj8_fba.d(34): Error:\
    \ undefined identifier `Array`\\n/tmp/tmpeuj8_fba.d(35): Error: undefined identifier\
    \ `Array`\\n/tmp/tmpeuj8_fba.d(36): Error: undefined identifier `Array`\\n/tmp/tmpeuj8_fba.d(37):\
    \ Error: cannot implicitly convert expression `res` of type `long[][]` to `Tuple!(long,\
    \ long)[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeuj8_fba.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[i].subarray(0,\
    \ x);\n    }\n    Arrays.sort(res, (a, b) -> {\n        long c = a[0] - b[0];\n\
    \        return c < 0 ? 1 : c;\n    });\n    Arrays.sort(res, (a, b) -> {\n  \
    \      long c = a[1] - b[1];\n        return c < 0 ? 1 : c;\n    });\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpggtw1nke.d(31): Error: expression expected, not `>`\\n/tmp/tmpggtw1nke.d(31):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpggtw1nke.d(32): Error: found `c`\
    \ when expecting `.` following long\\n/tmp/tmpggtw1nke.d(32): Error: found `=`\
    \ when expecting identifier following `long`.\\n/tmp/tmpggtw1nke.d(32): Error:\
    \ found `a` when expecting `,`\\n/tmp/tmpggtw1nke.d(32): Error: found `;` when\
    \ expecting `,`\\n/tmp/tmpggtw1nke.d(33): Error: expression expected, not `return`\\\
    n/tmp/tmpggtw1nke.d(33): Error: found `c` when expecting `,`\\n/tmp/tmpggtw1nke.d(33):\
    \ Error: expression expected, not `<`\\n/tmp/tmpggtw1nke.d(33): Error: found `0`\
    \ when expecting `,`\\n/tmp/tmpggtw1nke.d(33): Error: expression expected, not\
    \ `?`\\n/tmp/tmpggtw1nke.d(33): Error: found `1` when expecting `,`\\n/tmp/tmpggtw1nke.d(33):\
    \ Error: expression expected, not `:`\\n/tmp/tmpggtw1nke.d(33): Error: found `c`\
    \ when expecting `,`\\n/tmp/tmpggtw1nke.d(33): Error: expression expected, not\
    \ `;`\\n/tmp/tmpggtw1nke.d(34): Error: found `}` when expecting `,`\\n/tmp/tmpggtw1nke.d(35):\
    \ Error: expression expected, not `>`\\n/tmp/tmpggtw1nke.d(35): Error: found `{`\
    \ when expecting `,`\\n/tmp/tmpggtw1nke.d(36): Error: found `c` when expecting\
    \ `.` following long\\n/tmp/tmpggtw1nke.d(36): Error: found `=` when expecting\
    \ identifier following `long`.\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpggtw1nke.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n \
    \   for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n \
    \       {\n            Tuple!(long, long)[] row = Tuple!(long, long)[];\n    \
    \        for(int j = 0; j < lst[i].length; ++j)\n            {\n             \
    \   if(lst[i][j] == x)\n                {\n                    row.push((i, j));\n\
    \                }\n            }\n            res.push(row);\n        }\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplxva0uxg.d(31): Error: type `Tuple!(long, long)[]` has no value\\\
    n/tmp/tmplxva0uxg.d(36): Error: no property `push` for type `Tuple!(long, long)[]`\\\
    n/tmp/tmplxva0uxg.d(39): Error: no property `push` for type `Tuple!(long, long)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplxva0uxg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(row,lst){\n        foreach(col,row){\n  \
    \          if(col == x){\n                res.push(Tuple!(long, long)((row,col)));\n\
    \            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3pgy4qy4.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp3pgy4qy4.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp3pgy4qy4.d(28): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp3pgy4qy4.d(28): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp3pgy4qy4.d(33): Error: found `}` when expecting `)`\\n/tmp/tmp3pgy4qy4.d(37):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmp3pgy4qy4.d(48): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3pgy4qy4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.Length; i++)\n \
    \   {\n        for(int j = 0; j < lst[i].Length; j++)\n        {\n           \
    \ if(lst[i][j] == x)\n            {\n                result.Add(new Tuple!(long,\
    \ long)(i + 1, j + 1));\n            }\n        }\n    }\n    \n    result.Sort();\n\
    \    \n    for(int i = 0; i < result.Length; i++)\n    {\n        result[i].Sort();\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnn4fngpd.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpnn4fngpd.d(28): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpnn4fngpd.d(30): Error: no\
    \ property `Length` for type `long[]`\\n/tmp/tmpnn4fngpd.d(34): Error: no property\
    \ `Add` for type `Tuple!(long, long)[]`\\n/tmp/tmpnn4fngpd.d(39): Error: no property\
    \ `Sort` for type `Tuple!(long, long)[]`\\n/tmp/tmpnn4fngpd.d(41): Error: no property\
    \ `Length` for type `Tuple!(long, long)[]`\\n/tmp/tmpnn4fngpd.d(43): Error: no\
    \ property `Sort` for type `Tuple!(long, long)`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnn4fngpd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(long, long)[j, i];\n                break;\n           \
    \ }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n\
    \                res[i] = Tuple!(long, long)[j, i];\n                break;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv4hbv7qo.d(37): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmpv4hbv7qo.d(49): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv4hbv7qo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column:\
    \ row, column_index: 0) \n        {\n            if(column == x) \n          \
    \  {\n                result = Tuple!(long, long)[](row_index, column_index);\n\
    \                break;\n            }\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8kcvw1q8.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp8kcvw1q8.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp8kcvw1q8.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp8kcvw1q8.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp8kcvw1q8.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmp8kcvw1q8.d(30): Error: found `:` when expecting `;`\\n/tmp/tmp8kcvw1q8.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp8kcvw1q8.d(30): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp8kcvw1q8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    \n    foreach(i, l) \n    {\n     \
    \   row[i] = i;\n        foreach(j, c) \n        {\n            col[j] = j;\n\
    \            if(l[i] == x) \n            {\n                return Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpauj0oeir.d(29): Error: no identifier for declarator `l`\\n/tmp/tmpauj0oeir.d(29):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpauj0oeir.d(32): Error: no identifier\
    \ for declarator `c`\\n/tmp/tmpauj0oeir.d(32): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpauj0oeir.d(38): Error: expression expected, not `unittest`\\n/tmp/tmpauj0oeir.d(39):\
    \ Error: found `{` when expecting `)` following template argument list\\n/tmp/tmpauj0oeir.d(40):\
    \ Error: found `alias` when expecting `,`\\n/tmp/tmpauj0oeir.d(40): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmpauj0oeir.d(42): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpauj0oeir.d(43): Error: found `;` when expecting `,`\\n/tmp/tmpauj0oeir.d(44):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmpauj0oeir.d(45): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpauj0oeir.d(46): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpauj0oeir.d(47): Error: found `;` when expecting `,`\\n/tmp/tmpauj0oeir.d(48):\
    \ Error: expression expected, not `}`\\n/tmp/tmpauj0oeir.d(49): Error: found `void`\
    \ when expecting `,`\\n/tmp/tmpauj0oeir.d(49): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmpauj0oeir.d(49): Error: expression expected, not `}`\\n/tmp/tmpauj0oeir.d(49):\
    \ Error: found `End of File` when expecting `,`\\n/tmp/tmpauj0oeir.d(49): Error:\
    \ found `End of File` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpauj0oeir.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, row_index: 0) \n    {\n        foreach(col: row, col_index:\
    \ 0) \n        {\n            if(col == x) \n            {\n                res\
    \ = Tuple!(long, long)[](row_index, col_index);\n                break;\n    \
    \        }\n        }\n        if(res != null) break;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnwovf7o1.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpnwovf7o1.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpnwovf7o1.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpnwovf7o1.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpnwovf7o1.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmpnwovf7o1.d(29): Error: found `:` when expecting `;`\\n/tmp/tmpnwovf7o1.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpnwovf7o1.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnwovf7o1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        res[i] = lst[i].subarray(0,\
    \ lst[i].length-1);\n    }\n    \n    Arrays.sort(res);\n    \n    for(int i =\
    \ 0; i < res.length; i++)\n    {\n        Arrays.sort(res[i]);\n    }\n    \n\
    \    Arrays.sort(res, (a, b) => (b[0] - a[0]) * (b[1] - a[1]));\n    \n    for(int\
    \ i = 0; i < res.length; i++)\n    {\n        Arrays.sort(res[i], (a, b) => (b[0]\
    \ - a[0]) * (b[1] - a[1]));\n    }\n    \n    for(int i = 0; i < res.length; i++)\n\
    \    {\n        for(int j = 0; j < res[i].length; j++)\n        {\n          \
    \  if(res[i][j] == x)\n            {\n                return Tuple!((int)i, (int)j);\n\
    \            }\n        }\n    }\n    \n    return Tuple!(0, 0);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpby9ot260.d(52): Error: C style cast illegal, use `cast(int)i`\\\
    n/tmp/tmpby9ot260.d(52): Error: C style cast illegal, use `cast(int)j`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpby9ot260.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][lst[0].length];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n\
    \        {\n            if(res[i][j] == 1)\n            {\n                res[i][j]\
    \ = j;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n   \
    \         if(res[i][j] == j)\n            {\n                res[i][j] = i;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(res[i][j] == i)\n            {\n                res[i][j] = Tuple!(long,\
    \ long)(0, 0);\n            }\n        }\n    }\n    \n    for(int i = 0; i <\
    \ lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n  \
    \      {\n            if(res[i][j].x == 0)\n            {\n                res[i][j]\
    \ = Tuple!(long, long)(0, 0);\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(res[i][j].x == 0)\n            {\n         \
    \       res[i][j] = Tuple!(long, long)(0, 0);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(res[i][j].x == 0)\n     \
    \       {\n                res[i][j] = Tuple!(long, long)(0, 0);\n           \
    \ }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n\
    \        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j].x\
    \ == 0)\n            {\n                res[i][j] = Tuple!(long, long)(0, 0);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(res[i][j].x == 0)\n            {\n                res[i][j] = Tuple!(long,\
    \ long)(0, 0);\n            }\n        }\n    }\n    \n    for(int i = 0; i <\
    \ lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n  \
    \      {\n            if(res[i][j].x == 0)\n            {\n                res[i][j]\
    \ = Tuple!(long, long)(0, 0);\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(res[i][j].x == 0)\n            {\n         \
    \       res[i][j\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbn5r8are.d(144): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpbn5r8are.d(155): Error: found `void` when expecting `,`\\n/tmp/tmpbn5r8are.d(155):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpbn5r8are.d(155): Error: expression\
    \ expected, not `}`\\n/tmp/tmpbn5r8are.d(155): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpbn5r8are.d(155): Error: found `End of File` when expecting\
    \ `]`\\n/tmp/tmpbn5r8are.d(155): Error: found `End of File` when expecting `;`\
    \ following statement\\n/tmp/tmpbn5r8are.d(155): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpbn5r8are.d(155): Error:\
    \ found `End of File` when expecting `}` following compound statement\\n/tmp/tmpbn5r8are.d(155):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpbn5r8are.d(155): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbn5r8are.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    \n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[i] = new Tuple!(i, j);\n                break;\n        \
    \    }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(614):\
    \ Error: CTFE failed because of previous errors in `injectNamedFields`\\n/tmp/tmpd6cmarjk.d(38):\
    \ Error: template instance `tmpd6cmarjk.get_row.Tuple!(i, j)` error instantiating\\\
    n/tmp/tmpd6cmarjk.d(44): Error: undefined identifier `Arrays`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd6cmarjk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long result[][] = new long[n][m];\n    long i, j;\n\
    \    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(lst[i][j] == x)\n            {\n                result[i][j]\
    \ = 1;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(result[i][j] == 1)\n            {\n                for(long k = j + 1;\
    \ k < m; k++)\n                {\n                    if(result[i][k] == 1)\n\
    \                    {\n                        result[i][j] = result[i][j] +\
    \ result[i][k];\n                        result[i][k] = 0;\n                 \
    \       break;\n                    }\n                }\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                for(long k = j + 1; k < m; k++)\n            \
    \    {\n                    if(result[i][k] == 1)\n                    {\n   \
    \                     result[i][j] = result[i][j] + result[i][k];\n          \
    \              result[i][k] = 0;\n                        break;\n           \
    \         }\n                }\n                break;\n            }\n      \
    \  }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        for(long k = j + 1; k < m; k++)\n                {\n                \
    \    if(result[i][k] == 1)\n                    {\n                        result[i][j]\
    \ = result[i][j] + result[i][k];\n                        result[i][k] = 0;\n\
    \                        break;\n                    }\n                }\n  \
    \              break;\n            }\n        }\n    }\n    \n    for(i = 0; i\
    \ < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n            {\n                for(long k = j + 1; k < m; k++)\n    \
    \            {\n                    if(result[i][k] == 1)\n                  \
    \  {\n                        result[i][j] = result[i][j] + result[i][k];\n  \
    \                      result[i][k] = 0;\n                        break;\n   \
    \                 }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n \
    \               for(long k = j + 1; k < m; k++)\n                {\n         \
    \           if(result[i][k] == 1)\n                    {\n                   \
    \     result[i][j] = result[i][j] + result[i][k];\n                        result[i][k]\
    \ = 0;\n                        break;\n                    }\n              \
    \  }\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdgvs6zyy.d(28): Deprecation: instead of C-style syntax, use D-style\
    \ syntax `long[][] result`\\n/tmp/tmpdgvs6zyy.d(146): Error: found `unittest`\
    \ when expecting `)`\\n/tmp/tmpdgvs6zyy.d(157): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpdgvs6zyy.d(157): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdgvs6zyy.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    \n    long[][] res = new long[(int)ceil(n / m)][][];\n\
    \    \n    long i = 0, j = 0;\n    \n    while(i < n && j < m) {\n        if(lst[i][j]\
    \ == x) {\n            res[i][j] = Tuple!((int)i, (int)j);\n            i += 1;\n\
    \            j += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    \n    sort(res, 0, (int)ceil(n / m) - 1);\n    sort(res[(int)ceil(n / m)],\
    \ 0, (int)ceil(m / n) - 1);\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpolznwi2r.d(29): Error: C style cast illegal, use `cast(int)ceil(n\
    \ / m)`\\n/tmp/tmpolznwi2r.d(35): Error: C style cast illegal, use `cast(int)i`\\\
    n/tmp/tmpolznwi2r.d(35): Error: C style cast illegal, use `cast(int)j`\\n/tmp/tmpolznwi2r.d(43):\
    \ Error: C style cast illegal, use `cast(int)ceil(n / m)`\\n/tmp/tmpolznwi2r.d(44):\
    \ Error: C style cast illegal, use `cast(int)ceil(n / m)`\\n/tmp/tmpolznwi2r.d(44):\
    \ Error: C style cast illegal, use `cast(int)ceil(m / n)`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolznwi2r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length;\
    \ j++)\n            {\n                res.add((i, j));\n            }\n     \
    \   }\n    }\n    \n    sort(res);\n    sort(res, true);\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppu6aljq2.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmppu6aljq2.d(33): Error:\
    \ no property `add` for type `Tuple!(long, long)[]`\\n/tmp/tmppu6aljq2.d(38):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmppu6aljq2.d(39):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppu6aljq2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[(n + 1) * (m + 1)];\n    \n    for(i = 0; i < n; i++)\n        for(j =\
    \ 0; j < m; j++)\n            if(lst[i][j] == x)\n                res[(i * m)\
    \ + j] = Tuple!(long, long)[i, j];\n    \n    for(i = 0; i < n; i++)\n       \
    \ for(j = 0; j < m; j++)\n            if(lst[i][j] > x)\n                res[(i\
    \ * m) + j + 1] = Tuple!(long, long)[i, j];\n    \n    for(i = 0; i < n; i++)\n\
    \        for(j = 0; j < m; j++)\n            if(lst[i][j] < x)\n             \
    \   res[(i * m) + j - 1] = Tuple!(long, long)[i, j];\n    \n    for(i = 0; i <\
    \ n; i++)\n        for(j = 0; j < m; j++)\n            if(lst[i][j] == x)\n  \
    \              res[(i * m) + j + 1] = Tuple!(long, long)[i, j];\n    \n    for(i\
    \ = 0; i < n; i++)\n        for(j = 0; j < m; j++)\n            if(lst[i][j] >\
    \ x)\n                res[(i * m) + j - 1] = Tuple!(long, long)[i, j];\n    \n\
    \    for(i = 0; i < n; i++)\n        for(j = 0; j < m; j++)\n            if(lst[i][j]\
    \ < x)\n                res[(i * m) + j] = Tuple!(long, long)[i, j];\n    \n \
    \   sort(res, (a, b) => (a.0 == b.0) ? 0 : (a.0 < b.0) ? 1 : -1);\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0qxvfg51.d(61): Error: found `0.00000` when expecting `)`\\n/tmp/tmp0qxvfg51.d(61):\
    \ Error: found `0.00000` when expecting `,`\\n/tmp/tmp0qxvfg51.d(61): Error: found\
    \ `0.00000` when expecting `)`\\n/tmp/tmp0qxvfg51.d(61): Error: found `0.00000`\
    \ when expecting `;` following statement\\n/tmp/tmp0qxvfg51.d(61): Error: found\
    \ `)` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0qxvfg51.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m, n, m,\
    \ n, m, n, m, n, m, n, m, n, m, n, \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpynmbo57w.d(29): Error: no identifier for declarator `long`\\\
    n/tmp/tmpynmbo57w.d(29): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpynmbo57w.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst){\n        foreach(col,row){\n            if(col == x){\n\
    \                res = Tuple!(long, long)[](row,col);\n            }\n       \
    \ }\n    }\n    sort(res,fun(x1,x2)->x1.1 > x2.1);\n    sort(res,fun(x1,x2)->x1.2\
    \ > x2.2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe47d0t66.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpe47d0t66.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpe47d0t66.d(28): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpe47d0t66.d(28): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpe47d0t66.d(33): Error: found `}` when expecting `)`\\n/tmp/tmpe47d0t66.d(34):\
    \ Error: expression expected, not `>`\\n/tmp/tmpe47d0t66.d(34): Error: found `x1`\
    \ when expecting `,`\\n/tmp/tmpe47d0t66.d(34): Error: found `0.1` when expecting\
    \ `,`\\n/tmp/tmpe47d0t66.d(35): Error: expression expected, not `>`\\n/tmp/tmpe47d0t66.d(35):\
    \ Error: found `x1` when expecting `,`\\n/tmp/tmpe47d0t66.d(35): Error: found\
    \ `0.2` when expecting `,`\\n/tmp/tmpe47d0t66.d(38): Error: found `unittest` when\
    \ expecting `)`\\n/tmp/tmpe47d0t66.d(49): Error: found `End of File` when expecting\
    \ `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpe47d0t66.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            res[i] = i;\n        }\n    }\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp10wj8frn.d(35): Error: cannot implicitly convert expression `res`\
    \ of type `long[]` to `ulong`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp10wj8frn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.len();\n    long\
    \ m = lst[0].len();\n    long[][] res = new long[n][m];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n          \
    \  if(lst[i][j] == x)\n            {\n                res[i][j] = 1;\n       \
    \     }\n            else\n            {\n                res[i][j] = 0;\n   \
    \         }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n    Arrays.sort(res,\
    \ (a, b) -> {\n        if(a[0] == b[0])\n        {\n            return a[1] <\
    \ b[1];\n        }\n        else\n        {\n            return a[0] < b[0];\n\
    \        }\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg_2sp229.d(46): Error: expression expected, not `>`\\n/tmp/tmpg_2sp229.d(46):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpg_2sp229.d(47): Error: expression\
    \ expected, not `if`\\n/tmp/tmpg_2sp229.d(48): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmpg_2sp229.d(49): Error: expression expected, not `return`\\n/tmp/tmpg_2sp229.d(49):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpg_2sp229.d(49): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpg_2sp229.d(50): Error: expression expected, not\
    \ `}`\\n/tmp/tmpg_2sp229.d(51): Error: found `else` when expecting `,`\\n/tmp/tmpg_2sp229.d(55):\
    \ Error: found `}` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpg_2sp229.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row,lst){\n        foreach(col,row){\n\
    \            if(col == x)\n                res.push(Tuple!(long, long)((row,col)));\n\
    \        }\n    }\n    \n    sort(res,fun(Tuple!(long, long)(a,b)) -> (a.1 > b.1)\
    \ ? 1 : -1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphw9c6_4q.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmphw9c6_4q.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmphw9c6_4q.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmphw9c6_4q.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmphw9c6_4q.d(33): Error: found `}` when expecting `)`\\n/tmp/tmphw9c6_4q.d(35):\
    \ Error: expression expected, not `>`\\n/tmp/tmphw9c6_4q.d(35): Error: found `0.1`\
    \ when expecting `,`\\n/tmp/tmphw9c6_4q.d(35): Error: expression expected, not\
    \ `>`\\n/tmp/tmphw9c6_4q.d(35): Error: found `b` when expecting `,`\\n/tmp/tmphw9c6_4q.d(39):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmphw9c6_4q.d(50): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphw9c6_4q.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n  \
    \          if(col == x)\n            {\n                result = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n      \
    \  if(result != null)\n            break;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9mm4kah1.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp9mm4kah1.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp9mm4kah1.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp9mm4kah1.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp9mm4kah1.d(37): Error: found `if` when expecting `)`\\n/tmp/tmp9mm4kah1.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmp9mm4kah1.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp9mm4kah1.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp9mm4kah1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.Length;\n    long\
    \ m = lst[0].Length;\n    long i, j, k, l, m, n, m;\n    Tuple!(long, long)[]\
    \ result;\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     k = i;\n                m = j;\n                break;\n            }\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n    \
    \            l = i;\n                m = j;\n                break;\n        \
    \    }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                n = i;\n                m = j;\n                break;\n    \
    \        }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n      \
    \  for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                l = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                n = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                l = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                n = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                l = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                n = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                l = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                n = i;\n                m = j;\n                break;\n\
    \            }\n        }\n    }\n    \n    \nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkkqw6ct2.d(175): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkkqw6ct2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long rows = 0;\n    long cols\
    \ = 0;\n    for(long i = 0; i < lst.length; i++){\n        rows = rows + lst[i].length;\n\
    \        cols = cols + 1;\n    }\n    \n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[rows];\n    \n    for(long i = 0; i < lst.length; i++){\n        for(long\
    \ j = 0; j < lst[i].length; j++){\n            if(lst[i][j] == x){\n         \
    \       res[rows] = Tuple!(long, long)[i, j];\n                rows++;\n     \
    \       }\n        }\n    }\n    \n    for(long i = 0; i < rows; i++){\n     \
    \   res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < rows; i++){\n\
    \        res[i] = res[i].swap;\n    }\n    \n    for(long i = 0; i < \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc82mpcgt.d(121): Error: expression expected, not `unittest`\\\
    n/tmp/tmpc82mpcgt.d(122): Error: found `{` when expecting `;` following `for`\
    \ condition\\n/tmp/tmpc82mpcgt.d(123): Error: expression expected, not `alias`\\\
    n/tmp/tmpc82mpcgt.d(123): Error: found `candidate` when expecting `)`\\n/tmp/tmpc82mpcgt.d(123):\
    \ Error: found `=` instead of statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpc82mpcgt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row,lst)\n    {\n        foreach(column,row)\n\
    \        {\n            if(column == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row,column)));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    sort(result, 1, result.length-1);\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphrfnvcdk.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmphrfnvcdk.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmphrfnvcdk.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmphrfnvcdk.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmphrfnvcdk.d(37): Error: found `}` when expecting `)`\\n/tmp/tmphrfnvcdk.d(44):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmphrfnvcdk.d(55): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphrfnvcdk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(long, long)[i, j];\n                break;\n           \
    \ }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n\
    \                res[i] = Tuple!(long, long)[i, j];\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] < x)\n    \
    \        {\n                res[i] = Tuple!(long, long)[i, j];\n             \
    \   break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz7_t04yr.d(37): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmpz7_t04yr.d(49): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmpz7_t04yr.d(61): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz7_t04yr.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            res[i] = lst[i][1];\n        }\n    }\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9_4lya06.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmp9_4lya06.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmp9_4lya06.d(34):\
    \ Error: cannot implicitly convert expression `res` of type `long[]` to `ulong`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9_4lya06.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.length];\n\
    \    int[] col = new int[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int i =\
    \ 0; i < lst.length; i++)\n    {\n        if(lst[i][col[x]] == x)\n        {\n\
    \            return Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprsi_zsil.d(39): Error: expression expected, not `unittest`\\\
    n/tmp/tmprsi_zsil.d(40): Error: found `{` when expecting `,`\\n/tmp/tmprsi_zsil.d(41):\
    \ Error: expression expected, not `alias`\\n/tmp/tmprsi_zsil.d(41): Error: found\
    \ `candidate` when expecting `,`\\n/tmp/tmprsi_zsil.d(41): Error: expression expected,\
    \ not `=`\\n/tmp/tmprsi_zsil.d(41): Error: found `get_row` when expecting `,`\\\
    n/tmp/tmprsi_zsil.d(41): Error: expression expected, not `;`\\n/tmp/tmprsi_zsil.d(43):\
    \ Error: found `assert` when expecting `,`\\n/tmp/tmprsi_zsil.d(43): Error: found\
    \ `;` when expecting `,`\\n/tmp/tmprsi_zsil.d(44): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmprsi_zsil.d(45): Error: found `;` when expecting `,`\\n/tmp/tmprsi_zsil.d(46):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmprsi_zsil.d(47): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmprsi_zsil.d(48): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmprsi_zsil.d(49): Error: expression expected, not `}`\\n/tmp/tmprsi_zsil.d(50):\
    \ Error: found `void` when expecting `,`\\n/tmp/tmprsi_zsil.d(50): Error: found\
    \ `{` when expecting `,`\\n/tmp/tmprsi_zsil.d(50): Error: expression expected,\
    \ not `}`\\n/tmp/tmprsi_zsil.d(50): Error: found `End of File` when expecting\
    \ `,`\\n/tmp/tmprsi_zsil.d(50): Error: found `End of File` when expecting `)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprsi_zsil.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] result = new long[lst[0].Length];\n\
    \    for(int i = 0; i < lst[0].Length; i++)\n    {\n        result[i] = lst[0][i];\n\
    \    }\n    for(int i = 1; i < lst.Length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].Length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                Tuple!(long, long)[] res = new Tuple!(long, long)[lst[i].Length];\n\
    \                for(int k = 0; k < lst[i].Length; k++)\n                {\n \
    \                   res[k] = new Tuple!(long, long)(i, k);\n                }\n\
    \                Array.Sort(res);\n                return res;\n            }\n\
    \        }\n    }\n    return new Tuple!(long, long)[0];\n}\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfyd43w7x.d(26): Error: no property `Length` for type `long[]`\\\
    n/tmp/tmpfyd43w7x.d(27): Error: no property `Length` for type `long[]`\\n/tmp/tmpfyd43w7x.d(31):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpfyd43w7x.d(33): Error:\
    \ no property `Length` for type `long[]`\\n/tmp/tmpfyd43w7x.d(37): Error: no property\
    \ `Length` for type `long[]`\\n/tmp/tmpfyd43w7x.d(38): Error: no property `Length`\
    \ for type `long[]`\\n/tmp/tmpfyd43w7x.d(40): Error: template `std.typecons.Tuple!(long,\
    \ long).Tuple.opAssign` cannot deduce function from argument types `!()(Tuple!(long,\
    \ long)*)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\n/tmp/tmpfyd43w7x.d(42): Error:\
    \ undefined identifier `Array`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpfyd43w7x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(row::lst) foreach(col::row) \n    {\n   \
    \     if(col == x) \n        {\n            res[res.length] = Tuple!(long, long)((row,col));\n\
    \        }\n    }\n    sort(res);\n    sort(res, fun(Tuple!(long, long)) -> Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsubevrd7.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpsubevrd7.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpsubevrd7.d(27): Error: expression\
    \ expected, not `:`\\n/tmp/tmpsubevrd7.d(27): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpsubevrd7.d(27): Error: found `)` instead of statement\\n/tmp/tmpsubevrd7.d(33):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpsubevrd7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.length];\n\
    \    int[] col = new int[lst.length];\n    \n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][col[x]] == x)\n      \
    \  {\n            return Tuple!(long, long)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)[Tuple!(int,int)\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpot9ka4t7.d(40): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpot9ka4t7.d(51): Error: found `void` when expecting `,`\\n/tmp/tmpot9ka4t7.d(51):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpot9ka4t7.d(51): Error: expression\
    \ expected, not `}`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when expecting\
    \ `]`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when expecting `,`\\\
    n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when expecting `]`\\n/tmp/tmpot9ka4t7.d(51):\
    \ Error: found `End of File` when expecting `,`\\n/tmp/tmpot9ka4t7.d(51): Error:\
    \ found `End of File` when expecting `]`\\n/tmp/tmpot9ka4t7.d(51): Error: found\
    \ `End of File` when expecting `,`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End\
    \ of File` when expecting `]`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File`\
    \ when expecting `,`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when\
    \ expecting `]`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when expecting\
    \ `,`\\n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when expecting `]`\\\
    n/tmp/tmpot9ka4t7.d(51): Error: found `End of File` when expecting `,`\\n/tmp/tmpot9ka4t7.d(51):\
    \ Error: found `End of File` when expecting `]`\\n/tmp/tmpot9ka4t7.d(51): Error:\
    \ found `End of File` when expecting `,`\\n/tmp/tmpot9ka4t7.d(51): Error: found\
    \ `End of File` when expecting `]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpot9ka4t7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    \n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][col[i]] == x)\n      \
    \  {\n            return Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[]\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbqazpzig.d(40): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpbqazpzig.d(51): Error: found `void` when expecting `,`\\n/tmp/tmpbqazpzig.d(51):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpbqazpzig.d(51): Error: expression\
    \ expected, not `}`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when expecting\
    \ `)`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when expecting `,`\\\
    n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when expecting `)`\\n/tmp/tmpbqazpzig.d(51):\
    \ Error: found `End of File` when expecting `,`\\n/tmp/tmpbqazpzig.d(51): Error:\
    \ found `End of File` when expecting `)`\\n/tmp/tmpbqazpzig.d(51): Error: found\
    \ `End of File` when expecting `,`\\n/tmp/tmpbqazpzig.d(51): Error: found `End\
    \ of File` when expecting `)`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File`\
    \ when expecting `,`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when\
    \ expecting `)`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when expecting\
    \ `,`\\n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when expecting `)`\\\
    n/tmp/tmpbqazpzig.d(51): Error: found `End of File` when expecting `,`\\n/tmp/tmpbqazpzig.d(51):\
    \ Error: found `End of File` when expecting `)`\\n/tmp/tmpbqazpzig.d(51): Error:\
    \ found `End of File` when expecting `,`\\n/tmp/tmpbqazpzig.d(51): Error: found\
    \ `End of File` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpbqazpzig.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n\
    \    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n    \
    \        if(col == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    \n    foreach(row,result)\n    {\n        sort(row);\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0hpky4d6.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmp0hpky4d6.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp0hpky4d6.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp0hpky4d6.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp0hpky4d6.d(37): Error: found `}` when expecting `)`\\n/tmp/tmp0hpky4d6.d(41):\
    \ Error: no identifier for declarator `result`\\n/tmp/tmp0hpky4d6.d(41): Error:\
    \ found `)` when expecting `;`\\n/tmp/tmp0hpky4d6.d(46): Error: found `return`\
    \ when expecting `)`\\n/tmp/tmp0hpky4d6.d(48): Error: found `unittest` when expecting\
    \ `)`\\n/tmp/tmp0hpky4d6.d(59): Error: found `End of File` when expecting `}`\
    \ following compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0hpky4d6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    \n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][col[i]] == x)\n      \
    \  {\n            return Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long,\
    \ long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[]\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmj7359y8.d(40): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpmj7359y8.d(51): Error: found `void` when expecting `,`\\n/tmp/tmpmj7359y8.d(51):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpmj7359y8.d(51): Error: expression\
    \ expected, not `}`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when expecting\
    \ `)`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when expecting `,`\\\
    n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when expecting `)`\\n/tmp/tmpmj7359y8.d(51):\
    \ Error: found `End of File` when expecting `,`\\n/tmp/tmpmj7359y8.d(51): Error:\
    \ found `End of File` when expecting `)`\\n/tmp/tmpmj7359y8.d(51): Error: found\
    \ `End of File` when expecting `,`\\n/tmp/tmpmj7359y8.d(51): Error: found `End\
    \ of File` when expecting `)`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File`\
    \ when expecting `,`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when\
    \ expecting `)`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when expecting\
    \ `,`\\n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when expecting `)`\\\
    n/tmp/tmpmj7359y8.d(51): Error: found `End of File` when expecting `,`\\n/tmp/tmpmj7359y8.d(51):\
    \ Error: found `End of File` when expecting `)`\\n/tmp/tmpmj7359y8.d(51): Error:\
    \ found `End of File` when expecting `,`\\n/tmp/tmpmj7359y8.d(51): Error: found\
    \ `End of File` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\",\
    \ \"-o-\", \"/tmp/tmpmj7359y8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    \n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    for(int\
    \ i = 0; i < lst.Length; i++)\n    {\n        for(int j = 0; j < lst[i].Length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n       \
    \         \n                for(int k = 0; k < lst.Length; k++)\n            \
    \    {\n                    res[k] = new Tuple!(long, long)[lst.Length];\n   \
    \                 \n                    for(int l = 0; l < lst.Length; l++)\n\
    \                    {\n                        res[k][l] = new Tuple!(long, long)[lst.Length];\n\
    \                    }\n                }\n                \n                res[row[i]][col[i]]\
    \ = new Tuple!(long, long)[lst.Length];\n                \n                for(int\
    \ k = 0; k < lst.Length; k++)\n                {\n                    res[row[i]][col[i]][k]\
    \ = new Tuple!(long, long)[lst.Length];\n                }\n                \n\
    \                return res;\n            }\n        }\n    }\n    \n    return\
    \ new Tuple!(long, long)[lst.Length];\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7k4zrx_j.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmp7k4zrx_j.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(29):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(35): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(37): Error: no\
    \ property `Length` for type `long[]`\\n/tmp/tmp7k4zrx_j.d(41): Error: no property\
    \ `Length` for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(43): Error: no property `Length`\
    \ for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(45): Error: no property `Length` for\
    \ type `long[][]`\\n/tmp/tmp7k4zrx_j.d(47): Error: no property `Length` for type\
    \ `long[][]`\\n/tmp/tmp7k4zrx_j.d(49): Error: variable `l` cannot be read at compile\
    \ time\\n/tmp/tmp7k4zrx_j.d(49): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmp7k4zrx_j.d(53): Error: variable `col` cannot be read at compile time\\\
    n/tmp/tmp7k4zrx_j.d(53): Error: no property `Length` for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(55):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmp7k4zrx_j.d(57): Error:\
    \ variable `col` cannot be read at compile time\\n/tmp/tmp7k4zrx_j.d(57): Error:\
    \ only one index allowed to index `long`\\n/tmp/tmp7k4zrx_j.d(65): Error: no property\
    \ `Length` for type `long[][]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp7k4zrx_j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n     \
    \   {\n            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n        if(res\
    \ != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp739hacne.d(27): Error: no identifier for declarator `row`\\n/tmp/tmp739hacne.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp739hacne.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp739hacne.d(27): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmp739hacne.d(29): Error: no identifier for declarator\
    \ `col`\\n/tmp/tmp739hacne.d(29): Error: found `:` when expecting `;`\\n/tmp/tmp739hacne.d(29):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmp739hacne.d(29): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp739hacne.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    long[] res = new long[(n + 1) * (m +\
    \ 1)];\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n\
    \            if (lst[i][j] == x) {\n                res[(i * m) + j] = i;\n  \
    \              res[((i + 1) * m) + j] = j;\n            }\n        }\n    }\n\
    \    \n    sort(res, 0, res.length);\n    sort(res, n, m + 1);\n    \n    return\
    \ Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmj8ofus_.d(40): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpmj8ofus_.d(41): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmpmj8ofus_.d(43): Error: function expected\
    \ before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmj8ofus_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res = Tuple!(long, long)[](row,\
    \ col);\n                break;\n            }\n        }\n        if(res != null)\
    \ break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpma4t_xu2.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpma4t_xu2.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpma4t_xu2.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpma4t_xu2.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpma4t_xu2.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpma4t_xu2.d(37):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpma4t_xu2.d(37):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpma4t_xu2.d(39):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpma4t_xu2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    \n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n\
    \            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[](row, col);\n                break;\n            }\n        }\n    }\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz5tvxe1w.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpz5tvxe1w.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpz5tvxe1w.d(28): Error: expression\
    \ expected, not `:`\\n/tmp/tmpz5tvxe1w.d(28): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpz5tvxe1w.d(28): Error: found `)` instead of statement\\n/tmp/tmpz5tvxe1w.d(37):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz5tvxe1w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.Length; i++)\n \
    \   {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].Length;\
    \ j++)\n            {\n                result.Add(Tuple!(long, long)[i, j]);\n\
    \            }\n        }\n    }\n    \n    result.SortByDescending((x, y) =>\
    \ y.Item1 - x.Item1);\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcmi_2_co.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpcmi_2_co.d(28): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpcmi_2_co.d(32): Error: no\
    \ property `Length` for type `long[]`\\n/tmp/tmpcmi_2_co.d(34): Error: no property\
    \ `Add` for type `Tuple!(long, long)[]`\\n/tmp/tmpcmi_2_co.d(39): Error: no property\
    \ `SortByDescending` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpcmi_2_co.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_pmouz03.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp_pmouz03.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp_pmouz03.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp_pmouz03.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp_pmouz03.d(37): Error: found `if` when expecting `)`\\n/tmp/tmp_pmouz03.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmp_pmouz03.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp_pmouz03.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp_pmouz03.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long[][] res = new long[n][m];\n    long i, j;\n   \
    \ for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n \
    \           if(lst[i][j] == x)\n            {\n                res[i][j] = i;\n\
    \                res[i][m-1] = j;\n                return Tuple!(long, long)[](res);\n\
    \            }\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5_7tbmks.d(28): Error: variable `n` cannot be read at compile\
    \ time\\n/tmp/tmp5_7tbmks.d(38): Error: function expected before `()`, not `Tuple!(long,\
    \ long)[]` of type `Tuple!(long, long)[]`\\n/tmp/tmp5_7tbmks.d(42): Error: function\
    \ expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_7tbmks.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst[0].Length];\n\
    \    for(int i = 0; i < lst[0].Length; i++)\n    {\n        if(lst[0][i] == x)\n\
    \        {\n            res[i] = i;\n        }\n    }\n    Array.Sort(res);\n\
    \    Array.Sort(res, (x, y) => { return y - x; });\n    Tuple!(long, long)[] res\
    \ = new Tuple!(long, long)[res.Length];\n    for(int i = 0; i < res.Length; i++)\n\
    \    {\n        res[i] = new Tuple!(long, long)((int)res[i], i);\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjfy797on.d(39): Error: C style cast illegal, use `cast(int)res[i]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjfy797on.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(i, row) \n    {\n        foreach(j, col)\
    \ \n        {\n            if(row[j] == x) \n            {\n                res[res.length]\
    \ = Tuple!(long, long)(i,j);\n            }\n        }\n    }\n    sort(res);\n\
    \    sort(res, (a, b) => -cmp(a.i, b.i));\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcs493ebk.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpcs493ebk.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpcs493ebk.d(29): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmpcs493ebk.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpcs493ebk.d(36): Error: found `}` when expecting `)`\\n/tmp/tmpcs493ebk.d(41):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpcs493ebk.d(52): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcs493ebk.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst, i: int) \n    {\n       \
    \ foreach(col: row, j: int) \n        {\n            if(col == x) \n         \
    \   {\n                res[res.length] = Tuple!(i, j);\n            }\n      \
    \  }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfz94iptv.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpfz94iptv.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpfz94iptv.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpfz94iptv.d(28): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmpfz94iptv.d(28): Error: found `)` instead of statement\\n/tmp/tmpfz94iptv.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfz94iptv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(i, row) \n    {\n        foreach(j, col)\
    \ \n        {\n            if(row[j] == x) \n            {\n                res[res.length]\
    \ = Tuple!(long, long)(i,j);\n            }\n        }\n    }\n    sort(res);\n\
    \    sort(res, (a, b) => a.1 < b.1);\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxui6xj3y.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpxui6xj3y.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpxui6xj3y.d(29): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmpxui6xj3y.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpxui6xj3y.d(36): Error: found `}` when expecting `)`\\n/tmp/tmpxui6xj3y.d(38):\
    \ Error: found `0.1` when expecting `,`\\n/tmp/tmpxui6xj3y.d(38): Error: expression\
    \ expected, not `<`\\n/tmp/tmpxui6xj3y.d(38): Error: found `b` when expecting\
    \ `,`\\n/tmp/tmpxui6xj3y.d(41): Error: found `unittest` when expecting `)`\\n/tmp/tmpxui6xj3y.d(52):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxui6xj3y.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    \n    foreach(row: lst, row_index: 0) \n    {\n\
    \        foreach(column: row, column_index: 0) \n        {\n            if(column\
    \ == x) \n            {\n                foreach(coordinate: row, coordinate_index:\
    \ 0) \n                {\n                    result.push(Tuple!(long, long)((row_index,\
    \ coordinate_index), (column_index, coordinate_index)));\n                }\n\
    \            }\n        }\n    }\n    \n    result.sort(function(a, b) -> a.0\
    \ < b.0 ? -1 : a.0 > b.0 ? 1 : 0);\n    \n    foreach(coordinate: result, coordinate_index:\
    \ 0) \n    {\n        foreach(coordinate2: result, coordinate2_index: 0) \n  \
    \      {\n            if(coordinate.1 < coordinate2.1) \n            {\n     \
    \           swap(coordinate, coordinate2);\n            }\n        }\n    }\n\
    \    \n    foreach(coordinate: result, coordinate_index: 0) \n    {\n        foreach(coordinate2:\
    \ result, coordinate2_index: 0) \n        {\n            if(coordinate.1 < coordinate2.1)\
    \ \n            {\n                swap(coordinate, coordinate2);\n          \
    \  }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq73bwpx9.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpq73bwpx9.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpq73bwpx9.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpq73bwpx9.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpq73bwpx9.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpq73bwpx9.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpq73bwpx9.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpq73bwpx9.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmpq73bwpx9.d(34): Error: no identifier\
    \ for declarator `coordinate`\\n/tmp/tmpq73bwpx9.d(34): Error: found `:` when\
    \ expecting `;`\\n/tmp/tmpq73bwpx9.d(34): Error: found `:` when expecting `)`\\\
    n/tmp/tmpq73bwpx9.d(34): Error: found `)` when expecting `;` following statement\\\
    n/tmp/tmpq73bwpx9.d(42): Error: missing `{ ... }` for function literal\\n/tmp/tmpq73bwpx9.d(42):\
    \ Error: expression expected, not `>`\\n/tmp/tmpq73bwpx9.d(42): Error: found `a`\
    \ when expecting `,`\\n/tmp/tmpq73bwpx9.d(42): Error: found `0.00000` when expecting\
    \ `,`\\n/tmp/tmpq73bwpx9.d(42): Error: expression expected, not `?`\\n/tmp/tmpq73bwpx9.d(42):\
    \ Error: found `:` when expecting `,`\\n/tmp/tmpq73bwpx9.d(42): Error: found `0.00000`\
    \ when expecting `,`\\n/tmp/tmpq73bwpx9.d(42): Error: expression expected, not\
    \ `>`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq73bwpx9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n \
    \   \n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n   \
    \         if(col == x) \n            {\n                res[res.length] = Tuple!(long,\
    \ long)((row,col));\n            }\n        }\n    }\n    \n    sort(res);\n \
    \   sort(res, fun(Tuple!(long, long)) -> Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return Tuple!(long,\
    \ long)->bool { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool\
    \ { return Tuple!(long, long)->bool { return Tuple!(long, long)->bool { return\
    \ \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9p_y0ifm.d(28): Error: no identifier for declarator `lst`\\n/tmp/tmp9p_y0ifm.d(28):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp9p_y0ifm.d(30): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp9p_y0ifm.d(30): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp9p_y0ifm.d(37): Error: found `}` when expecting `)`\\n/tmp/tmp9p_y0ifm.d(40):\
    \ Error: expression expected, not `>`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `Tuple`\
    \ when expecting `,`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `,` when expecting\
    \ `.` following long\\n/tmp/tmp9p_y0ifm.d(40): Error: found `long` when expecting\
    \ identifier following `long`.\\n/tmp/tmp9p_y0ifm.d(40): Error: expression expected,\
    \ not `>`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `bool` when expecting `,`\\n/tmp/tmp9p_y0ifm.d(40):\
    \ Error: expression expected, not `>`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `bool`\
    \ when expecting `;` following `return` statement\\n/tmp/tmp9p_y0ifm.d(40): Error:\
    \ expression expected, not `>`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `bool` when\
    \ expecting `;` following `return` statement\\n/tmp/tmp9p_y0ifm.d(40): Error:\
    \ expression expected, not `>`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `bool` when\
    \ expecting `;` following `return` statement\\n/tmp/tmp9p_y0ifm.d(40): Error:\
    \ expression expected, not `>`\\n/tmp/tmp9p_y0ifm.d(40): Error: found `bool` when\
    \ expecting `;` following `return` statement\\n/tmp/tmp9p_y0ifm.d(40): Error:\
    \ expression expected, not `>`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp9p_y0ifm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row);\n\
    \    Array.Sort(col);\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][row[i]] ==\
    \ x)\n        {\n            res[i] = Tuple!(long, long)[Tuple!(0, row[i]), Tuple!(0,\
    \ col[i])];\n        }\n    }\n    return res;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsok0i0pd.d(45): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsok0i0pd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column:\
    \ row, column_index: 0) \n        {\n            if(column == x) \n          \
    \  {\n                result = Tuple!(long, long)[](row_index, column_index);\n\
    \                break;\n            }\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeugc3sqj.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpeugc3sqj.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpeugc3sqj.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpeugc3sqj.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpeugc3sqj.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpeugc3sqj.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpeugc3sqj.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpeugc3sqj.d(30): Error: found `)`\
    \ when expecting `;` following statement\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpeugc3sqj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i = 0;\n    long j = 0;\n    Tuple!(long, long)[]\
    \ res = null;\n    while(i < n && j < m) {\n        if(lst[i][j] == x) {\n   \
    \         if(res == null) {\n                res = new Tuple!(long, long)[(n +\
    \ 1) * (m + 1)];\n                for(long k = 0; k < n + 1; k++) {\n        \
    \            res[k][0] = k;\n                    res[k][1] = 0;\n            \
    \    }\n                for(long k = 0; k < m + 1; k++) {\n                  \
    \  res[k][n + 1] = k;\n                    res[k][m + 1] = 0;\n              \
    \  }\n            }\n            res[(i + 1) * (n + 1) + j + 1] = Tuple!(long,\
    \ long)[i, j];\n            i += 1;\n            j += 1;\n        }\n        else\
    \ if(lst[i][j] < x) {\n            i += 1;\n        }\n        else {\n      \
    \      j += 1;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkr39s1_f.d(40): Error: variable `n` cannot be read at compile\
    \ time\\n/tmp/tmpkr39s1_f.d(41): Error: variable `m` cannot be read at compile\
    \ time\\n/tmp/tmpkr39s1_f.d(44): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkr39s1_f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[Tuple!(0,\
    \ col), Tuple!(1, col)];\n                break;\n            }\n        }\n \
    \       if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp87cwko7j.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp87cwko7j.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp87cwko7j.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp87cwko7j.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp87cwko7j.d(37): Error: found `if` when expecting `)`\\n/tmp/tmp87cwko7j.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmp87cwko7j.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp87cwko7j.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp87cwko7j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row: lst) {\n        foreach(col: row) {\n            if(col == x)\
    \ {\n                res = Tuple!(long, long)[](row, col);\n            }\n  \
    \      }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph9hy7gb9.d(27): Error: no identifier for declarator `row`\\n/tmp/tmph9hy7gb9.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmph9hy7gb9.d(28): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmph9hy7gb9.d(28): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9hy7gb9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst[0].Length];\n\
    \    int[] col = new int[lst[0].Length];\n    for(int i = 0; i < lst[0].Length;\
    \ i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int\
    \ i = 0; i < lst[0].Length; i++)\n    {\n        if(lst[0][i] == x)\n        {\n\
    \            Tuple!(long, long)[] ret = new Tuple!(long, long)[lst[0].Length];\n\
    \            for(int j = 0; j < lst[0].Length; j++)\n            {\n         \
    \       ret[j] = (row[j], col[j]);\n            }\n            return ret;\n \
    \       }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt3jt193q.d(26): Error: no property `Length` for type `long[]`\\\
    n/tmp/tmpt3jt193q.d(27): Error: no property `Length` for type `long[]`\\n/tmp/tmpt3jt193q.d(28):\
    \ Error: no property `Length` for type `long[]`\\n/tmp/tmpt3jt193q.d(34): Error:\
    \ no property `Length` for type `long[]`\\n/tmp/tmpt3jt193q.d(38): Error: no property\
    \ `Length` for type `long[]`\\n/tmp/tmpt3jt193q.d(39): Error: no property `Length`\
    \ for type `long[]`\\n/tmp/tmpt3jt193q.d(41): Error: Using the result of a comma\
    \ expression is not allowed\\n/tmp/tmpt3jt193q.d(41): Error: template `std.typecons.Tuple!(long,\
    \ long).Tuple.opAssign` cannot deduce function from argument types `!()(int)`,\
    \ candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(898):\
    \        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if\
    \ (areCompatibleTuples!(typeof(this), R, \"=\"))`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpt3jt193q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j\
    \ : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res.push((i, j));\n            }\n        }\n    }\n    \n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwl8ox6yi.d(28): Error: no identifier for declarator `i`\\n/tmp/tmpwl8ox6yi.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpwl8ox6yi.d(30): Error: no identifier\
    \ for declarator `j`\\n/tmp/tmpwl8ox6yi.d(30): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwl8ox6yi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n        \
    \    if(col == x) \n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null) break;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1lzfwel6.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp1lzfwel6.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp1lzfwel6.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp1lzfwel6.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp1lzfwel6.d(37): Error: found `if` when expecting `)`\\n/tmp/tmp1lzfwel6.d(37):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmp1lzfwel6.d(37):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp1lzfwel6.d(39):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmp1lzfwel6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv8pbe69m.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpv8pbe69m.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpv8pbe69m.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpv8pbe69m.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpv8pbe69m.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpv8pbe69m.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpv8pbe69m.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpv8pbe69m.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpv8pbe69m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column:\
    \ row, column_index: 0) \n        {\n            if(column == x) \n          \
    \  {\n                if(result == null) \n                {\n               \
    \     result = Tuple!(long, long)[];\n                }\n                \n  \
    \              result[result.length] = Tuple!(row_index, column_index);\n    \
    \        }\n        }\n    }\n    \n    foreach(row: result, row_index: 0) \n\
    \    {\n        foreach(column: row, column_index: 0) \n        {\n          \
    \  foreach(coordinate: result, coordinate_index: 0) \n            {\n        \
    \        if(coordinate_index == row_index) \n                {\n             \
    \       foreach(coordinate2: result, coordinate2_index: 0) \n                \
    \    {\n                        if(coordinate2_index == column_index) \n     \
    \                   {\n                            if(result == null) \n     \
    \                       {\n                                result = Tuple!(long,\
    \ long)[];\n                            }\n                            \n    \
    \                        result[result.length] = Tuple!(coordinate2_index, coordinate_index);\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    \n    foreach(row: result, row_index: 0) \n   \
    \ {\n        foreach(column: row, column_index: 0) \n        {\n            foreach(coordinate:\
    \ result, coordinate_index: 0) \n            {\n                if(coordinate_index\
    \ == row_index) \n                {\n                    foreach(coordinate2:\
    \ result, coordinate2_index: 0) \n                    {\n                    \
    \    if(coordinate2_index == column_index) \n                        {\n     \
    \                       if(result == null) \n                            {\n \
    \                               result = Tuple!(long, long)[];\n             \
    \               }\n                            \n                            result[result.length]\
    \ = Tuple!(coordinate_index, coordinate2_index);\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    foreach(row: result, row_index: 0) \n    {\n        foreach(column:\
    \ row, column_index: 0) \n        {\n            foreach(coordinate: result, coordinate_index:\
    \ 0) \n            {\n                if(coordinate_index == row_index) \n   \
    \             {\n                    foreach(coordinate2: result, coordinate2_index:\
    \ 0) \n                    {\n                        if(coordinate2_index ==\
    \ column_index) \n                        {\n                            if(result\
    \ == null) \n                            {\n                                result\
    \ = Tuple!(long, long)[];\n                            }\n                   \
    \         \n                            result[result.length] = Tuple!(coordinate_index,\
    \ coordinate2_index);\n                        }\n                    }\n    \
    \            }\n            }\n        }\n    }\n    \n    foreach(row: result,\
    \ row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n    \
    \    {\n            foreach(coordinate: result, coordinate_index: 0) \n      \
    \      {\n                if(coordinate_index == row_index) \n               \
    \ {\n                    foreach(coordinate2: \nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptsxtl3u7.d(28): Error: no identifier for declarator `row`\\n/tmp/tmptsxtl3u7.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmptsxtl3u7.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmptsxtl3u7.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmptsxtl3u7.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmptsxtl3u7.d(30): Error: found `:` when expecting `;`\\n/tmp/tmptsxtl3u7.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmptsxtl3u7.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmptsxtl3u7.d(44): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmptsxtl3u7.d(44): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmptsxtl3u7.d(44): Error: found `:` when expecting `)`\\n/tmp/tmptsxtl3u7.d(44):\
    \ Error: found `)` when expecting `;` following statement\\n/tmp/tmptsxtl3u7.d(46):\
    \ Error: no identifier for declarator `column`\\n/tmp/tmptsxtl3u7.d(46): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmptsxtl3u7.d(46): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmptsxtl3u7.d(46): Error: found `)` when expecting `;`\
    \ following statement\\n/tmp/tmptsxtl3u7.d(48): Error: no identifier for declarator\
    \ `coordinate`\\n/tmp/tmptsxtl3u7.d(48): Error: found `:` when expecting `;`\\\
    n/tmp/tmptsxtl3u7.d(48): Error: found `:` when expecting `)`\\n/tmp/tmptsxtl3u7.d(48):\
    \ Error: found `)` when expecting `;` following statement\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptsxtl3u7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.length][lst[0].length];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[0].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i][j] = 1;\n            }\n            else\n            {\n       \
    \         res[i][j] = 0;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n\
    \    \n    Arrays.sort(res, (a, b) -> {\n        if(a[0] == b[0])\n        {\n\
    \            return a[1] > b[1];\n        }\n        else\n        {\n       \
    \     return a[0] > b[0];\n        }\n    });\n    \n    Arrays.sort(res, (a,\
    \ b) -> {\n        if(a[0] == b[0])\n        {\n            return a[1] < b[1];\n\
    \        }\n        else\n        {\n            return a[0] < b[0];\n       \
    \ }\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr0hidcio.d(44): Error: expression expected, not `>`\\n/tmp/tmpr0hidcio.d(44):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpr0hidcio.d(45): Error: expression\
    \ expected, not `if`\\n/tmp/tmpr0hidcio.d(46): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmpr0hidcio.d(47): Error: expression expected, not `return`\\n/tmp/tmpr0hidcio.d(47):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpr0hidcio.d(47): Error: found `;`\
    \ when expecting `,`\\n/tmp/tmpr0hidcio.d(48): Error: expression expected, not\
    \ `}`\\n/tmp/tmpr0hidcio.d(49): Error: found `else` when expecting `,`\\n/tmp/tmpr0hidcio.d(53):\
    \ Error: found `}` when expecting `,`\\n/tmp/tmpr0hidcio.d(55): Error: expression\
    \ expected, not `>`\\n/tmp/tmpr0hidcio.d(55): Error: found `{` when expecting\
    \ `,`\\n/tmp/tmpr0hidcio.d(56): Error: expression expected, not `if`\\n/tmp/tmpr0hidcio.d(57):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpr0hidcio.d(58): Error: expression\
    \ expected, not `return`\\n/tmp/tmpr0hidcio.d(58): Error: found `a` when expecting\
    \ `,`\\n/tmp/tmpr0hidcio.d(58): Error: found `;` when expecting `,`\\n/tmp/tmpr0hidcio.d(59):\
    \ Error: expression expected, not `}`\\n/tmp/tmpr0hidcio.d(60): Error: found `else`\
    \ when expecting `,`\\n/tmp/tmpr0hidcio.d(64): Error: found `}` when expecting\
    \ `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr0hidcio.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst[0].Length];\n\
    \    for(int i = 0; i < lst[0].Length; i++)\n    {\n        res[i] = lst[0][i];\n\
    \    }\n    for(int i = 1; i < lst.Length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].Length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res[i] = j;\n                break;\n            }\n\
    \        }\n    }\n    Array.Sort(res);\n    Array.Sort(res);\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_c7_26hy.d(26): Error: no property `Length` for type `long[]`\\\
    n/tmp/tmp_c7_26hy.d(27): Error: no property `Length` for type `long[]`\\n/tmp/tmp_c7_26hy.d(31):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmp_c7_26hy.d(33): Error:\
    \ no property `Length` for type `long[]`\\n/tmp/tmp_c7_26hy.d(42): Error: undefined\
    \ identifier `Array`\\n/tmp/tmp_c7_26hy.d(43): Error: undefined identifier `Array`\\\
    n/tmp/tmp_c7_26hy.d(44): Error: cannot implicitly convert expression `res` of\
    \ type `long[]` to `ulong`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_c7_26hy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n \
    \   foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n           \
    \ if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n    }\n    sort(res,by=byDescending);\n\
    \    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaxa_rfsy.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpaxa_rfsy.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpaxa_rfsy.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpaxa_rfsy.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpaxa_rfsy.d(37): Error: found `}` when expecting `)`\\n/tmp/tmpaxa_rfsy.d(41):\
    \ Error: unterminated /* */ comment\\n/tmp/tmpaxa_rfsy.d(53): Error: found `End\
    \ of File` when expecting `)`\\n/tmp/tmpaxa_rfsy.d(53): Error: found `End of File`\
    \ instead of statement\\n/tmp/tmpaxa_rfsy.d(53): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpaxa_rfsy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    \n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n\
    \            if(col == x) \n            {\n                res = Tuple!(long,\
    \ long)[](row, col);\n                break;\n            }\n        }\n    }\n\
    \    \n    if(res == null) \n    {\n        throw new Exception(\"Invalid input\"\
    );\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvug6esl9.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpvug6esl9.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpvug6esl9.d(28): Error: expression\
    \ expected, not `:`\\n/tmp/tmpvug6esl9.d(28): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmpvug6esl9.d(28): Error: found `)` instead of statement\\n/tmp/tmpvug6esl9.d(37):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpvug6esl9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n\
    \        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result.add((i, j));\n            }\n \
    \       }\n    }\n    result.sort(function(a, b) -> a.0 < b.0 ? -1 : a.0 > b.0\
    \ ? 1 : 0);\n    result.sort(function(a, b) -> a.1 < b.0 ? -1 : a.1 > b.0 ? 1\
    \ : 0);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ikxje8b.d(37): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmp8ikxje8b.d(37): Error: expression expected, not `>`\\n/tmp/tmp8ikxje8b.d(37):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmp8ikxje8b.d(37): Error: found `0.00000`\
    \ when expecting `,`\\n/tmp/tmp8ikxje8b.d(37): Error: expression expected, not\
    \ `?`\\n/tmp/tmp8ikxje8b.d(37): Error: found `:` when expecting `,`\\n/tmp/tmp8ikxje8b.d(37):\
    \ Error: found `0.00000` when expecting `,`\\n/tmp/tmp8ikxje8b.d(37): Error: expression\
    \ expected, not `>`\\n/tmp/tmp8ikxje8b.d(37): Error: found `b` when expecting\
    \ `,`\\n/tmp/tmp8ikxje8b.d(38): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmp8ikxje8b.d(38): Error: expression expected, not `>`\\n/tmp/tmp8ikxje8b.d(38):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmp8ikxje8b.d(38): Error: found `0.00000`\
    \ when expecting `,`\\n/tmp/tmp8ikxje8b.d(38): Error: expression expected, not\
    \ `?`\\n/tmp/tmp8ikxje8b.d(38): Error: found `:` when expecting `,`\\n/tmp/tmp8ikxje8b.d(38):\
    \ Error: found `0.1` when expecting `,`\\n/tmp/tmp8ikxje8b.d(38): Error: expression\
    \ expected, not `>`\\n/tmp/tmp8ikxje8b.d(38): Error: found `b` when expecting\
    \ `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ikxje8b.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.length];\n\
    \    int[] col = new int[lst[0].length];\n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] ==\
    \ x){\n                row[i] = j;\n                col[j] = i;\n            }\n\
    \        }\n    }\n    \n    int[] sorted = new int[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        sorted[i] = i;\n    }\n    \n    for(int\
    \ i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n\
    \            if(sorted[j] > sorted[i]){\n                swap(sorted[j], sorted[i]);\n\
    \            }\n        }\n    }\n    \n    int[] rowSorted = new int[lst.length];\n\
    \    int[] colSorted = new int[lst[0].length];\n    for(int i = 0; i < lst.length;\
    \ i++){\n        rowSorted[i] = sorted[i];\n        colSorted[i] = sorted[lst[i].length-1];\n\
    \    }\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n\
    \    for(int i = 0; i < lst.length; i++){\n        res[i] = Tuple!(long, long)((rowSorted[i],\
    \ colSorted[i]));\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnoru8o7d.d(45): Error: undefined identifier `swap`, did you mean\
    \ template `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable,\
    \ Targets))`?\\n/tmp/tmpnoru8o7d.d(59): Error: Using the result of a comma expression\
    \ is not allowed\\n/tmp/tmpnoru8o7d.d(59): Error: none of the overloads of `this`\
    \ are callable using argument types `(int)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(668):\
    \        `std.typecons.Tuple!(long, long).Tuple.this(long, long)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(689):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U, ulong n)(U[n] values)\
    \ if (n == Types.length && allSatisfy!(isBuildableFrom!U, Types))`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(715):\
    \        `std.typecons.Tuple!(long, long).Tuple.__ctor(U)(U another) if (areBuildCompatibleTuples!(typeof(this),\
    \ U))`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnoru8o7d.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                if(res == null)\n            \
    \        res = Tuple!(long, long)[](row,col);\n                else\n        \
    \            res = Tuple!(long, long)[](row,col);\n            }\n        }\n\
    \    }\n    \n    if(res == null)\n        return Tuple!(long, long)[]();\n  \
    \  \n    foreach(row,res)\n    {\n        foreach(col,row)\n        {\n      \
    \      if(col > res)\n                res = Tuple!(long, long)[](row,col);\n \
    \       }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7gpzizzs.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp7gpzizzs.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp7gpzizzs.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp7gpzizzs.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp7gpzizzs.d(39): Error: found `}` when expecting `)`\\n/tmp/tmp7gpzizzs.d(44):\
    \ Error: no identifier for declarator `res`\\n/tmp/tmp7gpzizzs.d(44): Error: found\
    \ `)` when expecting `;`\\n/tmp/tmp7gpzizzs.d(46): Error: no identifier for declarator\
    \ `row`\\n/tmp/tmp7gpzizzs.d(46): Error: found `)` when expecting `;`\\n/tmp/tmp7gpzizzs.d(51):\
    \ Error: found `}` when expecting `)`\\n/tmp/tmp7gpzizzs.d(55): Error: found `unittest`\
    \ when expecting `)`\\n/tmp/tmp7gpzizzs.d(66): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmp7gpzizzs.d(66): Error:\
    \ found `End of File` when expecting `)`\\n/tmp/tmp7gpzizzs.d(66): Error: found\
    \ `End of File` instead of statement\\n/tmp/tmp7gpzizzs.d(66): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7gpzizzs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long[]\
    \ res = new long[n];\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j\
    \ = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n  \
    \          {\n                res[i] = j;\n                res[i+1] = i;\n   \
    \             return Tuple!(long, long)[](res);\n            }\n        }\n  \
    \  }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp014t74xd.d(36): Error: function expected before `()`, not `Tuple!(long,\
    \ long)[]` of type `Tuple!(long, long)[]`\\n/tmp/tmp014t74xd.d(40): Error: function\
    \ expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp014t74xd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j, k;\n    Tuple!(long, long)[] result = new\
    \ Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                for(k = 0; k < m; k++)\n                {\n                 \
    \   result[i]._1 = i;\n                    result[i]._2 = k;\n               \
    \     break;\n                }\n                break;\n            }\n     \
    \   }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j <\
    \ m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n         \
    \       for(k = 0; k < m; k++)\n                {\n                    result[i]._1\
    \ = i;\n                    result[i]._2 = k;\n                    break;\n  \
    \              }\n                break;\n            }\n        }\n    }\n  \
    \  \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n     \
    \   {\n            if(lst[i][j] < x)\n            {\n                for(k = 0;\
    \ k < m; k++)\n                {\n                    result[i]._1 = i;\n    \
    \                result[i]._2 = k;\n                    break;\n             \
    \   }\n                break;\n            }\n        }\n    }\n    \n    sort(result,\
    \ 0, n - 1);\n    sort(result, n - 1, m - 1);\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9bojujm0.d(39): Error: no property `_1` for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp9bojujm0.d(40): Error: no property `_2` for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp9bojujm0.d(56): Error: no property `_1` for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp9bojujm0.d(57): Error: no property `_2` for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp9bojujm0.d(73): Error: no property `_1` for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp9bojujm0.d(74): Error: no property `_2` for type `Tuple!(long,\
    \ long)`\\n/tmp/tmp9bojujm0.d(82): Error: undefined identifier `sort`, did you\
    \ mean function `sqrt`?\\n/tmp/tmp9bojujm0.d(83): Error: undefined identifier\
    \ `sort`, did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp9bojujm0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n\
    \    \n    foreach(row: lst, row_index: 0) \n    {\n        foreach(column: row,\
    \ column_index: 0) \n        {\n            if(column == x) \n            {\n\
    \                foreach(coordinate: row, coordinate_index: 0) \n            \
    \    {\n                    result = append(result, Tuple!(long, long)((row_index,\
    \ coordinate_index), (column_index, coordinate_index)));\n                }\n\
    \            }\n        }\n    }\n    \n    sort(result, (a, b) => a.1 < b.1);\n\
    \    sort(result, (a, b) => a.2 < b.2);\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzyn9y8w2.d(28): Error: no identifier for declarator `row`\\n/tmp/tmpzyn9y8w2.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpzyn9y8w2.d(28): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpzyn9y8w2.d(28): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpzyn9y8w2.d(30): Error: no identifier for declarator\
    \ `column`\\n/tmp/tmpzyn9y8w2.d(30): Error: found `:` when expecting `;`\\n/tmp/tmpzyn9y8w2.d(30):\
    \ Error: found `:` when expecting `)`\\n/tmp/tmpzyn9y8w2.d(30): Error: found `)`\
    \ when expecting `;` following statement\\n/tmp/tmpzyn9y8w2.d(34): Error: no identifier\
    \ for declarator `coordinate`\\n/tmp/tmpzyn9y8w2.d(34): Error: found `:` when\
    \ expecting `;`\\n/tmp/tmpzyn9y8w2.d(34): Error: found `:` when expecting `)`\\\
    n/tmp/tmpzyn9y8w2.d(34): Error: found `)` when expecting `;` following statement\\\
    n/tmp/tmpzyn9y8w2.d(42): Error: found `0.1` when expecting `,`\\n/tmp/tmpzyn9y8w2.d(42):\
    \ Error: expression expected, not `<`\\n/tmp/tmpzyn9y8w2.d(42): Error: found `b`\
    \ when expecting `,`\\n/tmp/tmpzyn9y8w2.d(43): Error: found `0.2` when expecting\
    \ `,`\\n/tmp/tmpzyn9y8w2.d(43): Error: expression expected, not `<`\\n/tmp/tmpzyn9y8w2.d(43):\
    \ Error: found `b` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpzyn9y8w2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    while(true)\n\
    \    {\n        int minRow = -1;\n        for(int i = 0; i < lst.Length; i++)\n\
    \        {\n            if(row[i] != i)\n            {\n                col[i]\
    \ = 0;\n            }\n            else\n            {\n                col[i]\
    \ = col[i] + 1;\n                if(col[i] > x)\n                {\n         \
    \           col[i] = 0;\n                }\n            }\n            \n    \
    \        if(minRow == -1 || col[i] < col[minRow])\n            {\n           \
    \     minRow = i;\n            }\n        }\n        \n        if(minRow != -1)\n\
    \        {\n            Tuple!(long, long)[] res = new Tuple!(long, long)[minRow\
    \ + 1];\n            for(int i = 0; i < minRow + 1; i++)\n            {\n    \
    \            res[i] = Tuple!(long, long)[i, col[i]];\n            }\n        \
    \    return res;\n        }\n        \n        if(lst.Length == 0)\n        {\n\
    \            return new Tuple!(long, long)[0];\n        }\n        \n        lst\
    \ = lst[lst.Length - 1];\n    }\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnalw_3yy.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpnalw_3yy.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpnalw_3yy.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpnalw_3yy.d(37): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmpnalw_3yy.d(63): Error: no\
    \ `[]` operator overload for type `Tuple!(long, long)`\\n/tmp/tmpnalw_3yy.d(68):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpnalw_3yy.d(73): Error:\
    \ no property `Length` for type `long[][]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpnalw_3yy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long\
    \ m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[n];\n    \n    for(i = 0; i < n; ++i)\n    {\n        for(j = 0; j < m;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(long, long)[i, j];\n                break;\n           \
    \ }\n        }\n    }\n    \n    sort(res);\n    \n    for(i = 0; i < n; ++i)\n\
    \    {\n        res[i] = res[i].swap;\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf8xfxyiv.d(37): Error: no `[]` operator overload for type `Tuple!(long,\
    \ long)`\\n/tmp/tmpf8xfxyiv.d(43): Error: undefined identifier `sort`, did you\
    \ mean function `sqrt`?\\n/tmp/tmpf8xfxyiv.d(47): Error: no property `swap` for\
    \ type `Tuple!(long, long)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpf8xfxyiv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length;\
    \ j++)\n            {\n                if(lst[i][j] == x)\n                {\n\
    \                    res.add((i, j)); \n                }\n            }\n   \
    \     }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq_ibnydq.d(26): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpq_ibnydq.d(35): Error:\
    \ no property `add` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpq_ibnydq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col:\
    \ row) \n        {\n            if(col == x) \n            {\n               \
    \ res.push(Tuple!(long, long)((row), col));\n            }\n        }\n    }\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n\
    \            if(col != x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row), col));\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1x4ya8ja.d(28): Error: no identifier for declarator `row`\\n/tmp/tmp1x4ya8ja.d(28):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp1x4ya8ja.d(30): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmp1x4ya8ja.d(30): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmp1x4ya8ja.d(39): Error: no identifier for declarator `row`\\n/tmp/tmp1x4ya8ja.d(39):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp1x4ya8ja.d(41): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmp1x4ya8ja.d(41): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1x4ya8ja.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(row: lst, i: int) \n    {\n        foreach(col:\
    \ row, j: int) \n        {\n            if (col == x) \n            {\n      \
    \          res.add((i, j));\n            }\n        }\n    }\n    \n    foreach(row:\
    \ lst, i: int) \n    {\n        foreach(col: row, j: int) \n        {\n      \
    \      if (col != x) \n            {\n                res.add((i, j));\n     \
    \       }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_75oy9zr.d(27): Error: no identifier for declarator `row`\\n/tmp/tmp_75oy9zr.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp_75oy9zr.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmp_75oy9zr.d(27): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmp_75oy9zr.d(27): Error: found `)` instead of statement\\n/tmp/tmp_75oy9zr.d(35):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_75oy9zr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[] res = new long[lst[0].Length];\n\
    \    for(int i = 0; i < lst[0].Length; i++)\n    {\n        res[i] = lst[0][i];\n\
    \    }\n    for(int i = 1; i < lst.Length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].Length; j++)\n        {\n            if(lst[i][j] == x)\n       \
    \     {\n                res[i] = j;\n                break;\n            }\n\
    \        }\n    }\n    \n    Array.Sort(res);\n    Array.Sort(res, (x, y) => {\
    \ return y - x; });\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[res.Length];\n\
    \    for(int i = 0; i < res.Length; i++)\n    {\n        res[i] = new Tuple!(long,\
    \ long)(i, res[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw8ef34qr.d(26): Error: no property `Length` for type `long[]`\\\
    n/tmp/tmpw8ef34qr.d(27): Error: no property `Length` for type `long[]`\\n/tmp/tmpw8ef34qr.d(31):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmpw8ef34qr.d(33): Error:\
    \ no property `Length` for type `long[]`\\n/tmp/tmpw8ef34qr.d(43): Error: undefined\
    \ identifier `Array`\\n/tmp/tmpw8ef34qr.d(44): Error: undefined identifier `Array`\\\
    n/tmp/tmpw8ef34qr.d(46): Error: no property `Length` for type `long[]`\\n/tmp/tmpw8ef34qr.d(46):\
    \ Error: declaration `tmpw8ef34qr.get_row.res` is already defined\\n/tmp/tmpw8ef34qr.d(47):\
    \ Error: no property `Length` for type `long[]`\\n/tmp/tmpw8ef34qr.d(49): Error:\
    \ cannot implicitly convert expression `new Tuple!(long, long)(cast(long)i, res[cast(ulong)i])`\
    \ of type `Tuple!(long, long)*` to `long`\\n/tmp/tmpw8ef34qr.d(51): Error: cannot\
    \ implicitly convert expression `res` of type `long[]` to `Tuple!(long, long)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw8ef34qr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n\
    \    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n          \
    \  if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n\
    \                break;\n            }\n        }\n        if(res != null)\n \
    \           break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcjt9qz06.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpcjt9qz06.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpcjt9qz06.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpcjt9qz06.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpcjt9qz06.d(37): Error: found `if` when expecting `)`\\n/tmp/tmpcjt9qz06.d(38):\
    \ Error: found `break` when expecting `;` following statement\\n/tmp/tmpcjt9qz06.d(38):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmpcjt9qz06.d(40):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpcjt9qz06.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new\
    \ Tuple!(long, long)[];\n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j\
    \ : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n         \
    \   {\n                res[res.length] = Tuple!(i, j);\n            }\n      \
    \  }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg69o8z9x.d(27): Error: no identifier for declarator `i`\\n/tmp/tmpg69o8z9x.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpg69o8z9x.d(29): Error: no identifier\
    \ for declarator `j`\\n/tmp/tmpg69o8z9x.d(29): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg69o8z9x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result =\
    \ null;\n    foreach(row: lst, row_index: long) \n    {\n        foreach(column:\
    \ row, column_index: long) \n        {\n            if(column_index == x) \n \
    \           {\n                result = Tuple!(long, long)[](row_index, column_index);\n\
    \                break;\n            }\n        }\n        if(result != null)\
    \ break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb_uv9xdy.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpb_uv9xdy.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpb_uv9xdy.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpb_uv9xdy.d(27): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmpb_uv9xdy.d(27): Error: found `)` instead of statement\\n/tmp/tmpb_uv9xdy.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpb_uv9xdy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    long[][] res = new long[lst.Length][];\n\
    \    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i].Length == x)\n\
    \        {\n            res[i] = lst[i];\n        }\n    }\n    Array.Sort(res,\
    \ (x, y) => x.CompareTo(y));\n    Array.Sort(res, (x, y) => y.CompareTo(x));\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpifscz29o.d(26): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmpifscz29o.d(27): Error: no property `Length` for type `long[][]`\\n/tmp/tmpifscz29o.d(29):\
    \ Error: no property `Length` for type `long[]`\\n/tmp/tmpifscz29o.d(34): Error:\
    \ undefined identifier `Array`\\n/tmp/tmpifscz29o.d(35): Error: undefined identifier\
    \ `Array`\\n/tmp/tmpifscz29o.d(36): Error: cannot implicitly convert expression\
    \ `res` of type `long[][]` to `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpifscz29o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n\
    \    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) ==\
    \ []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n*/\nTuple!(long,\
    \ long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n\
    \    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row);\n\
    \    Array.Sort(col);\n    for(int i = 0; i < lst.Length; i++)\n    {\n      \
    \  if(row[i] == x)\n        {\n            for(int j = i; j < lst.Length; j++)\n\
    \            {\n                if(col[j] > i)\n                {\n          \
    \          col[j] = i;\n                    break;\n                }\n      \
    \      }\n            break;\n        }\n    }\n    Tuple!(long, long)[] res =\
    \ new Tuple!(long, long)[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        res[i] = new Tuple!(long, long)((row[i], col[i]));\n    }\n  \
    \  return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphc9k2mdn.d(57): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphc9k2mdn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
