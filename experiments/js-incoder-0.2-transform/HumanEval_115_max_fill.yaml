name: HumanEval_115_max_fill
language: js
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid, capacity){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0,\
  \ 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n\
  \  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"
completions: ["    let buckets = Array.from({ length: capacity }, () => new Array(capacity).fill(0));\n\
    \    \n    for (let i = 0; i < grid.length; i++){\n        for (let j = 0; j <\
    \ grid[i].length; j++){\n            if (grid[i][j] === 1){\n                buckets[grid[i][j]-1][grid[i][j]-1]++;\n\
    \            }\n        }\n    }\n    \n    let count = 0;\n    \n    for (let\
    \ i = 0; i < buckets.length; i++){\n        for (let j = 0; j < buckets[i].length;\
    \ j++){\n            if (buckets[i][j] === 0){\n                count++;\n   \
    \         }\n        }\n    }\n    \n    return count;\n}\n", "    let result\
    \ = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j <\
    \ grid[0].length; j++){\n            if(grid[i][j] === 1){\n                let\
    \ bucket = grid[i][j];\n                while(bucket > 0){\n                 \
    \   if(bucket > capacity){\n                        bucket -= capacity;\n    \
    \                    result++;\n                    }\n                    else{\n\
    \                        bucket--;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\n", "    let count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                for(let k = 0; k < bucket; k++){\n                    grid[i][j]\
    \ = 0;\n                    count++;\n                }\n            }\n     \
    \   }\n    }\n    return count;\n}\n", "    let result = 0;\n    for(let i = 0;\
    \ i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n \
    \           if(grid[i][j] == 1){\n                let bucket = grid[i][j];\n \
    \               for(let k = 0; k < bucket; k++){\n                    grid[i][j]\
    \ = 0;\n                    result++;\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}\n", "    let result = 0;\n    for(let i =\
    \ 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n\
    \            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                for(let k = 0; k < bucket; k++){\n                    grid[i][j]\
    \ = 0;\n                    result++;\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}\n", "    let count = 0;\n    for(let i =\
    \ 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n\
    \            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                while(bucket > 0){\n                    grid[i][j] = 0;\n   \
    \                 bucket--;\n                    count++;\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                count += max_fill(grid,\
    \ capacity);\n            }\n        }\n    }\n    return count;\n}\n", "    let\
    \ buckets = Array(grid.length).fill(0).map(() => Array(capacity).fill(0));\n \
    \   \n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                buckets[i][j] = 1;\n\
    \            }\n        }\n    }\n    \n    let count = 0;\n    \n    for(let\
    \ i = 0; i < buckets.length; i++){\n        for(let j = 0; j < buckets[i].length;\
    \ j++){\n            if(buckets[i][j] === 0){\n                count += 1;\n \
    \               buckets[i][j] = 1;\n            }\n        }\n    }\n    \n  \
    \  return count;\n}\n", "    let count = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                let bucket = grid[i][j];\n                for(let k\
    \ = 0; k < bucket; k++){\n                    grid[i][j] = 0;\n              \
    \      count++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let buckets = new Array(capacity);\n    for(let i=0; i<buckets.length;\
    \ i++){\n        buckets[i] = 0;\n    }\n    for(let i=0; i<grid.length; i++){\n\
    \        buckets[grid[i][0]] += grid[i][1];\n    }\n    let count = 0;\n    for(let\
    \ i=0; i<buckets.length; i++){\n        if(buckets[i] > 0){\n            buckets[i]\
    \ -= 1;\n            count += 1;\n        }\n    }\n    return count;\n}\n", " \
    \   let count = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n      \
    \          count += 1;\n                for(let k = i; k < grid.length; k++){\n\
    \                    grid[k][j] = 0;\n                }\n                for(let\
    \ k = j; k < grid[i].length; k++){\n                    grid[i][k] = 0;\n    \
    \            }\n            }\n        }\n    }\n    return count;\n}\n", "  \
    \  let buckets = Array(grid[0].length).fill(0).map(() => new Array(capacity).fill(0));\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            buckets[i][j] = grid[i][j];\n        }\n    }\n    for(let\
    \ i = 0; i < buckets.length; i++){\n        for(let j = 0; j < buckets[i].length;\
    \ j++){\n            if(buckets[i][j] === 0){\n                buckets[i][j] =\
    \ 1;\n                let min = Math.min(i, j);\n                for(let k = i;\
    \ k < buckets.length; k++){\n                    for(let l = j; l < buckets[k].length;\
    \ l++){\n                        if(buckets[k][l] === 0){\n                  \
    \          buckets[k][l] = 1;\n                            buckets[k][j] = 0;\n\
    \                            buckets[k][l] = 1;\n                            let\
    \ min2 = Math.min(k, l);\n                            if(buckets[min2][min2] ===\
    \ 0){\n                                buckets[min2][min2] = 1;\n            \
    \                    buckets[min2][j] = 0;\n                                buckets[min2][l]\
    \ = 1;\n                                let min3 = Math.min(min2, min);\n    \
    \                            if(buckets[min3][min3] === 0){\n                \
    \                    buckets[min3][min3] = 1;\n                              \
    \      buckets[min3][j] = 0;\n                                    buckets[min3][l]\
    \ = 1;\n                                }\n                            }\n   \
    \                     }\n                    }\n                }\n          \
    \  }\n        }\n    }\n    return buckets.length;\n}\n", "    let count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                while(bucket > 0){\n                    grid[i][j] = 0;\n   \
    \                 bucket--;\n                    count++;\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let buckets =\
    \ Array(grid[0].length).fill(0);\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ===\
    \ 1){\n                buckets[j]++;\n            }\n        }\n    }\n    let\
    \ count = 0;\n    for(let i = 0; i < buckets.length; i++){\n        if(buckets[i]\
    \ > capacity){\n            count += buckets[i] - capacity;\n            buckets[i]\
    \ = capacity;\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                count += 1;\n    \
    \            for(let k = i; k < grid.length; k++){\n                    for(let\
    \ l = j; l < grid[k].length; l++){\n                        if(grid[k][l] ===\
    \ 0){\n                            grid[k][l] = 1;\n                         \
    \   count -= 1;\n                            break;\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}\n", "    let result = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                let bucket = grid[i][j];\n                for(let k\
    \ = 0; k < bucket; k++){\n                    grid[i][j] = 0;\n              \
    \      result++;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\n", "    let buckets = Array(grid.length).fill(0).map(() => Array(capacity).fill(0));\n\
    \    \n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            buckets[i][j] = grid[i][j];\n        }\n    }\n    \n   \
    \ let count = 0;\n    \n    while(buckets.some(row => row.some(cell => cell ===\
    \ 1))){\n        for(let i = 0; i < buckets.length; i++){\n            for(let\
    \ j = 0; j < buckets[i].length; j++){\n                if(buckets[i][j] === 1){\n\
    \                    buckets[i][j] = 0;\n                    count += 1;\n   \
    \                 break;\n                }\n            }\n        }\n    }\n\
    \    \n    return count;\n}\n", "    let count = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                let bucket = grid[i][j];\n                for(let k\
    \ = 0; k < bucket; k++){\n                    grid[i][j] = 0;\n              \
    \      count++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j] ===\
    \ 1){\n                count += max_fill(grid.slice(i + 1, i + 1 + grid[0].length),\
    \ capacity);\n            }\n        }\n    }\n    return count;\n}\n", "    let\
    \ count = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0;\
    \ j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n             \
    \   let bucket = grid[i][j];\n                for(let k = j; k < grid[i].length;\
    \ k++){\n                    grid[i][k] = 0;\n                }\n            \
    \    for(let k = j; k < bucket; k++){\n                    grid[i][k] = 0;\n \
    \               }\n                count += 1;\n            }\n        }\n   \
    \ }\n    return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
